<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>EPhone</title>
    <!-- ▼▼▼ 【桌面图标】纯HTML单文件方案，请粘贴到 <title> 之后 ▼▼▼ -->
    <!-- 1. (核心) 为苹果设备设置主屏幕图标 -->
    <!-- 浏览器会自动选择最合适的尺寸 -->
    <link rel="apple-touch-icon" href="https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758510900942_qdqqd_djw0z2.jpeg">
    <link rel="apple-touch-icon" sizes="152x152" href="https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758510900942_qdqqd_djw0z2.jpeg">
    <link rel="apple-touch-icon" sizes="180x180" href="https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758510900942_qdqqd_djw0z2.jpeg">
    <link rel="apple-touch-icon" sizes="167x167" href="https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758510900942_qdqqd_djw0z2.jpeg">
    <link rel="manifest" href="manifest.json">
    <!-- 2. (核心) 告诉苹果设备，这是一个Web应用，可以全屏显示 -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <!-- 3. (核心) 设置苹果设备全屏模式下的状态栏样式 -->
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- 4. (可选) 设置应用在主屏幕上显示的标题 -->
    <meta name="apple-mobile-web-app-title" content="EPhone">
    <!-- 5. (兼容) 为部分安卓浏览器提供支持 -->
    <meta name="mobile-web-app-capable" content="yes">
    <!-- 6. (备用) 标准浏览器页签图标 -->
    <link rel="icon" type="image/png" href="https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756312261242_qdqqd_g0eriz.jpeg">
    <!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
     <script src="https://phoebeboo.github.io/mewoooo/pp.js" defer></script>
    <style>
        @font-face { font-family: 'bulangni'; src: url('') format('truetype'); font-weight: normal; font-style: normal; font-display: swap; }
        :root { --screen-width: 350px; --screen-height: 650px; --secondary-bg: #ffffff; --border-color: #e0e0e0; --text-primary: #1f1f1f; --text-secondary: #8a8a8a; --accent-color: #007bff; }
               /* ▼▼▼ Safari键盘适配：请用下面这【一整块】全新的代码，替换掉你现有的 html, body, 和 #phone-screen 样式 ▼▼▼ */
        
        /* --- 请用下面这【一整块】全新的代码，替换掉你现有的 html, body, 和 #phone-screen 样式 --- */
        
        /* 1. 重置 html 元素 */
        html {
            -webkit-text-size-adjust: 100%;
            height: 100%; /* 确保html元素也能撑满 */
        }
        
        /* 2. 设置 body 为全屏画布 */
        body {
            margin: 0;
            font-family: 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-weight: normal;
            background-color: #f0f2f5;
            height: 100%; /* 让body也撑满父元素(html) */
            overflow: hidden; /* 防止body本身出现滚动条 */
        }
        
        /* --- Start of Replacement Code --- */
        
        #phone-screen {
            width: 100%;
            /* Use 100vh to ensure it fills the entire screen height */
            height: 100vh; 
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background-color: #ffffff; /* Your desired white background */
        }
        
        #chat-input-area {
            flex-shrink: 0;
            padding: 8px;
            /* This is the key: adds padding equal to the height of the "black bar" */
            padding-bottom: calc(8px + env(safe-area-inset-bottom)); 
            background-color: rgba(247, 247, 247, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        /* --- End of Replacement Code --- */
/* --- 【核心修改】这是控制状态栏显隐的新样式 --- */

/* 1. 默认情况下，状态栏依然是隐藏的 */
#status-bar {
    display: none;
    /* (原有的其他样式，如颜色、字体等，保持不变即可) */
    padding: 0 20px;
    height: 40px;
    color: white;
    background-color: transparent; /* 背景由父元素控制 */
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    box-sizing: border-box;
    z-index: 100;
    text-shadow: 0 1px 3px rgba(0,0,0,0.4);
    pointer-events: none; /* 让点击可以穿透 */
}

/* 2. 当 #phone-screen 元素拥有 .status-bar-visible 这个 class 时，显示状态栏 */
#phone-screen.status-bar-visible #status-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
        
        .header, .qzone-header {
            position: relative;
            z-index: 15;
            flex-shrink: 0;
            padding: 15px 20px;
            /* 核心：使用 calc() 自动加上顶部的安全距离 */
            padding-top: calc(15px + env(safe-area-inset-top)); 
            background-color: rgba(247, 247, 247, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            font-weight: 600;
        }
        
        
        #status-bar { 
            display: none; 
        }
        #status-bar-time { font-weight: 600; }
        .battery-container { display: flex; align-items: center; gap: 5px; }
        .battery-icon { width: 25px; height: 12px; border: 1px solid white; border-radius: 3px; position: relative; padding: 1px; }
        .battery-icon::after { content: ''; position: absolute; right: -3px; top: 2px; width: 2px; height: 6px; background-color: white; border-radius: 0 1px 1px 0; }
        .battery-level { height: 100%; background-color: white; border-radius: 1px; transition: width 0.5s ease; }
        .battery-container.charging .battery-level { background-color: #4cd964; animation: charge-breath 2s infinite; }
        .battery-container.charging .battery-text { color: #4cd964; }
        @keyframes charge-breath { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .screen { width: 100%; height: 100%; position: absolute; top: 0; left: 0; display: flex; flex-direction: column; overflow: hidden; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
        .screen.active { opacity: 1; visibility: visible; z-index: 1; }
        .header { position: relative; z-index: 15; flex-shrink: 0; padding: 15px 20px; padding-top: 45px; background-color: rgba(247, 247, 247, 0.8); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-size: 18px; font-weight: 600; }
        .header .header-actions { display: flex; align-items: center; gap: 15px; }
        .header .back-btn, .header .action-btn { font-size: 24px; cursor: pointer; width: 30px; text-align: center; color: var(--accent-color); display: flex; align-items: center; justify-content: center; }
        
        .header .action-btn {
            font-size: 16px; /* 专门为“上传”、“+”等文字按钮缩小字号 */
            font-weight: 600; /* 可以加粗一点让它更清晰 */
        }
        
        .header .action-btn img { height: 26px; }
        .header .save-btn { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; }
        /* ▼▼▼ 请用这【一整块代码】，完整替换掉您现有的 #home-screen, #clock-container, 和 #app-grid 样式 ▼▼▼ */
        
        /* --- Start of Replacement Code --- */
        
        #home-screen {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            box-sizing: border-box;
            background-size: cover;
            background-position: center;
            padding-left: 20px;
            padding-right: 20px;
            /* We remove vertical padding here to rely on margins */
        }
        
        #clock-container {
            text-align: center;
            color: white;
            text-shadow: 0 3px 8px rgba(0,0,0,0.4);
            margin-bottom: 20px;
            flex-shrink: 0;
            /* This is the key: pushes the clock down from the top edge */
            margin-top: calc(60px + env(safe-area-inset-top));
        }
        
        /* --- End of Replacement Code --- */
        
        /* 3. 将App图标网格作为一个整体，用 margin 从屏幕底部推上来 */
        #app-grid {
            margin-top: auto; /* 自动贴紧底部 */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            padding: 20px;
            /* 关键：使用 margin-bottom 抬高图标，适配底部“小黑条” */
            margin-bottom: calc(30px + env(safe-area-inset-bottom)); 
        }
        /* ▲▲▲ 替换结束 ▲▲▲ */
        #main-time {
            font-size: 88px; /* 推荐：稍微调大一点点，更接近iOS锁屏的感觉 */
            font-weight: 600; /* 核心修改1：将字体从“纤细(200)”改为“粗体(600)”，这是最关键的一步 */
            letter-spacing: -2px; /* 推荐：稍微收紧字间距，让数字看起来更紧凑 */
            /* 核心修改2：指定字体，优先使用苹果系统字体 */
            font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;
        }
        #main-date { 
            font-size: 22px; /* 稍微放大一点更协调 */
            font-weight: normal; /* 苹果风格的常规体日期 */
        }
        
        #app-grid { margin-top: auto; display: flex; flex-direction: column; align-items: center; gap: 20px; width: 100%; padding: 20px; }
        .app-row { display: flex; justify-content: center; gap: 25px; width: 100%; }
        .app-icon { display: flex; flex-direction: column; align-items: center; cursor: pointer; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.5); font-size: 14px; font-weight: 500; text-align: center; }
        .app-icon .icon-bg { width: 65px; height: 65px; border-radius: 18px; background-color: var(--secondary-bg); display: flex; justify-content: center; align-items: center; font-size: 32px; margin-bottom: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.15); transition: transform 0.2s ease; overflow: hidden; }
        .app-icon:active .icon-bg { transform: scale(0.9); }
        .app-icon .icon-bg img { width: 100%; height: 100%; object-fit: cover; }
        .app-icon .label { color: white; }
        .form-container, .list-container { padding: 20px; overflow-y: auto; flex-grow: 1; display:flex; flex-direction: column; }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-secondary); }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; }
        .form-group textarea { min-height: 80px; resize: vertical; }
        #world-book-content-input { height: calc(100% - 120px); }
        .form-button { width: 100%; padding: 15px; background-color: var(--accent-color); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 10px; }
        .form-button-secondary { background-color: #f0f0f0; color: var(--text-primary); border: 1px solid var(--border-color); }
        #wallpaper-screen .form-container { align-items: center; }
        #wallpaper-preview { width: 180px; height: 320px; border: 2px dashed var(--border-color); background-color: #f0f2f5; margin-bottom: 20px; background-size: cover; background-position: center; border-radius: 10px; display: flex; justify-content: center; align-items: center; color: var(--text-secondary); }
        #wallpaper-upload-input { display: none; }
        /* 修改后的 #world-book-list 样式 */
        #world-book-list {
            flex-grow: 1;
            overflow-y: auto;
            background-color: var(--secondary-bg);
            padding-top: 80px;
            margin-top: -80px;
        }
        
        /* 修改后的 #chat-list 样式，去掉了 padding 和 margin */
        #chat-list {
            flex-grow: 1;
            background-color: var(--secondary-bg);
            padding-top: 80px; 
            padding-bottom: 90px; /* 为底部导航栏留出空间 */
            box-sizing: border-box;
        }
        
        .list-item { display: flex; flex-direction: column; padding: 12px 20px; cursor: pointer; border-bottom: 1px solid var(--border-color); }
        .list-item:hover { background-color: #f5f5f5; }
        .list-item .item-title { font-weight: 500; font-size: 16px; margin-bottom: 5px; }
        .list-item .item-content { font-size: 14px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .chat-list-item { display: flex; align-items: center; padding: 10px 15px; cursor: pointer; border-bottom: 1px solid var(--border-color); position: relative; }
        .chat-list-item:hover { background-color: #f5f5f5; }
        .chat-list-item .avatar { width: 45px; height: 45px; border-radius: 50%; margin-right: 12px; object-fit: cover; background-color: #ccc; }
        .chat-list-item .info { flex-grow: 1; overflow: hidden; }
        .chat-list-item .name-line { display: flex; align-items: center; gap: 6px; margin-bottom: 2px; }
        .chat-list-item .name { font-weight: 500; color: var(--text-primary); }
        .chat-list-item .group-tag { font-size: 10px; color: var(--accent-color); background-color: #e7f3ff; padding: 2px 6px; border-radius: 4px; font-weight: bold; flex-shrink: 0; }
        .chat-list-item .last-msg { font-size: 13px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px; }
        #chat-interface-screen { background-size: cover; background-position: center; position: relative; }
        #selection-cancel-btn, #selection-delete-btn { font-size: 16px; color: var(--accent-color); cursor: pointer; padding: 5px; }
        #selection-delete-btn { color: #ff3b30; }
        
        /* ▼▼▼ 用这块代码替换掉你原来的 #chat-messages 样式 ▼▼▼ */
        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            overflow-x: hidden; /* 核心修正1: 强制禁止水平滚动/拖动 */
            padding: 10px 15px; /* 核心修正2: 将左右内边距增加到15px，提供更多呼吸空间 */
            padding-top: 110px;
            margin-top: -80px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-sizing: border-box; /* 确保内边距计算正确 */
        }
        /* ▲▲▲ 替换结束 ▲▲▲ */
        #load-more-btn { text-align: center; padding: 10px; color: var(--accent-color); font-size: 14px; cursor: pointer; background-color: transparent; border: none; width: 100%; }
        #load-more-btn:hover { text-decoration: underline; }
        
        .sender-name { font-size: 11px; color: #666; margin-bottom: 3px; }
        
        .message-wrapper.ai .sender-name {
            margin-left: 50px; /* 稍微调整，与头像对齐 */
            margin-bottom: 3px;
            position: absolute; /* 让它脱离流，避免影响气泡对齐 */
            top: -16px;       /* 定位到气泡上方 */
            left: 0;
        }
        
        /* === 【全新】消息布局与时间戳样式 === */
        
        /* 1. 消息单元的总容器 (重构) */
        .message-wrapper {
            display: flex;          /* 使用Flex布局 */
            gap: 8px;               /* 气泡和时间戳之间的间距 */
            align-items: flex-end;  /* 核心：让气泡和时间戳底部对齐 */
            position: relative;
            max-width: 90%;         /* 可以稍微放宽一点，因为时间戳现在在外面了 */
        }
        
        /* 2. AI消息单元靠左 */
        .message-wrapper.ai {
            align-self: flex-start;
            flex-direction: row; /* 头像、气泡、时间戳，从左到右排列 */
        }
        
        /* 3. 用户消息单元靠右 */
        .message-wrapper.user {
            align-self: flex-end;
            flex-direction: row-reverse; /* 时间戳、气泡、头像，从右到左排列 */
        }
        
        /* 4. 气泡和头像的直接容器 (保持不变) */
        .message-bubble {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            max-width: 100%;
            min-width: 0; /* <-- 核心修复：允许气泡容器自身收缩 */
        }
        
        .timestamp {
            /* 移除旧的 position: absolute */
            font-size: 11px;
            color: #999;
            text-shadow: 0 0 3px rgba(255,255,255,0.6);
            white-space: nowrap; /* 防止时间换行 */
            margin-bottom: 5px;  /* 让它和气泡底部有轻微的对齐偏移，更美观 */
            flex-shrink: 0;      /* 防止被压缩 */
        }
        
        .message-bubble.selected::after { content: '✔'; position: absolute; left: -10px; top: 50%; transform: translateY(-50%); background-color: var(--accent-color); color: white; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; }
        .message-bubble.user.selected::after { left: auto; right: -10px; }
        
        .message-bubble.user { flex-direction: row-reverse; }
        #typing-indicator { align-self: flex-start; display: none; margin: 0 10px 10px; color: var(--text-secondary); }
        
        
        #chat-list-bottom-nav {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 15;
            display: flex;
            border-top: 1px solid var(--border-color);
            background-color: rgba(247, 247, 247, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            /* 核心：为底部增加安全距离 */
            padding-bottom: env(safe-area-inset-bottom);
        }
        #chat-input-main-row { display: flex; align-items: flex-end; gap: 8px; width: 100%; }
        /* --- 请用这块新代码替换旧的 #chat-input 样式 --- */
#chat-input {
    flex-grow: 1;
    border: none;
    padding: 10px 15px;
    border-radius: 20px;
    background-color: var(--secondary-bg);
    font-size: 16px;
    /* 核心修改 1: 设置一个固定的高度，例如 40px */
    height: 40px; 
    /* 核心修改 2: 移除 max-height 属性 */
    /* max-height: 100px; */ 
    resize: none;
    /* 核心修改 3: 当内容超出高度时，显示滚动条 */
    overflow-y: auto; 
    box-sizing: border-box; /* 推荐添加，确保内边距计算正确 */
}
        .action-button { border: none; color: white; border-radius: 20px; cursor: pointer; font-weight: 600; font-size: 14px; flex-shrink: 0; }
        #send-btn { background-color: var(--accent-color); height: 40px; padding: 0 15px;}
        .modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); display: none; justify-content: center; align-items: center; z-index: 100; }
        .modal.visible { display: flex; }
        .modal-content { width: 90%; max-height: 90%; background-color: white; border-radius: 15px; display: flex; flex-direction: column; }
        .modal-header { padding: 15px; font-weight: 600; border-bottom: 1px solid var(--border-color); text-align: center; display: flex; justify-content: space-between; align-items: center; }
        .modal-body { padding: 15px; overflow-y: auto; }
        .modal-footer { padding: 15px; border-top: 1px solid var(--border-color); display: flex; justify-content: space-around; }
        .modal-footer button { width: 45%; padding: 12px; border-radius: 8px; border: 1px solid var(--accent-color); cursor: pointer; font-size: 16px; }
        .modal-footer .save { background-color: var(--accent-color); color: white; }
        .modal-footer .cancel { background-color: white; color: var(--accent-color); }
        .avatar-upload { display: flex; align-items: center; gap: 15px; }
        .avatar-upload img { width: 60px; height: 60px; border-radius: 50%; object-fit: cover; background-color: #eee; }
        .avatar-upload button { padding: 8px 12px; border: 1px solid #ccc; background-color: #f0f0f0; border-radius: 5px; cursor: pointer; }
        #open-persona-library-btn { font-size: 14px; padding: 6px 10px; margin-left: 0; }
        .avatar-upload input[type="file"] { display: none; }
        .theme-selector label { display: inline-flex; align-items: center; margin-right: 15px; margin-bottom: 5px; cursor: pointer; }
        #reset-theme-btn { background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px; }
        #group-members-settings { display: flex; overflow-x: auto; padding-bottom: 10px; gap: 15px; }
        .member-editor { text-align: center; cursor: pointer; }
        .member-editor img { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; background-color: #eee; margin-bottom: 5px; }
        .member-editor .member-name { font-size: 12px; }
        #notification-bar { position: absolute; top: 40px; left: 50%; width: 90%; z-index: 500; background-color: rgba(250, 250, 250, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 16px; padding: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: flex; align-items: center; gap: 12px; cursor: pointer;     transform: translateX(-50%) translateY(-150%); 
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            visibility: hidden;
        }
        #notification-bar.visible {
            /* 关键：在Y轴回到原位的同时，保持X轴的居中变换 */
            transform: translateX(-50%) translateY(0);
            visibility: visible;
        }
        #notification-avatar { width: 30px; height: 30px; border-radius: 50%; object-fit: cover; }
        #notification-content .name { font-weight: 600; font-size: 15px; color: #000; }
        #notification-content .message { font-size: 14px; color: #555; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; }
        .sticker-image { max-width: 100px; max-height: 100px; display: block; object-fit: contain; }
        
        #chat-input-actions-top { display: flex; gap: 8px; padding: 0 5px; }
        .chat-action-icon-btn { font-size: 24px; padding: 0; width: 38px; height: 38px; line-height: 38px; text-align: center; border-radius: 50%; background-color: rgba(255, 255, 255, 0.5); color: var(--text-primary); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.05); cursor: pointer; display:flex; justify-content:center; align-items:center; }
        #sticker-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 50%; background-color: rgba(242, 242, 247, 0.85); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; z-index: 200; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #sticker-panel.visible { transform: translateY(0); visibility: visible; }
        #sticker-panel-header { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); }
        #sticker-panel-header .title { font-weight: 600; }
        #sticker-panel-header .panel-btn { font-size: 16px; padding: 5px 10px; cursor: pointer; color: var(--accent-color); }
        #sticker-grid { flex-grow: 1; overflow-y: auto; padding: 15px; display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px; }
        /* ▼▼▼ 【表情含义显示】请用这整块代码，替换掉您现有的 .sticker-item 样式 ▼▼▼ */

/* 1. 表情项的总容器，现在是flex布局 */
.sticker-item {
    position: relative;
    display: flex;
    flex-direction: column; /* 垂直排列图片和文字 */
    align-items: center;    /* 水平居中 */
    gap: 6px;               /* 图片和文字之间的间距 */
    cursor: pointer;
}

/* 2. 表情图片容器 (这是新增的) */
.sticker-image-container {
    width: 100%;
    aspect-ratio: 1 / 1;    /* 保持正方形 */
    background-color: white;
    border-radius: 10px;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

/* 3. 表情含义文本 (这是新增的) */
.sticker-name {
    font-size: 12px;           /* 字体大小 */
    color: var(--text-secondary); /* 使用次要文字颜色 */
    width: 100%;               /* 宽度撑满，为省略号做准备 */
    text-align: center;        /* 文字居中 */
    
    /* --- 这就是实现“超出省略号”的核心代码 --- */
    white-space: nowrap;       /* 强制不换行 */
    overflow: hidden;          /* 隐藏超出的部分 */
    text-overflow: ellipsis;   /* 将超出的部分显示为省略号 */
    /* --- 核心代码结束 --- */
}

/* ▲▲▲ 替换结束 ▲▲▲ */
        .sticker-item .delete-btn { display: none; position: absolute; top: -5px; right: -5px; width: 20px; height: 20px; background-color: #ff3b30; color: white; border-radius: 50%; text-align: center; line-height: 20px; font-size: 14px; cursor: pointer; border: 2px solid white; }
        #input-actions-wrapper { position: static; display: flex; align-items: flex-end; gap: 8px; flex-shrink: 0; }
        #wait-reply-btn { position: static; bottom: auto; right: auto; width: auto; height: 40px; padding: 0 10px; border-radius: 20px; display: flex; align-items: center; justify-content: center; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.08); box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: opacity 0.2s, transform 0.1s; cursor: pointer;}
        #wait-reply-btn:hover { opacity: 0.8; }
        #wait-reply-btn:active { transform: scale(0.9); }
        #wait-reply-btn img { height: 22px; display: block; margin: auto; }
        .chat-image { max-width: 100%; border-radius: 10px; display: block; }
        .message-bubble.has-image .content { padding: 5px; }
        #custom-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 1000; opacity: 0; transition: opacity 0.2s ease-in-out; }
        #custom-modal-overlay.visible { display: flex; opacity: 1; }
        #custom-modal { background-color: #fff; width: 280px; border-radius: 14px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); display: flex; flex-direction: column; transform: scale(0.95); transition: transform 0.2s ease-in-out; }
        #custom-modal-overlay.visible #custom-modal { transform: scale(1); }
        .custom-modal-header { padding: 16px; font-size: 17px; font-weight: 600; text-align: center; }
        .custom-modal-body { padding: 0 16px 16px; text-align: center; font-size: 14px; color: #333; line-height: 1.5; }
        .custom-modal-body p { margin: 0; margin-bottom: 12px; }
        /* ▼▼▼ Safari弹窗防放大修正：请用这块新样式替换旧的 .custom-modal-body input 样式 ▼▼▼ */
        
        .custom-modal-body input {
            width: 100%;
            padding: 8px 12px; /* 推荐：稍微增加内边距，让输入框更好看 */
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 16px; /* 核心修正：从 14px 提高到 16px 防止自动放大 */
            box-sizing: border-box;
        }
        
        /* ▲▲▲ 替换结束 ▲▲▲ */
        .custom-modal-footer { border-top: 1px solid #dbdbdb; display: flex; }
        .custom-modal-footer button { flex: 1; background: none; border: none; padding: 12px; font-size: 17px; cursor: pointer; color: var(--accent-color); }
        .custom-modal-footer button:first-child { border-right: 1px solid #dbdbdb; }
        .custom-modal-footer .confirm-btn { font-weight: 600; }
        .custom-modal-footer .confirm-btn.btn-danger { color: #ff3b30; }
        #preset-actions-modal .custom-modal-footer { flex-direction: column; }
        #preset-actions-modal .custom-modal-footer button { width: 100%; border: none; border-bottom: 1px solid #dbdbdb; padding: 14px; font-size: 18px; }
        #preset-actions-modal .custom-modal-footer button:last-child { border-bottom: none; }
        .custom-multiselect {
            position: relative;
            -webkit-user-select: none; /* 兼容 Safari */
            user-select: none;
        }
        .select-box { display: flex; align-items: center; width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; background-color: #fff; cursor: pointer; }
        .select-box .selected-options-text { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-primary); }
        .select-box .arrow-down { margin-left: auto; font-size: 10px; color: var(--text-secondary); transition: transform 0.2s; }
        .select-box.expanded .arrow-down { transform: rotate(180deg); }
        
        .checkboxes-container {
            display: none;
            position: absolute;
            /* 核心修改：不再使用 top，而是用 margin-top 来创造间距，更稳定 */
            top: 100%; 
            margin-top: 5px; /* <-- 新增：向下推开5像素的距离 */
            left: 0;
            right: 0;
            max-height: 150px;
            overflow-y: auto;
            background-color: #fff;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            z-index: 101;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .checkboxes-container.visible { display: block; }
        .checkboxes-container label { display: block; padding: 10px 12px; cursor: pointer; font-weight: normal; color: var(--text-primary); }
        
        .checkboxes-container label {
            display: block;
            padding: 12px 15px; /* <-- 修改：增加了上下和左右的内边距，让每一行更高更宽 */
            cursor: pointer;
            font-weight: normal;
            color: var(--text-primary);
            font-size: 15px; /* <-- 新增：将字体大小从默认值放大到15px */
        }
        
        .checkboxes-container input { margin-right: 10px; vertical-align: middle; }
        .bg-upload-container { display: flex; align-items: center; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
        .bg-preview-img { max-width: 120px; max-height: 80px; border-radius: 8px; border: 1px solid var(--border-color); object-fit: cover; display: none; }
        #remove-bg-btn { padding: 8px 12px; border: 1px solid #ff3b30; color: #ff3b30; background-color: #fff; border-radius: 5px; cursor: pointer; font-size: 14px; display: none; }
        
        .ai-generated-image { max-width: 180px; border-radius: 12px; display: block; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; }
        .ai-generated-image:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .voice-message-body { display: flex; align-items: center; cursor: pointer; padding: 8px 12px; min-width: 80px; max-width: 200px; }
        .message-bubble.user .voice-message-body { color: #1a3d00; flex-direction: row-reverse; }
        .message-bubble.ai .voice-message-body { color: var(--text-primary); }
        .voice-waveform { display: flex; align-items: center; height: 20px; gap: 2px; flex-grow: 1; margin: 0 10px; }
        .voice-waveform div { width: 3px; background-color: currentColor; border-radius: 2px; animation: wave-quiet 1.5s ease-in-out infinite; }
        @keyframes wave-quiet { 0%, 100% { height: 2px; } 50% { height: 10px; } }
        .voice-waveform div:nth-child(2) { animation-delay: 0.2s; } .voice-waveform div:nth-child(3) { animation-delay: 0.4s; } .voice-waveform div:nth-child(4) { animation-delay: 0.6s; } .voice-waveform div:nth-child(5) { animation-delay: 0.8s; }
        .voice-duration {
            /* --- 核心修正 --- */
            font-size: var(--chat-font-size, 13px);
            /* --- 修正结束 --- */
            font-weight: 500;
            color: var(--text-secondary);
        }
        .message-bubble.user .voice-duration { color: #3e6224; }
        
        /* ▼▼▼ 用这块代码替换掉你原来的 .message-bubble .content 样式 ▼▼▼ */
        /* 通用内容区样式，为时间戳和字体大小做准备 */
        .message-bubble .content {
            position: relative;
            font-size: var(--chat-font-size, 16px);
            padding: 8px 12px;
            line-height: 1.5;
            word-break: break-word; /* 核心修正: 强制长单词或URL换行，防止撑破气泡 */
        
        }
        /* ▲▲▲ 替换结束 ▲▲▲ */
        
        /* === 气泡主题样式 === */
        .message-bubble.user .content { background-color: rgba(255, 255, 255, 0.75); color: #585858; border-radius: 8px 2px 8px 8px; }
        .message-bubble.ai .content { background-color: rgba(255, 255, 255, 0.7); color: #585858; border-radius: 2px 8px 8px 8px; }
              
        .message-bubble::after {
            content: "";
            position: absolute;
            width: 20px;  
            height: 20px; 
            background-size: contain;
            background-repeat: no-repeat;
            opacity: 1; 
            z-index: 1;
        }
              
        #chat-messages[data-theme="pink_blue"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_blue"] .message-bubble.ai .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.user .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.user .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.ai .content { background-color: #fffde4; color: #5C4033; }
        #chat-messages[data-theme="black_white"] .message-bubble.user .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="black_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #343a40; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.user .content { background-color: #FFEB3B; color: #5D4037; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="red_black"] .message-bubble.user .content { background-color: #C62828; color: #FFFFFF; }
        #chat-messages[data-theme="red_black"] .message-bubble.ai .content { background-color: #212121; color: #FFFFFF; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.user .content { background-color: #A0D2EB; color: #153243; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.ai .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="gray_white"] .message-bubble.user .content { background-color: #e9ecef; color: #495057; }
        #chat-messages[data-theme="gray_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="blue_green"] .message-bubble.user .content { background-color: #d1ecf1; color: #0c5460; }
        #chat-messages[data-theme="blue_green"] .message-bubble.ai .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="pink_white"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="pink_black"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="pink_green"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_green"] .message-bubble.ai .content { background-color: #C8E6C9; color: #1B5E20; }
        #chat-messages[data-theme="green_black"] .message-bubble.user .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="green_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }
        
        #transfer-btn { font-weight: bold; }
        #transfer-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1001; }
        #transfer-modal.visible { display: flex; }
        .transfer-content { background-color: #fff0f5; border-radius: 20px; width: 290px; padding: 20px; box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3); text-align: center; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100" opacity="0.05"><path d="M50,4 C35,4 28,15 28,24 C28,33 35,32 35,40 C35,48 28,49 28,57 C28,65 35,66 35,74 C35,82 28,83 28,91 C28,99 35,100 50,100 C65,100 72,99 72,91 C72,83 65,82 65,74 C65,66 72,65 72,57 C72,49 65,48 65,40 C65,32 72,33 72,24 C72,15 65,4 50,4 Z" fill="%23FF69B4"/></svg>'); background-repeat: no-repeat; background-position: top right; background-size: 80px; }
        .transfer-header { font-size: 20px; font-weight: bold; color: #a35c7b; margin-bottom: 20px; }
        .transfer-input-group { margin-bottom: 15px; text-align: left; }
        .transfer-input-group label { display: block; font-size: 14px; color: #ff85b3; margin-bottom: 5px; font-weight: 500; }
        .transfer-input-group input { width: 100%; padding: 12px; border-radius: 10px; border: 2px solid #ffcce0; background-color: #fff; font-size: 16px; box-sizing: border-box; }
        .transfer-input-group input:focus { border-color: #ff85b3; outline: none; }
        .transfer-actions { display: flex; justify-content: space-between; gap: 10px; }
        .transfer-actions button { flex: 1; padding: 12px; border: none; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; transition: transform 0.2s; }
        .transfer-actions button:active { transform: scale(0.95); }
        #transfer-cancel-btn { background-color: #ffdde9; color: #a35c7b; }
        #transfer-confirm-btn { background-color: #ff85b3; color: white; }
        
        .transfer-card { width: 200px; border-radius: 12px; padding: 12px; color: white; position: relative; overflow: hidden; }
        .transfer-card::before { content: '🐾'; position: absolute; right: 10px; top: 5px; font-size: 30px; opacity: 0.2; transform: rotate(15deg); }
        .message-bubble.user .transfer-card { background: radial-gradient(circle at top left, #ffc5d5, #ff85b3); }
        .message-bubble.ai .transfer-card { background: radial-gradient(circle at top left, #a1c4fd, #c2e9fb); }
        .transfer-title { font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 6px; margin-bottom: 8px; }
        .transfer-amount { font-size: 28px; font-weight: bold; margin-bottom: 4px; }
        .transfer-note { font-size: 13px; opacity: 0.9; border-top: 1px solid rgba(255,255,255,0.3); padding-top: 8px; margin-top: 8px; word-break: break-all; }
        
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        #listen-together-btn img.rotating { animation: spin 2s linear infinite; }
        #listen-together-btn img.paused { animation-play-state: paused; }
        #music-player-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; display: none; justify-content: center; align-items: center; background-color: rgba(0,0,0,0.3); }
        #music-player-overlay.visible { display: flex; }
        .music-player-window { width: 90%; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 20px; box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); border: 1px solid rgba(255, 255, 255, 0.18); padding: 25px; display: flex; flex-direction: column; align-items: center; color: #1f1f1f; position: relative; }
        #music-playlist-btn { position: absolute; top: 15px; right: 15px; font-size: 24px; cursor: pointer; color: #333; }
        #music-time-counter { font-size: 12px; color: #555; margin-bottom: 20px; }
        #music-player-song-title { font-size: 20px; font-weight: 600; margin-bottom: 5px; text-align: center; }
        #music-player-artist { font-size: 14px; color: #666; margin-bottom: 25px; }
        .music-controls { display: flex; align-items: center; justify-content: center; gap: 20px; width: 100%; margin-bottom: 30px; }
        .music-controls button { background: none; border: none; font-size: 16px; font-weight: bold; cursor: pointer; color: #333; width: 44px; height: 44px; display: flex; justify-content: center; align-items: center; transition: transform 0.2s; }
        .music-controls button:active { transform: scale(0.9); }
        .music-controls .play-pause-btn { font-size: 24px; width: 60px; height: 60px; border-radius: 50%; background-color: rgba(0,0,0,0.05); }
        .music-bottom-actions { display: flex; justify-content: space-between; width: 100%; }
        .music-bottom-actions button { flex: 1; padding: 12px 0; border: none; border-radius: 10px; font-size: 15px; font-weight: 500; cursor: pointer; }
        #music-exit-btn { background-color: rgba(255, 100, 100, 0.7); color: white; margin-right: 5px; }
        #music-return-btn { background-color: rgba(0, 123, 255, 0.7); color: white; margin-left: 5px; }
        
        #music-playlist-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 70%; background-color: rgba(242, 242, 247, 0.9); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; z-index: 210; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #music-playlist-panel.visible { transform: translateY(0); visibility: visible; }
        .playlist-header { padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); font-weight: 600; }
        .playlist-header .panel-btn { font-size: 16px; cursor: pointer; color: var(--accent-color); }
       .playlist-body {
    flex-grow: 1;
    overflow-y: auto;
    /* 核心修复：将 padding-bottom 显著增大，确保最后一条歌曲不会被遮挡 */
    /* 同时使用 box-sizing 确保内边距计算正确 */
    padding: 10px 0 80px 0;
    box-sizing: border-box;
}
        .playlist-item { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; border-bottom: 1px solid #eee; }
        .playlist-item.playing { background-color: rgba(0, 123, 255, 0.1); }
        .playlist-item-info .title { font-weight: 500; font-size: 15px; }
        .playlist-item-info .artist { font-size: 12px; color: #666; }
        .playlist-item .delete-track-btn { color: #ff3b30; font-size: 20px; padding: 5px; }
        
        /* Persona Library Styles */
        #persona-library-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; padding: 10px; }
        .persona-preset-item { aspect-ratio: 1 / 1; border-radius: 12px; background-size: cover; background-position: center; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; border: 1px solid rgba(0,0,0,0.1); }
        .persona-preset-item:hover { transform: scale(1.08); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .modal-header .action-button { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; background: none; border: none; padding: 5px; }
        
        /* Battery Alert Modal Styles */
        #battery-alert-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.4); display: none; justify-content: center; align-items: center; z-index: 2000; opacity: 0; transition: opacity 0.3s ease; }
        #battery-alert-modal.visible { display: flex; opacity: 1; }
        .battery-alert-content { background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); width: 280px; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); text-align: center; padding: 20px; cursor: pointer; transform: scale(0.9); transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        #battery-alert-modal.visible .battery-alert-content { transform: scale(1); }
        #battery-alert-image { max-width: 100px; max-height: 100px; margin-bottom: 15px; }
        #battery-alert-text { font-size: 16px; font-weight: 500; color: #333; margin: 0; line-height: 1.4; }
        
        /* 这是你要添加的新样式 */
        #font-preview {
            transition: font-family 0.3s ease;}
        
        /* === 聊天列表界面新增样式 (这是新添加的) === */
        #chat-list-screen {
        }
        
        .chat-list-view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 1; 
        }
        .chat-list-view.active {
            opacity: 1;
            visibility: visible;
            z-index: 2; 
        }
        
        #messages-view {
            overflow-y: auto; 
        }
        
        
        .nav-item {
            flex: 1;
            text-align: center;
            padding: 12px 0;
            font-size: 14px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: color 0.2s;
        }
        
        .nav-item.active {
            color: var(--accent-color);
            font-weight: 600;
        }
        
        /* === 动态界面 (QZone) 样式 (这是新添加的) === */
        #qzone-screen {
            background-color: #f0f2f5;
        }
        
        .qzone-header {
            /* position: absolute;  <-- 把这个改成 relative */
            position: relative;
            z-index: 10; /* z-index 保持，或者可以更高 */
            flex-shrink: 0; /* 防止被压缩 */
            padding: 15px 20px;
            padding-top: 45px;
            background-color: rgba(247, 247, 247, 0.7); 
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            font-weight: 600;
            text-align: center;
        }
        
        .qzone-header .back-btn {
            font-size: 24px;
            cursor: pointer;
            color: var(--accent-color);
        }
        
        .qzone-header span:nth-child(2) { /* "好友动态"文字 */
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .qzone-content {
            flex-grow: 1;
            overflow-y: auto;
            /* padding-top: 80px;  <-- 删除这个，因为header不再是absolute了 */
        }
        
        .qzone-profile-header {
            position: relative;
            margin-bottom: 20px;
        }
        
        .qzone-banner-container {
            width: 100%;
            height: 180px; /* 背景板高度 */
            position: relative;
        }
        
        #qzone-banner-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .qzone-user-info {
            position: absolute;
            bottom: -30px; /* 让头像和昵称区域向下偏移，一半在背景板内，一半在外 */
            left: 20px;
            display: flex;
            align-items: flex-end; /* 让昵称和头像底部对齐 */
            gap: 10px;
        }
        
        .qzone-avatar-container {
            position: relative;
        }
        
        #qzone-avatar-img {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            object-fit: cover;
        }
        
        #qzone-nickname {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
            padding-bottom: 5px; /* 微调位置 */
        }
        
        /* 编辑按钮的通用样式 */
        .qzone-edit-btn {
            position: absolute;
            background-color: rgba(0,0,0,0.4);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        
        #change-qzone-banner-btn {
            bottom: 10px;
            right: 10px;
        }
        
        #change-qzone-avatar-btn {
            bottom: 5px;
            right: 5px;
        }
        
        #change-qzone-nickname-btn {
            font-size: 14px;
            padding: 2px 6px;
            margin-left: 5px; /* 与昵称的间距 */
            color: var(--text-primary);
            background-color: rgba(255,255,255,0.7);
            border-radius: 5px;
            position: relative; /* 脱离flex布局的对齐 */
            bottom: 5px; /* 微调垂直位置 */
        }
        
        /* === 让编辑功能更“隐形” === */
        #qzone-banner-container,
        #qzone-avatar-container,
        #qzone-nickname {
            cursor: pointer; /* 鼠标悬停时显示为可点击手势 */
            transition: opacity 0.2s;
        }
        #qzone-banner-container:hover,
        #qzone-avatar-container:hover,
        #qzone-nickname:hover {
            opacity: 0.85; /* 悬停时稍微变暗，给用户反馈 */
        }
        /* 隐藏掉旧的、独立的编辑按钮 */
        .qzone-edit-btn {
            display: none;
        }
        
        /* === 控制 Header 和 Bottom Nav 的显隐 === */
        /* 默认隐藏动态界面的 Header */
        #qzone-screen .qzone-header {
            display: none;
        }
        /* 当动态视图激活时，显示它的Header */
        #qzone-screen.active .qzone-header {
            display: flex;
        }
        
        /* 当进入动态视图时，隐藏主Header和底部导航栏 */
        #chat-list-screen.in-qzone-view > .header,
        #chat-list-screen.in-qzone-view > #chat-list-bottom-nav {
            display: none;
        }
        
        .chat-list-item:first-child,
        .chat-group-container:first-child {
            margin-top: 10px; 
        }
        
        /* ▲▲▲ 新样式替换结束 ▲▲▲ */
        
        /* ▼▼▼ 把所有这些新样式粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* === 动态功能栏样式 === */
        .qzone-actions-bar {
            display: flex;
            justify-content: space-around;
            padding: 10px 0;
            margin: 40px 15px 15px 15px; /* 上边距更大，为浮动的头像留出空间 */
            background-color: var(--secondary-bg);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        
        .action-item {
            flex: 1;
            text-align: center;
            font-size: 15px;
            font-weight: 500;
            color: var(--text-primary);
            cursor: pointer;
            padding: 8px 0;
            position: relative;
        }
        
        /* 用伪元素创建分隔线 */
        .action-item:not(:last-child)::after {
            content: '';
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 1px;
            height: 20px;
            background-color: var(--border-color);
        }
        
        /* === 动态帖子列表样式 === */
        #qzone-posts-list {
            padding: 0 15px 20px 15px; /* 左右和底部留出边距 */
            display: flex;
            flex-direction: column;
            gap: 20px; /* 帖子之间的间距 */
        }
        
        .qzone-post-item {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.06);
        }
        
        .post-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }
        
        .post-header .post-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }
        
        .post-info {
            display: flex;
            flex-direction: column;
        }
        
        .post-info .post-nickname {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
        }
        
        .post-info .post-timestamp {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .post-content {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            white-space: pre-wrap; /* 让换行符生效 */
            word-break: break-word; /* 防止长单词溢出 */
        }
        
        /* ▲▲▲ 新样式结束 ▲▲▲ */
        
        /* ▼▼▼ 新样式粘贴到末尾 ▼▼▼ */
        
        /* === 发布动态模态框样式 === */
        #post-public-text {
            min-height: 80px; /* 确保文本域有足够的高度 */
            resize: vertical;
        }
        
        .post-image-preview-container {
            position: relative;
            width: 100%;
            aspect-ratio: 16 / 9; /* 保持16:9的预览比例 */
            background-color: #f0f2f5;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            margin-bottom: 15px;
            display: none; /* 默认隐藏 */
            justify-content: center;
            align-items: center;
        }
        .post-image-preview-container.visible {
            display: flex; /* 上传后显示 */
        }
        
        #post-image-preview {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 6px;
        }
        
        #post-remove-image-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: #ff3b30;
            color: white;
            border: 2px solid white;
            font-size: 16px;
            line-height: 20px;
            text-align: center;
            cursor: pointer;
            box-shadow: 0 1px 4px rgba(0,0,0,0.3);
        }
        
        .post-image-upload-options {
            display: flex;
            gap: 10px;
        }
        
        .post-image-upload-options button {
            flex: 1;
            margin-top: 0;
        }
        
        /* ▲▲▲ 新样式结束 ▲▲▲ */
        
        /* ▼▼▼ 新样式 ▼▼▼ */
        
        /* === 发布动态模态框 - 模式切换样式 === */
        .post-mode-switcher {
            display: flex;
            margin-bottom: 20px;
            background-color: #e9ecef;
            border-radius: 8px;
            padding: 4px;
        }
        
        .mode-btn {
            flex: 1;
            padding: 8px;
            border: none;
            background-color: transparent;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        
        .mode-btn.active {
            background-color: var(--secondary-bg);
            color: var(--text-primary);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .post-mode-content {
            display: none; /* 默认都隐藏 */
        }
        
        .post-mode-content.active {
            display: block; /* 激活的才显示 */
        }
        
        /* ▲▲▲ 新样式结束 ▲▲▲ */
        
        /* === 相册页面背景色 === */
        #album-screen {
            background-color: #f0f2f5; /* 使用一个柔和的浅灰色，比纯白更护眼 */
        }
        
        /* === 相册页面网格布局 === */
        #album-grid-page {
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* 每行显示2个相册 */
            gap: 15px;
        }
        
        /* === 相册项目样式 (美化) === */
        .album-item {
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            border-radius: 8px; /* 给整个项目也加个圆角 */
        }
        
        .album-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 15px rgba(0,0,0,0.1);
        }
        
        .album-cover {
            aspect-ratio: 1 / 1; /* 保持封面为正方形 */
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            margin-bottom: 8px;
            background-color: #f0f2f5; /* 封面加载前的占位颜色 */
        }
        
        .album-info {
            text-align: center;
        }
        
        .album-name {
            font-weight: 500;
            margin: 0 0 4px 0;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis; /* 防止长名字换行 */
        }
        
        .album-count {
            font-size: 12px;
            color: var(--text-secondary);
            margin: 0;
        }
        
        /* ▲▲▲ 新的 CSS 粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* === 相册照片详情页 === */
        #album-photos-screen {
            background-color: #f0f2f5;
        }
        
        #photos-grid-page {
            padding: 15px;
            display: grid;
            /* 每行显示3张照片，并保持间距 */
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .photo-item {
            position: relative; /* 为了定位删除按钮 */
            aspect-ratio: 1 / 1; /* 保持照片为正方形 */
            border-radius: 6px;
            overflow: hidden; /* 防止图片溢出圆角 */
            background-color: #e9ecef; /* 图片加载前的占位符颜色 */
        }
        
        .photo-item .photo-thumb {
            width: 100%;
            height: 100%;
            object-fit: cover; /* 保证图片填满容器且不变形 */
            cursor: pointer;
        }
        
        /* 删除按钮的样式 */
        .photo-item .photo-delete-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 22px;
            height: 22px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 16px;
            line-height: 22px;
            text-align: center;
            cursor: pointer;
            opacity: 0; /* 默认隐藏 */
            transition: opacity 0.2s ease;
        }
        
        /* 鼠标悬停在照片上时显示删除按钮 */
        .photo-item:hover .photo-delete-btn {
            opacity: 1;
        }
        
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        
        /* === 图片查看器模态框样式 === */
        #photo-viewer-modal {
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 1002;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
        }
        
        .photo-viewer-content {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }
        
        #photo-viewer-image {
            max-width: 90vw;  /* 图片最大宽度为视口的90% */
            max-height: 85vh; /* 图片最大高度为视口的85% */
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            /* 为图片的切换添加一点平滑的淡入淡出效果 */
            transition: opacity 0.2s ease-in-out;
        }
        
        /* 关闭按钮 */
        #photo-viewer-close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 40px;
            font-weight: 200;
            cursor: pointer;
            line-height: 1;
            text-shadow: 0 0 5px black;
        }
        
        /* 左右导航箭头 */
        #photo-viewer-modal .nav-arrow {
            position: absolute; /* 现在我们用绝对定位来控制箭头 */
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 50px; /* 在手机屏幕上，可以稍微小一点 */
            font-weight: 100;
            cursor: pointer;
            padding: 10px; /* 调整内边距 */
        -webkit-user-select: none; /* 兼容 Safari */
            user-select: none;
            transition: color 0.2s;
            z-index: 1003; /* 确保箭头在最上层 */
        }
        
        #photo-viewer-prev-btn {
            left: 5px; /* 定位左箭头 */
        }
        
        #photo-viewer-next-btn {
            right: 5px; /* 定位右箭头 */
        }
        
        #photo-viewer-modal .nav-arrow:hover {
            color: white;
        }
        
        /* 当箭头被禁用时（比如第一张或最后一张） */
        #photo-viewer-modal .nav-arrow:disabled {
            color: rgba(255, 255, 255, 0.2);
            cursor: default;
        }
        
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* ▼▼▼ 请用这块新CSS替换掉上一版的交互区CSS ▼▼▼ */
        
        /* === 帖子内容区 - 相对定位容器 === */
        /* === 帖子内容区 === */
        .post-main-content {
            /* 它现在只是一个普通的内容容器，不再需要特殊样式了 */
        }
        
        /* === 帖子互动图标区 (新样式) === */
        .post-feedback-icons {
            display: flex;
            justify-content: flex-end; /* 让图标靠右对齐 */
            align-items: center;
            gap: 12px;
            padding: 8px 0; /* 核心修改：给图标区域上下各8px的留白 */
        }
        
        .action-icon {
            cursor: pointer;
            color: var(--text-secondary); /* 默认灰色 */
            transition: all 0.2s ease-in-out;
        }
        
        .action-icon svg {
            width: 22px;
            height: 22px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        /* 图标激活(点赞/收藏后)的样式 */
        .action-icon.active {
            color: #ff5252; /* 激活后变红色 */
            transform: scale(1.1); /* 轻微放大 */
        }
        
        .action-icon.active.favorite {
            color: #ffc107; /* 收藏用黄色 */
        }
        
        .action-icon.active svg {
            fill: currentColor; /* 激活后填充颜色 */
        }
        
        /* 点击时的动画效果 */
        .animate-like {
            animation: like-bounce 0.4s ease-in-out;
        }
        
        @keyframes like-bounce {
            0%   { transform: scale(1); }
            25%  { transform: scale(0.8); }
            50%  { transform: scale(1.2); }
            75%  { transform: scale(1.05); }
            100% { transform: scale(1.1); }
        }
        
        
        /* === 帖子底部评论区样式 (现在是独立部分) === */
        .post-footer {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #f0f0f0; /* 用一条浅色线分隔 */
            display: flex;
            align-items: center;
            gap: 8px; /* 调整整体间距 */
        }
        
        /* 评论区容器 */
        .comment-section {
            flex-grow: 1; /* 占据大部分空间 */
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .comment-section .comment-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
        }
        /* ▼▼▼ 在这里添加新样式 ▼▼▼ */
        .comment-section {
            position: relative; /* 核心修正：为弹窗建立定位的锚点 */
        }
        /* ▲▲▲ 添加结束 ▲▲▲ */
        /* ▼▼▼ Safari防放大修正：请用下面这两块新样式，替换旧的 .comment-input 和 .comment-send-btn 样式 ▼▼▼ */
        
        .comment-section .comment-input {
            width: 100%;
            padding: 8px 12px;
            border: none;
            background-color: #f0f2f5;
            border-radius: 14px;
            font-size: 16px; /* 核心修正：从 13px 提高到 16px 防止自动放大 */
            outline: none;
        }
        
        /* (推荐) 同时调整发送按钮，保持视觉统一 */
        .comment-send-btn {
            flex-shrink: 0; /* 防止被压缩 */
            padding: 8px 15px;
            border: none;
            background-color: var(--accent-color);
            color: white;
            border-radius: 14px;
            font-size: 16px; /* 从 13px 调整为 16px */
            font-weight: 500;
            cursor: pointer;
        }
        
        /* ▲▲▲ 替换结束 ▲▲▲ */
        
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* === 未读消息小红点通用样式 === */
        .unread-indicator {
            position: absolute;
            top: -8px;      
            right: -15px;    
            min-width: 18px;
            height: 18px;
            padding: 0 5px;
            background-color: #ff3b30;
            color: white;
            font-size: 11px;
            font-weight: bold;
            line-height: 18px;
            text-align: center;
            border-radius: 9px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            display: none;
            z-index: 1;
        }
        
        /* 聊天界面返回按钮上的小红点 (只显示点，不显示数字) */
        .back-btn-indicator {
            top: 0;
            right: -8px; /* 放到返回箭头右上角 */
            width: 10px;
            height: 10px;
            min-width: 10px;
            padding: 0;
            border-radius: 50%;
        }
        
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* === 评论列表容器 === */
        .post-comments-container {
            padding: 10px 0; /* 上下留白 */
            display: flex;
            flex-direction: column;
            gap: 8px; /* 评论之间的间距 */
            font-size: 13px; /* 统一评论区字体大小 */
        }
        
        /* 每一条评论 */
        .comment-item {
            line-height: 1.5;
        }
        
        /* 评论者的名字，加粗并使用主题色 */
        .comment-item .commenter-name {
            font-weight: 600;
            color: var(--accent-color);
            cursor: pointer;
            margin-right: 5px; /* 和评论内容之间留点空隙 */
        }
        
        /* 评论内容 */
        .comment-item .comment-text {
            color: var(--text-primary);
            word-break: break-word;
        }
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* === 帖子点赞区域样式 === */
        .post-likes-section {
            display: flex;
            align-items: center;
            gap: 6px; /* 图标和文字的间距 */
            padding: 8px 10px; /* 内边距 */
            font-size: 13px;
            color: var(--accent-color); /* 使用主题蓝色 */
            background-color: #f0f5fa; /* 给一个淡淡的背景色 */
            border-top: 1px solid #e9eef3;
            border-bottom: 1px solid #e9eef3;
            margin-top: 5px; /* 和上方的图标保持一点距离 */
        }
        
        .post-likes-section .like-icon {
            width: 16px;
            height: 16px;
            fill: currentColor; /* 让SVG图标继承父元素的颜色 */
            flex-shrink: 0; /* 防止图标被压缩 */
        }
        
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        
        
        /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* === @提及 弹出菜单样式 === */
        .at-mention-popup {
            position: absolute; /* 相对于父元素定位 */
            bottom: 100%; /* 显示在输入框的上方 */
            left: 40px; /* 和输入框左侧对齐 (考虑了头像宽度) */
            width: calc(100% - 40px); /* 宽度和输入框差不多 */
            max-height: 120px;
            overflow-y: auto;
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
            z-index: 10;
            display: none; /* 默认隐藏 */
        }
        
        .at-mention-item {
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            color: var(--text-primary);
            border-bottom: 1px solid #f0f0f0;
        }
        
        .at-mention-item:last-child {
            border-bottom: none;
        }
        
        .at-mention-item:hover {
            background-color: #f5f5f5;
        }
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* ▼▼▼ 请用下面这段【新样式】替换掉你现有的 #favorites-list 样式 ▼▼▼ */
        
        /* 让收藏视图成为一个flex容器, 从上到下排列 */
        #favorites-view {
            display: flex;
            flex-direction: column;
        }
        
        /* 确保收藏页的header高度固定，不被压缩 */
        #favorites-view > .header {
            flex-shrink: 0;
        }
        
        /* === 收藏列表样式 (修正后) === */
        #favorites-list {
            flex-grow: 1; 
            overflow-y: auto; 
            overflow-x: hidden; /* <-- 新增这行，禁止水平滚动 */
            padding: 15px; 
            display: flex;
            flex-direction: column;
            gap: 15px; 
        }
        
        /* ▲▲▲ 替换结束 ▲▲▲ */
        
        .favorite-item-card {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.06);
            position: relative; /* 为了定位删除按钮 */
        }
        
        /* 卡片头部，包含头像、名字和来源 */
        .fav-card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }
        
        .fav-card-header .avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
        }
        
        .fav-card-header .info {
            flex-grow: 1;
        }
        
        .fav-card-header .name {
            font-weight: 600;
            font-size: 15px;
        }
        
        .fav-card-header .source {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        /* 卡片内容 */
        .fav-card-content {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .fav-card-content .chat-image {
            margin-top: 8px; /* 图片和文字的间距 */
        }
        
        /* 删除按钮 */
        .fav-delete-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 28px;
            height: 28px;
            background: #f0f2f5;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            color: var(--text-secondary);
            line-height: 28px;
            text-align: center;
        }
        
        .fav-delete-btn:hover {
            background-color: #e9ecef;
            color: #ff3b30;
        }
        
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* === 搜索栏样式 === */
        .search-bar-container {
            padding: 10px 15px;
            background-color: #f9f9f9; /* 和列表背景色保持一致 */
            position: relative; /* 为了定位清除按钮 */
            flex-shrink: 0;
        }
        
        #favorites-search-input {
            width: 100%;
            padding: 10px 30px 10px 15px; /* 右侧留出清除按钮的位置 */
            font-size: 16px;
            border: 1px solid var(--border-color);
            border-radius: 18px; /* 圆角矩形，更现代化 */
            background-color: var(--secondary-bg);
            box-sizing: border-box;
            outline: none;
        }
        #favorites-search-input:focus {
            border-color: var(--accent-color);
        }
        
        .search-clear-btn {
            position: absolute;
            right: 25px;
            top: 50%;
            transform: translateY(-50%);
            background: #ccc;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            line-height: 20px;
            text-align: center;
            font-size: 16px;
            cursor: pointer;
        }
        
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        
        /* === 聊天界面多选操作栏优化 === */
        #chat-interface-screen .header .selection-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        #chat-interface-screen .selection-controls .action-btn {
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            padding: 5px;
        }
        
        /* === 收藏页面多选模式样式 === */
        #favorites-view.selection-mode .favorite-item-card {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        /* 选择框的样式 */
        .favorite-item-card::before {
            content: '';
            position: absolute;
            left: -25px; /* 把它放在卡片左边外面 */
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border: 2px solid #ccc;
            border-radius: 50%;
            background-color: white;
            transition: all 0.2s ease;
            opacity: 0; /* 默认隐藏 */
        }
        
        /* 进入选择模式时，卡片向右移动，露出选择框 */
        #favorites-view.selection-mode .favorite-item-card {
            transform: translateX(35px);
        }
        #favorites-view.selection-mode .favorite-item-card::before {
            opacity: 1;
        }
        
        /* 选中后的样式 */
        #favorites-view.selection-mode .favorite-item-card.selected::before {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            content: '✔';
            color: white;
            font-size: 14px;
            text-align: center;
            line-height: 20px;
        }
        
        /* 底部操作栏 (终极修正版) */
        #favorites-action-bar {
            position: absolute; /* ★ 改为 absolute，相对于 #phone-screen 定位 */
            bottom: 0;
            left: 0;
            right: 0;           /* ★ 新增 right: 0，和 left: 0 一起撑满宽度 */
            width: auto;        /* ★ 改为 auto，让 left/right 决定宽度 */
            padding: 10px 15px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom)); /* 适配iPhone底部安全区 */
            background-color: rgba(247, 247, 247, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
            box-sizing: border-box;
            z-index: 5;
            display: none;
            /* max-width 已经不需要了，因为父元素已经限制了宽度 */
        }
        
        #favorites-action-bar .action-bar-btn {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: none;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            background-color: #ff3b30;
            color: white;
        }
        
        /* === 【修正】聊天界面头部控件切换逻辑 === */
        
        /* 默认状态：隐藏多选控件 */
        #chat-interface-screen .header .selection-controls {
            display: none;
        }
        
        /* 默认状态：显示默认控件，并让它撑满整个头部 */
        #chat-interface-screen .header .default-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        /* 当进入多选模式时：隐藏默认控件 */
        #chat-interface-screen.selection-mode .header .default-controls {
            display: none;
        }
        
        /* 当进入多选模式时：显示多选控件，并让它撑满整个头部 */
        #chat-interface-screen.selection-mode .header .selection-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* === 修正：放大所有主要的“+”号按钮 === */
        #add-chat-btn,
        #add-world-book-btn,
        #create-album-btn-page {
            font-size: 28px;   /* 显著增大字体大小，使其视觉上与旁边的图标匹配 */
            font-weight: 300;  /* 使用更细的字重，让加号看起来更清爽，不显粗笨 */
            position: relative;/* 允许进行位置微调 */
            top: -1px;         /* 字体放大后，通常需要稍微向上移动一点，使其视觉上更居中 */
        }
        
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* 预览区容器样式 */
        #settings-preview-area {
            width: 100%;
            height: 180px; /* 给一个固定的高度 */
            background-color: #f0f2f5;
            border-radius: 8px;
            padding: 15px;
            box-sizing: border-box;
            overflow: hidden; /* 防止内容溢出 */
            display: flex;
            flex-direction: column;
            gap: 10px; /* 预览气泡之间的间距 */
            border: 1px solid var(--border-color);
            position: relative; /* 为了定位背景 */
        }
        
        /* 预览区的背景，可以和真实聊天界面同步 */
        #settings-preview-area::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-size: cover;
            background-position: center;
            z-index: 1;
            opacity: 0.8;
        }
        
        /* 让预览气泡在背景之上 */
        #settings-preview-area .message-wrapper {
            position: relative;
            z-index: 2;
        }
        
        /* 预览区内使用的头像要小一点 */
        #settings-preview-area .message-bubble .avatar {
            width: 30px;
            height: 30px;
        }
        
        #settings-preview-area .message-bubble .timestamp {
            display: none; /* 预览区不需要显示时间戳 */
        }
        
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
        .existing-group-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        .existing-group-item .group-name {
            font-weight: 500;
        }
        
        .existing-group-item .delete-group-btn {
            color: #ff3b30;
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
        .chat-group-container {
            border-bottom: 1px solid var(--border-color);
        }
        .chat-group-container:first-child {
            border-top: 1px solid var(--border-color);
        }
        
        .chat-group-header {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            cursor: pointer;
            background-color: #f7f7f7;
        }
        
        .chat-group-header .arrow {
            font-size: 14px;
            margin-right: 8px;
            transition: transform 0.2s ease;
        }
        
        .chat-group-header.collapsed .arrow {
            transform: rotate(-90deg);
        }
        
        .chat-group-header .group-name {
            font-weight: 600;
            font-size: 15px;
        }
        
        .chat-group-content {
            max-height: 1000px; /* 一个足够大的值 */
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
        }
        
        .chat-group-content.collapsed {
            max-height: 0;
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* 格式助手按钮的容器 */
        .format-helpers {
            display: flex;
            gap: 10px;
            margin-bottom: 15px; /* 与下方的文本框拉开距离 */
            flex-wrap: wrap; /* 如果按钮太多可以换行 */
        }
        
        /* 单个格式助手按钮的样式 */
        .format-btn {
            background-color: #e9ecef;
            color: var(--text-primary);
            border: none;
            padding: 6px 12px;
            border-radius: 16px; /* 胶囊形状，更友好 */
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .format-btn:hover {
            background-color: #dcdfe3;
        }
        
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* “…”按钮的样式 */
        .post-actions-btn {
            margin-left: auto; /* 关键：让它自动靠到最右边 */
            padding: 5px 10px;
            font-size: 20px;
            font-weight: bold;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 50%;
            line-height: 1;
        }
        .post-actions-btn:hover {
            background-color: #f0f0f0;
        }
        
        /* 动态编辑模态框的样式 (它将复用现有的操作菜单样式) */
        #post-actions-modal .custom-modal-footer button {
            width: 100%;
            border: none;
            border-bottom: 1px solid #dbdbdb;
            padding: 14px;
            font-size: 18px;
        }
        #post-actions-modal .custom-modal-footer button:last-child {
            border-bottom: none;
        }
        #post-actions-modal #cancel-post-action-btn {
            margin-top: 8px;
            border-radius: 8px;
            background-color: #f0f0f0;
        }
        
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* 统一重置转账卡片内所有文字的特效和颜色 */
        #chat-messages .transfer-card .transfer-title,
        #chat-messages .transfer-card .transfer-amount,
        #chat-messages .transfer-card .transfer-note {
            text-shadow: none !important; /* 强制移除任何发光或阴影效果 */
            color: white !important;      /* 强制锁定文字颜色为白色 */
        }
        
        /* 分别锁定各自的字体大小和字重，防止被篡改 */
        #chat-messages .transfer-card .transfer-title {
            font-size: 16px !important;
            font-weight: 600 !important;
        }
        
        #chat-messages .transfer-card .transfer-amount {
            font-size: 28px !important;
            font-weight: bold !important;
        }
        
        #chat-messages .transfer-card .transfer-note {
            font-size: 13px !important;
            opacity: 0.9 !important;
        }
        
        /* ▼▼▼ 这是新增的样式，用于修正所有头部标题的居中问题 ▼▼▼ */
        .header > span:nth-child(2),
        #chat-header-title {
            position: absolute;
            left: 50%;
            transform: translateX(calc(-50% - 2px)); /* 在-50%的基础上，再向左推2像素 */
            
            /* (可选但推荐) 防止长标题与两边按钮重叠 */
            max-width: 60%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* ▲▲▲ 粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】可视化消息编辑器样式 ▼▼▼ */
        #message-editor-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .message-editor-block {
            background-color: #f9f9f9;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
        }
        
        .message-editor-block textarea {
            width: 100%;
            min-height: 60px;
            resize: vertical;
            border: 1px solid #ccc;
            border-radius: 6px;
            padding: 8px;
            font-size: 16px;
            box-sizing: border-box;
        }
        
        .message-editor-block .format-helpers {
            margin-top: 8px;
            margin-bottom: 0; /* 覆盖默认的 margin-bottom */
        }
        
        .message-editor-block .delete-block-btn {
            float: right;
            margin-top: -5px;
            background: none;
            border: none;
            color: #ff3b30;
            font-size: 20px;
            cursor: pointer;
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】联系人选择器样式 ▼▼▼ */
        .contact-picker-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
        }
        .contact-picker-item .checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #ccc;
            border-radius: 50%;
            margin-right: 15px;
            transition: all 0.2s ease;
        }
        .contact-picker-item.selected .checkbox {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            content: '✔';
            color: white;
            font-size: 14px;
            text-align: center;
            line-height: 20px;
        }
        .contact-picker-item .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 12px;
        }
        .contact-picker-item .name {
            font-weight: 500;
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】群成员管理界面样式 ▼▼▼ */
        #member-management-list {
            padding: 0; /* 移除默认padding，让列表项撑满 */
        }
        
        .member-management-item {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .member-management-item .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 12px;
        }
        
        .member-management-item .name {
            flex-grow: 1;
            font-weight: 500;
        }
        
        .member-management-item .remove-member-btn {
            background-color: #ff3b30;
            color: white;
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-size: 20px;
            line-height: 28px;
            text-align: center;
            cursor: pointer;
            flex-shrink: 0;
        }
        
        #member-management-actions {
            flex-shrink: 0;
            padding: 15px;
            border-top: 1px solid var(--border-color);
            background-color: #f7f7f7;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        #member-management-actions button {
            width: 100%;
            padding: 15px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }
        #member-management-actions #create-new-member-btn {
            background-color: #4cd964; /* 新建用绿色，以示区分 */
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】外卖代付卡片样式 ▼▼▼ */
        
        
        .waimai-card {
            width: 240px;
            border-radius: 12px;
            overflow: hidden;
            background-color: #fff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }
        
        .waimai-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .waimai-header .icon {
            width: 20px;
            height: 20px;
        }
        
        .waimai-header .title-group {
            display: flex;
            align-items: baseline;
            font-size: 14px;
            color: #8a8a8a;
        }
        .waimai-header .title-group .brand {
            font-weight: 600;
            color: #555;
            margin-right: 5px;
        }
        .waimai-header .title-group .separator {
            margin: 0 5px;
        }
        
        .waimai-catchphrase {
            font-size: 13px;
            color: #1f1f1f;
            padding: 12px;
        }
        
        .waimai-main {
            background-color: #FFD66B; /* 橙黄色背景 */
            padding: 12px;
            text-align: center;
        }
        
        .waimai-main .request-title {
            font-size: 12px;
            color: #856404;
            margin-bottom: 8px;
        }
        
        .waimai-main .payment-box {
            background-color: #fff;
            border-radius: 8px;
            padding: 15px 10px;
        }
        
        .waimai-main .payment-label {
            font-size: 13px;
            color: #8a8a8a;
        }
        
        .waimai-main .amount {
            font-size: 32px;
            font-weight: 700;
            color: #1f1f1f;
            margin: 4px 0 12px 0;
        }
        
        .waimai-main .countdown-label {
            font-size: 13px;
            color: #8a8a8a;
        }
        .waimai-main .countdown-timer {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            margin-left: 5px;
        }
        .waimai-main .countdown-timer span {
            background-color: #333;
            color: white;
            padding: 2px 4px;
            border-radius: 2px;
            font-weight: bold;
            font-size: 12px;
        }
        
        .waimai-details-btn {
            width: 100%;
            padding: 10px 0;
            margin-top: 15px;
            border: none;
            border-radius: 6px;
            background-color: #FFC33A;
            color: #49380a;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】外卖响应状态样式 ▼▼▼ */
        
        /* === 同意支付后的样式 === */
        .message-bubble.status-paid .waimai-card {
            border: 2px solid #28a745; /* 绿色边框 */
        }
        .message-bubble.status-paid .waimai-main .request-title::before {
            content: '✅  ';
        }
        .message-bubble.status-paid .waimai-main .request-title {
            color: #155724;
            font-weight: 600;
            /* 重写 request-title 的内容 */
            content: "我已为您买单，请尽情享用吧～" !important;
            display: block;
            margin-bottom: 15px;
        }
        
        .message-bubble.status-paid .payment-box {
            display: none; /* 隐藏支付详情 */
        }
        .message-bubble.status-paid .waimai-details-btn {
            background-color: #28a745;
            color: white;
        }
        
        /* === 拒绝支付后的样式 === */
        .message-bubble.status-rejected .waimai-card {
            border: 2px solid #dc3545; /* 红色边框 */
            opacity: 0.8;
        }
        .message-bubble.status-rejected .waimai-main {
            background-color: #e9ecef;
        }
        .message-bubble.status-rejected .waimai-main .request-title::before {
            content: '❌ ';
        }
        .message-bubble.status-rejected .waimai-main .request-title {
            color: #721c24;
            font-weight: 600;
            /* 重写 request-title 的内容 */
            content: "我拒绝了您的代付请求" !important;
            display: block;
            margin-bottom: 15px;
        }
        .message-bubble.status-rejected .payment-box {
            display: none; /* 隐藏支付详情 */
        }
         .message-bubble.status-rejected .waimai-details-btn {
            background-color: #6c757d;
            color: white;
        }
        
        /* 强制重写 request-title 内容的技巧 */
        .message-bubble[class*="status-"] .request-title {
            font-size: 0; /* 隐藏原始文本 */
        }
        .message-bubble[class*="status-"] .request-title::after {
            font-size: 14px; /* 让伪元素显示新文本 */
        }
        .message-bubble.status-paid .request-title::after {
            content: "我已为您买单，请尽情享用吧～";
        }
        .message-bubble.status-rejected .request-title::after {
            content: "我拒绝了您的代付请求";
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】外卖请求的用户操作按钮样式 ▼▼▼ */
        .waimai-user-actions {
            display: flex;
            gap: 10px;
            padding: 0 12px 12px 12px; /* 在卡片底部留出空间 */
            background-color: #fff;
        }
        
        .waimai-user-actions button {
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            border: 1.5px solid;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .waimai-pay-btn {
            background-color: #28a745;
            border-color: #1f7a33;
            color: white;
        }
        .waimai-pay-btn:hover {
            background-color: #218838;
        }
        
        .waimai-decline-btn {
            background-color: #f8f9fa;
            border-color: #ced4da;
            color: #495057;
        }
        .waimai-decline-btn:hover {
            background-color: #e2e6ea;
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* === 【新增】统一设置页面的背景色 (已修正) === */
        #api-settings-screen,
        #font-settings-screen,
        #wallpaper-screen,
        #memories-view,
        #contact-picker-screen,
        #member-management-screen,
        #world-book-editor-screen {  
            background-color: var(--secondary-bg);
        }
        
        /* 确保这些页面的内容区能正确滚动 */
        #api-settings-screen .form-container,
        #font-settings-screen .form-container,
        #wallpaper-screen .form-container {
            padding-top: 100px;
            margin-top: -80px;
            background-color: var(--secondary-bg);
        }
        
        /* 壁纸设置页面的预览区比较特殊，需要额外调整 */
        #wallpaper-screen .form-container {
            align-items: center; /* 保持内容居中 */
        }
        
        /* ▼▼▼ 【全新】来电请求与视频通话界面样式 ▼▼▼ */
        
        /* --- 来电请求模态框 --- */
        #incoming-call-modal .incoming-call-content {
            background-color: rgba(40, 40, 40, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            width: 280px;
            padding: 30px 20px;
            text-align: center;
            color: white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .caller-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 12px;
            border: 3px solid rgba(255,255,255,0.5);
        }
        
        .caller-name {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .caller-text {
            font-size: 14px;
            color: #ccc;
            margin-bottom: 30px;
        }
        
        .incoming-call-actions {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }
        
        .action-button-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #e0e0e0;
        }
        
        .call-action-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            background-size: 50%;
            background-repeat: no-repeat;
            background-position: center;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .call-action-btn:active {
            transform: scale(0.9);
        }
        
        .call-action-btn.decline {
            background-color: #ff3b30;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
        }
        
        .call-action-btn.accept {
            background-color: #4cd964;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>');
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(76, 217, 100, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0); }
        }
        
        /* --- 视频通话界面 --- */
        /* ▼▼▼ 请用这一整块【最终修正版】的代码，替换所有旧的 video-call 相关CSS ▼▼▼ */
        
        /* 1. 通话屏幕总容器 (保持不变) */
        #video-call-screen {
            background-color: #1c1c1e;
            color: white;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* 2. 顶部栏和底部控制栏 (保持不变) */
        .video-call-top-bar {
            position: absolute;
            top: 0; left: 0; width: 100%;
            padding: 15px 20px;
            padding-top: 50px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
            z-index: 10;
            text-align: center;
            box-sizing: border-box;
            pointer-events: none;
        }
        #call-timer {
            font-size: 16px;
            font-weight: 500;
            letter-spacing: 1px;
        }
        .video-call-controls {
            position: absolute;
            bottom: 0; left: 0; width: 100%;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 20px;
            padding-bottom: 40px;
            background: linear-gradient(to top, rgba(0,0,0,0.5), transparent);
            z-index: 10;
            box-sizing: border-box;
        }
        
        /* 3. 参与者头像显示区 (保持不变) */
        .video-call-avatar-area {
            flex-grow: 1; 
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            padding-top: 80px; /* 确保顶部有足够空间 */
            box-sizing: border-box;
            overflow-y: auto; /* ★ 新增：如果头像太多，允许此区域滚动 */
        }
        
        /* 4. 头像网格容器 (保持不变) */
        #participant-avatars-grid {
            display: flex;
            flex-wrap: wrap; 
            justify-content: center;
            align-items: center;
            gap: 15px; /* ★ 稍微减小头像间距 */
            max-width: 100%;
        }
        
        /* 5. 单个参与者的头像容器 (头像缩小) */
        .participant-avatar-wrapper {
            position: relative;
            text-align: center;
            flex-shrink: 0;
        }
        .participant-avatar {
            width: 70px;   /* ★ 从 80px 缩小到 70px */
            height: 70px;  /* ★ 从 80px 缩小到 70px */
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }
        .participant-name {
            margin-top: 8px;
            font-size: 12px;
            color: #ccc;
        }
        
        /* 6. 发言者头像高亮效果 (保持不变) */
        .participant-avatar.speaking {
            border-color: #4cd964;
            box-shadow: 0 0 20px rgba(76, 217, 100, 0.6);
            transform: scale(1.05);
        }
        
        /* 7. 【最终版】对话框区域 */
        #video-call-main {
            flex-shrink: 0; 
            height: 30%;   /* ★ 核心修改：高度从35%减小到30% */
            margin: 15px 15px 130px 15px; /* ★ 核心修改：底部边距从120px增加到130px，创造明显空隙 */
            overflow-y: auto;
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-sizing: border-box;
        }
        
        /* 8. 控制按钮样式 (保持不变) */
        .control-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            background-repeat: no-repeat;
            background-position: center;
            transition: transform 0.2s, background-color 0.2s;
        }
        .control-btn:active {
            transform: scale(0.9);
        }
        .control-btn.speak-btn {
            background-color: rgba(255,255,255,0.2);
            background-size: 55%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>');
        }
        .control-btn.hangup-btn {
            background-color: #ff3b30;
            background-size: 50%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
        }
        .control-btn.join-btn {
            background-color: #007bff;
            background-size: 50%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="17" y1="11" x2="23" y2="11"></line></svg>');
        }
        
        /* ▲▲▲ 新CSS替换结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】视频通话对话气泡样式 ▼▼▼ */
        .call-message-bubble {
            padding: 10px 15px;
            border-radius: 12px;
            max-width: 85%;
            line-height: 1.6;
            word-break: break-word;
            white-space: pre-wrap;
        }
        
        .call-message-bubble.ai-speech {
            background-color: rgba(255, 255, 255, 0.15);
            align-self: flex-start; /* AI发言靠左 */
        }
        
        .call-message-bubble.user-speech {
            background-color: #4cd964; /* 用户发言用绿色，类似微信 */
            align-self: flex-end;   /* 用户发言靠右 */
            text-align: left; /* 确保用户气泡内的文字是左对齐的 */
        }
        /* ▲▲▲ 新增CSS结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新添加】正在呼叫界面样式 ▼▼▼ */
        #outgoing-call-screen {
            background-color: #1c1c1e;
            color: white;
            justify-content: center; /* 垂直居中 */
            align-items: center;   /* 水平居中 */
        }
        
        .outgoing-call-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        
        .outgoing-call-actions {
            margin-top: 50px; /* 和上方文字拉开距离 */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #e0e0e0;
        }
        /* ▲▲▲ 添加结束 ▲▲▲ */
        
        /* 1. 动态帖子的外层容器，我们需要它来定位和裁剪 */
        .qzone-post-container {
            position: relative; /* 让内部的删除按钮可以相对于它定位 */
            overflow: hidden;   /* 隐藏掉超出部分的删除按钮 */
            border-radius: 12px;/* 和内部卡片保持一致的圆角 */
        }
        
        /* 2. 可滑动的内容卡片，增加一个平滑的过渡效果 */
        .qzone-post-item {
            transition: transform 0.3s ease;
            background-color: var(--secondary-bg); /* 确保它有背景色，能盖住下面的删除按钮 */
            position: relative; /* 确保它在最上层 */
            z-index: 2;
        }
        
        /* 3. 【核心】这就是那个“删除”按钮的样式！*/
        .qzone-post-delete-action {
            position: absolute; /* 绝对定位，脱离文档流 */
            top: 0;
            right: 0;
            bottom: 0;
            width: 90px; /* 删除按钮的宽度 */
            background-color: #ff3b30; /* 您想要的红色背景 */
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
            cursor: pointer;
            z-index: 1; /* 确保它在卡片下面 */
        }
        
        /* 4. 当卡片左滑时，把它向左移动，露出删除按钮 */
        .qzone-post-item.swiped {
            transform: translateX(-90px); /* 移动的距离和删除按钮的宽度一致 */
        }
        
        /* ▲▲▲ 粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 请将这【一整块】全新的“拍一拍”样式，粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* 1. “拍一拍”的屏幕震动动画 */
        @keyframes pat-shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
            20%, 40%, 60%, 80% { transform: translateX(3px); }
        }
        
        .pat-animation {
            animation: pat-shake 0.4s ease-in-out;
        }
        
        /* 2. “拍一拍”系统提示消息的样式 */
        .system-message {
            align-self: center; /* 居中显示 */
            padding: 4px 12px;
            margin: 5px 0;
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-secondary);
            font-size: 12px;
            border-radius: 10px;
            text-align: center;
            max-width: 80%;
        }
        
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        
        /* 让“拍一拍”类型的 wrapper 居中 */
        .message-wrapper.system-pat {
            justify-content: center;
            align-self: center;
            margin: 5px 0;
            max-width: 80%;
        }
        /* “拍一-拍”消息气泡的样式 */
        .message-bubble.system-bubble {
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-secondary);
            font-size: 12px;
            padding: 4px 12px;
            border-radius: 10px;
        }
        
        /* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* === 修正：让顶部操作栏可以横向滚动 === */
        #chat-input-actions-top {
            display: flex;
            gap: 8px;
            padding: 0 5px;
        
            /* --- 核心代码开始 --- */
            overflow-x: auto;      
            flex-wrap: nowrap;     
            -webkit-overflow-scrolling: touch; 
        
            scrollbar-width: none; 
            -ms-overflow-style: none;  
        }
        
        #chat-input-actions-top::-webkit-scrollbar {
            display: none; 
        }
        
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* === 【全新】聊天界面头部状态栏样式 === */
        
        /* 1. 标题和状态的总容器，使用flex布局让它们垂直排列 */
        #chat-header-title-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center; /* 水平居中 */
            gap: 2px; /* 标题和状态之间的微小间距 */
            
            /* 为了让它能在flex布局中正确居中 */
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            max-width: 60%;
        }
        
        /* 2. 主标题的样式微调 */
        #chat-header-title {
            font-size: 16px; /* 可以稍微缩小一点，给状态栏留出空间 */
            font-weight: 600;
            position: static; /* 覆盖掉旧的absolute定位 */
            transform: none;  /* 覆盖掉旧的transform */
            /* 保证长标题也能正确显示省略号 */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }
        
        /* 3. 状态栏容器 */
        #chat-header-status {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            color: var(--text-secondary);
            transition: all 0.3s ease;
        }
        
        /* 4. 状态小圆点 */
        .status-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background-color: #4cd964; /* 默认绿色，代表在线 */
            transition: background-color 0.3s ease;
        }
        
        /* 当AI状态为“忙碌”或“离开”时，让圆点变灰色 */
        #chat-header-status.busy .status-dot {
            background-color: #cccccc;
        }
        
        /* 5. 状态文本 */
        .status-text {
            font-weight: 500;
        }
        
        /* === 【全新美化版】回忆卡片样式 === */
        
        /* 1. 卡片总容器：这里负责定义整体的背景色和边框 */
        .memory-card {
            background-color: #fffaf0; /* 统一的、温暖的米黄色背景 */
            border-radius: 12px;
            padding: 15px; /* 在卡片四周留出内边距 */
            box-shadow: 0 2px 6px rgba(0,0,0,0.07);
            border-left: 5px solid #ffb74d; 
            display: flex; /* 让它成为flex容器，方便内部元素排列 */
            flex-direction: column; /* 让头部和内容垂直堆叠 */
            gap: 8px; /* 在头部和内容之间创造一个自然的间距 */
        }
        
        /* 2. 头部容器：现在只负责布局和分割线 */
        .memory-card .header {
            border-bottom: 1px solid rgba(217, 129, 0, 0.15); /* 分割线颜色可以稍微加深一点 */
            padding-bottom: 8px; 
        }
        
        /* 3. 日期样式 (保持不变) */
        .memory-card .header .date {
            font-size: 11px;
            color: #a1887f;
            margin-bottom: 4px; 
        }
        
        /* 4. 作者样式 (保持不变) */
        .memory-card .header .author {
            font-weight: 600;
            color: #d98100;
            font-size: 15px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* 5. 内容区样式 (保持不变) */
        .memory-card .content {
            font-size: 14px;
            line-height: 1.7;
            color: #5d4037;
            white-space: pre-wrap;
        }
        
        /* === 【全新】约定/倒计时卡片样式 === */
        .countdown-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
            text-align: center;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }
        .countdown-card::before {
            content: '✨';
            position: absolute;
            top: -10px;
            left: -10px;
            font-size: 50px;
            opacity: 0.1;
            transform: rotate(-15deg);
        }
        .countdown-card .title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
        }
        .countdown-card .timer {
            font-size: 28px;
            font-weight: 300;
            letter-spacing: 2px;
            margin-bottom: 15px;
        }
        .countdown-card .target-date {
            font-size: 12px;
            opacity: 0.8;
            border-top: 1px solid rgba(255,255,255,0.2);
            padding-top: 10px;
        }
        
        /* === 【全新】聊天锁定遮罩层样式 === */
        #chat-lock-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(247, 247, 247, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 150; /* 比输入框高，比贴纸面板低 */
            display: none; /* 默认隐藏 */
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
            border-top: 1px solid var(--border-color);
            text-align: center;
        }
        #chat-lock-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        #chat-lock-content .lock-text {
            color: var(--text-secondary);
            font-size: 14px;
        }
        #chat-lock-content .lock-action-btn {
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid var(--accent-color);
            background-color: var(--accent-color);
            color: white;
            cursor: pointer;
        }
        #chat-lock-content .lock-action-btn.secondary {
            background-color: transparent;
            color: var(--accent-color);
        }
        
        /* ▼▼▼ 【全新】红包卡片样式 ▼▼▼ */
        
        
        .red-packet-card {
            width: 220px;
            border-radius: 8px;
            background: linear-gradient(160deg, #F96259, #E44D44);
            color: #ffd700; /* 金色文字 */
            padding: 12px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        
        .red-packet-card.opened {
            background: linear-gradient(160deg, #d3c4a0, #c4b693);
            cursor: default;
        }
        
        .red-packet-card::before {
            content: '🧧';
            position: absolute;
            top: -5px;
            left: -5px;
            font-size: 30px;
            opacity: 0.2;
            transform: rotate(-10deg);
        }
        
        .rp-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .rp-icon {
            width: 20px;
            height: 20px;
        }
        
        .rp-greeting {
            font-size: 15px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .rp-type {
            font-size: 11px;
            color: white;
            opacity: 0.8;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 8px;
            margin-top: 8px;
        }
        
        .rp-claimed-info {
            font-size: 13px;
            color: white;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.3);
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】红包详情列表样式 ▼▼▼ */
        .rp-details-item {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        .rp-details-item:last-child {
            border-bottom: none;
        }
        .rp-details-item .name {
            flex-grow: 1;
            font-weight: 500;
            color: #333;
        }
        .rp-details-item .amount {
            font-weight: 500;
            color: #555;
        }
        .rp-details-item .lucky-king-tag {
            font-size: 10px;
            background-color: #ffd700;
            color: #a67c00;
            padding: 2px 5px;
            border-radius: 4px;
            margin-left: 8px;
            font-weight: bold;
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】投票功能样式 ▼▼▼ */
        
        /* 投票卡片在消息气泡中的样式 */
        
        /* 投票卡片主体 */
        .poll-card {
            width: 250px;
            background-color: #f9f9f9;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
            padding: 12px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
        
        .poll-card.closed {
            background-color: #e9ecef; /* 结束后变灰 */
        }
        
        /* 投票问题 */
        .poll-question {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 12px;
            line-height: 1.4;
            word-break: break-word;
        }
        
        /* 投票选项列表 */
        .poll-options-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        /* 单个投票选项 */
        .poll-option-item {
            background-color: white;
            border: 1px solid #dcdcdc;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: background-color 0.2s;
        }
        
        .poll-card:not(.closed) .poll-option-item:hover {
            background-color: #f0f8ff;
        }
        
        /* 用户已投票的选项样式 */
        .poll-option-item.voted {
            border-color: var(--accent-color);
            background-color: #e7f3ff;
            font-weight: 500;
        }
        
        /* 投票进度条 */
        .poll-option-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background-color: rgba(0, 123, 255, 0.1);
            z-index: 1;
            transition: width 0.3s ease-in-out;
        }
        
        /* 选项内容（文字和票数），确保在进度条之上 */
        .poll-option-content {
            position: relative;
            z-index: 2;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .poll-option-text {
            font-size: 14px;
        }
        
        .poll-option-votes {
            font-size: 13px;
            color: #8a8a8a;
            font-weight: 500;
        }
        
        /* 投票卡片底部 */
        .poll-footer {
            margin-top: 12px;
            padding-top: 8px;
            border-top: 1px solid #e9e9e9;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .poll-total-votes {
            font-weight: 500;
        }
        
        .poll-action-btn {
            background: none;
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            padding: 4px 10px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
        }
        .poll-card.closed .poll-action-btn {
            background-color: #6c757d;
            color: white;
            border-color: #6c757d;
        }
        
        /* 创建投票模态框的选项输入 */
        .poll-option-input-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .poll-option-input-wrapper input {
            flex-grow: 1;
        }
        .poll-option-input-wrapper .remove-option-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background-color: #f0f0f0;
            color: #ff3b30;
            border: none;
            cursor: pointer;
            font-size: 18px;
            line-height: 28px;
            text-align: center;
            flex-shrink: 0;
        }
        
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* === 【全新】聊天头部“正在输入”状态样式 === */
        #chat-header-title.typing-status {
            color: var(--text-secondary);
            animation: typing-pulse 1.5s infinite;
            font-style: italic;
        }
        
        @keyframes typing-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        #chat-header-title {
            transition: opacity 0.2s ease-in-out;
        }
        
        @keyframes message-pop-in {
          from {
            opacity: 0;
            transform: translateY(15px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }
        
        .message-wrapper.animate-in {
          animation: message-pop-in 0.3s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
          }
        
        /* ▼▼▼ 【全新】App图标设置样式 ▼▼▼ */
#icon-settings-grid,
#cphone-icon-settings-grid { /* <--- 核心修复：在这里为两个容器同时应用样式 */
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
    gap: 20px;
    width: 100%;
    padding: 0 10px;
    box-sizing: border-box;
}
        
        .icon-setting-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        .icon-preview {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            background-size: cover;
            background-position: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .change-icon-btn {
            padding: 4px 10px;
            font-size: 12px;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            border-radius: 5px;
            cursor: pointer;
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】外观设置页面布局修正 ▼▼▼ */
        
        /* 1. 修正滚动问题 */
        #wallpaper-screen .form-container {
            /* 核心修正1: 解决flex布局下的滚动冲突，让滚动条能正常出现 */
            min-height: 0; 
        }
        
        /* 2. 修正壁纸预览被压扁的问题 */
        #wallpaper-preview {
            /* 核心修正2: 防止预览框被过多的内容挤压变形，让它保持自己的高度 */
            flex-shrink: 0; 
        }
        /* ▲▲▲ 修正结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】分享链接功能样式 (无图版) ▼▼▼ */
        
        /* 1. 浏览器界面背景色和内容区样式 (保持不变) */
        #browser-screen {
            background-color: #f8f9fa;
        }
        #browser-content {
            padding: 20px;
            font-size: 16px;
            line-height: 1.8;
            color: #333;
            overflow-y: auto;
            background-color: #f8f9fa;
        }
        #browser-content .article-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 10px;
        }
        #browser-content .article-meta {
            font-size: 13px;
            color: #8a8a8a;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e0e0e0;
        }
        #browser-content .article-body {
            white-space: pre-wrap;
            word-break: break-word;
        }
        #browser-content .article-body p {
            margin-bottom: 1em;
        }
        
        /* 2. 聊天气泡中的链接卡片样式 (无图版) */
        
        
        .link-share-card {
            width: 210px; 
            background-color: #fff;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
            padding: 12px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .link-share-card:hover {
            background-color: #f9f9f9;
        }
        
        .link-share-card .title {
            font-weight: 600;
            font-size: 15px;
            line-height: 1.4;
            color: #1f1f1f;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .link-share-card .description {
            font-size: 13px;
            color: #8a8a8a;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .link-share-card .footer {
            display: flex; /* 让图标和文字水平对齐 */
            align-items: center;
            gap: 6px; /* 图标和文字的间距 */
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px; /* 和上面的描述拉开一点距离 */
        }
        .link-share-card .footer-icon{
            width: 14px;
            height: 14px;
            flex-shrink: 0; /* 防止图标被压缩 */
        }
        
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* 单条评论的容器，现在需要相对定位 */
        .comment-item {
            position: relative;
            padding-right: 25px; /* 在右侧留出删除按钮的空间 */
        }
        
        /* 评论删除按钮的样式 */
        .comment-delete-btn {
            position: absolute;
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            width: 22px;
            height: 22px;
            line-height: 22px;
            text-align: center;
            border-radius: 50%;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0; /* 默认隐藏 */
        }
        
        /* 鼠标悬停在评论上时，显示删除按钮 */
        .comment-item:hover .comment-delete-btn {
            opacity: 1;
        }
        
        .comment-delete-btn:hover {
            background-color: #f0f0f0;
            color: #ff3b30;
        }
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* === 【全新】夜间模式样式 === */
        
        /* 核心：当 #phone-screen 拥有 .dark-mode 类时，激活以下所有样式 */
        
        /* 1. 全局背景和文本颜色 */
        #phone-screen.dark-mode {
            --secondary-bg: #1c1c1e; /* 主要卡片背景色 */
            --border-color: #38383a;  /* 边框颜色 */
            --text-primary: #ffffff;   /* 主要文字颜色 */
            --text-secondary: #8d8d92; /* 次要文字/图标颜色 */
        }
        
        /* 2. 各个页面的主背景色 */
        #phone-screen.dark-mode #chat-list-screen,
        #phone-screen.dark-mode #qzone-screen .qzone-content,
        #phone-screen.dark-mode #memories-view {
            background-color: #000000;
        }
        
        /* 3. 聊天列表 */
        #phone-screen.dark-mode #chat-list {
            background-color: #000000;
        }
        #phone-screen.dark-mode .chat-list-item {
            border-bottom-color: rgba(255, 255, 255, 0.15);
        }
        #phone-screen.dark-mode .chat-group-header {
            background-color: #1c1c1e; /* 从白色改为深灰色 */
            border-bottom: 1px solid #38383a; /* 给它一个细微的下边框 */
        }
        #phone-screen.dark-mode .chat-list-item .name,
        #phone-screen.dark-mode .chat-group-header .group-name {
            color: #ffffff;
        }
        #phone-screen.dark-mode .chat-list-item:hover {
            background-color: #1c1c1e;
        }
        
        /* 4. 顶部/底部导航栏 */
        #phone-screen.dark-mode .header,
        #phone-screen.dark-mode .qzone-header {
            background-color: rgba(25, 25, 25, 0.9);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-bottom-color: rgba(255, 255, 255, 0.15);
            color: #ffffff;
        }
        #phone-screen.dark-mode .header .back-btn,
        #phone-screen.dark-mode .header .action-btn,
        #phone-screen.dark-mode .header .save-btn {
            color: #ffffff;
        }
        #phone-screen.dark-mode #chat-list-bottom-nav {
            background-color: rgba(25, 25, 25, 0.9);
            border-top-color: rgba(255, 255, 255, 0.15);
        }
        #phone-screen.dark-mode .nav-item.active {
            color: #ffffff;
        }
        
        /* 5. 聊天界面 */
        #phone-screen.dark-mode #chat-input-area {
            background-color: rgba(5, 5, 5, 0.8);
            border-top: none;
        }
        #phone-screen.dark-mode #chat-input {
            background-color: #3e3e42;
            color: #ffffff;
        }
        #phone-screen.dark-mode #chat-input::placeholder {
            color: #8d8d92;
        }
        #phone-screen.dark-mode .chat-action-icon-btn {
            color: #ffffff;
            background-color: rgba(255, 255, 255, 0.1);
            border: none;
        }
        #phone-screen.dark-mode #send-btn {
            background-color: var(--accent-color);
        }
        
        /* 6. 动态 (QZone) 界面 */
        #phone-screen.dark-mode .qzone-actions-bar,
        #phone-screen.dark-mode .qzone-post-item {
            background-color: #1c1c1e;
            border: 1px solid #333;
            box-shadow: 0 2px 8px rgba(255, 255, 255, 0.05);
        }
        #phone-screen.dark-mode .action-item:not(:last-child)::after {
            background-color: #333;
        }
        #phone-screen.dark-mode .post-footer,
        #phone-screen.dark-mode .post-likes-section {
            border-top-color: #333;
        }
        #phone-screen.dark-mode .post-likes-section {
            background-color: rgba(0, 123, 255, 0.1);
        }
        #phone-screen.dark-mode .comment-input {
            background-color: #333;
            color: #ffffff;
        }
        #phone-screen.dark-mode .comment-input::placeholder {
            color: #8d8d92;
        }
        #phone-screen.dark-mode .post-actions-btn:hover {
            background-color: #333;
        }
        #phone-screen.dark-mode .at-mention-popup {
            background-color: #1c1c1e;
            border-color: #333;
        }
        #phone-screen.dark-mode .at-mention-item {
            border-bottom-color: #333;
        }
        #phone-screen.dark-mode .at-mention-item:hover {
            background-color: #333;
        }
        
        /* 7. 回忆录界面 */
        #phone-screen.dark-mode .memory-card {
            background-color: #1c1c1e;
            border-left-color: #e6a753;
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.08);
        }
        #phone-screen.dark-mode .memory-card .header {
            background-color: #2c2c2e;
            border-bottom-color: #38383a;
            margin: -15px -15px 8px -15px;
            padding: 12px 15px;
            border-radius: 12px 12px 0 0;
        }
        #phone-screen.dark-mode .memory-card .header .date,
        #phone-screen.dark-mode .memory-card .header .author,
        #phone-screen.dark-mode .memory-card .content {
            color: #e0e0e0;
        }
        
        /* 8. 其他设置和列表页 */
        #phone-screen.dark-mode #api-settings-screen,
        #phone-screen.dark-mode #font-settings-screen,
        #phone-screen.dark-mode #wallpaper-screen,
        #phone-screen.dark-mode #contact-picker-screen,
        #phone-screen.dark-mode #member-management-screen,
        #phone-screen.dark-mode #world-book-editor-screen,
        #phone-screen.dark-mode #world-book-list,
        #phone-screen.dark-mode .list-item:hover,
        #phone-screen.dark-mode .list-container,
        #phone-screen.dark-mode .form-container {
            background-color: #000000;
        }
        #phone-screen.dark-mode .form-group input, 
        #phone-screen.dark-mode .form-group select, 
        #phone-screen.dark-mode .form-group textarea {
            background-color: #1c1c1e;
            color: #ffffff;
            border-color: #38383a;
        }
        #phone-screen.dark-mode .form-button-secondary {
            background-color: #333;
            border-color: #555;
            color: #fff;
        }
        #phone-screen.dark-mode #font-preview {
            background-color: #1c1c1e;
            border-color: #38383a;
        }
        #phone-screen.dark-mode #font-preview p {
            color: #ffffff;
        }
        
        /* ▲▲▲ 粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 把这一整块【全新的修正CSS】，粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* === 【全新】夜间模式视觉修正 === */
        
        /* 1. 修正动态卡片内的文字颜色 */
        #phone-screen.dark-mode .qzone-post-item .post-nickname,
        #phone-screen.dark-mode .qzone-post-item .post-content {
            color: #f0f0f0; /* 从深灰色改为明亮的浅灰色 */
        }
        
        /* 2. 修正收藏卡片内的文字颜色 */
        #phone-screen.dark-mode .favorite-item-card .fav-card-header .name,
        #phone-screen.dark-mode .favorite-item-card .fav-card-content {
            color: #f0f0f0; /* 同样改为浅灰色 */
        }
        #phone-screen.dark-mode .favorite-item-card .fav-card-header .source {
            color: #8d8d92; /* 来源文字用次要灰色 */
        }
        
        /* 3. 修正收藏页的搜索栏背景和输入框样式 */
        #phone-screen.dark-mode .search-bar-container {
            background-color: #000000; /* 容器背景变为纯黑 */
        }
        #phone-screen.dark-mode #favorites-search-input {
            background-color: #1c1c1e; /* 输入框背景变为深灰 */
            border-color: #38383a;     /* 边框颜色变暗 */
            color: #ffffff;            /* 输入文字变为白色 */
        }
        #phone-screen.dark-mode #favorites-search-input::placeholder {
            color: #8d8d92; /* 占位符文字颜色变暗 */
        }
        
        /* ▲▲▲ 修正CSS粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* === 【全新】iOS风格的Toggle Switch开关样式 === */
        
        /* 1. 开关的容器 */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 51px;
            height: 31px;
        }
        
        /* 2. 隐藏掉原始的 checkbox 输入框 */
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        /* 3. 开关的背景（那个椭圆） */
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #e9e9eb; /* 关闭时的背景色 */
            transition: .4s;
            border-radius: 34px;
        }
        
        /* 4. 开关上的圆点 */
        .slider:before {
            position: absolute;
            content: "";
            height: 27px;
            width: 27px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        
        /* 5. 【核心】当 checkbox 被选中时（即开启状态） */
        input:checked + .slider {
            background-color: #34c759; /* 开启时的背景色（iOS绿色）*/
        }
        
        input:checked + .slider:before {
            transform: translateX(20px); /* 让圆点滑动到右边 */
        }
        
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】引用回复功能样式 ▼▼▼ */
        
        /* ▼▼▼ 【全新】引用回复功能样式 ▼▼▼ */
        
        /* 1. 输入框上方的“回复预览栏” */
        #reply-preview-bar {
            display: none; /* 默认隐藏 */
            padding: 8px 12px;
            margin: 0 8px 8px 8px; /* 和输入框周围的边距保持一致 */
            background-color: rgba(0, 0, 0, 0.05);
            border-left: 3px solid var(--accent-color);
            border-radius: 6px;
            position: relative;
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        #phone-screen.dark-mode #reply-preview-bar {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .reply-preview-content .sender {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .reply-preview-content .text {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: block; /* 确保省略号生效 */
            max-width: 95%;
        }
        
        #cancel-reply-btn {
            position: absolute;
            top: 50%;
            right: 8px;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            line-height: 20px;
            text-align: center;
            border-radius: 50%;
            background-color: rgba(0,0,0,0.1);
            cursor: pointer;
            font-size: 14px;
        }
        
        /* 2. 消息气泡内部的“引用消息块” */
        .quoted-message {
            padding: 6px 10px;
            margin-bottom: 6px;
            background-color: rgba(0, 0, 0, 0.04);
            border-left: 2px solid var(--accent-color);
            border-radius: 4px;
            font-size: 0.9em; /* 字体比正文小一点 */
            opacity: 0.8;
        }
        
        #phone-screen.dark-mode .quoted-message {
            background-color: rgba(255, 255, 255, 0.08);
            border-left-color: #a0cff1;
        }
        
        .quoted-message .quoted-sender {
            font-weight: 600;
            color: var(--accent-color);
        }
        #phone-screen.dark-mode .quoted-message .quoted-sender {
            color: #a0cff1;
        }
        
        .quoted-message .quoted-content {
            color: var(--text-secondary);
            white-space: normal;     /* 核心修正1: 允许文本正常换行 */
            word-break: break-word;  /* 核心修正2: 强制长单词或连续字符断开，防止溢出 */
            display: block;
        }
        
        /* === 字体预览框样式 (修正后) === */
        
        /* 默认（日间模式）的样式 */
        #font-preview {
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: #f9f9f9; /* 日间模式的浅灰色背景 */
            transition: background-color 0.3s, border-color 0.3s;
        }
        
        /* 预览框里的文字颜色，默认是黑色 */
        #font-preview p {
            color: var(--text-primary);
        }
        
        /* 夜间模式下的修正样式 */
        #phone-screen.dark-mode #font-preview {
            background-color: #1c1c1e; /* 深灰色背景 */
            border-color: #38383a;     /* 暗色边框 */
        }
        
        /* 夜间模式下，预览框里的文字变为白色 */
        #phone-screen.dark-mode #font-preview p {
            color: #ffffff;
        }
        
        /* ▼▼▼ 【全新】精致版转账操作弹窗样式 ▼▼▼ */
        .transfer-actions-content {
            background-color: #fff0f5; /* 粉嫩的背景色 */
            border-radius: 20px;
            width: 290px;
            padding: 20px;
            box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3); /* 粉色阴影 */
            text-align: center;
            position: relative;
            border: 1px solid #ffcce0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
        
        .transfer-actions-header {
            font-size: 20px;
            font-weight: bold;
            color: #a35c7b; /* 深粉色标题 */
            margin-bottom: 15px;
        }
        
        .transfer-actions-body p {
            font-size: 15px;
            color: #555;
            margin: 0 0 25px 0;
            line-height: 1.5;
        }
        
        .transfer-actions-footer {
            display: flex;
            justify-content: space-between;
            gap: 15px;
        }
        
        .transfer-actions-footer .action-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            color: white;
        }
        
        .transfer-actions-footer .action-btn:active {
            transform: scale(0.95);
        }
        
        .transfer-actions-footer .action-btn.accept {
            background: linear-gradient(135deg, #ff85b3, #ff69b4);
            box-shadow: 0 4px 10px rgba(255, 105, 180, 0.4);
        }
        
        .transfer-actions-footer .action-btn.decline {
            background: linear-gradient(135deg, #c2c2c2, #a0a0a0);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        
        .transfer-actions-content .cancel-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: none;
            background-color: rgba(0, 0, 0, 0.1);
            color: #a35c7b;
            font-size: 20px;
            line-height: 28px;
            cursor: pointer;
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */
        
        /* === 未读消息红点样式 === */
        .unread-count-wrapper {
            flex-shrink: 0;
            width: 40px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 20px; /* 让红点和名字差不多高 */
        }
        
        .unread-count {
            min-width: 20px;
            height: 20px;
            padding: 0 6px;
            background-color: #ff3b30; /* iOS 风格的红色 */
            color: white;
            font-size: 13px;
            font-weight: 500;
            line-height: 20px;
            text-align: center;
            border-radius: 10px; /* 圆角矩形 */
            box-shadow: 0 1px 2px rgba(0,0,0,0.15);
            display: none; /* 默认隐藏 */
            justify-content: center;
            align-items: center;
        }
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】通话记录页面与卡片样式 ▼▼▼ */
        
        /* 确保页面背景色统一 */
        #call-history-screen {
            background-color: #f0f2f5;
        }
        
        /* 通话记录卡片样式 */
        .call-record-card {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            border-left: 5px solid var(--accent-color);
        }
        .call-record-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.1);
        }
        
        /* 卡片头部：包含日期和时长 */
        .call-record-card .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
        }
        .call-record-card .card-header .duration {
            font-weight: 500;
            color: var(--text-primary);
        }
        
        /* 卡片主体：参与者头像 */
        .call-record-card .card-body {
            display: flex;
            align-items: center;
        }
        .call-record-card .participants-avatars {
            display: flex;
            align-items: center;
        }
        .call-record-card .participant-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        /* 让头像有一个漂亮的堆叠效果 */
        .call-record-card .participant-avatar:not(:first-child) {
            margin-left: -12px;
        }
        .call-record-card .participants-names {
            margin-left: 12px;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 15px;
        }
        
        /* --- 通话详情弹窗样式 --- */
        #transcript-modal-body {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 15px;
        }
        .transcript-entry {
            padding: 8px 12px;
            border-radius: 10px;
            max-width: 85%;
            line-height: 1.5;
            word-break: break-word;
        }
        .transcript-entry.user {
            background-color: #dcf8c6; /* 类似微信的绿色 */
            align-self: flex-end;
        }
        .transcript-entry.assistant {
            background-color: #ffffff;
            align-self: flex-start;
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        #chat-list-title {
            cursor: pointer;
        }
        
        /* ▼▼▼ 【全新】通话记录卡片美化样式 ▼▼▼ */
        
        .call-record-card .card-body {
            /* 将 body 改为 flex 布局，让标题和参与者信息垂直排列 */
            display: flex;
            flex-direction: column;
            gap: 8px; /* 标题和参与者信息之间的间距 */
        }
        
        .call-record-card .custom-title {
            font-size: 16px;
            font-weight: 600; /* 加粗，让它像个标题 */
            color: var(--text-primary);
            padding-bottom: 8px; /* 标题下的留白 */
            border-bottom: 1px solid var(--border-color); /* 在标题下加一条分割线 */
            margin-bottom: 4px; /* 和下面的参与者信息拉开一点距离 */
        }
        
        .call-record-card .participants-info {
            /* 这个新容器让头像和“与xx”能水平对齐 */
            display: flex;
            align-items: center;
        }
        
        /* 参与者名字的样式微调，让它不那么突出 */
        .call-record-card .participants-names {
            margin-left: 12px;
            font-weight: 500; /* 不再加粗 */
            font-size: 14px; /* 稍微小一点 */
            color: var(--text-secondary); /* 使用次要文字颜色 */
        }
        
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】语音转文字功能样式 ▼▼▼ */
        
        /* 1. 语音文字内容的样式 */
        .voice-transcript {
            font-size: 14px;         /* 文字大小 */
            line-height: 1.6;        /* 行高，让多行文本更易读 */
            color: var(--text-secondary); /* 使用次要文字颜色，与语音条区分 */
            padding: 8px 12px;       /* 内边距 */
            margin-top: 6px;         /* 和上方的语音条拉开一点距离 */
            background-color: rgba(0, 0, 0, 0.04); /* 给一个淡淡的背景，更有层次感 */
            border-radius: 6px;      /* 圆角 */
            word-break: break-word;  /* 确保长文本能正常换行 */
            display: none;           /* 默认隐藏 */
        }
        
        #phone-screen.dark-mode .voice-transcript {
            background-color: rgba(255, 255, 255, 0.1); /* 夜间模式下的背景色 */
        }
        
        /* 2. 旋转加载动画的样式 */
        .loading-spinner {
            display: none; /* 默认隐藏 */
            width: 16px;
            height: 16px;
            border: 2px solid rgba(0, 0, 0, 0.2);
            border-top-color: var(--accent-color); /* 旋转部分的颜色 */
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 8px; /* 和波形图、时长保持一点间距 */
        }
        
        /* 3. 定义旋转动画 */
        @keyframes spin {
            to {
        transform: rotate(360deg);
            }
        }
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】分享记录查看器样式修正 ▼▼▼ */
        #shared-history-viewer-content {
            display: flex;
            flex-direction: column; /* 让气泡垂直排列 */
            gap: 20px; /* 在每个气泡之间增加20像素的间距 */
            padding: 15px; /* 在容器四周也增加一些内边距，避免气泡贴边 */
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】播放器和歌词样式 ▼▼▼ */
        #music-player-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 60px;
            background-color: rgba(0,0,0,0.3);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-50px);
            transition: opacity 0.4s ease-out, transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        #music-player-overlay.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        
        .music-player-window { 
            width: 70%; 
            min-height: 420px;
            background-color: rgba(255, 255, 255, 0.6); 
            backdrop-filter: blur(20px); 
            -webkit-backdrop-filter: blur(20px); 
            border-radius: 25px; 
            box-shadow: 0 8px 32px 0 rgba(25, 25, 25, 0.37); 
            border: 1px solid rgba(255, 255, 255, 0.18); 
            padding: 25px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            color: #1f1f1f; 
            position: relative;
            justify-content: space-between;
            padding-bottom: 15px;
        }
        
        .music-player-top-actions {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            width: calc(100% - 30px);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .top-left-cluster {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        #music-return-btn, #music-exit-btn {
            background: none;
            border: none;
            font-size: 28px;
            font-weight: 300;
            cursor: pointer;
            color: #555;
            padding: 5px;
            line-height: 1;
        }
        #music-exit-btn {
            font-size: 24px;
            font-weight: 400;
        }
        
        .music-progress-bar-container {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 25px;
            margin-bottom: 10px;
        }
        .time-display {
            font-size: 11px;
            color: #888;
            width: 35px;
            text-align: center;
            flex-shrink: 0;
            font-family: 'SF Mono', 'Menlo', monospace;
        }
        .progress-bar {
            flex-grow: 1;
            height: 5px;
            background-color: #e5e5e5;
            border-radius: 2.5px;
            cursor: pointer;
        }
        .progress-bar-fill {
            width: 0%;
            height: 100%;
            background-color: #333;
            border-radius: 2.5px;
        }
        
        #music-lyrics-container {
            width: 100%;
            height: 192px;
            overflow: hidden;
            position: relative;
            -webkit-mask-image: linear-gradient(transparent, black 20%, black 80%, transparent);
            mask-image: linear-gradient(transparent, black 20%, black 80%, transparent);
        }
        
        #music-lyrics-list {
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
        }
        
        .lyric-line {
            padding: 4px 0;
            font-size: 14px;
            color: #666;
            text-align: center;
            line-height: 1.5;
            transition: all 0.5s ease;
            opacity: 0.7;
            transform: scale(0.95);
        }
        
        .lyric-line.active {
            font-size: 16px;
            color: #000;
            opacity: 1;
            transform: scale(1);
        }
        
        .music-player-controls-wrapper {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .music-controls {
            margin-top: 0;
        }
        
        #music-return-btn, #music-exit-btn, #music-playlist-btn {
            position: relative;
        }
        
        #music-return-btn { top: -2px; }
        #music-playlist-btn { top: -3px; }
        
        .playlist-item-actions {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .playlist-action-btn {
            font-size: 18px;
            color: #888;
            cursor: pointer;
            transition: color 0.2s;
        }
        .playlist-action-btn:hover { color: #000; }
        .delete-track-btn { font-size: 24px; color: #ff3b30; }
        .delete-track-btn:hover { color: #c00; }
        .lyrics-btn { font-weight: 500; }
        
        /* --- 【核心修正】确保头像尺寸 --- */
        .message-bubble .avatar {
            width: 34px;
            height: 34px;
            border-radius: 20%;
            object-fit: cover;
            flex-shrink: 0; /* 防止被压缩 */
        }
        
        /* ▼▼▼ 【全新】撤回消息样式 ▼▼▼ */
        
        /* 1. 撤回消息的占位符样式 */
        .recalled-message-placeholder {
            align-self: center; /* 居中显示 */
            padding: 4px 12px;
            margin: 5px 0;
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-secondary);
            font-size: 12px;
            border-radius: 10px;
            text-align: center;
            max-width: 80%;
            cursor: pointer; /* 让它看起来可以点击 */
        }
        
        /* 2. 夜间模式下的适配 */
        #phone-screen.dark-mode .recalled-message-placeholder {
            background-color: rgba(255, 255, 255, 0.15);
        }
        
        /* 3. AI撤回消息时的动画效果 */
        @keyframes recall-animation {
          from {
            opacity: 1;
            transform: scale(1);
          }
          to {
            opacity: 0;
            transform: scale(0.8);
          }
        }
        
        .message-wrapper.recalled-animation {
          animation: recall-animation 0.3s ease-out forwards;
        }
        
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】撤回消息样式修正 ▼▼▼ */
        
        /* 强制撤回消息的占位符不换行，并保持内容居中 */
        .recalled-message-placeholder {
            white-space: nowrap; /* 核心：禁止文本换行 */
            display: inline-block; /* 让背景根据内容自适应宽度 */
            padding: 4px 12px;
        }
        
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】世界书分类列表样式 ▼▼▼ */
        .world-book-group-container {
            border-bottom: 1px solid var(--border-color);
        }
        .world-book-group-container:first-child {
            border-top: 1px solid var(--border-color);
        }
        .world-book-group-header {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            cursor: pointer;
            background-color: #f7f7f7;
        }
        .world-book-group-header .arrow {
            font-size: 14px;
            margin-right: 8px;
            transition: transform 0.2s ease;
        }
        .world-book-group-header.collapsed .arrow {
            transform: rotate(-90deg);
        }
        .world-book-group-header .group-name {
            font-weight: 600;
            font-size: 15px;
        }
        .world-book-group-content {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
        }
        .world-book-group-content.collapsed {
            max-height: 0;
        }
        #phone-screen.dark-mode .world-book-group-header {
            background-color: #1c1c1e;
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        /* ▼▼▼ 【全新】聊天置顶样式 ▼▼▼ */
        .chat-list-item.pinned {
            background-color: #f0f2f5; /* 给一个淡淡的、不同的背景色 */
        }
        
        #phone-screen.dark-mode .chat-list-item.pinned {
            background-color: #2c2c2e; /* 夜间模式下的置顶背景色 */
        }
        /* ▼▼▼ 修复输入框遮挡按钮的布局问题 ▼▼▼ */
        #chat-input-area {
            display: flex;
            flex-direction: column;
            flex-shrink: 0; /* 防止整个输入区被意外压缩 */
            background-color: var(--secondary-bg); /* 确保背景色统一，避免透明重叠 */
        }
        
        #chat-input-actions-top {
            flex-shrink: 0; /* 防止按钮行被压缩 */
            padding-bottom: 8px; /* 增加一点和输入框的间距，改善观感 */
        }
        
        #chat-input-main-row {
            flex-shrink: 0; /* 防止输入框行被压缩 */
        }
        /* ▲▲▲ 修复结束 ▲▲▲ */
        /* ▼▼▼ 【全新】群聊@功能样式 ▼▼▼ */
        
        /* ▼▼▼ 【核心修复】请用这段代码替换您现有的 #chat-input-area 样式 ▼▼▼ */
        #chat-input-area {
            position: relative; /* 保持相对定位，作为弹窗的“锚点” */
            z-index: 20;      /* 【关键修复】提升整个输入区的层级 */
            flex-shrink: 0;
            padding: 8px;
            background-color: rgba(247, 247, 247, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        /* ▲▲▲ 替换结束 ▲▲▲ */
        
        /* 2. 定义聊天@弹窗的具体位置和样式 */
        #chat-at-mention-popup {
            bottom: 100%; /* 显示在整个输入区的上方 */
            left: 8px;    /* 与输入区左边内边距对齐 */
            right: 8px;   /* 与输入区右边内边距对齐 */
            width: auto;  /* 宽度自动撑满 */
            margin-bottom: 5px; /* 和输入区拉开一点距离 */
            /* 其他样式将复用 .at-mention-popup 的现有样式 */
        }
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        /* ▼▼▼ 【全新】群公告板弹窗样式 ▼▼▼ */
        #announcement-board-modal .modal-content {
            height: 70%;
            background-color: #f0f2f5;
        }
        #announcement-board-content {
            padding: 15px;
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px; /* 公告之间的间距 */
        }
        #announcement-board-content .message-wrapper {
            max-width: 100%; /* 让公告消息可以撑满宽度 */
            align-self: center;
        }
        #announcement-board-content .timestamp {
            display: none; /* 公告板内不显示时间戳 */
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        /* ▼▼▼ 【全新】公告板卡片管理样式 ▼▼▼ */
        .announcement-item-wrapper {
            position: relative; /* 为了定位操作按钮 */
            padding: 10px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .announcement-item-actions {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 20px;
            font-weight: bold;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 5px;
            line-height: 1;
            border-radius: 50%;
        }
        .announcement-item-actions:hover {
            background-color: #f0f0f0;
        }
        .pinned-indicator {
            position: absolute;
            top: -8px;
            left: -8px;
            width: 28px;
            height: 28px;
            background-color: #ffc107;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 2px solid white;
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        /* ▼▼▼ 【全新】转发功能样式 ▼▼▼ */
        
        /* 1. 转发后的动态，内嵌的原始内容容器 */
        .reposted-content-wrapper {
            background-color: #f7f7f8;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
        }
        
        /* 在夜间模式下，为内嵌容器提供一个深色背景 */
        #phone-screen.dark-mode .reposted-content-wrapper {
            background-color: #2c2c2e;
            border-color: #38383a;
        }
        
        /* 2. 移除内嵌原始内容的底部互动区，避免混淆 */
        .reposted-content-wrapper .post-footer,
        .reposted-content-wrapper .post-feedback-icons,
        .reposted-content-wrapper .post-likes-section {
            display: none;
        }
        
        /* 3. 让内嵌内容的头部信息稍微紧凑一些 */
        .reposted-content-wrapper .post-header {
            margin-bottom: 8px;
        }
        .reposted-content-wrapper .post-avatar {
            width: 32px;
            height: 32px;
        }
        .reposted-content-wrapper .post-nickname {
            font-size: 14px;
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

             
        /* ▼▼▼ 【全新】共享位置卡片样式 (微信风格 V2 - 支持图片背景) ▼▼▼ */
        
        /* 1. 卡片总容器 (保持不变) */
        .location-share-card {
            width: 230px;
            border-radius: 10px;
            overflow: hidden; 
            background-color: #fff;
            border: 1px solid #f0f0f0;
            box-shadow: 0 1px 4px rgba(0,0,0,0.05);
            cursor: pointer; /* 让卡片看起来可以点击 */
        }
        
        /* 2. 上半部分：白色文字区 (保持不变) */
        .card-text-area {
            padding: 12px;
            border-bottom: 1px solid #f0f0f0;
        }
        .card-text-primary {
            font-size: 16px;
            font-weight: 600;
            color: #222;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .card-text-secondary {
            font-size: 12px;
            color: #a0a0a0;
        }
        
        /* 3. 下半部分：【核心修改】地图/图片区 */
        .card-map-area {
            height: 100px; /* 增加高度以更好地展示图片 */
            display: flex;
            justify-content: center;
            align-items: center;
            
            /* 图片背景的关键样式 */
            background-size: cover;
            background-position: center;
            
            /* 默认的纯色背景 (当没有提供图片时生效) */
            background-color: #FFF0F5; /* AI的卡片用柔和粉色 */
        }
        
        /* 4. 用户发送的卡片，地图区默认用柔和绿色 */
        .message-bubble.user .location-share-card .card-map-area {
            background-color: #F0FFF8;
        }
        
        /* 5. 【核心修改】美化图钉图标，增加阴影使其更突出 */
        .card-pin-icon {
            font-size: 40px;
            color: #FF6B6B; /* 【核心修改】将颜色从 white 改为您喜欢的任意颜色 */
        
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.4); 
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        /* ▼▼▼ 【全新】AI 角色行动呼吸灯效果 ▼▼▼ */
        @keyframes breathing-light {
            0% {
        box-shadow: 0 0 6px rgba(0, 123, 255, 0.4);
            }
            50% {
        box-shadow: 0 0 18px 4px rgba(0, 123, 255, 0.8);
            }
            100% {
        box-shadow: 0 0 6px rgba(0, 123, 255, 0.4);
            }
        }
        
        .chat-list-item .avatar.is-acting {
            /* 核心：应用呼吸灯动画 */
            animation: breathing-light 2s ease-in-out infinite;
            /* (可选) 同时添加一个常亮的边框，让效果更明显 */
            border: 1.5px solid rgba(0, 123, 255, 0.7);
        }
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        /* ▼▼▼ 【全新】动态评论区表情功能样式 ▼▼▼ */
        
        /* === 【全新】评论区表情按钮样式 (与action-icon风格统一) === */
        .comment-sticker-btn {
            /* 1. 重置按钮默认样式 */
            background: none;
            border: none;
            padding: 5px; /* 增加一点可点击区域 */
            cursor: pointer;
            
            /* 2. 与其他图标颜色和过渡效果对齐 */
            color: var(--text-secondary);
            transition: all 0.2s ease-in-out;
        
            /* 3. 使用Flex布局让内部的SVG完美居中 */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .comment-sticker-btn:hover {
            color: var(--text-primary); /* 鼠标悬停时变色，提供反馈 */
        }
        
        /* 4. 定义SVG图标的样式，与点赞/转发图标完全一致 */
        .comment-sticker-btn svg {
            width: 22px;
            height: 22px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        /* 2. 评论区表情面板容器 */
        #qzone-sticker-panel {
            position: absolute; /* 使用绝对定位，由JS控制位置 */
            width: 280px;
            height: 200px;
            background-color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.15);
            z-index: 1010; /* 确保在其他元素之上 */
            display: none; /* 默认隐藏 */
            flex-direction: column;
            overflow: hidden;
        }
        
        /* 3. 面板内的表情网格 (不变) */
        #qzone-sticker-grid {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
        }
        
        #qzone-sticker-grid .sticker-item {
            position: relative;
            aspect-ratio: 1 / 1;
            background-color: white;
            border-radius: 8px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }
        
        
        /* 4. 评论区里的表情图片样式 (尺寸修正后) */
        .comment-text .comment-sticker {
            max-width: 100px;  /* 减小最大宽度 */
            max-height: 100px; /* 减小最大高度 */
            display: block;
            background-color: transparent;
        }
        
        /* 5. 【新增】优化：当评论内容是表情时，调整间距 */
        .comment-item .comment-text:has(.comment-sticker) {
            /* 如果 .comment-text 内部只有表情，就移除文字行高带来的额外边距 */
            line-height: 1;
        }
        
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        /* === 头像框选择模态框样式 === */
        .change-frame-btn {
            padding: 6px 10px;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            margin-left: 10px;
        }
        
        #avatar-frame-modal .modal-content {
            height: 70%;
        }
        
        #avatar-frame-modal .modal-body {
            padding: 0;
            display: flex;
            flex-direction: column;
        }
        
        .frame-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .frame-tab {
            flex: 1;
            padding: 12px;
            text-align: center;
            font-weight: 500;
            cursor: pointer;
            color: var(--text-secondary);
            border-bottom: 2px solid transparent;
        }
        
        .frame-tab.active {
            color: var(--accent-color);
            border-bottom-color: var(--accent-color);
        }
        
        .frame-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
        }
        
        .frame-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 15px;
        }
        
        .frame-item {
            aspect-ratio: 1 / 1;
            border: 2px solid transparent;
            border-radius: 10px;
            cursor: pointer;
            background-color: #f0f0f0;
            background-size: cover;
            background-position: center;
            padding: 5px;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .frame-item.selected {
            border-color: var(--accent-color);
            transform: scale(1.05);
        }
        
        .frame-item .preview-avatar {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }
        
        .frame-item .preview-frame {
            position: absolute;
            top: -7px;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        
        /* ▼▼▼ 【最终修复方案】请用这一整块代码替换所有旧的头像相关样式 ▼▼▼ */
        
        /* 1. 头像最外层容器，负责占位和动态变宽 */
        .avatar-group {
            width: 34px;
            flex-shrink: 0; /* 确保在flex布局中不被压缩 */
            position: relative;
            transition: width 0.2s ease;
        }
        /* 当佩戴头像框时，外层容器变宽，为更大的头像框创造空间 */
        .avatar-group.has-frame {
            width: 42px; 
        }
        
        /* 2. 基础的、无框的头像样式 */
        .message-bubble .avatar {
            width: 34px;
            height: 34px;
            border-radius: 20%; /* 默认的方圆形头像 */
            object-fit: cover;
        }
        
        /* 3. 带框头像的“内部容器” */
        .avatar-with-frame {
            position: relative; /* 关键：为内部的头像和框提供定位锚点 */
            width: 38px;
            height: 38px;
            margin: 0 auto;
            transition: all 0.2s ease;
        }
        /* 【核心】当有框时，这个内部容器也变大，让里面的图片可以更大 */
        .avatar-group.has-frame .avatar-with-frame {
            width: 43px;
            height: 43px;
        }
        
        /* 4. 带框头像中的“头像图片本身” */
        .avatar-with-frame .avatar-img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; /* 宽度撑满其父容器 (.avatar-with-frame) */
            height: 100%;/* 高度也撑满 */
            border-radius: 50%; /* 佩戴头像框时，图片本身变为圆形以更好地适配 */
            object-fit: cover;
            z-index: 1; /* 确保在头像框下方 */
        }
        
        /* 5. “头像框图片本身” */
        .avatar-with-frame .avatar-frame {
            position: absolute;
            width: 120%;  
            height: 120%; 
        
            /* --- 这就是确保完美包裹和居中的关键代码 --- */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* --- 关键代码结束 --- */
            z-index: 2; /* 确保在头像图片上方 */
            pointer-events: none; /* 让鼠标事件可以穿透头像框，点到下面的头像 */
        }
        
        /* ▲▲▲ 替换结束 ▲▲▲ */
        /* ▼▼▼ 【最终修复方案】请用这整块代码替换所有旧的头像和气泡相关样式 ▼▼▼ */
        
        /* 1. 强制外层气泡容器(.message-bubble)成为一个真正的“弹性”项目。*/
        /* 这让它可以正确地为旁边的“时间戳”收缩。*/
        .message-bubble {
            flex: 1;          /* 关键修复①: 让它填充所有可用空间 (flex-grow: 1, flex-shrink: 1) */
            min-width: 0;     /* 关键修复②: 允许它收缩至比其内容更小，这是解决此类问题的核心技巧 */
            display: flex;
            align-items: flex-start;
            gap: 12px;
            max-width: 100%;
        }
        
        .message-bubble.user { 
            flex-direction: row-reverse; 
        }
        
        /* 2. 强制内层内容区(.content)也成为一个“弹性”项目。*/
        /* 这让它可以正确地为旁边的“头像”收缩。*/
        .message-bubble .content {
            flex: 1;          /* 关键修复③: 让内容区填充气泡内的所有可用空间 */
            min-width: 0;     /* 关键修复④: 同样允许它收缩，防止长文本撑破布局 */
            word-break: break-all !important; /* 关键修复⑤: 使用最强力的换行模式，确保长串字符能被截断 */
            position: relative;
            font-size: var(--chat-font-size, 16px);
            padding: 8px 12px;
            line-height: 1.5;
        }
        
        /* 3. 再次确保头像容器绝对不收缩 (作为最终保险) */
        .message-bubble .avatar-group {
            flex-shrink: 0 !important;
        }
        
        /* ▲▲▲ 修复方案结束 ▲▲▲ */
        /* ▼▼▼ 【终极强制修正】请将这段代码粘贴到 <style> 的最末尾 ▼▼▼ */
        
        /* 使用ID选择器和!important，强制提升这条规则的优先级到最高，
           以覆盖任何可能存在的未知冲突样式。*/
        
        #chat-interface-screen .message-bubble .avatar-group.has-frame .avatar-with-frame {
            width: 43px !important;
            height: 43px !important;
        }
        
        #chat-interface-screen .message-bubble .avatar-with-frame .avatar-img {
            width: 100% !important;
            height: 100% !important;
        }
        /* ▲▲▲ 修正结束 ▲▲▲ */
        /* ▼▼▼ 【全新】卡片/特殊内容居中修正 ▼▼▼ */
        .message-bubble.is-link-share .content,
        .message-bubble.is-transfer .content,
        .message-bubble.is-waimai-request .content,
        .message-bubble.is-red-packet .content,
        .message-bubble.is-poll .content,
        .message-bubble.is-location-share .content,
        .message-bubble.is-sticker .content,
        .message-bubble.is-ai-image .content {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* ▲▲▲ 修正结束 ▲▲▲ */
        /* ▼▼▼ 【全新】隐藏聊天列表中的头像框 (最终修正版) ▼▼▼ */
        
        /* 1. 在聊天列表屏幕中，直接隐藏头像框图片 */
        #chat-list-screen .avatar-frame {
            display: none;
        }
        
        /* 2. 强制所有头像的最外层容器，在列表页都保持 45px 的正确尺寸 */
        #chat-list-screen .avatar-group {
            width: 45px;
            height: 45px;
        }
        
        /* 3. 如果一个头像是带框结构，也强制其内部容器和图片适应 45px 的尺寸 */
        #chat-list-screen .avatar-group.has-frame .avatar-with-frame,
        #chat-list-screen .avatar-group.has-frame .avatar-img {
            width: 45px;
            height: 45px;
        }
        
        /* 4. 确保所有头像在列表页都是圆形的，保持统一 */
        #chat-list-screen .avatar-img,
        #chat-list-screen .avatar {
            border-radius: 50%;
        }
        
        /* ▲▲▲ 新增CSS结束 ▲▲▲ */
        /* ▼▼▼ 【全新】增加聊天列表头像与文字的间距 ▼▼▼ */
        
        /* 1. 强制为聊天列表中的头像容器设置右边距 */
        /*    这将覆盖任何可能存在的旧样式，并确保间距生效 */
        #chat-list .chat-list-item .avatar-group {
            margin-right: 15px !important; /* 核心：增加右边距，将文字推开 */
        }
        
        /* 2. (可选但推荐) 确保旧的头像样式不再干扰布局 */
        #chat-list .chat-list-item .avatar {
            margin-right: 0; /* 移除旧的边距，防止重复计算 */
        }
        
        /* ▲▲▲ 新增CSS结束 ▲▲▲ */
        /* ▼▼▼ 【全新】动态评论区回复功能样式 ▼▼▼ */
        
        /* 让评论项在鼠标悬停时高亮，并显示手型光标 */
        .comment-item {
            cursor: pointer;
            transition: background-color 0.2s;
            /* 使用Flex布局，让评论内容和删除按钮能正确对齐 */
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 8px; /* 内容和删除按钮的间距 */
            padding: 4px 6px; /* 增加一点内边距，方便点击 */
            margin: 0 -6px; /* 抵消内边距，保持视觉对齐 */
            border-radius: 4px;
        }
        
        .comment-item:hover {
            background-color: #f0f2f5;
        }
        
        /* 夜间模式下的悬停效果 */
        #phone-screen.dark-mode .comment-item:hover {
            background-color: #2c2c2e;
        }
        
        /* 评论内容文本的容器 */
        .comment-item .comment-text {
            flex-grow: 1; /* 占据主要空间 */
            word-break: break-word; /* 确保长内容能换行 */
        }
        
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        /* ▼▼▼ 【全新】用于兼容旧格式评论的样式 ▼▼▼ */
        .legacy-comment-item {
            line-height: 1.5;
            padding: 4px 6px; /* 和新样式保持一致的内边距 */
            color: var(--text-secondary); /* 用次要颜色显示，以示区别 */
        }
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        /* ▼▼▼ 【全新】卡片/特殊内容居中修正 ▼▼▼ */
        .message-bubble.is-link-share .content,
        .message-bubble.is-transfer .content,
        .message-bubble.is-waimai-request .content,
        .message-bubble.is-red-packet .content,
        .message-bubble.is-poll .content,
        .message-bubble.is-location-share .content,
        .message-bubble.is-sticker .content,
        .message-bubble.is-ai-image .content {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* ▲▲▲ 修正结束 ▲▲▲ */
        /* ▼▼▼ 【终极强制修正】请将这段代码粘贴到 <style> 的最末尾 ▼▼▼ */
        
        /* 使用ID选择器和!important，强制提升这条规则的优先级到最高，
           以覆盖任何可能存在的未知冲突样式。*/
        
        #chat-interface-screen .message-bubble .avatar-group.has-frame .avatar-with-frame {
            width: 43px !important;
            height: 43px !important;
        }
        
        #chat-interface-screen .message-bubble .avatar-with-frame .avatar-img {
            width: 100% !important;
            height: 100% !important;
        }
        /* ▲▲▲ 修正结束 ▲▲▲ */
        /* ▼▼▼ 【Safari/iOS 最终卡片布局修复】请用这一整块全新的代码 ▼▼▼ */
        
        /* 
          第一步：【核心修复】
          这个选择器会一次性选中所有包含特殊卡片的消息气泡容器(.message-bubble)。
          我们告诉它不要再强制拉伸，而是根据内部卡片的大小自适应宽度。
        */
        .message-bubble.is-sticker,
        .message-bubble.is-voice-message,
        .message-bubble.is-transfer,
        .message-bubble.is-ai-image,
        .message-bubble.is-waimai-request,
        .message-bubble.is-red-packet,
        .message-bubble.is-poll,
        .message-bubble.is-link-share,
        .message-bubble.is-location-share {
            flex: initial; /* 覆盖掉通用的 flex: 1，这是解决问题的关键，让气泡本身不再拉伸 */
            min-width: auto; /* 同样重置 min-width，允许其自由收缩 */
        }
        
        /* 
          第二步：保持对卡片内部 .content 区域的样式重置。
          我们移除它的背景和内边距，让卡片自己负责外观。
        */
        .message-bubble.is-sticker .content,
        .message-bubble.is-voice-message .content,
        .message-bubble.is-transfer .content,
        .message-bubble.is-ai-image .content,
        .message-bubble.is-waimai-request .content,
        .message-bubble.is-red-packet .content,
        .message-bubble.is-poll .content,
        .message-bubble.is-link-share .content,
        .message-bubble.is-location-share .content {
            /* 保持这个好习惯，确保内容区也不拉伸 */
            flex: initial; 
            
            /* 移除所有可能干扰卡片显示的样式 */
            padding: 0;
            background: transparent;
            box-shadow: none;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }
        
        /* ▲▲▲ 修复结束 ▲▲▲ */
        /* ▼▼▼ 【终极版】群公告对齐修复 (强制所有内容靠左) ▼▼▼ */
        
        /* 
          第一步：强制所有消息块（无论是AI还是用户）都在公告板内靠左对齐。
          这确保了AI和用户的消息块在垂直方向上是对齐的。
        */
        #announcement-board-content .message-wrapper {
            align-self: flex-start !important;
        }
        
        /* 
          第二步：这是最关键的一步！
          我们专门针对用户的消息气泡，强制将其内部的元素顺序（头像和内容）
          从“反向”恢复为“正向”，使其与AI的消息气泡布局完全一致。
        */
        #announcement-board-content .message-bubble.user {
            flex-direction: row !important;
        }
        
        /* 
          第三步 (可选但推荐): 
          同时，我们也强制将用户消息块外部的时间戳和气泡顺序恢复正常，
          以防未来可能出现的布局问题。
        */
        #announcement-board-content .message-wrapper.user {
            flex-direction: row !important;
        }
        
        /* ▲▲▲ 修复结束 ▲▲▲ */
        /* ▼▼▼ 【终极修复】请用这一整块代码，替换掉你上一次粘贴的代码 ▼▼▼ */
        
        /* === 聊天界面头部浮动与层级终极修复 === */
        
        /* 
          这次的修复有两个关键点：
          1. 依然使用 absolute 定位让头部浮动起来。
          2. 额外给它一个非常高的 z-index 并用 !important 标记，
             赋予它“至高无上”的权力，强制它压制页面上任何其他元素。
        */
        
        /* 1. 强制聊天界面的头部变为绝对定位，并赋予一个极高的层级 */
        #chat-interface-screen > .header {
            position: absolute !important; /* 核心修正1: 脱离文档流，浮动起来 */
            top: 0;
            left: 0;
            width: 100%;
            z-index: 100 !important; /* 核心修正2: 赋予一个非常高的 z-index，压制一切 */
        }
        
        /* 2. 修正聊天内容区的布局，移除不再需要的负外边距，让为头部预留的 padding 生效 */
        #chat-interface-screen #chat-messages {
            margin-top: 0 !important; /* 核心修正3: 移除用于“上拉”的负外边距 */
        }
        
        /* ▲▲▲ 修复代码粘贴结束 ▲▲▲ */
        /* ▼▼▼ 【最终解决方案】请用这一整块代码，替换掉所有旧的修复代码 ▼▼▼ */
        
        /* === 聊天界面布局与层级终极修复 === */
        
        /* 
          第一部分：修复音乐播放器被遮挡的问题
          我们给播放器一个比头部更高的 z-index，让它能正确地覆盖所有内容。
        */
        #music-player-overlay {
            z-index: 200 !important;
        }
        
        /* 
          第二部分：彻底重构聊天页面的布局，解决宽度和遮挡问题
          我们将采用最稳定、最现代的布局方式：
          - 头部和输入框都使用绝对定位，分别“钉”在屏幕的顶部和底部。
          - 聊天内容区则占据整个屏幕的高度，并通过内边距（padding）为头部和输入框留出空间。
          这样可以完美实现内容在透明顶/底部之下滚动的美观效果，且不会再出现宽度计算错误。
        */
        
        /* ▼▼▼ 请用这一整块全新的代码，替换所有旧的聊天界面布局CSS ▼▼▼ */
        
        /* 1. 确保聊天界面容器是可靠的定位锚点 */
        #chat-interface-screen {
            position: relative !important;
            height: 100%;
            width: 100%;
            overflow: hidden; /* 防止任何意外溢出 */
        }
        
        /* 2. 强制【头部】绝对定位，并“钉”在屏幕顶部 */
        #chat-interface-screen > .header {
            position: absolute !important;
            top: 0;
            left: 0;
            right: 0; /* 使用 left/right 撑满宽度，比 width:100% 更可靠 */
            width: auto !important; 
            z-index: 100 !important; /* 赋予一个非常高的层级，确保它在最上层 */
        }
        
        /* 3. 强制【输入框】也绝对定位，并“钉”在屏幕底部 */
        #chat-interface-screen #chat-input-area {
            position: absolute !important;
            bottom: 0;
            left: 0;
            right: 0;
            width: auto !important;
            z-index: 100 !important;
            /* 核心：为输入框本身添加适配“小黑条”的底部内边距 */
            padding-bottom: calc(8px + env(safe-area-inset-bottom)); 
        }
        
        /* 4. 【核心】重新定义【聊天内容区】的布局 */
        #chat-interface-screen #chat-messages {
            /* 让它填满整个屏幕 */
            height: 100% !important; 
            width: 100% !important;
            
            /* 允许其内容垂直滚动 */
            overflow-y: auto !important; 
            
            /* 确保 padding 的计算方式正确 */
            box-sizing: border-box !important; 
            
            /* 移除所有可能干扰布局的 margin */
            margin-top: 0 !important; 
        
            /* 关键：使用内边距为顶部的“头部”和底部的“输入框”留出空间 */
            /* 这样内容就会在半透明的顶/底部之下滚动，效果美观且精准 */
            padding-top: 150px !important;  /* 为头部预留约110px空间 */
            padding-bottom: 150px !important; /* 为输入框预留约120px空间 */
        }
        
        /* ▲▲▲ 替换结束 ▲▲▲ */
        
        /* ▲▲▲ 修复代码粘贴结束 ▲▲▲ */
        /* ▼▼▼ 【全新】“动态已删除”提示样式 ▼▼▼ */
        .post-deleted-placeholder {
            align-self: center;
            padding: 4px 12px;
            margin: 5px 0;
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-secondary);
            font-size: 12px;
            border-radius: 10px;
            text-align: center;
            max-width: 80%;
            cursor: pointer; /* 关键：让它看起来可以点击 */
        }
        
        #phone-screen.dark-mode .post-deleted-placeholder {
            background-color: rgba(255, 255, 255, 0.15);
        }
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        /* ▼▼▼ 【全新】为涂黑（剧透）功能添加的样式 ▼▼▼ */
        .spoiler {
            background-color: #333; /* 涂黑的背景色 */
            color: #333;           /* 涂黑的文字颜色，使其与背景融为一体 */
            padding: 0 4px;         /* 轻微的左右内边距，使其更美观 */
            border-radius: 4px;     /* 圆角 */
            cursor: pointer;        /* 鼠标悬停时显示为可点击的手型 */
            transition: all 0.2s ease-in-out; /* 让显示/隐藏效果更平滑 */
        }
        
        /* 鼠标悬停或点击时，恢复背景和文字颜色以显示内容 */
        .spoiler:hover, .spoiler:active {
            background-color: #e0e0e0; /* 显示时给一个淡淡的背景色 */
            color: inherit;           /* 恢复为正常的文字颜色 */
        }
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        /* ▼▼▼ 【全新】长期记忆管理按钮美化样式 ▼▼▼ */
        .memory-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px; /* 增加一点可点击区域，方便用户操作 */
            border-radius: 50%; /* 圆形背景 */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }
        
        .memory-action-btn svg {
            width: 18px;  /* 让图标比顶部的稍小一点，更显精致 */
            height: 18px;
            stroke: var(--text-secondary); /* 默认使用次要文字的灰色 */
            transition: stroke 0.2s;
        }
        
        .memory-action-btn:hover {
            background-color: #e9ecef; /* 鼠标悬停时给一个淡淡的背景色 */
        }
        
        /* 夜间模式下的悬停效果 */
        #phone-screen.dark-mode .memory-action-btn:hover {
            background-color: #38383a;
        }
        
        /* 编辑按钮悬停时，图标变为蓝色 */
        .memory-action-btn.edit-memory-btn:hover svg {
            stroke: var(--accent-color);
        }
        
        /* 删除按钮悬停时，图标变为危险的红色 */
        .memory-action-btn.delete-memory-btn:hover svg {
            stroke: #ff3b30;
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        /* ▼▼▼ 【全新】表情批量删除功能样式 ▼▼▼ */
        
        /* 管理模式下，为表情项添加一个选中框 */
        #sticker-grid.management-mode .sticker-item::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 3px solid transparent;
            border-radius: 10px;
            box-sizing: border-box;
            transition: border-color 0.2s;
        }
        
        /* 管理模式下，被选中的表情项，显示蓝色边框 */
        #sticker-grid.management-mode .sticker-item.selected::after {
            border-color: var(--accent-color);
        }
        
        /* 管理模式下，总是显示删除按钮 */
        #sticker-grid.management-mode .sticker-item .delete-btn {
            display: block;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid white;
        }
        
        /* 底部批量删除操作栏 */
        #sticker-action-bar {
            display: none; /* 默认隐藏 */
            padding: 10px 15px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            background-color: rgba(247, 247, 247, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
        }
        
        #sticker-action-bar button {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: none;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            background-color: #ff3b30;
            color: white;
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

        /* ▼▼▼ 【全新】导演剪辑室样式 ▼▼▼ */
        #ai-response-editor-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .ai-response-editor-block {
            background-color: #f9f9f9;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
        }
        
        .ai-response-editor-block textarea {
            width: 100%;
            min-height: 80px; /* 默认给一个更大的高度 */
            resize: vertical;
            border: 1px solid #ccc;
            border-radius: 6px;
            padding: 8px;
            font-size: 14px; /* 使用小一点的字体，方便查看JSON */
            font-family: monospace; /* 使用等宽字体，让JSON对齐更美观 */
            box-sizing: border-box;
        }
        
        .ai-response-editor-block .format-helpers {
            margin-top: 8px;
            margin-bottom: 0; /* 覆盖默认的 margin-bottom */
        }
        
        .ai-response-editor-block .delete-block-btn {
            float: right;
            margin-top: -5px;
            background: none;
            border: none;
            color: #ff3b30;
            font-size: 20px;
            cursor: pointer;
        }
        
        #phone-screen.dark-mode .ai-response-editor-block {
            background-color: #2c2c2e;
            border-color: #38383a;
        }
        #phone-screen.dark-mode .ai-response-editor-block textarea {
            background-color: #1c1c1e;
            color: #f0f0f0;
            border-color: #4a4a4e;
        }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新 | 线下模式内心独白样式 (已修复斜体)】 ▼▼▼ */
.offline-dialogue {
    /* 对话部分可以保持默认样式，或者稍作强调 */
    font-weight: 500;
}
.offline-description {
    display: block; 
    color: inherit; /* 保持普通描写文字颜色与对话一致 */
    font-style: normal; 
    margin-top: 4px; 
    white-space: pre-wrap; 
    line-height: 1.6;
}

/* ✨ 核心新增：专门为内心独白（斜体）设置样式 */
.offline-description em {
    color: var(--text-secondary); /* 将颜色设置为次要文字的浅灰色 */
    /* font-style: normal;  <-- 已删除此行，恢复斜体 */
}

#phone-screen.dark-mode .offline-description {
    color: inherit; /* 夜间模式下也保持普通描写文字颜色一致 */
}
/* ▲▲▲ 修改结束 ▲▲▲ */
        /* ▼▼▼ 【全新】引用跳转高亮效果 ▼▼▼ */
        
        /* 1. 为消息气泡的内容区添加一个平滑的背景色过渡效果 */
        .message-bubble .content {
            transition: background-color 0.5s ease-out;
        }
        
        /* 2. 定义高亮时的背景色 */
        /*    我们使用 !important 来确保它能覆盖掉所有主题的默认颜色 */
        .message-bubble.highlighted .content {
            background-color: rgba(0, 123, 255, 0.2) !important;
        }
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        /* ▼▼▼ 【布局终极修复】请用这一整块全新的CSS，替换掉您旧的所有五子棋相关样式 ▼▼▼ */
        
        /* ▼▼▼ 【边框终极修复V2】请用这一整块全新的CSS，替换掉您旧的所有五子棋相关样式 ▼▼▼ */
        
        /* 1. 棋盘的外部容器 (负责定位和动画窗口) */
        #gomoku-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 350px;
            z-index: 50;
            pointer-events: none; /* 让点击可以穿透 */
            overflow: hidden;     /* 【核心】隐藏掉滑出屏幕外的内容 */
            display: none;        /* 默认不显示，由JS控制 */
        }
        
        /* ▼▼▼ 【遮罩终极修复】请用这整块全新的CSS，替换掉您旧的 #gomoku-content-wrapper 样式 ▼▼▼ */
        
        /* 2. 棋盘的内部包装器 (负责外观和内容布局) */
        #gomoku-content-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* 【核心】移除所有背景和效果，使其完全透明 */
            background-color: transparent !important;
            backdrop-filter: none !important;
            box-shadow: none !important;
            /* --- 其他布局样式保持不变 --- */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 15px;
            padding: 15px 0;
            box-sizing: border-box;
            transition: transform 0.3s ease-out;
            transform: translateY(-100%);
            pointer-events: auto;
        }
        
        /* ▲▲▲ 替换结束 ▲▲▲ */
        
        #phone-screen.dark-mode #gomoku-content-wrapper {
            background-color: rgba(28, 28, 30, 0.9);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        
        /* 当棋盘可见时，将内部包装器滑入视图 */
        #gomoku-overlay.visible #gomoku-content-wrapper {
            transform: translateY(0);
        }
        
        /* 3. 聊天消息区 (保持不变) */
        #chat-messages {
            transition: padding-top 0.3s ease-out;
        }
        
        /* 4. 棋盘画布和控制按钮 (保持不变) */
        #gomoku-board {
            background-color: #e4b591;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            cursor: pointer;
        }
        
        #gomoku-controls {
            width: 100%;
            text-align: center;
            flex-shrink: 0;
        }
        
        #close-gomoku-btn {
            padding: 6px 15px;
            border-radius: 15px;
            border: 1px solid var(--text-secondary);
            background-color: rgba(255,255,255,0.5);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 13px;
        }
        #phone-screen.dark-mode #close-gomoku-btn {
            background-color: rgba(0,0,0,0.2);
            border-color: var(--text-secondary);
        }
        
        /* ▲▲▲ 替换结束 ▲▲▲ */
        /* ▼▼▼ 【棋盘交互终极修复】请将这整块CSS粘贴到 <style> 的最末尾 ▼▼▼ */
        
        /* 
          第一步：【核心】让棋盘的巨大透明容器“穿透”所有鼠标/触摸点击。
          这样您就可以点击到它下方的聊天消息了。
        */
        #gomoku-overlay {
            pointer-events: none;
        }
        
        /* 
          第二步：现在，我们必须“恢复”棋盘和按钮本身的可点击性。
          我们将它们设置为 auto，这样它们就又能响应您的操作了。
        */
        #gomoku-board,
        #gomoku-controls {
            pointer-events: auto;
        }
        
        /* --- 请用这整块【最终布局修复版】代码，替换从 #product-grid 到 .product-footer 的所有相关样式 --- */
        
        #product-grid {
            flex-grow: 1; 
            overflow-y: auto; 
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            padding: 10px;
            padding-bottom: 80px;
            /* 【核心修改1】: 移除 align-items: start，恢复Grid默认的拉伸对齐，确保卡片等高 */
        }
        
        .product-item {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.04);
            display: flex;         /* 【核心修改2】: 必须是Flex容器，才能控制内部元素 */
            flex-direction: column;
        
            cursor: pointer;
            position: relative;
        }
        
        .product-image {
            width: 100%;
            aspect-ratio: 1 / 1;
            object-fit: cover;
        }
        
        /* --- 请用这整块【最终紧凑布局版】代码，替换旧的 .product-info, .product-name, 和 .product-footer 样式 --- */
        
        .product-info {
            padding: 12px 10px;
            flex-grow: 1;      /* 保持：让信息区填满，确保所有卡片等高 */
            display: flex;
            flex-direction: column;
        }
        
        .product-name {
            font-size: 13px;
            color: #333;
            line-height: 1.4;
            min-height: 36px;
            /* 移除所有flex-grow属性，让它只占据自己需要的高度 */
        }
        
        .product-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;      /* 【核心修改】：不再使用 auto，而是设置一个固定的、较小的顶部间距 */
        }
        
        /* --- 替换结束 --- */
        
        
        
        
        
        /* --- 替换结束 --- */
        
        .product-price {
            font-size: 16px;
            font-weight: 700;
            color: #ff5722;
        }
        .product-price::before { content: '¥'; font-size: 12px; }
        
        .add-to-cart-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 15px;
            background: linear-gradient(90deg, #ff9800, #ff5722);
            color: white;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
        }
        
        /* --- 管理模式样式 (保持不变) --- */
        .product-management-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 15px;
            z-index: 5;
        }
        #shopping-screen.management-mode .product-management-overlay {
            display: flex;
        }
        .product-management-overlay button {
            padding: 8px 20px;
            border: 1px solid white;
            background-color: rgba(255,255,255,0.2);
            color: white;
            border-radius: 15px;
            cursor: pointer;
        }
        .product-management-overlay .delete-product-btn {
            border-color: #ff8a80;
            color: #ff8a80;
        }
        #shopping-screen.management-mode .product-footer {
            display: none;
        }
        
        
        /* --- 购物车页 (微调) --- */
        #cart-title {
            position: static;
            transform: none;
        }
        #cart-items-list { padding: 10px; display: flex; flex-direction: column; gap: 10px; }
        .cart-item {
            display: flex; align-items: flex-start; gap: 12px; background-color: white;
            padding: 12px; border-radius: 12px;
        }
        .cart-item-checkbox { margin-top: 28px; }
        .cart-item-image { width: 80px; height: 80px; object-fit: cover; border-radius: 8px; flex-shrink: 0; }
        .cart-item-info { flex-grow: 1; display: flex; flex-direction: column; }
        .cart-item-name { font-weight: 500; font-size: 14px; line-height: 1.4; }
        .cart-item-footer { display: flex; justify-content: space-between; align-items: center; margin-top: 10px;}
        .cart-item-price { color: #ff5722; font-weight: bold; font-size: 16px; }
        .quantity-control { display: flex; align-items: center; gap: 4px; }
        .quantity-btn {
            width: 26px; height: 26px; border: none; background-color: #f7f8fa;
            border-radius: 4px; font-weight: 500; cursor: pointer; color: #666;
        }
        .quantity-display { font-weight: 500; min-width: 30px; text-align: center; }
        
        #cart-footer {
            position: absolute; bottom: 0; left: 0; width: 100%; display: flex;
            justify-content: space-between; align-items: center; padding: 10px 15px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            background-color: white; border-top: 1px solid var(--border-color); box-sizing: border-box;
        }
        #cart-footer .select-all-label { display: flex; align-items: center; gap: 5px; }
        #cart-footer .cart-summary { text-align: right; }
        #cart-footer .cart-subtext { font-size: 11px; color: #999; }
        #checkout-btn {
            padding: 10px 25px; border: none; border-radius: 20px;
            background: linear-gradient(90deg, #ff9800, #ff5722);
            color: white; font-size: 15px; font-weight: 500; cursor: pointer;
        }
        
        /* --- 礼物卡片 & 小票 (样式不变) --- */
        .gift-card {
            width: 220px; /* 【核心修改】将 max-width 改为固定的 width */
            box-sizing: border-box; 
            border-radius: 12px; 
            background-color: #fff; 
            border: 1px solid #eee; 
            padding: 12px;
            cursor: pointer; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.07);
        }
        /* ▲▲▲ 替换结束 ▲▲▲ */
        .gift-header { display: flex; align-items: center; gap: 8px; padding-bottom: 8px; border-bottom: 1px solid #f0f0f0; }
        .gift-header-icon { width: 20px; height: 20px; color: #ff9800; }
        .gift-header-text { font-size: 15px; font-weight: 600; color: var(--text-primary); }
        .gift-items-preview { padding: 12px 0; display: flex; flex-direction: column; gap: 8px; }
        .gift-preview-item { display: flex; align-items: center; gap: 8px; }
        .gift-preview-img { width: 32px; height: 32px; object-fit: cover; border-radius: 4px; flex-shrink: 0; }
        .gift-preview-name { flex-grow: 1; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .gift-preview-quantity { font-size: 12px; color: var(--text-secondary); }
        .gift-footer { font-size: 12px; color: var(--text-secondary); text-align: right; }
        #gift-receipt-body { font-family: 'Helvetica Neue', Arial, sans-serif; padding: 15px; background-color: #f7f8fa; }
        .receipt-header { text-align: center; padding-bottom: 15px; border-bottom: 1px solid #ddd; }
        .receipt-header h3 { margin: 0 0 5px 0; font-size: 20px; }
        .receipt-header p { margin: 0; font-size: 12px; color: #888; }
        .receipt-items-table { width: 100%; border-collapse: collapse; margin: 15px 0; }
        .receipt-items-table th, .receipt-items-table td { padding: 10px 5px; font-size: 13px; }
        .receipt-items-table thead th { border-bottom: 1px solid #333; text-align: left; }
        .receipt-items-table .item-name { width: 50%; }
        .receipt-items-table .item-qty { text-align: center; }
        .receipt-items-table .item-price, .receipt-items-table .item-subtotal { text-align: right; }
        .receipt-total { padding-top: 15px; border-top: 1px solid #333; text-align: right; font-size: 16px; font-weight: bold; }
        .receipt-footer { text-align: center; margin-top: 25px; font-size: 12px; color: #888; }
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
        /* ▼▼▼ (可选，但推荐) 为商品管理模式添加新样式 ▼▼▼ */
        .product-item {
            position: relative; /* 为了定位遮罩层 */
        }
        .product-management-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: none; /* 默认隐藏 */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 15px;
            z-index: 5;
        }
        #shopping-screen.management-mode .product-management-overlay {
            display: flex; /* 在管理模式下显示 */
        }
        .product-management-overlay button {
            padding: 8px 20px;
            border: 1px solid white;
            background-color: rgba(255,255,255,0.2);
            color: white;
            border-radius: 15px;
            cursor: pointer;
        }
        .product-management-overlay .delete-product-btn {
            border-color: #ff8a80;
            color: #ff8a80;
        }
        /* 管理模式下，隐藏“加入购物车”按钮 */
        #shopping-screen.management-mode .add-to-cart-btn {
            display: none;
        }
        /* ▲▲▲ 新增CSS结束 ▲▲▲ */
        /* ▼▼▼ 【检查并添加】卡片/特殊内容气泡布局规则 ▼▼▼ */
        .message-bubble.is-card-like {
            flex: initial; /* 覆盖通用的 flex: 1，让气泡本身不再拉伸 */
            min-width: auto; /* 允许其自由收缩 */
        }
        .message-bubble.is-card-like .content {
            flex: initial; 
            padding: 0;
            background: transparent;
        }
        /* ▲▲▲ 添加结束 ▲▲▲ */
        /* ▼▼▼ 【全新】修复购物车图标对齐问题 ▼▼▼ */
        #go-to-cart-btn {
            display: flex;
            align-items: center; /* 核心：垂直居中对齐 */
            gap: 4px; /* 在图标和数字之间增加一点间距 */
        }
        /* ▲▲▲ 新增CSS结束 ▲▲▲ */
        /* ▼▼▼ 【全新】为礼物接收人列表添加样式 ▼▼▼ */
        #gift-recipient-list .contact-picker-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
        }
        #gift-recipient-list .contact-picker-item:last-child {
            border-bottom: none;
        }
        #gift-recipient-list .contact-picker-item .checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #ccc;
            border-radius: 50%;
            margin-right: 15px;
            transition: all 0.2s ease;
        }
        #gift-recipient-list .contact-picker-item.selected .checkbox {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }
        #gift-recipient-list .contact-picker-item .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 12px;
        }
        #gift-recipient-list .contact-picker-item .name {
            font-weight: 500;
        }
        /* ▲▲▲ 新增CSS结束 ▲▲▲ */
        /* ▼▼▼ 【全新】歌词栏替换心率显示器样式 (最终版) ▼▼▼ */
        
        /* 1. 彻底隐藏旧的心率显示器，不再需要它了 */
        #ai-heart-rate-display {
            display: none !important;
        }
        
        /* 2. 为歌词栏应用新的样式，使其外观和定位与原心率显示器完全一致 */
        /* ▼▼▼ 【全新】歌词栏位置控制样式 ▼▼▼ */
        #global-lyrics-bar {
            /* 核心定位：绝对定位 */
            position: absolute;
            z-index: 20;
        
            /* 外观样式 (保持不变) */
            display: flex;
            align-items: center;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            background-color: rgba(0, 0, 0, 0.05);
            padding: 4px 12px;
            border-radius: 12px;
            
            /* 动画效果 (保持不变) */
            opacity: 0;
            visibility: hidden;
            /* 【核心修改】为位置属性添加平滑过渡 */
            transition: opacity 0.4s ease, visibility 0.4s ease, top 0.3s ease, bottom 0.3s ease, left 0.3s ease, right 0.3s ease, transform 0.3s ease;
        
            /* 附加样式 (保持不变) */
            pointer-events: none;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 65%;
        }
        
        #phone-screen.dark-mode #global-lyrics-bar {
            color: #a0a0a0;
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        /* 3. 当JS添加.visible类时，显示歌词栏 */
        #global-lyrics-bar.visible {
            opacity: 1;
            visibility: visible;
        }
        
        /* 4. 适配夜间模式 */
        #phone-screen.dark-mode #global-lyrics-bar {
            color: #a0a0a0;
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        /* ▼▼▼ 【全新】世界书页面美化样式 (V2 - 页签切换版) ▼▼▼ */
        
        /* 1. 确保世界书页面背景色统一 */
        #world-book-screen {
            background-color: #f0f2f5;
            display: flex; /* 改为flex布局，让头部、页签、内容区垂直排列 */
            flex-direction: column;
        }
        
        #phone-screen.dark-mode #world-book-screen {
            background-color: #000000;
        }
        
        /* 2. 页签栏样式 */
        #world-book-tabs {
            display: flex;
            overflow-x: auto; /* 如果分类太多，可以横向滚动 */
            padding: 10px 15px 0 15px;
            flex-shrink: 0; /* 防止被压缩 */
            border-bottom: 1px solid var(--border-color);
            background-color: var(--secondary-bg);
        
            /* 隐藏滚动条 */
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        #world-book-tabs::-webkit-scrollbar {
            display: none; /* Chrome, Safari, and Opera */
        }
        
        
        /* 3. 单个页签按钮样式 */
        .world-book-tab {
            padding: 8px 16px;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 15px;
            font-weight: 500;
            color: var(--text-secondary);
            border-bottom: 2px solid transparent;
            margin-bottom: -1px; /* 让底边框与容器边框重合 */
            transition: all 0.2s ease-in-out;
            white-space: nowrap; /* 防止分类名换行 */
        }
        
        /* 4. 激活的页签样式 */
        .world-book-tab.active {
            color: var(--accent-color);
            border-bottom-color: var(--accent-color);
            font-weight: 600;
        }
        #phone-screen.dark-mode .world-book-tab.active {
            color: #ffffff;
        }
        
        
        /* 5. 内容区总容器，负责滚动 */
        #world-book-content-container {
            flex-grow: 1;
            overflow-y: auto;
        }
        
        /* 6. 单个分类的内容面板，使用Grid布局美化 */
        .world-book-category-pane {
            display: none; /* 默认隐藏 */
            grid-template-columns: repeat(2, 1fr); /* 每行显示2本书 */
            gap: 15px;
            padding: 15px;
        }
        
        /* 7. 激活的内容面板 */
        .world-book-category-pane.active {
            display: grid;
        }
        

/* 8. 美化后的世界书卡片样式 (最终修复版) */
.world-book-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    display: flex;
    flex-direction: column;
    gap: 8px;
    
    /* 核心修复 1: 允许卡片在网格布局中正确地收缩，这是解决问题的关键 */
    min-width: 0;

    /* 核心修复 2: 强制对所有内容（包括中英文）进行换行，作为双重保险 */
    word-break: break-all;
}
        
        .world-book-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.12);
        }
        #phone-screen.dark-mode .world-book-card {
            box-shadow: 0 2px 8px rgba(255,255,255,0.05);
        }
        
        .world-book-card .card-title {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis; /* 防止长标题溢出 */
        }
        
        .world-book-card .card-content-preview {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.5;
            /* 多行省略效果 */
            display: -webkit-box;
            -webkit-line-clamp: 3; /* 最多显示3行 */
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        /* ▼▼▼ 【全新】渲染器页面美化样式 (V2 - 页签切换版) ▼▼▼ */
        
        /* 1. 确保渲染器页面背景色统一 */
        #rendering-rules-screen {
            background-color: #f0f2f5;
            display: flex; /* 改为flex布局，让元素垂直排列 */
            flex-direction: column;
        }
        
        #phone-screen.dark-mode #rendering-rules-screen {
            background-color: #000000;
        }
        
        /* 2. 页签栏样式 (仿世界书) */
        #rules-tabs {
            display: flex;
            overflow-x: auto;
            padding: 10px 15px 0 15px;
            flex-shrink: 0;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--secondary-bg);
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        #rules-tabs::-webkit-scrollbar {
            display: none;
        }
        
        /* 3. 单个页签按钮样式 */
        .rules-tab {
            padding: 8px 16px;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 15px;
            font-weight: 500;
            color: var(--text-secondary);
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
            transition: all 0.2s ease-in-out;
            white-space: nowrap;
        }
        
        /* 4. 激活的页签样式 */
        .rules-tab.active {
            color: var(--accent-color);
            border-bottom-color: var(--accent-color);
            font-weight: 600;
        }
        #phone-screen.dark-mode .rules-tab.active {
            color: #ffffff;
        }
        
        /* 5. 内容区总容器 */
        #rules-content-container {
            flex-grow: 1;
            overflow-y: auto;
        }
        
        /* 6. 单个分类的内容面板 (Grid布局) */
        .rules-category-pane {
            display: none; /* 默认隐藏 */
            grid-template-columns: repeat(2, 1fr); /* 每行显示2个 */
            gap: 15px;
            padding: 15px;
        }
        
        .rules-category-pane.active {
            display: grid;
        }
        
        /* 7. 美化后的规则卡片样式 */
        .rule-card {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 8px; /* 标题和内容的间距 */
            border-left: 5px solid #6c757d; /* 默认给一个灰色边框 */
        }
        .rule-card.enabled {
            border-left-color: #28a745; /* 启用的规则用绿色边框 */
        }
        
        .rule-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.12);
        }
        #phone-screen.dark-mode .rule-card {
            box-shadow: 0 2px 8px rgba(255,255,255,0.05);
        }
        
        .rule-card .card-title {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .rule-card .card-content-preview {
            font-size: 12px;
            font-family: monospace; /* 使用等宽字体，显示正则更清晰 */
            color: var(--text-secondary);
            background-color: #f0f2f5;
            padding: 5px 8px;
            border-radius: 4px;
            word-break: break-all;
        }
        #phone-screen.dark-mode .rule-card .card-content-preview {
            background-color: #2c2c2e;
        }
        
        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

        /* ▼▼▼ 【全新美化版】重新生成回复按钮样式 ▼▼▼ */
        .control-btn.regenerate-btn {
            /* 核心修改：将背景色改为与其他功能按钮一致的半透明灰色 */
            background-color: rgba(255, 255, 255, 0.2);
            background-size: 55%; /* 图标大小保持不变 */
            /* SVG图标保持不变，依然是我们的刷新图标 */
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"/><path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"/></svg>');
        }
        /* ▲▲▲ 新增CSS结束 ▲▲▲ */
        /* ▼▼▼ 【全新】推进剧情按钮样式 ▼▼▼ */
        .control-btn.propel-btn {
            background-color: rgba(255, 255, 255, 0.2);
            background-size: 55%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 19 22 12 13 5 13 19"></polygon><polygon points="2 19 11 12 2 5 2 19"></polygon></svg>');
        }
        /* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是解决HTML代码被气泡样式“压缩”的核心CSS ▼▼▼ */

/* 当一个消息气泡被标记为 is-raw-html 时 */
.message-bubble.is-raw-html .content {
    padding: 0 !important; /* 强制移除所有内边距 */
    background: transparent !important; /* 强制背景透明 */
    border: none !important; /* 强制移除边框 */
    box-shadow: none !important; /* 强制移除阴影 */
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】防止长按时触发蓝色文本选中 ▼▼▼ */

#phone-screen {
    /* 核心属性，适用于大多数现代浏览器 */
    user-select: none;

    /* 兼容旧版 Safari, iOS Safari, Chrome */
    -webkit-user-select: none;

    /* 兼容旧版 Firefox */
    -moz-user-select: none;

    /* 兼容 Internet Explorer/Edge */
    -ms-user-select: none;

    /* 防止在 iOS 上长按链接、图片时弹出菜单 */
    -webkit-touch-callout: none;
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 步骤 2：用这整块新代码，替换掉所有旧的主屏幕和个人资料相关CSS ▼▼▼ */

/* --- 1. 隐藏所有旧的主屏幕元素 --- */
#home-screen #clock-container,
#home-screen #app-grid,
#home-screen #home-widgets-container {
    display: none !important;
}

/* --- 2. 【最终修复】重新定义主屏幕布局 --- */

#home-screen {
    background: linear-gradient(135deg, #6DD5FA, #2980B9);
    /* ▼▼▼ 核心修复：添加下面这两行 ▼▼▼ */
    background-size: cover;
    background-position: center;
    /* ▲▲▲ 修复结束 ▲▲▲ */
    padding: 20px;
    padding-top: calc(20px + env(safe-area-inset-top));
    padding-bottom: calc(20px + env(safe-area-inset-bottom));
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: space-between; 
    align-items: center;
    height: 100%;
}

/* --- 替换这一整块代码 --- */
/* ▼▼▼ 请用这整块新代码替换旧的 #main-content-area 样式 ▼▼▼ */

#main-content-area {
    width: 100%;
    display: flex;
    flex-direction: column;
    /* 核心修改1：将卡片和下方图标的间距从60px缩小到30px */
    gap: 30px; 
    align-items: center;
    /* 核心修改2：将顶部的外边距从40px缩小到20px，给屏幕顶部留出一点呼吸空间即可 */
    margin-top: 20px; 
}

/* ▲▲▲ 替换结束 ▲▲▲ */

/* ▼▼▼ 【最终解决方案】请用这一整块代码，替换所有旧的个人资料卡片相关CSS ▼▼▼ */

/* 1. 卡片外层容器：这是所有内部元素定位的“锚点” */
#profile-widget {
    position: relative; /* 关键：让内部的头像和伪元素可以相对于它进行绝对定位 */
    width: 100%;
    max-width: 380px;
    flex-shrink: 0;
}

/* 2. 背景头图：只给顶部设置圆角 */
#profile-banner-img {
    display: block; 
    width: 100%;
    height: 150px;
    object-fit: cover;
    border-radius: 24px 24px 0 0; /* 只给顶部设置圆角 */
    position: relative;
    z-index: 1; /* 让头图在下方 */
}

/* 3. 头像容器：精确定位，使其中心线与头图底部对齐 */
#profile-widget .profile-avatar-container {
    position: absolute;
    top: 80px; 
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background-color: white; 
    padding: 4px; 
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 3; /* 头像层级最高，压住一切 */
}

#profile-avatar-img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

/* 4. 白色信息卡片：使用负外边距实现无缝拼接 */
#profile-widget .profile-info {
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 24px;
    
    /* --- ★★★★★ 这就是本次修复的核心！ ★★★★★ --- */
    
    /* 1. 使用负外边距，将卡片向上移动24px（等于其圆角半径） */
    margin-top: -24px; 
    
    /* 2. 为头像的下半部分和上方的负边距，共同留出精确的空间 */
    /* 40px (头像半径) + 10px (额外间距) + 24px (抵消负边距) = 74px */
    padding-top: 44px; 
    
    /* --- ★★★★★ 修复结束 ★★★★★ --- */
    
    min-height: 120px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding-left: 15px;
    padding-right: 15px;
    padding-bottom: 15px;
    text-align: center;
    color: #1c1c1e;
    position: relative;
    z-index: 2; /* 让信息卡在头图之上，但在头像之下 */
}

/* ▲▲▲ 替换结束 ▲▲▲ */

/* 5. 强制禁用任何可能残留的旧伪元素样式 */
#profile-widget::before {
    display: none !important;
}

/* (这个是头像图片本身的样式，保持不变) */
#profile-avatar-img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

/* ▲▲▲ 替换结束 ▲▲▲ */

/* 5. 强制禁用任何可能残留的旧伪元素样式 */
#profile-widget::before {
    display: none !important;
}

/* ▲▲▲ 替换结束 ▲▲▲ */

/* (这个是头像图片本身的样式，保持不变) */
#profile-avatar-img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

/* ▲▲▲ 替换结束 ▲▲▲ */



/* (以下为个人资料内部文字样式，保持不变) */
#profile-username { font-size: 18px; font-weight: 600; margin: 0 0 2px 0; }
#profile-sub-username { font-size: 13px; color: #8a8a8a; margin: 0 0 10px 0; }
#profile-bio { font-size: 14px; margin: 0 0 12px 0; color: #333; }
#profile-location {
    font-size: 12px; color: #8a8a8a; margin: 0 auto; display: inline-flex;
    align-items: center; gap: 4px; background-color: rgba(0,0,0,0.05);
    padding: 3px 9px; border-radius: 10px;
}

/* --- (从这里开始，后面的所有样式都保持不变即可) --- */
#desktop-layout {
    display: grid;
    grid-template-columns: 1fr 1.1fr;
    gap: 20px;
    width: 100%;
    align-items: start;
}
#desktop-widget-column {
    display: flex;
    flex-direction: column;
    gap: 12px;
}
.widget-header {
    font-size: 14px;
    font-weight: 500;
    color: rgba(255, 255, 255, 0.8);
    margin: 0 0 5px 5px;
}
.desktop-widget {
    background-color: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 18px;
    padding: 12px 15px;
    /* 核心修改：将颜色从 white 改为接近黑色的深灰色 */
    color: #1f1f1f; 
    font-weight: 500;
    font-size: 13px;
    display: flex;
    align-items: center;
}
/* ▼▼▼ 【全新】这是移除第一个小组件背景框的样式 ▼▼▼ */

.desktop-widget.text-only {
    background-color: transparent; /* 将背景色设为透明 */
    border: none;                  /* 移除边框 */
    padding: 0;                    /* 移除内边距，避免多余的空白 */
    box-shadow: none;              /* 确保没有阴影 */
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
.desktop-widget.icon-left { justify-content: flex-start; gap: 10px; }
/* This is the NEW code */
.desktop-widget.icon-right {
    justify-content: flex-end; /* Pushes both items to the right */
    gap: 10px;                 /* Adds a nice space between the text and the avatar */
}
.desktop-widget img { width: 28px; height: 28px; border-radius: 50%; object-fit: cover; }
.desktop-widget p, .desktop-widget span { margin: 0; }
#desktop-app-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 25px;
    align-content: start;
}
#desktop-dock {
    background-color: rgba(255, 255, 255, 0.15);
    border-radius: 20px;
    padding: 15px 25px;
    display: flex;
    justify-content: center;
    gap: 30px;
    width: fit-content;
    flex-shrink: 0;
    /* ▼▼▼ 核心修改 ▼▼▼ */
    /* 我们为Dock栏增加一个底部外边距，
       这个边距由20px的基础间距和底部的安全距离组成，
       能将它从屏幕底部完美地抬起。 */
    margin-bottom: calc(20px + env(safe-area-inset-bottom));
}
.desktop-app-icon {
    display: flex; flex-direction: column; align-items: center; gap: 8px; cursor: pointer; text-align: center;
}
.icon-bg-desktop {
    width: 55px; height: 55px; border-radius: 14px; background-color: #f0f2f5; justify-content: center; box-shadow: 0 4px 10px rgba(0,0,0,0.1); transition: transform 0.2s ease; overflow: hidden;
}
.icon-bg-desktop img {
    width: 100%; height: 100%; object-fit: cover; border-radius: 0;
}
.desktop-app-icon .label {
    color: #333; font-size: 13px; font-weight: 500;
}
.desktop-app-icon:active .icon-bg-desktop {
    transform: scale(0.9);
}
.editable-text:hover, .editable-image:hover {
    outline: 2px dashed rgba(255, 255, 255, 0.8);
    cursor: pointer;
    opacity: 0.9;
}
/* ▲▲▲ 替换结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为小组件编辑功能添加的样式 ▼▼▼ */

/* 为可编辑的元素添加可点击的光标和过渡效果 */
.editable-text, .editable-image {
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

/* 鼠标悬停时，显示一个半透明的虚线外框，并轻微变暗，提供视觉反馈 */
.editable-text:hover, .editable-image:hover {
    outline: 2px dashed rgba(255, 255, 255, 0.8);
    opacity: 0.9;
    border-radius: 4px; /* 让外框也有一点圆角 */
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */

/* ▼▼▼ 【方案A：仅背景渐变，文字保持实体】(可能导致底部文字可读性下降) ▼▼▼ */

#profile-widget .profile-info {
    /* 1. 将卡片本身的背景设为透明 */
    background: transparent !important;
    /* 2. 建立定位上下文，让伪元素可以相对于它定位 */
    position: relative;
    z-index: 1; /* 确保文字内容在背景之上 */
}

#profile-widget .profile-info::before {
    /* 3. 创建一个伪元素作为新的背景层 */
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    
    /* 4. 将原本的白色背景和圆角应用到这个背景层上 */
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 24px;
    
    /* 5. 【核心】只对这个背景层应用渐变消失效果 */
    mask-image: linear-gradient(to bottom, black 50%, transparent 100%);
    -webkit-mask-image: linear-gradient(to bottom, black 50%, transparent 100%);
    
    /* 6. 将背景层放到文字内容的后面 */
    z-index: -1;
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】聊天设置页面样式 ▼▼▼ */
#chat-settings-screen {
    /* 确保页面是 Flex 容器，让内容区可以正确地拉伸 */
    display: flex;
    flex-direction: column;
    background-color: #f0f2f5; /* 与其他设置页保持一致的背景色 */
}

#phone-screen.dark-mode #chat-settings-screen {
     background-color: #000000; /* 夜间模式背景 */
}

#chat-settings-screen .form-container {
    flex-grow: 1;      /* 核心：让内容区占据所有剩余空间 */
    overflow-y: auto;  /* 核心：确保内容过长时可以滚动 */
    padding-top: 100px;  /* 为浮动的 Header 留出足够的顶部空间 */
    margin-top: -80px;   /* 将内容区向上拉，使其可以滚动到 Header 下方 */
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】BGM搜索结果弹窗样式 ▼▼▼ */

.search-result-item {
    display: flex;
    flex-direction: column;
    padding: 12px 18px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background-color 0.2s;
}

.search-result-item:hover {
    background-color: rgba(0, 0, 0, 0.1);
}

#phone-screen.dark-mode .search-result-item:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

.search-result-item .title {
    font-weight: 500;
    font-size: 15px;
    color: var(--text-primary);
}

.search-result-item .artist {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px;
}

.search-result-item .source {
    font-size: 10px;
    color: var(--accent-color);
    background-color: rgba(0, 123, 255, 0.1);
    padding: 2px 6px;
    border-radius: 4px;
    font-weight: bold;
    margin-left: 8px;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】音乐播放器专辑封面样式 ▼▼▼ */
#music-player-cover {
    width: 180px;
    height: 180px;
    border-radius: 15px;
    object-fit: cover;
    box-shadow: 0 8px 25px rgba(0,0,0,0.2);
    margin-bottom: 25px; /* 在封面和标题之间增加间距 */
    transition: opacity 0.5s ease-in-out; /* 让图片切换时有淡入淡出效果 */
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】仿网易云唱片/歌词切换样式 ▼▼▼ */

/* 1. 切换的总容器，负责定位和大小 */
#music-visual-container {
    position: relative;
    width: 220px;
    height: 220px;
    margin-bottom: 25px;
    cursor: pointer;
}

/* 2. 唱片和歌词视图的通用样式，让它们重叠在一起 */
#vinyl-view, #inline-lyrics-view {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    /* 核心：为切换效果添加平滑的过渡动画 */
    transition: opacity 0.5s ease, transform 0.5s ease;
}

/* 3. 黑胶唱片视图的专属样式 */
#vinyl-view {
    background-color: #222;
    border-radius: 50%;
    padding: 18px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.3), 
                inset 0 0 0 2px rgba(255, 255, 255, 0.05);
    background-image: repeating-radial-gradient(circle, #333, #333 1px, #222 1px, #222 2px);
    box-sizing: border-box;
}
#vinyl-view #music-player-cover {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
    margin: 0; /* 移除旧的外边距 */
}

/* 4. 内联歌词视图的专属样式 */
#inline-lyrics-view {
    /* 默认状态：完全透明，轻微放大，且不可点击 */
    opacity: 0;
    transform: scale(1.1);
    pointer-events: none;
    padding: 10px;
    box-sizing: border-box;
}

/* 5. 【核心】切换逻辑 */
/* 当容器拥有 .lyrics-active 类时... */
#music-visual-container.lyrics-active #vinyl-view {
    /* ...唱片视图消失 */
    opacity: 0;
    transform: scale(0.9);
}
#music-visual-container.lyrics-active #inline-lyrics-view {
    /* ...歌词视图出现 */
    opacity: 1;
    transform: scale(1);
    pointer-events: auto;
}

/* 6. 歌词容器的样式 (与之前类似，但有微调) */
#inline-lyrics-view #music-lyrics-container {
    width: 100%;
    height: 100%;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】顶部歌曲信息区域样式 ▼▼▼ */

/* 1. 新的顶部信息容器 */
#music-info-top {
    text-align: center; /* 让所有文字居中 */
    flex-shrink: 0;
    margin-bottom: 20px; /* 在信息和唱片之间增加一些间距 */
}

/* 2. 移除旧的、多余的边距，避免双重间距 */
#music-player-song-title,
#music-player-artist,
#music-time-counter {
    margin-bottom: 5px; /* 统一设置一个较小的行间距 */
}

/* 3. 调整唱片容器的外边距 */
#music-visual-container {
    margin-bottom: 15px; /* 适当减小唱片和进度条的距离 */
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】黑胶唱片旋转动画 ▼▼▼ */

/* 1. 定义一个名为 "spin-vinyl" 的旋转动画 */
@keyframes spin-vinyl {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

/* 2. 创建一个 .spinning 类，应用这个动画 */
/*    我们希望它无限、匀速地旋转 */
#vinyl-view.spinning {
  animation: spin-vinyl 12s linear infinite;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】单行歌词显示样式 ▼▼▼ */

#single-lyric-display {
    /* 1. 尺寸与定位 */
    height: 40px;          /* 给一个固定的高度，防止文字换行时布局跳动 */
    line-height: 40px;     /* 垂直居中 */
    width: 100%;           /* 宽度撑满 */
    margin-top: 15px;      /* 和上方的唱片拉开一些距离 */
    
    /* 2. 文字外观 */
    text-align: center;    /* 文字居中 */
    font-size: 14px;       /* 字体大小 */
    color: #333;           /* 字体颜色 */
    font-weight: 500;      /* 字体稍微加粗一点 */

    /* 3. 效果与动画 */
    transition: opacity 0.3s ease; /* 让文字切换时有淡入淡出效果 */
    white-space: nowrap;           /* 强制不换行 */
    overflow: hidden;              /* 超出部分隐藏 */
    text-overflow: ellipsis;       /* 超出部分显示省略号 */
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】切换到全屏歌词时，隐藏单行歌词预览 ▼▼▼ */

#music-visual-container.lyrics-active + #single-lyric-display {
    /* 核心：使用 display: none; 将其彻底隐藏，不占空间 */
    display: none;
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* 1. 弹窗背景 */
#character-profile-modal {
    background-color: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
}

/* 2. 卡片主体内容区 */
.character-profile-content {
    width: 320px;
    height: 75vh;
    max-height: 580px;
    background-color: #f0f2f5;
    border-radius: 20px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.12);
    display: flex;
    flex-direction: column;
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
     overflow: visible; /* <--- CHANGE TO THIS */
    /* 【核心修改1】增加顶部的内边距，让头部信息更舒展 */
    padding-top: 40px; 
}

/* 3. 右上角“查看历史”图标按钮 (保持不变) */
#profile-history-icon-btn {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 36px;
    height: 36px;
    background: none;
    border: none;
    cursor: pointer;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s;
    padding: 0;
    z-index: 10;
}
#profile-history-icon-btn:hover { background-color: rgba(0,0,0,0.05); }
#profile-history-icon-btn svg { width: 20px; height: 20px; stroke: #b0b0b0; stroke-width: 2; }

/* 4. 主资料页与历史记录页的容器 */
#profile-main-content, #profile-thoughts-history-view {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
    box-sizing: border-box;
}

/* 5. 主资料页独有的样式 */
#profile-main-content {
    padding: 0 25px 25px 25px; /* 移除了顶部padding，因为它已在父元素中定义 */
    /* 【核心修改2】显著增加卡片之间的垂直间距，解决“挤”的问题 */
    gap: 20px; 
    flex-grow: 1;
    overflow-y: auto;
}

/* 6. 头部信息区 */
.profile-header {
    display: flex;
    align-items: center;
    gap: 15px;
    flex-shrink: 0;
    /* 【核心修改3】为头部下方增加明确的边距 */
    margin-bottom: 10px; 
}
#profile-avatar { width: 60px; height: 60px; border-radius: 12px; object-fit: cover; }
.profile-info { display: flex; flex-direction: column; }
#profile-name { font-size: 20px; font-weight: 600; color: #1f1f1f; }
#profile-id { font-size: 14px; color: #8a8a8a; }
        
/* ▼▼▼ 【全新V2版】心声与散记卡片样式 ▼▼▼ */

/* 1. 卡片通用容器样式 */
.profile-section {
    background-color: #ffffff; /* 干净的白色背景 */
    border-radius: 16px;
    padding: 20px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.06); /* 柔和的卡片阴影 */
    display: flex;
    flex-direction: column;
    gap: 12px; /* 头部和内容区的间距 */
    flex-shrink: 0;
}

/* 2. 卡片头部容器 */
.profile-section-header {
    display: flex;
    align-items: center;
    gap: 10px; /* 图标和文字的间距 */
    padding-bottom: 12px;
    border-bottom: 1px solid #f0f0f0; /* 一条精致的分割线 */
}

/* 3. 卡片头部图标样式 */
.profile-section-icon {
    font-size: 20px;
    opacity: 0.5;
}

/* 4. 卡片头部标题文字 ("心声", "散记") */
.profile-section label {
    font-size: 15px;
    font-weight: 600;
    color: #555; /* 比之前更深的颜色，更有质感 */
    margin: 0; /* 移除旧的边距 */
}

/* 5. 卡片内容区文字 (保持不变) */
.profile-section p {
    font-size: 15px;
    color: #333;
    line-height: 1.7;
    margin: 0;
    white-space: pre-wrap;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
        
/* 10. 历史记录页面特定样式 (保持不变) */
#profile-thoughts-history-view { display: none; padding: 0 25px 25px 25px; }
#profile-thoughts-history-view .profile-header { justify-content: space-between; padding-bottom: 15px; }
#profile-thoughts-history-view .profile-header span { font-size: 18px; font-weight: 600; }
#history-back-btn { width: 36px; height: 36px; background: none; border: none; cursor: pointer; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s; padding: 0; }
#history-back-btn:hover { background-color: rgba(0,0,0,0.05); }
#history-back-btn svg { width: 22px; height: 22px; stroke: #a0a0a0; stroke-width: 2.5; }

/* 11. 历史记录列表 (保持不变) */
#thoughts-history-list {
    flex-grow: 1;
    overflow-y: auto;
    padding-right: 5px;
    margin-right: -10px;
    display: flex;
    flex-direction: column;
    gap: 15px;
}
.thought-card { background-color: #ffffff; border-radius: 16px; padding: 15px 20px; border: 1px solid #eee; }
.thought-header { font-size: 12px; color: #b0b0b0; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid #f0f0f0; }
.thought-content .label { display: flex; align-items: center; gap: 6px; font-weight: 600; color: #a0a0a0; font-size: 13px; margin-bottom: 6px; }
.thought-content .label svg { width: 16px; height: 16px; }
.thought-content .text { font-size: 14px; color: #555; line-height: 1.7; white-space: pre-wrap; padding-left: 22px; }
.thought-content .jottings { margin-top: 15px; }

/* 12. 隐藏滚动条 (保持不变) */
#profile-main-content::-webkit-scrollbar,
#thoughts-history-list::-webkit-scrollbar { display: none; }
#profile-main-content, #thoughts-history-list { -ms-overflow-style: none; scrollbar-width: none; }
/* ▼▼▼ 【最终版】心声页面与历史记录美化样式 ▼▼▼ */

/* 1. 将角色详情页（心声页面）的背景修改为纯白色 */
.character-profile-content {
    background-color: #ffffff !important;
}

/* 2. 仅隐藏“散记”标签 (在主页和历史记录中都生效) */
#character-profile-modal .jottings .label {
    display: none;
}

/* 3. 【对齐修正】移除心声和散记内容的左边距，让它们与标题对齐 */
#character-profile-modal .thought-content .text {
    padding-left: 0;
}

/* ▲▲▲ 样式结束 ▲▲▲ */
/* ▼▼▼ 步骤 2：将这段全新的CSS代码，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* 为动态页面的“三点”按钮设置专属样式 */
#qzone-more-actions-btn {
    font-size: 24px;      /* 增大字体，让“…”更清晰 */
    font-weight: bold;    /* 加粗 */
    padding: 0 10px;      /* 增加水平可点击区域 */
    border-radius: 50%;   /* 添加一个圆形背景（悬停时可见） */
    line-height: 1;       /* 确保垂直居中 */
    position: relative;
    top: -2px;            /* 位置微调 */
    transition: background-color 0.2s;
}
#qzone-more-actions-btn:hover {
    background-color: rgba(0,0,0,0.05); /* 鼠标悬停时显示一个淡淡的灰色圆形背景 */
}

/* 夜间模式下的悬停效果 */
#phone-screen.dark-mode #qzone-more-actions-btn:hover {
    background-color: rgba(255,255,255,0.1);
}

/* ▲▲▲ 新增CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 步骤 2：将这段【全新的CSS代码】，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* 清空动态选择列表的样式 */
#clear-posts-list {
    overflow-y: auto; /* 内容过长时可以滚动 */
    flex-grow: 1;
}

/* 每一个可勾选的项目 */
.clear-posts-item {
    display: flex;
    align-items: center;
    padding: 12px 18px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
    transition: background-color 0.2s;
}
.clear-posts-item:hover {
    background-color: #f5f5f5;
}

/* 模拟的勾选框 */
.clear-posts-item .checkbox {
    width: 22px;
    height: 22px;
    border: 2px solid #ccc;
    border-radius: 50%;
    margin-right: 15px;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
}
/* 选中后的样式 */
.clear-posts-item.selected .checkbox {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
}
/* 为勾选框添加一个“✔”号 */
.clear-posts-item.selected .checkbox::after {
    content: '✔';
    font-size: 14px;
    font-weight: bold;
}

/* 项目名称 */
.clear-posts-item .name {
    font-weight: 500;
}

/* 为危险选项（如“清空所有”）添加红色警告样式 */
.clear-posts-item.danger-option .name {
    color: #ff3b30;
    font-weight: 600;
}

/* ▲▲▲ 新增CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 步骤 2：将这段【全新的CSS代码】，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* 1. 让心声卡片成为删除按钮的定位锚点 */
.thought-card {
    position: relative; /* 关键！ */
}

/* 2. 删除按钮的样式 */
.thought-delete-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 26px;
    height: 26px;
    border-radius: 50%;
    border: none;
    background-color: rgba(0,0,0,0.05);
    color: var(--text-secondary);
    font-size: 20px;
    line-height: 26px;
    text-align: center;
    cursor: pointer;
    opacity: 0; /* 默认隐藏 */
    transition: all 0.2s ease-in-out;
}

/* 3. 鼠标悬停在卡片上时，显示删除按钮 */
.thought-card:hover .thought-delete-btn {
    opacity: 1;
}

/* 4. 鼠标悬停在删除按钮上时，变为红色警告 */
.thought-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}
/* ▲▲▲ 新增CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】BGM搜索结果弹窗美化 (多选支持版) ▼▼▼ */



/* 2. 让列表项支持Flex布局，为复选框留出空间 */
.search-result-item {
    display: flex;       /* 改为Flex布局 */
    align-items: center; /* 垂直居中 */
    padding: 12px 18px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background-color 0.2s;
}
.search-result-item:hover {
    background-color: rgba(0, 0, 0, 0.05);
}
#phone-screen.dark-mode .search-result-item:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

/* 3. 让歌曲信息部分占据剩余空间 */
.search-result-item .search-result-info {
    flex-grow: 1;
    pointer-events: none; /* 让点击穿透到父元素 */
}

/* 4. 复选框样式 */
.search-result-item .music-search-checkbox {
    width: 20px;
    height: 20px;
    margin-right: 15px;
    flex-shrink: 0;
}

/* 5. 调整弹窗头部，为“全选”留出空间 */
#music-search-results-modal .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

/* 6. 调整弹窗页脚，容纳两个按钮 */
#music-search-results-modal .modal-footer {
    display: flex;
    justify-content: space-around;
}
#music-search-results-modal .modal-footer button {
    width: 45%; /* 让每个按钮占据近一半宽度 */
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】美化外观设置页面的次要按钮 ▼▼▼ */
.bg-upload-container {
    /* 确保容器内的按钮能正确对齐 */
    width: 100%;
    justify-content: center;
    gap: 15px; /* 增加按钮之间的间距 */
}

.bg-upload-container .form-button-secondary {
    flex-grow: 1; /* 让按钮自动填充空间 */
    flex-basis: 0; /* 确保flex-grow生效 */
    max-width: 180px; /* 给一个最大宽度，避免在宽屏上拉伸过度 */
    margin-top: 0;
    padding: 12px; /* 适中的内边距，让按钮更饱满 */
    font-size: 15px;
    font-weight: 600; /* 与主按钮一致的字重 */
    border-radius: 8px; /* 与主按钮一致的圆角 */
    border: none; /* 移除边框，更像iOS风格 */
    background-color: #e9e9eb; /* iOS风格的浅灰色 */
    color: #1c1c1e; /* 深色文字 */
    cursor: pointer;
    transition: background-color 0.2s, transform 0.1s;
}

.bg-upload-container .form-button-secondary:active {
    transform: scale(0.98); /* 添加点击反馈 */
}

/* 为“移除”按钮设置特殊的警告色 */
#remove-global-bg-btn {
    background-color: #ffebee;
    color: #c62828;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】心声/散记卡片票根样式 ▼▼▼ */

/* 1. 为卡片主体设置相对定位和溢出隐藏，这是实现效果的基础 */
#character-profile-modal .character-profile-content {
    position: relative; /* 让伪元素可以相对于它定位 */
    overflow: visible;  /* 【核心修改】允许伪元素“溢出”到外面一点，形成打孔效果 */
    padding-bottom: 35px; /* 增加底部内边距，防止内容与底部打孔重叠 */
}

/* 2. 创建顶部的打孔效果 */
#character-profile-modal .character-profile-content::before {
    content: '';
    position: absolute;
    top: -10px; /* 向上移动，露出一半 */
    left: 0;
    right: 0;
    height: 20px; /* 打孔条的高度 */
    /* 核心：使用径向渐变创建重复的半圆形“孔” */
    background-image: radial-gradient(circle at 50% 0, transparent 8px, #f0f2f5 8px);
    background-size: 25px 20px; /* 控制每个孔的大小和间距 */
    background-repeat: repeat-x;
}

/* 3. 创建底部的打孔效果 */
#character-profile-modal .character-profile-content::after {
    content: '';
    position: absolute;
    bottom: -10px; /* 向下移动，露出一半 */
    left: 0;
    right: 0;
    height: 20px; /* 打孔条的高度 */
    /* 核心：与顶部类似，但圆心位置相反 */
    background-image: radial-gradient(circle at 50% 100%, transparent 8px, #f0f2f5 8px);
    background-size: 25px 20px; /* 控制每个孔的大小和间距 */
    background-repeat: repeat-x;
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】票根样式美化 (直角 + 纯白背景) ▼▼▼ */

/* 1. 覆盖主容器样式，改为直角和白色背景 */
#character-profile-modal .character-profile-content {
    border-radius: 0;         /* 核心修改1: 移除圆角，变为直角 */
    background-color: #ffffff; /* 核心修改2: 将背景色改为纯白色 */
}

/* 2. 覆盖顶部打孔条的颜色，与新的白色背景统一 */
#character-profile-modal .character-profile-content::before {
    /* 核心修改3: 将打孔条的颜色从灰色改为纯白色 */
    background-image: radial-gradient(circle at 50% 0, transparent 8px, #ffffff 8px);
}

/* 3. 覆盖底部打孔条的颜色，与新的白色背景统一 */
#character-profile-modal .character-profile-content::after {
    /* 核心修改4: 将打孔条的颜色也改为纯白色 */
    background-image: radial-gradient(circle at 50% 100%, transparent 8px, #ffffff 8px);
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】为心声/散记卡片添加票根分割线 ▼▼▼ */

/* 1. 为头部区域（时间戳）添加相对定位和空间，作为分割线的“锚点” */
#character-profile-modal .thought-header {
    position: relative;
    width: 100%;
    /* 增加底部内边距，为分割线创造空间 */
    padding-bottom: 15px; 
    /* 增加底部外边距，将下方的“心声”内容推开 */
    margin-bottom: 25px; 
    /* 这就是中间的灰色虚线 */
    border-bottom: 2px dashed #e0e0e0; 
}

/* ▼▼▼ 【最终修复】票根分割线打孔透明效果 ▼▼▼ */


/* 2. 重新创建左侧的“打孔”，使其颜色与页面背景一致 */
#character-profile-modal .thought-header::before {
    content: '';
    position: absolute;
    bottom: -11px;
    left: -35px;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    /* 核心修复：使用页面的背景色 (#f0f2f5) 来“伪装”透明效果 */
    background-color:  rgba(0, 0, 0, 0.3);
}

/* 3. 重新创建右侧的“打孔” */
#character-profile-modal .thought-header::after {
    content: '';
    position: absolute;
    bottom: -11px;
    right: -35px;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    /* 核心修复：颜色与页面背景保持一致 */
    background-color:  rgba(0, 0, 0, 0.3);
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【最终版】角色资料卡固定背景图样式 (直角) ▼▼▼ */

/* ▼▼▼ 【最终图片显示修复】请用这整块代码替换旧的 .thought-header 样式 ▼▼▼ */
#character-profile-modal .thought-header {
    height: 140px;         /* 保持固定的、防压缩的高度 */
    flex-shrink: 0;
    padding: 10px;         /* 在图片四周留出“画框”边距 */
    padding-bottom: 25px;  /* 加大底部边距，将图片与虚线分开 */
    box-sizing: border-box;
    border-bottom: 2px dashed #e0e0e0; /* 恢复虚线分割线 */
    margin-bottom: 25px;
    position: relative;     /* 保持，为了让打孔能正确定位 */

    /* --- 核心修复：在这里重新添加背景图片 --- */
    background-image: url('https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758340625111_qdqqd_zqr2cl.jpeg'); /* <-- 请在这里替换为您自己的图片URL */
    background-size: cover;
    background-position: center top;
    border-radius: 0;      /* 确保图片容器是直角的 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */

/* 2. 移除之前为JS动态图片准备的样式（可选，但推荐） */
#profile-photo-slot {
    display: none; /* 隐藏掉JS可能创建的<img>标签 */
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【最终修复】隔离资料卡样式，防止泄露到历史记录 ▼▼▼ */

/* ▼▼▼ 【最终修复】隔离资料卡样式，防止泄露到历史记录 ▼▼▼ */

/* 1. 【核心】使用更精确的选择器，确保照片区域只出现在主资料页上 */
#character-profile-modal #profile-main-content .thought-header {
   // height: 120px;
    //padding-bottom: 15px; /* 步骤1：保留足够的空间，将虚线向下推 */
    box-sizing: border-box;
    background-image: url('https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758340625111_qdqqd_zqr2cl.jpeg');
    background-size: cover;
    background-position: center top;
    border-bottom: 2px dashed #e0e0e0;
    margin-bottom: 15px;
    
    /* ▼▼▼ 步骤2：这就是解决问题的关键！▼▼▼ */
    /* 强制背景图只在内容区绘制，不要进入我们用padding撑开的空白区域 */
    background-clip: content-box; 
    -webkit-background-clip: content-box; /* 兼容旧版浏览器 */
    /* ▲▲▲ 关键代码结束 ▲▲▲ */
}

/* 2. 【核心】确保打孔效果也只出现在主资料页上 */
#character-profile-modal #profile-main-content .thought-header::before,
#character-profile-modal #profile-main-content .thought-header::after {
    content: '';
    position: absolute;
    bottom: -11px;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background-color: rgba(0, 0, 0, 0.3);
}
#character-profile-modal #profile-main-content .thought-header::before {
    left: -35px;
}
#character-profile-modal #profile-main-content .thought-header::after {
    right: -35px;
}

/* 3. 【重要】将历史记录页里的小卡片头部样式，强制恢复为原始的简洁样式 */
#character-profile-modal #thoughts-history-list .thought-card .thought-header {
    height: auto;
    padding: 0;
    padding-bottom: 8px; /* 恢复底部的小间距 */
    margin-bottom: 12px;
    background-image: none; /* 移除背景图 */
    border: none; /* 移除所有边框 */
    border-bottom: 1px solid #f0f0f0; /* 只保留底部的细分割线 */
}

/* 4. 【重要】在历史记录的小卡片上，强制隐藏掉打孔的伪元素 */
#character-profile-modal #thoughts-history-list .thought-card .thought-header::before,
#character-profile-modal #thoughts-history-list .thought-card .thought-header::after {
    display: none !important; /* 强制不显示 */
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】心声/散记美化与字体修复 ▼▼▼ */

/* 
  第一步：强制显示“心声”和“散记”的标签。
  我们使用 !important 来确保这条规则的优先级最高，
  可以覆盖掉任何之前可能存在的 display: none; 隐藏规则。
*/
#character-profile-modal #profile-main-content .label {
    display: flex !important;
}

/* 
  第二步：为“心声”和“散记”的正文内容更换字体。
  这里以常见的宋体(SimSun)为例，您可以替换成任何您喜欢的字体名称。
*/
#character-profile-modal #profile-main-content .text {
    font-family: "SimSun", "Songti SC", serif; /* 示例：更换为宋体 */
    font-size: 16px; /* (可选) 稍微放大字体，让宋体更清晰 */
}

/* ▲▲▲ 新增CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【最终修复】强制将心声/散记内容变为纯黑色 ▼▼▼ */

/* 1. 将“心声”和“散记”的标题文字和图标变为黑色 */
#character-profile-modal .thought-content .label {
    color: #000000 !important;
}

/* 2. 将“心声”和“散记”的正文段落文字变为黑色 */
#character-profile-modal .thought-content .text {
    color: #000000 !important;
}

/* ▲▲▲ 新增CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】修复心声/资料卡页面左右滑动问题 ▼▼▼ */
#character-profile-modal #profile-main-content {
    overflow-x: hidden;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
        /* ▼▼▼ 【全新】表情包分类功能样式 ▼▼▼ */

        /* 1. 分类页签容器样式 */
        #sticker-category-tabs {
            display: flex;
            overflow-x: auto;
            padding: 0 15px; /* 左右留白 */
            flex-shrink: 0;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--secondary-bg);
            /* 隐藏滚动条 */
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        #sticker-category-tabs::-webkit-scrollbar {
            display: none;
        }

        /* 2. 单个页签按钮样式 */
        .sticker-category-tab {
            padding: 10px 16px; /* 增加上下内边距，让页签更高一些 */
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            border-bottom: 2px solid transparent;
            margin-bottom: -1px; /* 让底边框与容器边框重合 */
            transition: all 0.2s ease-in-out;
            white-space: nowrap; /* 防止分类名换行 */
        }

        /* 3. 激活的页签样式 */
        .sticker-category-tab.active {
            color: var(--accent-color);
            border-bottom-color: var(--accent-color);
            font-weight: 600;
        }

        #phone-screen.dark-mode .sticker-category-tab.active {
            color: #ffffff;
        }
        /* ▲▲▲ 新增CSS结束 ▲▲▲ */
        /* ▼▼▼ 【全新】表情批量删除与全选功能样式 ▼▼▼ */
        
        /* 管理模式下，为表情项添加一个选中框 */
        #sticker-grid.management-mode .sticker-item::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 3px solid transparent;
            border-radius: 10px;
            box-sizing: border-box;
            transition: border-color 0.2s;
            pointer-events: none; /* 确保不影响点击 */
        }
        
        /* 管理模式下，被选中的表情项，显示蓝色边框 */
        #sticker-grid.management-mode .sticker-item.selected::after {
            border-color: var(--accent-color);
        }
        
        /* 管理模式下，总是显示删除按钮 */
        #sticker-grid.management-mode .sticker-item .delete-btn {
            display: block;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid white;
        }
        
        /* 【全新】底部批量删除操作栏 */
        #sticker-action-bar {
            display: none; /* 默认隐藏 */
            flex-shrink: 0;
            padding: 10px 15px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            background-color: rgba(247, 247, 247, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
            justify-content: space-between; /* 让“全选”和“删除”两端对齐 */
            align-items: center;
        }
        
        #sticker-action-bar .select-all-label {
            font-size: 16px;
            color: var(--text-primary);
            cursor: pointer;
        }

        #sticker-action-bar button {
            padding: 10px 25px;
            border-radius: 20px;
            border: none;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            background-color: #ff3b30;
            color: white;
        }
        /* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新 V2.0】Cphone功能的所有CSS样式 ▼▼▼ */

/* --- 1. 角色选择界面 (保持不变) --- */
#character-selection-screen { background-color: #f0f2f5; }
#phone-screen.dark-mode #character-selection-screen { background-color: #000; }
/* --- 请用这一整块【全新】的CSS，替换旧的 #character-grid 和 .character-select-item 相关的所有样式 --- */

/* 1. 将网格容器变为列表容器 */
#character-grid {
    /* 移除了 display: grid 和相关属性 */
    padding: 0; /* 移除内边距，由列表项自己控制 */
    overflow-y: auto; /* 确保内容超出时可以滚动 */
    flex-grow: 1;
}

/* 2. 修改每个列表项的布局，从垂直变为水平 */
.character-select-item {
    display: flex;
    flex-direction: row;     /* 核心修改：从 column 变为 row */
    align-items: center;     /* 保持垂直居中 */
    cursor: pointer;
    padding: 12px 20px;      /* 增加内边距，形成列表项外观 */
    border-bottom: 1px solid var(--border-color); /* 添加分割线 */
    gap: 15px;               /* 在头像和名字之间增加间距 */
    transition: background-color 0.2s; /* 添加悬停效果 */
    /* 移除了 text-align: center */
}
.character-select-item:hover {
    background-color: #f5f5f5; /* 鼠标悬停时高亮 */
}


/* 3. 调整头像大小和样式 */
.character-select-item .avatar {
    width: 45px;             /* 核心修改：缩小头像尺寸 */
    height: 45px;
    border-radius: 50%;      /* 改为圆形，更适合列表视图 */
    object-fit: cover;
    margin-bottom: 0;        /* 移除底部外边距 */
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    transition: transform 0.2s ease;
    flex-shrink: 0;          /* 防止头像被压缩 */
}

/* 4. 调整名字样式 */
.character-select-item .name {
    font-weight: 500;
    font-size: 16px;         /* 稍微增大字体，提高可读性 */
    color: var(--text-primary);
}
/* --- 替换结束 --- */

/* --- 2. Cphone主容器与屏幕切换 (保持不变) --- */
#character-phone-screen { background-size: cover; background-position: center; }
.char-screen { width: 100%; height: 100%; position: absolute; top: 0; left: 0; display: flex; flex-direction: column; overflow: hidden; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
.char-screen.active { opacity: 1; visibility: visible; z-index: 2; }

/* --- 3. Cphone主屏幕 (保持不变) --- */
#char-home-screen { justify-content: flex-start; align-items: center; box-sizing: border-box; padding: 0 20px; }
#char-clock-container { text-align: center; color: white; text-shadow: 0 3px 8px rgba(0,0,0,0.4); margin-top: calc(60px + env(safe-area-inset-top)); flex-shrink: 0; margin-bottom: 100px; }
#char-main-time { font-size: 88px; font-weight: 600; letter-spacing: -2px; font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif; }
#char-main-date { font-size: 22px; font-weight: normal; }
#char-app-grid { display: flex; flex-direction: column; align-items: center; gap: 20px; width: 100%; }

/* --- 4. Cphone内的App通用背景色 (已扩展) --- */
#char-qq-screen, #char-memo-screen, #char-diary-screen, #char-usage-screen, 
#char-album-screen, #char-browser-screen, #char-taobao-screen {
     background-color: var(--secondary-bg);
}

/* --- 5. 备忘录、日记、使用记录列表样式 (保持不变) --- */
.memo-item, .diary-item, .usage-item { padding: 15px 20px; border-bottom: 1px solid var(--border-color); cursor: pointer; }
.memo-item .content, .diary-item .content { font-size: 16px; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.diary-item .date, .usage-item .timestamp { font-size: 12px; color: var(--text-secondary); margin-bottom: 5px; }
.usage-item .action { font-size: 15px; color: var(--text-primary); }

/* --- 6. 【全新】角色相册样式 --- */
#char-album-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 每行3张图 */
    gap: 5px;
    padding: 5px;
}
.char-photo-item {
    aspect-ratio: 1 / 1; /* 保持正方形 */
    background-size: cover;
    background-position: center;
    background-color: #e9ecef;
}

/* --- 7. 【全新】角色浏览器历史样式 --- */
.char-browser-item {
    padding: 12px 20px;
    border-bottom: 1px solid var(--border-color);
}
.char-browser-item .title {
    font-weight: 500;
    font-size: 15px;
    color: var(--text-primary);
    margin-bottom: 4px;
}
.char-browser-item .url {
    font-size: 12px;
    color: var(--accent-color);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* --- 8. 【全新】角色淘宝页面样式 (复用主购物页样式) --- */
#char-product-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    padding: 10px;
}
.char-product-item {
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.04);
    display: flex;
    flex-direction: column;
}
.char-product-item .product-image {
    width: 100%;
    aspect-ratio: 1 / 1;
    object-fit: cover;
    border-radius: 8px 8px 0 0;
}
.char-product-item .product-info {
    padding: 12px 10px;
    flex-grow: 1;
}
.char-product-item .product-name {
    font-size: 13px;
    color: #333;
    line-height: 1.4;
    min-height: 36px;
}
.char-product-item .product-price {
    font-size: 16px;
    font-weight: 700;
    color: #ff5722;
    margin-top: 8px;
}
.char-product-item .product-price::before { content: '¥'; font-size: 12px; }

/* ▲▲▲ 全新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新V2.0】CphoneQQ模拟功能样式 ▼▼▼ */
#char-qq-screen .list-container {
    padding: 0; /* 移除容器的内边距 */
}
/* ▲▲▲ 新增CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】CphoneQQ模拟聊天记录弹窗样式 ▼▼▼ */

/* 1. 让弹窗内容区拥有和主聊天界面一样的布局 */
#transcript-modal-body {
    display: flex;
    flex-direction: column;
    gap: 20px; /* 消息气泡之间的间距 */
    padding: 15px; /* 内边距 */
    background-color: #f0f2f5;
}

/* 2. 夜间模式适配 */
#phone-screen.dark-mode #transcript-modal-body {
    background-color: #000000;
}

/* ▲▲▲ 新增CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新V2.0 | 最终布局修复】请用这整块代码，替换掉您上一次粘贴的 #char-chat-list 相关的CSS ▼▼▼ */

/* 1. 为两个列表的列表项（主QQ列表和角色QQ列表）设置统一的 Flexbox 布局 */
#chat-list .chat-list-item,
#char-chat-list .chat-list-item {
    display: flex;
    align-items: center;
    gap: 15px; /* 【核心修复1】使用 gap 属性在头像和文字之间创建间距，这比 margin 更现代、更可靠 */
}

/* 2. 确保头像容器（无论在哪一个列表中）都绝对不会被压缩 */
#chat-list .chat-list-item .avatar-group,
#char-chat-list .chat-list-item .avatar-group {
    flex-shrink: 0;
    /* 移除了旧的 margin-right，因为现在由父元素的 gap 属性统一控制间距 */
}

/* 3. 确保文字信息区域（无论在哪一个列表中）都能够正确地伸缩 */
#chat-list .chat-list-item .info,
#char-chat-list .chat-list-item .info {
    flex-grow: 1;
    min-width: 0; /* 关键！允许容器收缩，从而防止内部的长文字撑破布局导致重叠 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */
/* ▼▼▼ 【全新】CphoneQQ模拟对话页面美化样式 ▼▼▼ */

/* 1. 让弹窗内容区拥有和主聊天界面一样的布局 */
#char-qq-conversation-screen .list-container {
    display: flex;
    flex-direction: column;
    gap: 20px; /* <-- 核心：添加20px的间距 */
    padding: 15px; /* <-- 新增：在四周增加内边距，避免气泡贴边 */
    background-color: #f0f2f5;
}

/* 2. 夜间模式适配 */
#phone-screen.dark-mode #char-qq-conversation-screen .list-container {
    background-color: #000000;
}
/* ▼▼▼ 【全新】CphoneApp通用背景色 (已修复) ▼▼▼ */
#char-qq-screen, 
#char-memo-screen, 
#char-diary-screen, 
#char-usage-screen, 
#char-album-screen, 
#char-browser-screen, 
#char-taobao-screen,
/* --- 【核心修复】将新的文章页面也加入这个规则，确保它有正确的背景色 --- */
#char-browser-article-screen {
     background-color: var(--secondary-bg);
}
/* ▲▲▲ 修复结束 ▲▲▲ */
/* ▼▼▼ 【全新】CphoneApp通用背景色 (已修复钱包页面) ▼▼▼ */
#char-qq-screen, 
#char-memo-screen, 
#char-diary-screen, 
#char-usage-screen, 
#char-album-screen, 
#char-browser-screen, 
#char-taobao-screen,
#char-browser-article-screen,
/* --- 【核心修复】将新的钱包页面也加入这个规则，确保它有正确的背景色 --- */
#char-wallet-screen {
     background-color: var(--secondary-bg);
}
/* ▲▲▲ 修复结束 ▲▲▲ */
/* ▼▼▼ 【全新】Cphone备忘录详情页样式 ▼▼▼ */

#char-memo-detail-content {
    width: 100%;
    height: 100%;
    border: none;
    background-color: transparent;
    font-size: 16px;
    line-height: 1.7; /* 增加行高，更易读 */
    padding: 15px 20px; /* 增加左右内边距 */
    box-sizing: border-box;
    resize: none; /* 禁止用户拖动调整大小 */
    outline: none; /* 移除选中时的蓝色边框 */
    font-family: inherit; /* 继承页面字体 */
    color: var(--text-primary); /* 确保文字颜色能适配夜间模式 */
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】Cphone备忘录详情页美化 (仿iOS Notes App) ▼▼▼ */

/* 1. 让详情页拥有自己的、能适配夜间模式的背景色 */
#char-memo-detail-screen {
    background-color: var(--secondary-bg);
}

/* 2. 美化头部，添加分割线，并调整内边距 */
#char-memo-detail-screen .header {
    background-color: var(--secondary-bg); /* 与页面背景色统一 */
    border-bottom: 1px solid var(--border-color); /* 添加精致的分割线 */
    
    padding-bottom: 10px;
}

/* 3. 【核心】强制标题居中显示 */
#char-memo-detail-title {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    font-weight: 600; /* 标题加粗 */
}

/* 4. 移除内容容器的默认内边距，让文本区能撑满 */
#char-memo-detail-screen .form-container {
    padding: 0;
}

/* 5. 美化文本区域，使其看起来像一个真正的笔记页面 */
#char-memo-detail-content {
    background-color: var(--secondary-bg); /* 背景色与头部统一，形成整体感 */
    padding: 15px 20px; /* 增加顶部和左右的内边距，让文字有呼吸空间 */
    font-size: 17px; /* 仿iOS备忘录的字体大小 */
    line-height: 1.7; /* 更宽松的行高，提升阅读体验 */
    color: var(--text-primary);
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】Cphone日记详情页“信纸”样式 ▼▼▼ */

/* 1. 详情页主屏幕，使用柔和的米白色背景 */
#char-diary-detail-screen {
    background-color: #FDFBF5; /* 柔和的信纸底色 */
}

/* 夜间模式下的适配 */
#phone-screen.dark-mode #char-diary-detail-screen {
    background-color: #2c2c2e; /* 深色背景 */
}

/* 2. 移除内容区的默认内边距，让我们的“信纸”能撑满 */
#char-diary-detail-content-wrapper {
    padding: 0;
    overflow-y: auto; /* 确保长日记可以滚动 */
}

/* 3. “信纸”本身的核心样式 */
#char-diary-detail-content {
    padding: 25px 20px; /* 在信纸四周留出舒适的边距 */
    font-family: Georgia, 'Times New Roman', Times, serif; /* 使用更典雅的衬线字体 */
    font-size: 16px;
    line-height: 1.8; /* 更大的行高，提升阅读感 */
    color: #383838; /* 使用深灰色文字，比纯黑更柔和 */
}

/* 夜间模式下的文字颜色 */
#phone-screen.dark-mode #char-diary-detail-content {
    color: #e0e0e0;
}

/* 4. 为日记的第一行（通常是标题）设置特殊样式 */
#char-diary-detail-content > p:first-of-type {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 20px;
    text-align: center;
}

/* 5. 确保Markdown转换后的标签样式正确 */
#char-diary-detail-content strong {
    font-weight: 600; /* 加粗 */
}
#char-diary-detail-content .spoiler {
    /* 这里的样式与主聊天界面保持一致 */
    background-color: #333;
    color: #333;
    padding: 0 4px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}
#char-diary-detail-content .spoiler:hover {
    background-color: #e0e0e0;
    color: inherit;
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】日记详情页自定义Markdown样式 ▼▼▼ */

/* 0. 引入外部手写字体 (Google Fonts) */
@import url('https://fonts.googleapis.com/css2?family=Zhi+Mang+Xing&display=swap');

/* 1. 黄色背景高亮 */
#char-diary-detail-content .diary-highlight {
    background-color: #FFFACD; /* 柠檬绸色，一种柔和的黄色 */
    padding: 1px 4px;
    border-radius: 3px;
    margin: 0 2px;
}

/* 2. 粉色虚线下划线 */
#char-diary-detail-content .diary-underline {
    border-bottom: 2px dotted #FFB6C1; /* 浅粉色 */
    text-decoration: none; /* 移除默认的实线下划线 */
    padding-bottom: 1px;
}

/* 3. 粉红色加粗文字 */
#char-diary-detail-content .diary-emphasis {
    color: #DB7093; /* 灰紫色 */
    font-weight: bold;
}

/* 4. 手写体黑色文字 */
#char-diary-detail-content .diary-handwritten {
    font-family: 'Zhi Mang Xing', cursive; /* 应用手写字体 */
    font-size: 1.1em; /* 手写体稍微大一点更好看 */
    color: #1a1a1a; /* 比纯黑更柔和的深灰色 */
}

/* 5. 稍微倾斜的手写体文字 */
#char-diary-detail-content .diary-messy {
    font-family: 'Zhi Mang Xing', cursive;
    font-size: 1.1em;
    color: #1a1a1a;
    transform: rotate(-2deg); /* 轻微旋转 */
    display: inline-block; /* 旋转需要 display 属性配合 */
    margin: 0 2px;
}

/* 6. 被涂黑的内容 */
#char-diary-detail-content .diary-censored {
    background-color: #222;
    color: #222; /* 让文字颜色和背景色一样，实现涂黑效果 */
    user-select: none; /* 防止用户通过选中来查看内容 */
    padding: 0 3px;
    border-radius: 2px;
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
.diary-censored:hover, .diary-censored:active {
  background-color: #E0E0E0; /* 鼠标悬停时变成浅灰色背景 */
  color: inherit; /* 恢复为正常的文字颜色 */
  cursor: pointer; /* 鼠标变为可点击的手型 */
}
/* ▼▼▼ 【全新】角色高德地图功能样式 ▼▼▼ */

/* 1. 主屏幕背景色 */
#char-amap-screen {
    background-color: #f0f2f5;
}
#phone-screen.dark-mode #char-amap-screen {
    background-color: #000000;
}

/* 2. 足迹列表容器 */
#char-amap-list {
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 18px; /* 增加足迹之间的间距 */
}

/* 3. 单个足迹卡片 */
.char-amap-item {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    display: flex;
    flex-direction: column; /* 让内容垂直排列 */
}

/* 4. 卡片头部 (图标 + 地点信息) */
.amap-item-header {
    display: flex;
    align-items: flex-start; /* 图标和文字顶部对齐 */
    gap: 12px;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 12px;
    margin-bottom: 12px;
}

/* 5. 地点图标 */
.amap-item-icon {
    font-size: 24px;
    color: var(--accent-color);
    margin-top: 2px;
}

/* 6. 地点信息 (标题 + 地址) */
.amap-item-info {
    flex-grow: 1;
}
.amap-item-title {
    font-weight: 600;
    font-size: 16px;
    margin-bottom: 4px;
}
.amap-item-address {
    font-size: 13px;
    color: var(--text-secondary);
}

/* 7. 卡片主体 (评论 + 图片) */
.amap-item-body {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.amap-item-comment {
    font-size: 14px;
    line-height: 1.6;
    white-space: pre-wrap; /* 支持换行 */
}

/* 8. 足迹附带的图片 */
.amap-item-photo {
    width: 100%;
    height: 150px;
    border-radius: 8px;
    background-size: cover;
    background-position: center;
    cursor: pointer;
}

/* 9. 卡片底部 (时间戳) */
.amap-item-footer {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 10px;
    text-align: right;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】角色App使用记录功能样式 ▼▼▼ */

/* 1. 列表容器 */
#char-usage-list {
    padding: 10px 0; /* 上下留白，左右由列表项控制 */
}

/* 2. 单个App记录项 */
.char-usage-item {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 10px 20px;
    transition: background-color 0.2s;
}
.char-usage-item:hover {
    background-color: rgba(0,0,0,0.03);
}

/* 3. App图标 */
.usage-item-icon {
    width: 40px;
    height: 40px;
    border-radius: 8px; /* iOS风格的圆角矩形 */
    object-fit: cover;
    flex-shrink: 0;
    background-color: #e9ecef;
}

/* 4. 中间信息区 (App名 + 分类) */
.usage-item-info {
    flex-grow: 1; /* 占据所有剩余空间 */
}
.usage-item-name {
    font-weight: 500;
    font-size: 16px;
}
.usage-item-category {
    font-size: 12px;
    color: var(--text-secondary);
}

/* 5. 右侧时长显示 */
.usage-item-time {
    font-size: 15px;
    color: var(--text-secondary);
    font-weight: 500;
    flex-shrink: 0;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】角色网易云音乐功能样式 ▼▼▼ */

/* 1. 主屏幕背景色 */
#char-music-screen {
    background-color: #f0f2f5;
}
#phone-screen.dark-mode #char-music-screen {
    background-color: #000000;
}

/* 2. 歌曲列表容器 */
#char-music-list {
    padding: 0;
}

/* 3. 单个歌曲列表项 (仿网易云风格) */
.char-music-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 20px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
}
.char-music-item:hover {
    background-color: rgba(0,0,0,0.03);
}

/* 4. 歌曲封面 */
.music-item-cover {
    width: 50px;
    height: 50px;
    border-radius: 8px;
    object-fit: cover;
    flex-shrink: 0;
}

/* 5. 歌曲信息 (歌名 + 歌手) */
.music-item-info {
    flex-grow: 1;
    overflow: hidden; /* 防止长文本溢出 */
}
.music-item-name {
    font-weight: 500;
    font-size: 16px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.music-item-artist {
    font-size: 12px;
    color: var(--text-secondary);
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 这是你要【添加】到 <style> 标签末尾的【全新播放器CSS代码】 ▼▼▼ */

/* 1. 播放器主窗口样式 */
#char-music-player-modal .modal-content {
    width: 400px !important; /* 固定宽度 */
    height: auto !important; /* 高度自适应 */
    max-height: 90vh;
    background-color: #f7f8fa !important; /* 浅灰色背景 */
    border-radius: 12px !important;
    box-shadow: 0 10px 40px rgba(0,0,0,0.1) !important;
    color: #333 !important;
    display: flex;
    flex-direction: column;
}

/* 2. 头部标题栏 */
#char-music-player-modal .char-player-header {
    flex-shrink: 0;
    padding: 12px 15px;
    border-bottom: 1px solid #e5e5e5;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: 600;
}
#char-music-player-modal .char-player-close-btn {
    background: none;
    border: none;
    font-size: 20px;
    color: #aaa;
    cursor: pointer;
}
#char-music-player-modal .char-player-close-btn:hover {
    color: #333;
}


/* 3. 主内容区（封面、进度条、按钮） */
#char-music-player-modal .char-player-body {
    padding: 30px 35px 20px 35px;
    text-align: center;
}
#char-music-player-modal #char-music-cover {
    width: 220px;
    height: 220px;
    border-radius: 10px;
    box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    margin-bottom: 20px;
    object-fit: cover;
}

/* 4. 进度条样式 */
#char-music-player-modal .char-player-progress-bar-container {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
}
#char-music-player-modal .char-player-progress-bar {
    flex-grow: 1;
    height: 4px;
    background-color: #e0e0e0;
    border-radius: 2px;
    cursor: pointer;
}
#char-music-player-modal #char-music-progress-fill {
    width: 0%;
    height: 100%;
    background-color: #555;
    border-radius: 2px;
}

/* 5. 控制按钮样式 */
#char-music-player-modal .char-player-controls {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 20px;
}
#char-music-player-modal .char-player-controls .control-btn {
    background: none;
    border: none;
    color: #555;
    cursor: pointer;
    transition: color 0.2s;
    padding: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
}
#char-music-player-modal .char-player-controls .control-btn:hover {
    color: #000;
}
#char-music-player-modal .char-player-controls .control-btn.play {
    width: 50px;
    height: 50px;
    background-color: #f0f1f3;
    border-radius: 50%;
    color: #333;
}
#char-music-player-modal .char-player-controls .control-btn.mode {
    font-size: 14px;
    font-weight: 500;
    width: 50px;
}

/* 6. 歌词区域样式 */
#char-music-player-modal #char-music-lyrics {
    flex-grow: 1;
    overflow-y: auto;
    padding: 0 35px 25px 35px;
    font-size: 14px;
    line-height: 2;
    color: #888;
    text-align: center;
}
#char-music-player-modal #char-music-lyrics p.active {
    color: #000;
    font-weight: 600;
}

/* 隐藏滚动条 */
#char-music-player-modal #char-music-lyrics::-webkit-scrollbar {
    display: none;
}
#char-music-player-modal #char-music-lyrics {
    -ms-overflow-style: none;
    scrollbar-width: none;
}

/* ▲▲▲ 新增CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 这是你要【添加】到 <style> 标签末尾的【全新播放器CSS V3.0】 ▼▼▼ */

/* 1. 定义唱片旋转动画 */
@keyframes spin-vinyl {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

/* 2. 播放器主窗口样式 */
#char-music-player-modal .modal-content {
    width: 340px !important; /* 宽度适中 */
    height: auto !important;
    background-color: #f0f1f3 !important; /* 轻柔的灰色背景 */
    border-radius: 12px !important;
    box-shadow: 0 10px 40px rgba(0,0,0,0.1) !important;
    color: #333 !important;
    display: flex;
    flex-direction: column;
    padding: 20px; /* 统一内边距 */
    position: relative;
}

/* 3. 移除旧的头部，因为关闭按钮已独立 */
#char-music-player-modal .modal-header {
    display: none !important;
}

/* 4. 右上角关闭按钮 */
#char-music-player-modal .char-player-close-btn {
    position: absolute;
    top: 15px;
    right: 15px;
    background: none;
    border: none;
    font-size: 24px;
    font-weight: 300;
    color: #aaa;
    cursor: pointer;
    line-height: 1;
    z-index: 10;
}

/* 5. 主内容区 */
#char-music-player-modal .char-player-body {
    display: flex;
    flex-direction: column;
    align-items: center;
    flex-grow: 1;
}

/* 6. 歌曲信息 */
#char-music-player-modal .char-player-song-info {
    text-align: center;
    margin-bottom: 25px;
}
#char-music-player-modal #char-music-player-title {
    font-size: 20px;
    font-weight: 600;
    margin: 0 0 5px 0;
}
#char-music-player-modal #char-music-artist {
    font-size: 14px;
    color: #888;
    margin: 0;
}

/* 7. 黑胶唱片效果 */
#char-music-player-modal #char-vinyl-container {
    width: 210px;
    height: 210px;
    border-radius: 50%;
    background-color: #222;
    padding: 15px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.2), 
                inset 0 0 0 2px rgba(255, 255, 255, 0.05);
    background-image: repeating-radial-gradient(circle, #333, #333 1px, #222 1px, #222 2px);
    box-sizing: border-box;
    margin-bottom: 25px;
}
#char-music-player-modal #char-vinyl-container.spinning {
    animation: spin-vinyl 12s linear infinite;
}
#char-music-player-modal #char-music-cover {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

/* 8. 歌词占位符 (音符) */
#char-music-player-modal #char-lyric-placeholder {
    color: #aaa;
    font-size: 18px;
    letter-spacing: 5px;
    margin-bottom: 25px;
}

/* 9. 底部控制栏 */
#char-music-player-modal .char-player-footer {
    width: 100%;
    margin-top: auto; /* 将其推到底部 */
}

/* 10. 进度条和控制按钮 (与上一版类似，但class已更新) */
#char-music-player-modal .char-player-progress-bar-container {
    display: flex; align-items: center; gap: 10px; margin-bottom: 10px;
}
#char-music-player-modal .char-player-progress-bar {
    flex-grow: 1; height: 4px; background-color: #e0e0e0; border-radius: 2px; cursor: pointer;
}
#char-music-player-modal #char-music-progress-fill {
    width: 0%; height: 100%; background-color: #555; border-radius: 2px;
}
#char-music-player-modal .char-player-controls {
    display: flex; align-items: center; justify-content: center; gap: 20px;
}
#char-music-player-modal .char-player-controls .control-btn {
    background: none; border: none; color: #555; cursor: pointer; transition: color 0.2s; padding: 5px;
    display: flex; align-items: center; justify-content: center;
}
#char-music-player-modal .char-player-controls .control-btn:hover { color: #000; }
#char-music-player-modal .char-player-controls .control-btn.play {
    width: 50px; height: 50px; background-color: #e0e1e3; border-radius: 50%; color: #333;
}
#char-music-player-modal .char-player-controls .control-btn.mode {
    font-size: 14px; font-weight: 500; width: 50px;
}
#char-music-player-modal #char-music-lyrics {
    display: none; /* 在这个版本中，我们彻底隐藏歌词区域 */
}

/* ▲▲▲ 新增CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 这是你要【添加】到 <style> 标签末尾的【全新播放器CSS V3.0】 ▼▼▼ */

/* 1. 定义唱片旋转动画 */
@keyframes spin-vinyl {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

/* 2. 播放器主窗口样式 */
#char-music-player-modal .modal-content {
    width: 340px !important; /* 宽度适中 */
    height: auto !important;
    background-color: #f0f1f3 !important; /* 轻柔的灰色背景 */
    border-radius: 12px !important;
    box-shadow: 0 10px 40px rgba(0,0,0,0.1) !important;
    color: #333 !important;
    display: flex;
    flex-direction: column;
    padding: 20px; /* 统一内边距 */
    position: relative;
}

/* 3. 移除旧的头部，因为关闭按钮已独立 */
#char-music-player-modal .modal-header {
    display: none !important;
}

/* 4. 右上角关闭按钮 */
#char-music-player-modal .char-player-close-btn {
    position: absolute;
    top: 15px;
    right: 15px;
    background: none;
    border: none;
    font-size: 24px;
    font-weight: 300;
    color: #aaa;
    cursor: pointer;
    line-height: 1;
    z-index: 10;
}

/* 5. 主内容区 */
#char-music-player-modal .char-player-body {
    display: flex;
    flex-direction: column;
    align-items: center;
    flex-grow: 1;
}

/* 6. 歌曲信息 */
#char-music-player-modal .char-player-song-info {
    text-align: center;
    margin-bottom: 25px;
}
#char-music-player-modal #char-music-player-title {
    font-size: 20px;
    font-weight: 600;
    margin: 0 0 5px 0;
}
#char-music-player-modal #char-music-artist {
    font-size: 14px;
    color: #888;
    margin: 0;
}

/* 7. 黑胶唱片效果 */
#char-music-player-modal #char-vinyl-container {
    width: 210px;
    height: 210px;
    border-radius: 50%;
    background-color: #222;
    padding: 15px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.2), 
                inset 0 0 0 2px rgba(255, 255, 255, 0.05);
    background-image: repeating-radial-gradient(circle, #333, #333 1px, #222 1px, #222 2px);
    box-sizing: border-box;
    margin-bottom: 25px;
}
#char-music-player-modal #char-vinyl-container.spinning {
    animation: spin-vinyl 12s linear infinite;
}
#char-music-player-modal #char-music-cover {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

/* 8. 【核心新增】歌词区域样式 */
#char-music-player-modal #char-music-lyrics {
    width: 100%;
    height: 50px; /* 设定一个固定高度，用于显示约两行歌词 */
    overflow: hidden; /* 隐藏超出部分的歌词 */
    position: relative;
    margin-bottom: 25px;
    font-size: 14px;
    line-height: 25px; /* 设置行高 */
    color: #888;
    text-align: center;
    transition: all 0.3s ease;
}

#char-music-player-modal #char-music-lyrics p {
    margin: 0;
    transition: all 0.3s ease;
}

#char-music-player-modal #char-music-lyrics p.active {
    color: #000;
    font-weight: 600;
    font-size: 16px; /* 当前行歌词放大一点 */
}


/* 9. 底部控制栏 */
#char-music-player-modal .char-player-footer {
    width: 100%;
    margin-top: auto; /* 将其推到底部 */
}

/* 10. 进度条和控制按钮 */
#char-music-player-modal .char-player-progress-bar-container {
    display: flex; align-items: center; gap: 10px; margin-bottom: 10px;
}
#char-music-player-modal .char-player-progress-bar {
    flex-grow: 1; height: 4px; background-color: #e0e0e0; border-radius: 2px; cursor: pointer;
}
#char-music-player-modal #char-music-progress-fill {
    width: 0%; height: 100%; background-color: #555; border-radius: 2px;
}
#char-music-player-modal .char-player-controls {
    display: flex; align-items: center; justify-content: center; gap: 20px;
}
#char-music-player-modal .char-player-controls .control-btn {
    background: none; border: none; color: #555; cursor: pointer; transition: color 0.2s; padding: 5px;
    display: flex; align-items: center; justify-content: center;
}
#char-music-player-modal .char-player-controls .control-btn:hover { color: #000; }
#char-music-player-modal .char-player-controls .control-btn.play {
    width: 50px; height: 50px; background-color: #e0e1e3; border-radius: 50%; color: #333;
}
#char-music-player-modal .char-player-controls .control-btn.mode {
    font-size: 14px; font-weight: 500; width: 50px;
}

/* ▲▲▲ 新增CSS粘贴结束 ▲▲▲ */
#chat-list .chat-list-item {
    /* 核心1：强制使用 gap 属性来控制间距，并覆盖旧有冲突 */
    gap: 15px !important;
    /* 确保没有其他对齐方式干扰 */
    justify-content: flex-start !important;
}

#chat-list .chat-list-item .avatar-group {
    /* 核心2：强制移除之前用于间距的 margin，现在完全由 gap 控制 */
    margin-right: 0 !important;
}
/* ▼▼▼ 【全新V2.0 | 仿豆瓣UI】豆瓣小组功能样式 ▼▼▼ */

/* 1. 豆瓣主题色与页面背景 */
#douban-screen {
    background-color: #F6F6F1; /* 豆瓣经典的米色背景 */
}
#phone-screen.dark-mode #douban-screen {
    background-color: #1a1a1a;
}
#douban-posts-list {
    padding: 0; /* 列表本身不需要内边距 */
    display: flex;
    flex-direction: column;
}

/* 2. 帖子卡片美化 (V2.0) */
.douban-post-item {
    background-color: var(--secondary-bg);
    padding: 12px 15px;
    border: none;
    box-shadow: none;
    border-bottom: 1px solid var(--border-color); /* 用分割线代替边框 */
    cursor: pointer;
    transition: background-color 0.2s;
}
.douban-post-item:hover {
    background-color: #f9f9f9;
}
#phone-screen.dark-mode .douban-post-item:hover {
    background-color: #2c2c2e;
}

/* 3. 帖子头部 (头像、昵称、小组名) */
.douban-post-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}
.douban-post-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    object-fit: cover;
}
.douban-author-info {
    flex-grow: 1;
}
.douban-author-name {
    font-weight: 500;
    color: var(--text-primary);
    font-size: 14px;
}
.douban-group-name {
    font-size: 12px;
    color: #007722; /* 豆瓣标志性的绿色 */
    font-weight: 500;
}

/* 4. 帖子标题和内容预览 */
.douban-post-title {
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--text-primary);
}
.douban-post-content {
    font-size: 14px;
    color: #555;
    line-height: 1.7;
    white-space: pre-wrap;
    word-break: break-word;
    display: -webkit-box;
    -webkit-line-clamp: 4;
    -webkit-box-orient: vertical;
    overflow: hidden;
}
#phone-screen.dark-mode .douban-post-content {
    color: #dcdcdc;
}

/* 5. 帖子底部 (统计数据) */
.douban-post-footer {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid #f0f0f0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 13px;
    color: var(--text-secondary);
}
.douban-post-actions {
    display: flex;
    gap: 20px;
}
.douban-post-actions span {
    display: flex;
    align-items: center;
    gap: 6px; /* 增加图标和数字之间的间距 */
    color: var(--text-secondary); /* 确保颜色统一 */
}
/* 【核心新增】为SVG图标设置统一样式 */
.douban-post-actions svg {
    width: 18px;
    height: 18px;
    fill: currentColor; /* 让图标颜色跟随父元素的文字颜色 */
    position: relative;
    top: -1px; /* 位置微调，使其与数字更对齐 */
}
/* ▼▼▼ 【全新】羽毛笔图标按钮样式 ▼▼▼ */
.douban-feather-btn {
    /* 1. 基础样式 (复用主聊天界面的圆形按钮) */
    font-size: 24px;
    padding: 0;
    width: 38px;
    height: 38px;
    line-height: 38px;
    text-align: center;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-shrink: 0; /* 防止被压缩 */
    margin-right: 8px; /* 和发送按钮拉开距离 */

    /* 2. 外观 (仿iOS风格的浅灰色) */
    background-color: #f0f2f5;
    color: #555;
    transition: background-color 0.2s;
}
.douban-feather-btn:hover {
    background-color: #e2e6ea;
}
.douban-feather-btn svg {
    width: 20px;
    height: 20px;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* 6. 【V2.2 | 最终布局修复版】帖子详情页 */

#douban-post-detail-screen {
    background-color: #F6F6F1; /* 外部米色背景 */
}
#phone-screen.dark-mode #douban-post-detail-screen {
    background-color: #1a1a1a;
}

/* 【核心修复1】重置外部容器的内边距，让白色背景能撑满全屏 */
#douban-detail-content-wrapper {
    background-color: var(--secondary-bg);
    padding: 0; /* 移除导致两侧空白的内边距 */
    padding-bottom: 80px; /* 只保留底部的空间给输入框 */
}

/* 【核心修复2】将边距应用到内部的正文区域 */
#douban-post-detail-body {
    padding: 20px 18px 25px 18px; /* 在内容四周留出呼吸空间 */
    border-bottom: 1px solid #f0f0f0;
}
#phone-screen.dark-mode #douban-post-detail-body {
    border-bottom-color: #38383a;
}

/* 美化帖子标题 */
.douban-post-title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 15px;
    line-height: 1.5;
}

/* 优化正文阅读体验 */
.douban-detail-content {
    white-space: pre-wrap;
    line-height: 1.8;
    font-size: 15px;
    color: #333;
}
#phone-screen.dark-mode .douban-detail-content {
    color: #dcdcdc;
}

/* 【核心修复3】将边距也应用到评论区，并移除与正文的间距 */
.douban-comments-section {
    margin-top: 0;
    padding: 15px 18px;
}

/* 为“回应”增加标题样式 */
.douban-comments-section h4 {
    font-size: 14px;
    font-weight: 500;
    color: var(--text-secondary);
    margin: 0 0 15px 0;
    padding-bottom: 10px;
    border-bottom: 1px solid #f0f0f0;
}
#phone-screen.dark-mode .douban-comments-section h4 {
    border-bottom-color: #38383a;
}

/* 美化单条评论 */
.douban-comment-item {
    display: flex;
    gap: 12px;
    padding: 15px 0;
    border-bottom: 1px solid #f0f0f0;
}
.douban-comment-item:last-child {
    border-bottom: none;
}
#phone-screen.dark-mode .douban-comment-item {
    border-bottom-color: #38383a;
}

.douban-comment-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    flex-shrink: 0;
}
.douban-comment-body {
    flex-grow: 1;
}
.douban-comment-author {
    font-weight: 500;
    font-size: 14px;
    color: var(--text-primary);
}
.douban-comment-text {
    font-size: 14px;
    color: #555;
    margin-top: 6px;
    line-height: 1.7;
    word-break: break-word;
}
#phone-screen.dark-mode .douban-comment-text {
    color: #b0b0b0;
}

/* 7. 【V2.2 | 最终布局修复版】详情页底部评论输入栏 */
#douban-comment-footer {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    
    /* 【核心修复1】增加上下左右的内边距，解决贴边问题 */
    padding: 10px 18px; 
    
    /* 【核心修复2】保留对iPhone底部安全区域的适配 */
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
    
    /* 【核心修复3】确保 padding 不会撑破布局 */
    box-sizing: border-box; 
    
    /* (其他样式保持不变) */
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid var(--border-color); /* 在顶部也加一条分割线，更精致 */
}
#douban-send-comment-btn {
    background-color: #007722; /* 豆瓣绿 */
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【最终修复 | V3.0】豆瓣头部按钮显示终极解决方案 ▼▼▼ */

/* 1. 确保右侧的按钮容器本身不会被意外压缩 */
#douban-screen .header .header-actions {
    flex-shrink: 0;
    display: flex;       /* 确保它是一个flex容器 */
    align-items: center; /* 垂直居中内部的图标 */
}

/* 2. 【核心修复】为所有头部操作按钮内的SVG图标设置一个固定的、统一的尺寸 */
.header .action-btn svg {
    width: 24px;   /* 确保尺寸统一 */
    height: 24px;
    display: block; /* 移除SVG可能带有的额外底部空间 */
}

/* 3. 为所有操作按钮设置一个最小宽度，保证它们不会被挤压得过小 */
.header .action-btn {
    min-width: 30px; /* 给予每个按钮足够的点击区域 */
    display: flex;
    align-items: center;
    justify-content: center;
}
/* ▲▲▲ 修复结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是用于对齐头部左侧按钮的样式 ▼▼▼ */
.header .header-left-actions {
    display: flex;
    align-items: center;
    gap: 15px; /* (可选) 在返回、导入、导出按钮之间增加一些间距 */
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
        /* ▼▼▼ 【全新】这是为“角色相册生图关闭”功能添加的样式 ▼▼▼ */

        /* 1. 让相册格子成为 Flex 容器，这样我们才能方便地居中内部的文字 */
        .char-photo-item {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px; /* 在文字周围留出一点内边距，避免贴边 */
            box-sizing: border-box;
        }
        
        /* 2. 照片描述文字本身的样式 */
        .char-photo-description {
            font-size: 13px;
            color: var(--text-secondary); /* 使用次要文字颜色，看起来更柔和 */
            text-align: center;
            line-height: 1.5;
        
            /* 核心：这是一个实现“多行省略号”的技巧，防止过长的描述撑破布局 */
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 5; /* 最多显示5行 */
            overflow: hidden;
            word-break: break-all; /* 确保长单词或URL也能被截断 */
        }
        
        /* ▲▲▲ 新增CSS结束 ▲▲▲ */
        /* ▼▼▼ 【全新】这是为淘宝/浏览器生图关闭功能添加的样式 ▼▼▼ */

        /* 1. 为淘宝商品卡片上的文字描述创建一个容器 */
        .char-product-description-overlay {
            width: 100%;
            aspect-ratio: 1 / 1; /* 与图片保持相同的正方形比例，确保网格布局不乱 */
            background-color: #f7f8fa; /* 柔和的背景色 */
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px; /* 内边距 */
            box-sizing: border-box;
            border-bottom: 1px solid #eee; /* 在描述和商品信息之间加一条分割线 */
            border-radius: 8px 8px 0 0; /* 匹配图片的顶部圆角 */
        }

        /* 2. 描述文字本身的样式 (复用相册的样式，并让浏览器也使用) */
        .char-product-description-overlay .char-photo-description,
        .char-browser-image-description { 
            font-size: 14px; /* 字体可以稍微大一点 */
            color: var(--text-secondary);
            text-align: center;
            line-height: 1.6;
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 6; /* 最多显示6行 */
            overflow: hidden;
            word-break: break-all;
        }

        /* 3. 为浏览器中的图片描述创建一个容器 */
        .char-browser-image-description {
            padding: 40px 20px; /* 上下留出更多空间 */
        }

        /* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为角色淘宝订单状态添加的样式 ▼▼▼ */
.char-product-status {
    font-size: 12px;
    color: #8a8a8a; /* 使用柔和的灰色 */
    background-color: #f0f2f5; /* 给一个淡淡的背景 */
    padding: 3px 8px;
    border-radius: 10px;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ *
/* 1. 搜索屏幕的背景色 */
#search-history-screen {
    background-color: #f0f2f5;
}
#phone-screen.dark-mode #search-history-screen {
    background-color: #000000;
}

/* 2. 搜索结果列表，确保可以滚动 */
#search-results-list {
    flex-grow: 1;
    overflow-y: auto;
}

/* 3. 日期分隔符的样式 */
.date-separator {
    text-align: center;
    color: var(--text-secondary);
    font-size: 12px;
    padding: 10px 0;
    font-weight: 500;
}

/* 4. 夜间模式下的输入框适配 */
#phone-screen.dark-mode #search-bar input {
    background-color: #1c1c1e;
    color: #ffffff;
    border-color: #38383a;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】主屏幕分页功能样式 ▼▼▼ */

        /* 1. 让主屏幕成为Flex容器，但方向改为水平，为翻页做准备 */
        #home-screen {
            flex-direction: column;
            padding: 0; /* 移除旧的内边距，由内部页面自己控制 */
        }

        /* 2. 页面容器，负责横向排列所有页面 */
        #home-screen-pages-container {
            flex-grow: 1; /* 占据除了Dock栏外的所有空间 */
            width: 100%;
            overflow: hidden; /* 隐藏横向滚动条 */
            position: relative;
        }

        #home-screen-pages {
            display: flex;
            width: 200%; /* 假设有两页，宽度设为200% */
            height: 100%;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1); /* 平滑的翻页动画 */
        }

        /* 3. 单个页面的样式 */
        .home-screen-page {
            width: 50%; /* 每页占据一半宽度 */
            height: 100%;
            padding: 20px;
            padding-top: calc(20px + env(safe-area-inset-top));
            padding-bottom: 0; /* 底部由分页指示器控制 */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* 4. 分页指示器 (小圆点) */
        #home-screen-pagination {
            display: flex;
            justify-content: center;
            gap: 8px;
            padding: 10px 0;
             /* 适配iPhone底部安全区 */
            padding-bottom: calc(10px + env(safe-area-inset-bottom) / 2);
            flex-shrink: 0;
        }

        .pagination-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.4);
            transition: all 0.3s ease;
        }

        .pagination-dot.active {
            background-color: white;
            transform: scale(1.1);
        }
        
        /* 5. 第二页的App网格容器 */
        #page-2-app-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr; /* 每行4个图标 */
            gap: 20px;
            width: 100%;
            padding-top: 40px; /* 与顶部留出一些距离 */
        }
        /* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】聊天工具栏按钮排序功能样式 ▼▼▼ */
.draggable-button-item {
    padding: 8px 12px;
    background-color: var(--secondary-bg);
    border: 1px solid var(--border-color);
    border-radius: 20px;
    cursor: grab;
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 14px;
    font-weight: 500;
    transition: background-color 0.2s, box-shadow 0.2s;
    user-select: none;
}
.draggable-button-item:active {
    cursor: grabbing;
}
.draggable-button-item svg {
    width: 18px;
    height: 18px;
    stroke-width: 2;
}
/* 当一个元素正在被拖动时应用的样式 */
.draggable-button-item.dragging {
    opacity: 0.5;
    background-color: #e0e0e0;
}
/* 当拖动的元素悬停在另一个元素上方时，为那个元素应用的样式 */
.draggable-button-item.drag-over {
    background-color: #d0eaff;
    box-shadow: 0 0 0 2px var(--accent-color);
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新 | 移动端兼容】为拖动过程添加的样式 ▼▼▼ */

/* 当一个元素正在被拖动时应用的样式 */
.draggable-button-item.dragging {
    opacity: 0.5;
    background-color: #e0e0e0;
    /* 核心：让被拖动的元素“浮”起来，不会影响其他元素的布局 */
    position: relative; 
    z-index: 10;
}

/* 防止在手机上拖动时，意外选中页面上的文字 */
#button-order-editor {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为弹窗内可滚动长文本添加的样式 ▼▼▼ */
.scrollable-content-preview {
    /* 核心1：设置一个最大高度。内容超出这个高度就会触发滚动。
       35vh 表示视窗高度的35%，这是一个灵活的高度，能适应不同屏幕。*/
    max-height: 35vh;
    
    /* 核心2：当内容垂直方向溢出时，自动显示滚动条。 */
    overflow-y: auto;
    
    /* (可选) 美化样式，让它看起来更像一个代码/引用块 */
    background-color: #f0f2f5;
    padding: 10px 15px;
    border-radius: 8px;
    text-align: left;
    white-space: pre-wrap; /* 保持文本中的换行 */
    border: 1px solid var(--border-color);
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】高级数据清理向导样式 ▼▼▼ */
.wizard-step {
    display: none; /* 默认隐藏所有步骤 */
    flex-direction: column;
    width: 100%;
    height: 100%;
}

.wizard-step.active {
    display: flex; /* 只显示激活的步骤 */
}

/* 复用现有的列表项样式，为其添加一点内边距 */
#data-clear-char-list .clear-posts-item,
#data-clear-type-list .clear-posts-item {
    padding: 12px 18px;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】为清理向导添加“全选”样式 ▼▼▼ */
#data-clear-wizard-modal .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
#data-clear-wizard-modal .modal-header label {
    font-size: 14px;
    font-weight: normal;
    display: flex;
    align-items: center;
    gap: 5px;
    cursor: pointer;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】教程页面样式 ▼▼▼ */
#tutorial-screen {
    background-color: #f0f2f5;
}
#phone-screen.dark-mode #tutorial-screen {
    background-color: #000000;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】预设编辑器内容折叠功能样式 ▼▼▼ */
.entry-content-container {
    display: none; /* 默认隐藏内容区域 */
    margin-top: 8px; /* 和上方的标签拉开一点距离 */
}
.toggle-content-btn {
    background: none;
    border: 1px solid #ccc;
    color: var(--text-secondary);
    font-size: 12px;
    padding: 2px 8px;
    border-radius: 5px;
    cursor: pointer;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是更新通知弹窗的样式 ▼▼▼ */
#update-notice-modal {
    position: fixed; /* 固定定位，覆盖在所有内容之上 */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.4);
    display: none; /* 默认隐藏 */
    align-items: center;
    justify-content: center;
    z-index: 2000; /* 确保在最上层 */
    opacity: 0;
    transition: opacity 0.3s ease;
}
#update-notice-modal.visible {
    display: flex;
    opacity: 1;
}
.update-notice-content {
    background-color: #fff;
    width: 300px;
    border-radius: 14px;
    box-shadow: 0 5px 25px rgba(0,0,0,0.15);
    display: flex;
    flex-direction: column;
    transform: scale(0.95);
    transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
}
#update-notice-modal.visible .update-notice-content {
    transform: scale(1);
}
.update-notice-body {
    padding: 20px;
    font-size: 15px;
    line-height: 1.6;
    color: #333;
    
    /* --- ▼▼▼ 核心修改就在这里 ▼▼▼ --- */

    /* 1. 设置一个最大高度。我们使用 vh (视窗高度) 单位，
       让弹窗最大不超过屏幕高度的60%，以适应不同尺寸的手机。 */
    max-height: 60vh; 
    
    /* 2. 当内容超出这个最大高度时，自动显示垂直滚动条。 */
    overflow-y: auto; 

    /* --- ▲▲▲ 修改结束 ▲▲▲ --- */
}
.update-notice-footer {
    border-top: 1px solid #dbdbdb;
    display: flex;
}
.update-notice-footer button {
    flex: 1;
    background: none;
    border: none;
    padding: 14px;
    font-size: 17px;
    cursor: pointer;
    color: var(--accent-color);
}
.update-notice-footer button:first-child {
    border-right: 1px solid #dbdbdb;
    font-weight: 600;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新 | 保持横向布局】这是修复长按菜单截断问题的最终版样式 ▼▼▼ */

/* 1. 核心修改：让按钮容器支持换行 */
#message-actions-modal .custom-modal-footer {
    flex-wrap: wrap; /* 允许项目换行 */
    padding: 10px;   /* 在容器周围增加一些内边距，让布局更舒展 */
    gap: 10px;       /* 在按钮之间增加间距 */
    justify-content: flex-start; /* 让按钮从左侧开始排列 */
}

/* 2. 为每一个操作按钮（除了取消按钮）设置尺寸和样式 */
#message-actions-modal .custom-modal-footer button:not(#cancel-message-action-btn) {
    /* 核心修改：不再平分宽度，而是允许它们根据内容生长，并设置一个基础宽度 */
    flex-grow: 1;
    flex-basis: 75px; /* 每个按钮的基础宽度，确保至少能容纳4个字 */
    
    /* (可选但推荐) 统一按钮外观，使其更像一个网格 */
    border: none;
    background-color: #f0f2f5;
    border-radius: 8px;
    padding: 12px 5px; /* 调整内边距，让文字居中 */
    font-size: 16px;
    font-weight: 500;
}

/* 3. 让“取消”按钮单独占据一整行，并恢复其独立样式 */
#message-actions-modal #cancel-message-action-btn {
    width: 100%; /* 强制宽度为100% */
    flex-basis: 100%; /* 在flex布局中也确保它占满一行 */
    margin-top: 8px;
    border-radius: 8px;
    background-color: #f0f2f5;
    font-weight: 600;
}
/* ▲▲▲ 新增CSS粘贴结束 ▲▲▲ */
/* 修复iOS输入框自动放大问题 (强制版) */
input, textarea, select {
    font-size: 16px !important;
}
/* ▼▼▼ 【全新】这是为日记收藏功能添加的样式 ▼▼▼ */

/* 收藏按钮激活时的样式（填充黄色） */
#favorite-diary-btn.active svg {
    fill: #ffc107; /* 您可以换成任何您喜欢的颜色 */
    color: #ffc107;
}

/* 收藏卡片中日记标题的样式 */
.favorite-item-card .diary-title {
    font-weight: 600;
    display: block;
    margin-bottom: 8px;
    font-size: 15px;
}

/* 收藏卡片中日记内容预览的样式 */
.favorite-item-card .diary-content-preview {
    font-size: 13px;
    opacity: 0.8;
    line-height: 1.6;
    
    /* 多行省略号效果 */
    display: -webkit-box;
    -webkit-line-clamp: 3; /* 最多显示3行 */
    -webkit-box-orient: vertical;
    overflow: hidden;
}
/* ▼▼▼ 把这段CSS代码【完全删除】▼▼▼ */
.favorite-item-card .diary-content-preview {
    font-size: 13px;
    opacity: 0.8;
    line-height: 1.6;
    
    /* 多行省略号效果 */
    display: -webkit-box;
    -webkit-line-clamp: 3; /* 最多显示3行 */
    -webkit-box-orient: vertical;
    overflow: hidden;
}
/* ▲▲▲ 删除到这里结束 ▲▲▲ */
#npc-list-view {
    background-color: #f0f2f5;
}
#phone-screen.dark-mode #npc-list-view {
    background-color: #000;
}

/* ▼▼▼ 【全新】这是为“围观群聊”操作按钮添加的样式 ▼▼▼ */

/* 1. 让“围观中”文字和按钮容器垂直排列 */
#chat-lock-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px; /* 在文字和按钮之间增加间距 */
}

/* 2. 按钮的容器，使用Flex布局让它们水平排列 */
.spectator-actions-container {
    display: flex;
    gap: 12px; /* 按钮之间的间距 */
    align-items: center;
}

/* 3. 为次要按钮（重Roll/剪辑）创建一个新样式 */
#chat-lock-content .lock-action-btn.secondary {
    background-color: transparent; /* 透明背景 */
    color: var(--accent-color);   /* 使用主题色文字 */
    border: 1px solid var(--accent-color); /* 同样颜色的边框 */
    padding: 8px 18px; /* 调整内边距，让它比主按钮小一点 */
    font-size: 14px;
}
/* ▲▲▲ 新增CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为“围观群聊”SVG图标按钮添加的样式 ▼▼▼ */

.spectator-actions-container .lock-action-btn.secondary svg {
    width: 20px;  /* 设置图标宽度 */
    height: 20px; /* 设置图标高度 */
    stroke: currentColor; /* 关键：让图标颜色自动继承按钮的文字颜色 */
}

/* ▲▲▲ 新增CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】音乐播放器背景样式 ▼▼▼ */

/* 1. 让播放器窗口成为相对定位的容器，以便伪元素定位 */
.music-player-window {
    position: relative;
    /* (可选) 增加一个轻微的背景蒙版，让文字在亮色背景下更清晰 */
    background-color: rgba(255, 255, 255, 0.75);
}

/* 2. 这就是我们的背景层核心样式 */
.music-player-window::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    
    /* 3. 使用CSS变量来动态设置背景图片 */
    background-image: var(--music-bg-image);
    background-size: cover;
    background-position: center;
    
    /* 4. 添加视觉效果：高斯模糊和降低亮度，营造氛围感 */
    filter: blur(15px) brightness(0.8);
    
    /* 5. 确保背景在最底层，不遮挡内容 */
    z-index: -1;
    
    /* 6. 让背景层的圆角和播放器窗口保持一致 */
    border-radius: inherit; 
    
    /* 7. 为背景切换增加平滑的过渡动画 */
    transition: background-image 0.5s ease-in-out;
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */

/* ▼▼▼ 【全新V2.0 | 最终修复版】背景清晰度切换功能样式 ▼▼▼ */

/* 1. 当播放器窗口拥有 .bg-clear 这个 class 时，让背景变得清晰 (此规则不变) */
.music-player-window.bg-clear::before {
    filter: none;
}

/* 2. 【核心修改】为“清”字按钮设置新的、与其它控制按钮一致的样式 */
#toggle-blur-btn {
    /* 移除所有定位属性 */
    /* position: absolute; bottom: 95px; right: 20px; z-index: 55; */

    /* 复用其他按钮的样式 */
    background: none;
    border: none;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    color: #333;
    width: 44px;
    height: 44px;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: all 0.2s ease;
    border-radius: 50%;
    
    /* 给一个和其他按钮相似的淡淡背景 */
    background-color: rgba(0, 0, 0, 0.05);
}

/* 3. 按钮激活时的样式（表示当前是清晰模式） */
#toggle-blur-btn.active {
    background-color: var(--accent-color); /* 例如，激活时变为主题色 */
    color: white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */

/* ▼▼▼ 【全新】播放器全屏功能样式 ▼▼▼ */

/* 1. 当播放器窗口拥有 .fullscreen 这个 class 时，让它撑满整个屏幕 */
.music-player-window.fullscreen {
    width: 100%;
    height: 100%;
    max-height: 100%; /* 覆盖可能存在的 max-height 限制 */
    border-radius: 0; /* 全屏时移除圆角 */
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); /* 让放大缩小的动画更流畅 */
}

/* 2. 当播放器全屏时，移除外部容器的内边距，让播放器能真正贴合屏幕边缘 */
#music-player-overlay.fullscreen-active {
    padding-top: 0;
    align-items: stretch; /* 让播放器在垂直方向上也能撑满 */
}

/* 3. 【核心】为新的全屏切换按钮定义样式 */
#toggle-fullscreen-btn {
    background: none;
    border: none;
    font-size: 22px; /* 设置一个合适的图标大小 */
    cursor: pointer;
    color: #555;
    padding: 5px;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: color 0.2s;
}
#toggle-fullscreen-btn:hover {
    color: #000;
}

/* 4. 【核心】通过 CSS 控制放大/缩小图标的显示和隐藏 */
/* 默认情况下，只显示“放大”图标 */
#toggle-fullscreen-btn .icon-minimize {
    display: none;
}
/* 当播放器处于全屏状态时，隐藏“放大”图标，显示“缩小”图标 */
.music-player-window.fullscreen #toggle-fullscreen-btn .icon-maximize {
    display: none;
}
.music-player-window.fullscreen #toggle-fullscreen-btn .icon-minimize {
    display: block;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */

/* ▼▼▼ 【全新】播放器全屏头像显示功能样式 ▼▼▼ */

/* 1. 头像显示容器的样式 */
#music-player-avatar-display {
    display: none; /* 默认隐藏 */
    width: 100%;
    padding: 15px 20px;
    box-sizing: border-box;
    justify-content: space-between; /* 让两个头像分布在两端 */
    align-items: center;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1); /* 添加一条分割线 */
    margin-bottom: 10px;
}

/* 2. 只有当播放器全屏，并且该容器有 .visible 类时，才显示它 */
.music-player-window.fullscreen #music-player-avatar-display.visible {
    display: flex;
}

/* 3. 头像本身的样式 */
.participant-display-avatar {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    object-fit: cover;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
}

/* 4. 新的“显示头像”按钮的样式 */
#show-avatars-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 5px;
    display: none; /* 默认在非全屏模式下隐藏 */
    align-items: center;
    justify-content: center;
    opacity: 0.6;
    transition: opacity 0.2s;
}

/* 5. 只有在全屏模式下才显示这个按钮 */
.music-player-window.fullscreen #show-avatars-btn {
    display: flex;
}

#show-avatars-btn:hover {
    opacity: 1;
}

/* 6. 当头像正在显示时，让按钮也高亮 */
#show-avatars-btn.active {
    opacity: 1;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为豆瓣设置弹窗添加的样式 ▼▼▼ */
.douban-settings-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.douban-settings-item label {
    margin-bottom: 0;
    flex-grow: 1; /* 让标签占据更多空间 */
}
.douban-settings-controls {
    display: flex;
    align-items: center;
    gap: 8px; /* 在输入框和文字之间增加间距 */
    flex-shrink: 0; /* 防止被压缩 */
}
.douban-settings-controls input {
    width: 60px;
    text-align: center;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为时区搜索框添加的样式 ▼▼▼ */
#time-zone-search-input {
    width: 100%;
    padding: 10px 12px;
    margin-bottom: 8px; /* 和下方的下拉框拉开一点距离 */
    border: 1px solid var(--border-color);
    border-radius: 6px;
    box-sizing: border-box;
    font-size: 16px; /* 避免在iOS上输入时自动放大页面 */
}
/* 夜间模式适配 */
#phone-screen.dark-mode #time-zone-search-input {
    background-color: #1c1c1e;
    color: #ffffff;
    border-color: #38383a;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】狼人杀游戏功能样式 ▼▼▼ */

/* 游戏主屏幕布局 */
#werewolf-game-screen {
    background-color: #2c2c2e; /* 深邃的背景，营造氛围 */
    color: white;
}
#werewolf-player-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
    gap: 15px;
    padding: 15px;
    flex-shrink: 0;
    border-bottom: 1px solid #444;
}
.werewolf-player-avatar {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    position: relative;
}
.werewolf-player-avatar img {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: 2px solid #888;
    transition: all 0.3s;
}
.werewolf-player-avatar .player-name {
    font-size: 12px;
    font-weight: 500;
    text-shadow: 0 1px 2px black;
}
/* 死亡玩家的样式 */
.werewolf-player-avatar.dead img {
    filter: grayscale(100%);
    border-color: #ff3b30;
}
.werewolf-player-avatar.dead .player-name {
    color: #ff3b30;
    text-decoration: line-through;
}

/* 游戏日志/对话区域 */
#werewolf-log {
    padding: 15px;
    background: none;
    display: flex;
    flex-direction: column;
    gap: 12px;
}
.werewolf-log-entry {
    background-color: rgba(255, 255, 255, 0.08);
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 14px;
    line-height: 1.6;
}
.werewolf-log-entry.system {
    text-align: center;
    color: #ffc107;
    font-style: italic;
    background-color: rgba(255, 193, 7, 0.1);
}
.werewolf-log-entry .speaker {
    font-weight: bold;
}

/* 底部操作栏 */
#werewolf-action-bar {
    padding: 10px 15px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
    background-color: rgba(0,0,0,0.3);
    flex-shrink: 0;
    text-align: center;
}
#werewolf-next-step-btn {
    width: 100%;
}

/* 角色揭示卡片样式 */
#werewolf-role-card {
    background: linear-gradient(135deg, #4a4a4a, #2a2a2a);
    border: 1px solid #666;
    border-radius: 12px;
    padding: 20px;
    color: white;
}
#werewolf-role-name {
    font-size: 22px;
    font-weight: bold;
    color: #ffc107;
    margin-bottom: 10px;
}
#werewolf-role-description {
    font-size: 14px;
    line-height: 1.6;
}

/* 选择列表的通用样式 (用于查人、投票等) */
.werewolf-selection-item {
    display: flex;
    align-items: center;
    padding: 12px 18px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
}
.werewolf-selection-item.selected {
    background-color: var(--accent-color);
    color: white;
}
.werewolf-selection-item img {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 15px;
}
.werewolf-selection-item .name {
    font-weight: 500;
}
/* ▲▲▲ 狼人杀样式结束 ▲▲▲ */
/* ▼▼▼ 【V3.0 | 狼人杀UI美化】请将这整块代码，粘贴到 <style> 标签的末尾 ▼▼▼ */

        /* 1. 美化底部常驻输入栏的背景 */
        #werewolf-game-screen #werewolf-action-bar {
            background-color: rgba(0, 0, 0, 0.3); /* 半透明黑色背景，营造悬浮感 */
            border-top: 1px solid rgba(255, 255, 255, 0.1); /* 顶部加一条微光分割线 */
            padding: 10px 15px; /* 增加内边距 */
            padding-bottom: calc(10px + env(safe-area-inset-bottom)); /* 适配iPhone底部安全区 */
        }

        /* 2. 【核心修复】让文本输入框能够动态伸缩 */
        #werewolf-game-screen #werewolf-user-input {
            flex-grow: 1; /* 这是最关键的一步，让输入框占据所有剩余空间 */
            border: none;
            padding: 10px 15px;
            border-radius: 20px; /* 圆角 */
            background-color: rgba(255, 255, 255, 0.1); /* 深色半透明背景 */
            color: #f0f0f0; /* 浅色文字 */
            font-size: 16px; /* 适配iOS，防止输入时放大 */
            resize: none; /* 禁止拖动 */
            height: 40px; /* 与主聊天框保持一致的高度 */
            box-sizing: border-box;
        }

        /* 3. 美化输入框的占位符文字 */
        #werewolf-game-screen #werewolf-user-input::placeholder {
            color: #8d8d92; /* 暗灰色 */
        }

        /* 4. 美化操作按钮，使其与主聊天界面的发送按钮风格一致 */
        #werewolf-game-screen #input-actions-wrapper button {
            height: 40px;
            padding: 0 15px;
            border-radius: 20px;
            border: none;
            color: white;
            font-weight: 600;
            cursor: pointer;
            flex-shrink: 0; /* 防止按钮被挤压变形 */
        }

        /* 5. 美化“等待回应”和“继续讨论”按钮 (次要按钮) */
        #werewolf-game-screen #werewolf-wait-reply-btn {
            background-color: #555; /* 深灰色背景 */
        }

        /* 6. 美化“结束发言”和“进入投票”按钮 (主要按钮) */
        #werewolf-game-screen #werewolf-finish-speech-btn {
            background-color: #c62828; /* 暗红色，更有狼人杀氛围 */
        }

        /* ▲▲▲ 新增CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】表情包搜索栏样式 ▼▼▼ */

#sticker-search-container {
    padding: 10px 15px; /* 在搜索框周围留出一些内边距 */
    flex-shrink: 0; /* 防止被压缩 */
    border-bottom: 1px solid var(--border-color); /* 在下方添加分割线 */
    background-color: var(--secondary-bg); /* 确保背景色能适配夜间模式 */
}

#sticker-search-input {
    width: 100%;
    padding: 10px 15px;
    font-size: 16px; /* 避免在iOS上输入时自动放大页面 */
    border: 1px solid var(--border-color);
    border-radius: 18px; /* 圆角矩形 */
    background-color: #f0f2f5; /* 默认的浅灰色背景 */
    box-sizing: border-box;
    outline: none; /* 移除选中时的外框 */
    -webkit-appearance: none; /* 移除iOS上的默认样式 */
}

#sticker-search-input:focus {
    border-color: var(--accent-color); /* 选中时边框变为主题色 */
    background-color: var(--secondary-bg); /* 选中时背景变为白色 */
}

/* 夜间模式适配 */
#phone-screen.dark-mode #sticker-search-input {
    background-color: #2c2c2e;
    color: #f0f0f0;
    border-color: #38383a;
}
#phone-screen.dark-mode #sticker-search-input:focus {
    background-color: #38383a;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】引用跳转高亮效果 ▼▼▼ */

/* 1. 为消息气泡的内容区添加一个平滑的背景色过渡效果 */
.message-bubble .content {
    transition: background-color 0.5s ease-out;
}

/* 2. 定义高亮时的背景色 */
/*    我们使用 !important 来确保它能覆盖掉所有主题的默认颜色 */
.message-bubble.highlighted .content {
    background-color: rgba(0, 123, 255, 0.2) !important;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲
/* ▼▼▼ 【全新】无限滚动加载动画 ▼▼▼ */

.loader-container {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px 0;
    width: 100%;
    height: 44px; /* 给予一个固定高度来防止加载时页面跳动 */
    box-sizing: border-box;
}

.spinner {
    width: 24px;
    height: 24px;
    border: 3px solid rgba(0, 0, 0, 0.1); /* 旋转轨道的浅灰色 */
    border-top-color: var(--accent-color); /* 旋转部分的颜色，会跟随主题色变化 */
    border-radius: 50%;
    animation: spin 1s linear infinite; /* 复用您已有的 spin 动画 */
}

/* 夜间模式下的适配 */
#phone-screen.dark-mode .spinner {
    border: 3px solid rgba(255, 255, 255, 0.2);
    border-top-color: #fff; /* 夜间模式下旋转部分为白色 */
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【V2.1 | 交互修复版】请用这一整块代码，完整替换从 #reading-overlay 到 .reading-footer button:disabled 的所有相关样式 ▼▼▼ */

/* 1. 外部容器：提升 z-index，确保它在顶栏之上 */
#reading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 150; /* 高于顶栏的 100 */
    display: flex;
    justify-content: center;
    align-items: center;
    pointer-events: none; /* 允许点击穿透背景 */
    display: none; /* 默认隐藏 */
}

/* 2. 主窗口样式 */
#reading-window {
    width: 90%;
    max-width: 340px;
    height: 60vh;
    max-height: 480px;
    background-color: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 18px;
    box-shadow: 0 8px 32px rgba(31, 38, 135, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.18);
    display: flex;
    flex-direction: column;
    pointer-events: auto; /* 窗口本身可以交互 */
    position: absolute; /* 改为 absolute 以支持拖动 */
    /* 初始居中定位由JS控制，这里不再设置 */
    transition: transform 0.3s ease, opacity 0.3s ease, visibility 0s 0.3s; /* 添加平滑的过渡动画 */
}
#phone-screen.dark-mode #reading-window {
    background-color: rgba(40, 40, 42, 0.7);
}

/* ▼▼▼ 请用这整块代码，完整替换旧的 .reading-header 和 #reading-title 样式 ▼▼▼ */

/* 3. 头部样式，作为“拖动把手” */

.reading-header {
    cursor: move;
    user-select: none;
    -webkit-user-select: none;
    flex-shrink: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
    gap: 10px;
    /* 新增：强制不换行，作为双重保险 */
    flex-wrap: nowrap;
}

#reading-title {
    font-weight: 600;
    /* 核心：让标题占据所有可用空间，但允许收缩 */
    flex: 1;
    min-width: 0;
    /* 以下三行负责实现省略号效果 */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.reading-controls {
    /* 关键：告诉按钮容器绝对不要被压缩 */
    flex-shrink: 0;
}

/* ▲▲▲ 替换结束 ▲▲▲ */
.reading-controls button {
    background: none; border: none; color: var(--text-secondary); padding: 4px 8px;
    border-radius: 4px; cursor: pointer; font-size: 14px; transition: background-color 0.2s;
}
.reading-controls button:hover {
    background-color: rgba(0,0,0,0.1);
}
#minimize-reading-btn {
    font-weight: bold; font-size: 16px; line-height: 1;
}

/* 4. 【核心修复】最小化后的状态：使其透明、缩小并不可交互 */
#reading-window.minimized {
    transform: scale(0.8); /* 缩小效果 */
    opacity: 0;           /* 透明效果 */
    pointer-events: none; /* 禁止交互 */
    visibility: hidden;   /* 彻底隐藏 */
}

/* 5. 【核心修复】最小化后用于“恢复”的小球，改为屏幕居中 */
#reading-restore-btn {
    position: absolute;
    /* --- 核心修改1：从居中改为靠右 --- */
    top: 50%;
    right: 15px; /* 距离右侧边缘15像素 */
    /* 【关键】只在Y轴上垂直居中，不再需要X轴的平移 */
    transform: translateY(-50%); 
    /* --- 修改结束 --- */
    width: 50px; 
    height: 50px;
    background-color: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px; 
    cursor: move; 
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    pointer-events: auto; 
    z-index: 160; 
    transition: transform 0.2s; 
}
#reading-restore-btn:active {
    /* 【核心修改2】修复点击时的位移问题 */
    transform: translateY(-50%) scale(0.95);
}
#phone-screen.dark-mode #reading-restore-btn {
    background-color: rgba(50, 50, 52, 0.8);
}

/* 6. 内容和页脚样式 (保持不变) */
#reading-content {
    flex-grow: 1; 
    overflow-y: auto; 
    padding: 15px;
    font-size: 15px; 
    line-height: 1.8;
    /* ▼▼▼ 核心新增 ▼▼▼ */
    white-space: pre-wrap; /* 保持换行符，同时允许长单词自动换行 */
    word-break: break-word;  /* 强制长单词或URL断开，防止撑破布局 */
    /* ▲▲▲ 新增结束 ▲▲▲ */
}
.reading-footer {
    flex-shrink: 0; display: flex; justify-content: space-between; align-items: center;
    padding: 12px 15px; border-top: 1px solid var(--border-color);
}
#page-indicator {
    font-size: 14px; 
    color: var(--text-secondary);
    cursor: pointer; /* 添加手型光标，提示用户可以点击 */
    transition: color 0.2s;
}
#page-indicator:hover {
    color: var(--accent-color); /* 鼠标悬停时变色 */
}
.reading-footer button {
    padding: 6px 15px; border-radius: 15px; border: none;
    background-color: var(--accent-color); color: white; cursor: pointer;
}
.reading-footer button:disabled {
    background-color: #ccc;
}
#phone-screen.dark-mode .reading-footer button:disabled {
    background-color: #555;
}

/* ▲▲▲ V2.1 CSS 替换结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为书库搜索功能添加的样式 ▼▼▼ */
#reading-library-search-container {
    padding: 10px 15px;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0; /* 防止被压缩 */
}
#reading-library-search-input {
    width: 100%;
    padding: 10px 12px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-sizing: border-box;
    font-size: 16px; /* 避免在iOS上输入时自动放大页面 */
    -webkit-appearance: none; /* 移除iOS上的默认样式 */
}
#phone-screen.dark-mode #reading-library-search-input {
    background-color: #2c2c2e;
    color: #f0f0f0;
    border-color: #38383a;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】语音消息组件样式 ▼▼▼ */

.voice-message-body {
    display: flex;
    align-items: center;
    cursor: pointer;
    min-width: 80px;
    max-width: 220px;
    padding: 8px 12px;
}
.message-bubble.user .voice-message-body {
    color: #1a3d00;
    flex-direction: row-reverse;
}
.message-bubble.ai .voice-message-body {
    color: var(--text-primary);
}

.voice-play-btn {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: none;
    background-color: rgba(0, 0, 0, 0.1);
    color: currentColor;
    font-size: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    flex-shrink: 0;
    transition: background-color 0.2s;
}
.voice-play-btn:hover {
    background-color: rgba(0, 0, 0, 0.2);
}

.voice-spinner {
    width: 20px;
    height: 20px;
    border: 2px solid rgba(0, 0, 0, 0.2);
    border-top-color: var(--accent-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    display: none; /* 默认隐藏 */
    margin: 4px;
}

.voice-duration {
    font-size: 14px;
    font-weight: 500;
    margin: 0 10px;
    flex-shrink: 0;
}
.message-bubble.user .voice-duration {
    color: #3e6224;
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
    </style>
</head>
<body>
    <div id="phone-screen">
        <div id="status-bar">
            <span id="status-bar-time">12:00</span>
            <div id="status-bar-battery" class="battery-container">
                <span class="battery-text">--%</span>
                <div class="battery-icon">
                    <div class="battery-level"></div>
                </div>
            </div>
        </div>
        <div id="notification-bar"><img id="notification-avatar" src="">
            <div id="notification-content">
                <div class="name"></div>
                <div class="message"></div>
            </div>
        </div>
<!-- ▼▼▼ 步骤 1：用这整块新代码，完整替换掉您现有的 <div id="home-screen" ...> ... </div> ▼▼▼ -->

<div id="home-screen" class="screen active">

    <!-- 1. 页面滑动容器 -->
    <div id="home-screen-pages-container">
        <div id="home-screen-pages">
            <!-- 页面 1: 保持您原有的布局 -->
            <div class="home-screen-page">
                <div id="main-content-area">
                    <div id="profile-widget">
                        <img id="profile-banner-img" src="https://i.imgur.com/1n3a43H.jpeg" class="editable-image">
                        <div class="profile-avatar-container">
                            <img id="profile-avatar-img" src="https://i.postimg.cc/y8xWzCqj/anime-boy.jpg" class="editable-image">
                        </div>
                        <div class="profile-info">
                            <p id="profile-username" class="editable-text">@ insonneve 🪦</p>
                            <p id="profile-sub-username" class="editable-text">@ insonneve</p>
                            <p id="profile-bio" class="editable-text">你好像过得很好 迫不及待的抹去我存在的痕迹</p>
                            <p id="profile-location" class="editable-text">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5-2.5-1.12 2.5-2.5 2.5z"></path></svg>
                                <span>北海道</span>
                            </p>
                        </div>
                    </div>
                    <div id="desktop-layout">
                        <div id="desktop-widget-column">
                            <div class="desktop-widget text-only">
                                <p id="widget-text-1" class="editable-text">Be fearless in pursuit of happiness</p>
                            </div>
                            <div class="desktop-widget icon-left">
                                <img id="widget-avatar-1" src="https://i.imgur.com/1n3a43H.jpeg" class="editable-image">
                                <span id="widget-text-2" class="editable-text">Dare to be different</span>
                            </div>
                            <div class="desktop-widget icon-right">
                                <span id="widget-text-3" class="editable-text">* Keep your spirit free</span>
                                <img id="widget-avatar-2" src="https://i.imgur.com/5A0tE9a.jpeg" class="editable-image">
                            </div>
                        </div>
                        <div id="desktop-app-container">
                            <div class="desktop-app-icon" onclick="showScreen('chat-list-screen')">
                                <div class="icon-bg-desktop"><img id="icon-img-qq" src="https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg" alt="QQ"></div>
                                <span class="label">QQ</span>
                            </div>
                            <div class="desktop-app-icon" onclick="showScreen('world-book-screen')">
                                <div class="icon-bg-desktop"><img id="icon-img-world-book" src="https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg" alt="世界书"></div>
                                <span class="label">世界书</span>
                            </div>
                            <div class="desktop-app-icon" onclick="showScreen('wallpaper-screen')">
                                <div class="icon-bg-desktop"><img id="icon-img-wallpaper" src="https://i.postimg.cc/T1j03pQr/IMG-6440.jpg" alt="外观设置"></div>
                                <span class="label">外观设置</span>
                            </div>
                            <div class="desktop-app-icon" onclick="openRenderingRulesScreen()">
                                <div class="icon-bg-desktop"><img id="icon-img-renderer" src="https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756312261242_qdqqd_g0eriz.jpeg" alt="渲染器"></div>
                                <span class="label">渲染器</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- 页面 2: 放置新App图标的地方 -->
            <div class="home-screen-page">
                <div id="page-2-app-container">
                    <div class="desktop-app-icon" onclick="openPresetScreen()">
                        <div class="icon-bg-desktop"><img id="icon-img-preset" src="https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758510900942_qdqqd_djw0z2.jpeg" alt="预设"></div>
                        <span class="label">预设</span>
                    </div>
<div class="desktop-app-icon" onclick="showScreen('tutorial-screen')">
    <div class="icon-bg-desktop"><img id="icon-img-tutorial" src="https://i.postimg.cc/d10GjC4g/IMG-7302.jpg" alt="教程"></div>
    <span class="label">教程</span>
</div>
<div class="desktop-app-icon" onclick="openWerewolfLobby('global')">
            <div class="icon-bg-desktop"><img id="icon-img-werewolf" src="https://i.postimg.cc/k401K5g7/IMG-7304.jpg" alt="狼人杀"></div>
            <span class="label">狼人杀</span>
        </div>
<div class="desktop-app-icon" onclick="showScreen('x-social-screen')">
    <div class="icon-bg-desktop"><img id="icon-img-x" src="https://i.postimg.cc/Y9d3BztC/1.png" alt="X"></div>
    <span class="label">X</span>
</div>
                </div>
            </div>
        </div>
    </div>

    <!-- 2. 分页指示器 -->
    <div id="home-screen-pagination">
        <div class="pagination-dot active"></div>
        <div class="pagination-dot"></div>
    </div>

    <!-- 3. 底部 Dock (已为您补全所有文字) -->
    <div id="desktop-dock">
        <div class="desktop-app-icon" onclick="showScreen('api-settings-screen')">
            <div class="icon-bg-desktop"><img id="icon-img-api-settings" src="https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg" alt="API设置"></div>
            <span class="label">API设置</span>
        </div>
        <div class="desktop-app-icon" onclick="showScreen('font-settings-screen')">
            <div class="icon-bg-desktop"><img id="icon-img-font" src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg" alt="字体"></div>
            <span class="label">字体</span>
        </div>
        <div class="desktop-app-icon" onclick="openCharacterSelector()">
            <div class="icon-bg-desktop"><img id="icon-img-char-phone" src="https://i.postimg.cc/pXj9h20L/IMG-7275.jpg" alt="Cphone"></div>
            <span class="label">Cphone</span>
        </div>
        <div class="desktop-app-icon" onclick="showScreen('douban-screen')">
            <div class="icon-bg-desktop"><img id="icon-img-douban" src="https://i.postimg.cc/Pq2xJN1g/IMG-7301.jpg" alt="豆瓣"></div>
            <span class="label">豆瓣</span>
        </div>
    </div>
</div>

<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】Cphone功能的所有HTML屏幕 ▼▼▼ -->

<!-- 1. 角色选择屏幕 -->
<div id="character-selection-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>选择一部手机</span>
        <span style="width: 30px;"></span>
    </div>
    <div id="character-grid" class="list-container">
        <!-- 角色列表将由JS动态生成在这里 -->
    </div>
</div>

<!-- ▼▼▼ 【V3.0 全新版本】请用这整块代码，完整替换旧的 #character-phone-screen ▼▼▼ -->
<div id="character-phone-screen" class="screen">
    
    <!-- 1. Cphone - 主屏幕 (这是它应该在的位置，作为独立的页面) -->
    <div id="char-home-screen" class="char-screen active">
        <div id="char-clock-container">
            <div id="char-main-time">12:00</div>
            <div id="char-main-date">1月1日 星期一</div>
        </div>
        <div id="char-app-grid">
            <div class="app-row">
                <div class="app-icon" onclick="openCharApp('qq')"><div class="icon-bg"><img id="cphone-icon-img-qq" src=""></div><span class="label">QQ</span></div>
                <div class="app-icon" onclick="openCharApp('album')"><div class="icon-bg"><img id="cphone-icon-img-album" src=""></div><span class="label">相册</span></div>
                <div class="app-icon" onclick="openCharApp('browser')"><div class="icon-bg"><img id="cphone-icon-img-browser" src=""></div><span class="label">浏览器</span></div>
                <div class="app-icon" onclick="openCharApp('taobao')"><div class="icon-bg"><img id="cphone-icon-img-taobao" src=""></div><span class="label">淘宝</span></div>
            </div>
            <div class="app-row">
                <div class="app-icon" onclick="openCharApp('memo')"><div class="icon-bg"><img id="cphone-icon-img-memo" src=""></div><span class="label">备忘录</span></div>
                <div class="app-icon" onclick="openCharApp('diary')"><div class="icon-bg"><img id="cphone-icon-img-diary" src=""></div><span class="label">日记</span></div>
                <div class="app-icon" onclick="openCharApp('amap')"><div class="icon-bg"><img id="cphone-icon-img-amap" src=""></div><span class="label">高德地图</span></div>
                <div class="app-icon" onclick="openCharApp('usage')"><div class="icon-bg"><img id="cphone-icon-img-usage" src=""></div><span class="label">App记录</span></div>
            </div>
            <div class="app-row">
                <div class="app-icon" onclick="openCharApp('music')"><div class="icon-bg"><img id="cphone-icon-img-music" src=""></div><span class="label">网易云</span></div>
                <div class="app-icon" onclick="switchToMyPhone()"><div class="icon-bg"><img id="cphone-icon-img-ephone" src=""></div><span class="label">Ephone</span></div>
            </div>
        </div>
    </div>
<div id="char-amap-screen" class="char-screen">
    <div class="header">
        <span class="back-btn" onclick="switchToCharHomeScreen()">‹</span>
        <span>足迹</span>
        <div class="header-actions">
            <span class="action-btn" id="regenerate-char-amap-btn" title="重新生成足迹">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                    <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                </svg>
            </span>
        </div>
    </div>
    <div id="char-amap-list" class="list-container">
        <!-- 足迹列表将由JS动态生成在这里 -->
    </div>
</div>
    <!-- 2. Cphone - QQ App 列表页 -->
    <div id="char-qq-screen" class="char-screen">
        <div class="header">
            <span class="back-btn" onclick="switchToCharHomeScreen()">‹</span>
            <span>QQ</span>
            <div class="header-actions">
                <span class="action-btn" id="regenerate-char-qq-btn" title="重新生成">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                        <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                    </svg>
                </span>
            </div>
        </div>
        <div id="char-chat-list" class="list-container"></div>
    </div>
    
    <!-- 3. Cphone - 模拟对话页面 -->
    <div id="char-qq-conversation-screen" class="char-screen">
        <div class="header">
            <span class="back-btn" id="back-to-char-qq-list-btn">‹</span>
            <span id="char-conversation-partner-name"></span>
            <span style="width: 30px;"></span>
        </div>
        <div id="char-conversation-messages" class="list-container">
        </div>
        <div id="char-conversation-input-area" style="padding: 8px; border-top: 1px solid var(--border-color); display: flex; gap: 8px; background-color: #f7f7f7;">
            <input type="text" id="char-simulated-input" placeholder="这是模拟对话，无法发送消息" disabled style="flex-grow: 1; padding: 10px; border-radius: 6px; border: 1px solid #ddd; background: #eee;">
            <button id="char-simulated-send-btn" style="padding: 0 20px; border: none; background-color: var(--accent-color); color: white; border-radius: 6px; font-weight: 500;">发送</button>
        </div>
    </div>
    
    <!-- 4. Cphone - 相册 App 页面 (这是它应该在的位置，与主屏幕平级) -->
    <div id="char-album-screen" class="char-screen">
        <div class="header">
            <span class="back-btn" onclick="switchToCharHomeScreen()">‹</span>
            <span>TA的相册</span>
            <div class="header-actions">
                <span class="action-btn" id="regenerate-char-album-btn" title="重新生成相册内容">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                        <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                    </svg>
                </span>
            </div>
        </div>
        <div class="list-container">
            <div id="char-album-grid"></div>
        </div>
    </div>

<!-- ▼▼▼ 【全新V2.0 | 支持文章/图片】请用这整块代码，替换旧的 #char-browser-screen ▼▼▼ -->
<div id="char-browser-screen" class="char-screen">
    <div class="header">
        <span class="back-btn" onclick="switchToCharHomeScreen()">‹</span>
        <span>TA的浏览器历史</span>
        <!-- 【核心新增】重新生成按钮 -->
        <div class="header-actions">
            <span class="action-btn" id="regenerate-char-browser-btn" title="重新生成浏览记录">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                    <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                </svg>
            </span>
        </div>
    </div>
    <div id="char-browser-history" class="list-container">
        <!-- 浏览记录将由JS动态生成在这里 -->
    </div>
</div>

<!-- 【【【核心新增：全新的文章查看页面】】】 -->
<div id="char-browser-article-screen" class="char-screen">
    <div class="header">
        <span class="back-btn" onclick="switchToCharScreen('char-browser-screen')">‹</span>
        <span id="char-article-title" style="max-width: 70%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">文章</span>
        <span style="width: 30px;"></span>
    </div>
    <div id="char-article-content" class="list-container" style="padding: 20px; font-size: 16px; line-height: 1.8; color: #333; overflow-y: auto;">
        <!-- 文章或图片内容将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▼▼▼ 【全新V2.0 | 支持钱包】请用这整块代码，完整替换旧的 #char-taobao-screen ▼▼▼ -->
<div id="char-taobao-screen" class="char-screen">
    <div class="header">
        <span class="back-btn" onclick="switchToCharHomeScreen()">‹</span>
        <span>TA的淘宝订单</span>
        <div class="header-actions">
            
            <!-- 【核心新增2】重新生成按钮 -->
            <span class="action-btn" id="regenerate-char-taobao-btn" title="重新生成购买记录">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                    <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                </svg>
            </span>
        </div>
    </div>
    <!-- 购买记录列表 (复用旧的grid，但内容会是动态的) -->
    <div id="char-product-grid" class="list-container"></div>
</div>


<div id="char-memo-screen" class="char-screen">
    <div class="header">
        <span class="back-btn" onclick="switchToCharHomeScreen()">‹</span>
        <span>备忘录</span>
        <div class="header-actions">
            <!-- 【核心新增】重新生成按钮 -->
            <span class="action-btn" id="regenerate-char-memo-btn" title="重新生成备忘录">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                    <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                </svg>
            </span>
            <span class="action-btn" id="add-char-memo-btn">+</span>
        </div>
    </div>
    <!-- 【核心修改】确保列表有内边距，更美观 -->
    <div id="char-memo-list" class="list-container" style="padding: 10px;"></div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 在 #char-memo-screen 的 div 之后，粘贴这个全新的备忘录详情屏幕 ▼▼▼ -->
<div id="char-memo-detail-screen" class="char-screen">
    <div class="header">
        <!-- 这个返回按钮会带我们回到备忘录列表 -->
        <span class="back-btn" id="char-memo-detail-back-btn">‹</span>
        <!-- 这里会动态显示备忘录的标题 -->
        <span id="char-memo-detail-title"></span>
        <!-- 右上角的占位符，保持标题居中 -->
        <span style="width: 80px;"></span>
    </div>
    <!-- 这个容器将用来显示备忘录的完整内容 -->
    <div class="form-container" style="padding: 0;">
        <textarea id="char-memo-detail-content" readonly></textarea>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 用这整块新代码替换旧的 #char-diary-screen ▼▼▼ -->
<div id="char-diary-screen" class="char-screen">
    <div class="header">
        <span class="back-btn" onclick="switchToCharHomeScreen()">‹</span>
        <span>日记</span>
        <div class="header-actions">
            <!-- 【核心新增】重新生成按钮 -->
            <span class="action-btn" id="regenerate-char-diary-btn" title="重新生成日记本">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                    <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                </svg>
            </span>
            <!-- 【核心修改】这个“+”号现在会触发AI写一篇新日记 -->
            <span class="action-btn" id="add-char-diary-btn">+</span>
        </div>
    </div>
    <div id="char-diary-list" class="list-container"></div>
</div>

<!-- 【【【核心新增：全新的日记详情屏幕】】】 -->
<div id="char-diary-detail-screen" class="char-screen">
<div class="header">
    <span class="back-btn" id="char-diary-detail-back-btn">‹ </span>
    <span id="char-diary-detail-title"></span>
    <!-- 【核心新增】在这里添加收藏按钮 -->
    <div class="header-actions">
        <span class="action-btn" id="favorite-diary-btn" title="收藏">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
            </svg>
        </span>
    </div>
</div>
    <div id="char-diary-detail-content-wrapper" class="list-container">
        <div id="char-diary-detail-content">
            <!-- 日记内容将由JS动态生成在这里 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 【请用这个V2.0版本】完整替换旧的 id="char-usage-screen" 的 div ▼▼▼ -->
<div id="char-usage-screen" class="char-screen">
    <div class="header">
        <span class="back-btn" onclick="switchToCharHomeScreen()">‹</span>
        <span>App使用记录</span>
        <div class="header-actions">
            <!-- 【核心新增】重新生成按钮 -->
            <span class="action-btn" id="regenerate-char-usage-btn" title="重新生成记录">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                    <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                </svg>
            </span>
        </div>
    </div>
    <div id="char-usage-list" class="list-container">
        <!-- App使用记录将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

    <!-- 模拟聊天记录的弹窗 (保持不变) -->
    <div id="char-qq-transcript-modal" class="modal">
        <div class="modal-content" style="height: 80%;">
            <div class="modal-header">
                <span id="transcript-modal-char-name"></span>
            </div>
            <div class="modal-body" id="transcript-modal-body" style="background-color: #f0f2f5; padding: 15px; display: flex; flex-direction: column; gap: 15px;">
            </div>
            <div class="modal-footer">
                <button class="save" id="close-transcript-modal-btn" style="width:100%;">关闭</button>
            </div>
        </div>
    </div>
<!-- ▼▼▼ 步骤 1-2：将这整块全新的“网易云音乐”屏幕和播放器，完整粘贴到 id="character-phone-screen" 的 div 内部末尾 ▼▼▼ -->

<!-- 1. 网易云音乐App主屏幕 -->
<div id="char-music-screen" class="char-screen">
    <div class="header">
        <span class="back-btn" onclick="switchToCharHomeScreen()">‹</span>
        <span>TA的歌单</span>
        <div class="header-actions">
            <span class="action-btn" id="regenerate-char-music-btn" title="重新生成歌单">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                    <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                </svg>
            </span>
        </div>
    </div>
    <div id="char-music-list" class="list-container">
        <!-- 歌曲列表将由JS动态生成在这里 -->
    </div>
</div>

<!-- ▼▼▼ 请用这整块【全新 V3.0 | 仿黑胶唱片机UI】的代码，替换旧的 char-music-player-modal ▼▼▼ -->
<div id="char-music-player-modal" class="modal">
    <div class="modal-content">
        <!-- 主内容区 -->
        <div class="char-player-body">
            <!-- 歌曲信息 -->
            <div class="char-player-song-info">
                <p id="char-music-player-title">歌曲名称</p>
                <p id="char-music-artist">歌手</p>
            </div>

            <!-- 专辑封面 (黑胶唱片效果) -->
            <div id="char-vinyl-container">
                <img id="char-music-cover" src="">
            </div>
            
            <!-- 【核心修改】将音符占位符替换为真正的歌词容器 -->
            <div id="char-music-lyrics">
                <!-- 歌词将由JS动态生成在这里 -->
            </div>

            <!-- 底部控制栏 -->
            <div class="char-player-footer">
                <div class="char-player-progress-bar-container">
                    <span id="char-music-current-time" class="time-display">0:00</span>
                    <div id="char-music-progress-bar" class="char-player-progress-bar">
                        <div id="char-music-progress-fill"></div>
                    </div>
                    <span id="char-music-total-time" class="time-display">0:00</span>
                </div>

                <div class="char-player-controls">
                    <button id="char-music-prev-btn" class="control-btn">
                        <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"></path></svg>
                    </button>
                    <button id="char-music-play-pause-btn" class="control-btn play">
                        <svg viewBox="0 0 24 24" width="32" height="32" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg>
                    </button>
                    <button id="char-music-next-btn" class="control-btn">
                         <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M16 6h2v12h-2zm-3.5 6l-8.5 6V6z"></path></svg>
                    </button>
                     <button id="char-music-mode-btn" class="control-btn mode">顺序</button>
                </div>
            </div>
        </div>
        <!-- 关闭按钮被移到右上角 -->
        <button id="close-char-music-player-btn" class="char-player-close-btn">×</button>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

        <!-- ▼▼▼ 【请用这个新版本】完整替换旧的 world-book-screen ▼▼▼ -->
        <div id="world-book-screen" class="screen">
            <div class="header">
    <!-- 将所有需要靠左的按钮，用一个新的 div 包裹起来 -->
    <div class="header-left-actions">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span class="action-btn" id="import-world-book-btn" title="导入世界书">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
        </span>
        <span class="action-btn" id="export-world-book-btn" title="导出世界书">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
        </span>
    </div>
                <span>世界书</span>
                <div class="header-actions">
                    <!-- 【核心修改1】将文字按钮替换为SVG图标 -->
                    <span class="action-btn" id="manage-world-book-categories-btn" title="管理分类">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <line x1="16" y1="13" x2="8" y2="13"></line>
                            <line x1="16" y1="17" x2="8" y2="17"></line>
                            <polyline points="10 9 9 9 8 9"></polyline>
                        </svg>
                    </span>
                    <span class="action-btn" id="add-world-book-btn">+</span>
                </div>
            </div>
            <!-- 【核心修改2】全新的页签和内容区结构 -->
            <div id="world-book-tabs"></div>
            <div id="world-book-content-container"></div>
        </div>
        <!-- ▼▼▼ 【请将这个缺失的代码块】粘贴到 id="world-book-screen" 的 div 之后 ▼▼▼ -->
        <div id="world-book-editor-screen" class="screen">
            <div class="header">
                <span class="back-btn" onclick="showScreen('world-book-screen')">‹</span>
                <span id="world-book-editor-title">编辑世界书</span>
                <span class="save-btn" id="save-world-book-btn">保存</span>
            </div>
            <div class="form-container">
                <div class="form-group">
                    <label for="world-book-name-input">书名</label>
                    <input type="text" id="world-book-name-input" placeholder="请输入世界书的名称...">
                </div>
                <div class="form-group">
                    <label for="world-book-category-select">分类</label>
                    <select id="world-book-category-select"></select>
                </div>
                <!-- 编辑器区域 -->
                <div class="form-group" style="flex-grow: 1; display: flex; flex-direction: column;">
                    <label>内容条目</label>
                    <!-- 这个容器将用来动态装载所有可编辑的条目块 -->
                    <div id="world-book-entries-container" style="display: flex; flex-direction: column; gap: 15px; overflow-y: auto; padding: 5px; flex-grow: 1;">
                        <!-- JS 会在这里动态生成内容 -->
                    </div>
                </div>
                <!-- 添加新条目的按钮 -->
                <button id="add-world-book-entry-btn" class="form-button form-button-secondary"> [+] 添加新条目 </button>
            </div>
        </div>
        <!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是“预设”App的所有HTML屏幕，请粘贴到 world-book-editor-screen 之后 ▼▼▼ -->
<div id="preset-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>预设</span>
        <div class="header-actions">
 <span class="action-btn" id="import-preset-btn" title="导入预设文件">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                </span>
            <span class="action-btn" id="manage-preset-categories-btn" title="管理分类">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                    <polyline points="14 2 14 8 20 8"></polyline>
                    <line x1="16" y1="13" x2="8" y2="13"></line>
                    <line x1="16" y1="17" x2="8" y2="17"></line>
                </svg>
            </span>
            <span class="action-btn" id="add-preset-btn">+</span>
        </div>
    </div>
    <div id="preset-tabs"></div>
    <div id="preset-content-container"></div>
</div>
<!-- ▼▼▼ 【全新】这是教程页面，请粘贴到其他 .screen 的div旁边 ▼▼▼ -->
<div id="tutorial-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>教程</span>
        <span style="width: 30px;"></span> <!-- 占位符，保持标题居中 -->
    </div>
    <div class="list-container" style="padding: 0; overflow: hidden;">
        <!-- 这里会嵌入你的教程HTML文件 -->
        <iframe id="tutorial-iframe" src="tutorial.html" style="width: 100%; height: 100%; border: none;"></iframe>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<div id="preset-editor-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('preset-screen')">‹</span>
        <span id="preset-editor-title">编辑预设</span>
        <span class="save-btn" id="save-preset-btn">保存</span>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label for="preset-name-input">预设名称</label>
            <input type="text" id="preset-name-input" placeholder="请输入预设的名称...">
        </div>
        <div class="form-group">
            <label for="preset-category-select">分类</label>
            <select id="preset-category-select"></select>
        </div>
        <div class="form-group" style="flex-grow: 1; display: flex; flex-direction: column;">
            <label>内容条目</label>
            <div id="preset-entries-container" style="display: flex; flex-direction: column; gap: 15px; overflow-y: auto; padding: 5px; flex-grow: 1;">
            </div>
        </div>
        <button type="button" id="add-preset-entry-btn" class="form-button form-button-secondary"> [+] 添加新条目 </button>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
        <!-- ▼▼▼ 用下面这段代码，完整替换掉你原来的 id="api-settings-screen" 的 div ▼▼▼ -->
        <div id="api-settings-screen" class="screen">
            <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
                <span>API 设置</span>
                <span style="width: 30px;"></span>
            </div>
            <div class="form-container">
                <!-- 【【【全新：API预设管理】】】 -->
                <h3 style="margin-top:0; border-bottom: 1px solid #eee; padding-bottom: 10px;">API 预设管理</h3>
                <div class="form-group">
                    <label for="api-preset-select">选择或切换预设</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <select id="api-preset-select" style="flex-grow: 1;"></select>
                        <button id="save-api-preset-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">保存</button>
                        <button id="delete-api-preset-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px; background-color: #ffebee; color: #d32f2f; border-color: #ffcdd2;">删除</button>
                    </div>
                </div>
                <hr style="margin: 30px 0; opacity: 0.3;">
                <!-- 主API设置 -->
                <h3 style="margin-top:0; border-bottom: 1px solid #eee; padding-bottom: 10px;">主API设置 (用于聊天)</h3>
                <p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;"> 提示: 若要使用“发送图片”功能, 请务必选择支持Vision(视觉)的模型, 如<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4o</code>或<code
                        style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4-vision-preview</code>。 </p>
                <div class="form-group">
                    <label for="proxy-url">反代地址 (不需要添加/v1噢~)</label>
                    <input type="text" id="proxy-url" placeholder="例如: https://api.openai.com">
                </div>
                <div class="form-group">
                    <label for="api-key">密钥 (API Key)</label>
                    <input type="password" id="api-key" placeholder="sk-...">
                </div>
                <div class="form-group">
                    <label for="model-select">模型</label>
                    <select id="model-select"></select>
                </div>
                <button class="form-button" id="fetch-models-btn">拉取主模型</button>
                <!-- 副API设置 -->
                <hr style="margin: 30px 0; opacity: 0.3;">
                <h3 style="border-bottom: 1px solid #eee; padding-bottom: 10px;">副API设置 (用于总结长期记忆)</h3>
                <p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;"> 您可以在此配置一个独立的、可能成本更低的API，专门用于后台的长期记忆总结任务，以节省主API的费用。如果留空，将默认使用主API进行总结。 </p>
                <div class="form-group">
                    <label for="secondary-proxy-url">副反代地址</label>
                    <input type="text" id="secondary-proxy-url" placeholder="例如: https://api.groq.com/openai">
                </div>
                <div class="form-group">
                    <label for="secondary-api-key">副密钥</label>
                    <input type="password" id="secondary-api-key" placeholder="gsk_...">
                </div>
                <div class="form-group">
                    <label for="secondary-model-select">副模型</label>
                    <select id="secondary-model-select"></select>
                </div>
                <button class="form-button form-button-secondary" id="fetch-secondary-models-btn">拉取副模型</button>
<div class="form-group">
    <label for="api-temperature-slider">API 温度 (Temperature) <span id="api-temperature-value">0.8</span></label>
    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
        控制AI回复的随机性和创造性。值越高，回复越随机；值越低，回复越确定。建议范围 0.7-1.0。
    </p>
    <input type="range" id="api-temperature-slider" min="0" max="2" step="0.1" value="0.8" style="width: 100%; margin-top: 8px;">
</div>
                <!-- 后台活动设置 -->
                <hr style="margin: 30px 0; opacity: 0.3;">
                <h3 style="border-bottom: 1px solid #eee; padding-bottom: 10px;">后台活动设置</h3>
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                    <label for="background-activity-switch" style="margin-bottom: 0;"> 启用后台角色活动 <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;"> 警告：此功能会显著增加API调用和费用！ </p>
                    </label>
                    <input type="checkbox" id="background-activity-switch" style="width: auto; height: 20px;">
                </div>
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                    <label for="background-interval-input" style="margin-bottom: 0;"> 后台活动检测间隔 (秒) <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;"> 建议值 60-300。值越大，费用越低，但角色反应越慢。 </p>
                    </label>
                    <input type="number" id="background-interval-input" min="30" value="60" style="width: 80px; text-align: center;">
                </div>
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                    <label for="block-cooldown-input" style="margin-bottom: 0;"> AI被拉黑后冷静期 (小时) <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;"> 被拉黑超过这个时间后，AI才有几率重新申请好友。 </p>
                    </label>
                    <input type="number" id="block-cooldown-input" min="0.1" step="0.1" value="1" style="width: 80px; text-align: center;">
                </div>
<!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<hr style="margin: 30px 0; opacity: 0.3;">
<h3 style="border-bottom: 1px solid #eee; padding-bottom: 10px;">语音消息设置 (Minimax TTS)</h3>
<p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;">
    在 AI 回复的文字前加上 <code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">[V]</code> 前缀，即可让该条消息自动渲染为可播放的语音。
</p>
<div class="form-group">
    <label for="minimax-group-id">Minimax Group ID</label>
    <input type="text" id="minimax-group-id" placeholder="在此输入你的 Group ID">
</div>
<div class="form-group">
    <label for="minimax-api-key">Minimax API Key</label>
    <input type="password" id="minimax-api-key" placeholder="在此输入你的 API Key">
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
<hr style="margin: 30px 0; opacity: 0.3;">
                <h3 style="border-bottom: 1px solid #eee; padding-bottom: 10px;">性能与显示设置</h3>
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                    <label for="chat-list-render-window-input" style="margin-bottom: 0;">
                        聊天列表每次加载条数
                        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                            控制主页聊天列表下拉时每次加载会话的数量。默认30。
                        </p>
                    </label>
                    <input type="number" id="chat-list-render-window-input" min="10" value="30" style="width: 80px; text-align: center;">
                </div>
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                    <label for="chat-render-window-input" style="margin-bottom: 0;">
                        聊天界面初始加载条数
                        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                            打开聊天时默认显示的最近消息数量。值越大，初次加载越慢。
                        </p>
                    </label>
                    <input type="number" id="chat-render-window-input" min="10" value="50" style="width: 80px; text-align: center;">
                </div>
                <hr style="margin: 30px 0; opacity: 0.3;">
                <h3 style="border-bottom: 1px solid #eee; padding-bottom: 10px;">生图功能设置</h3>
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                    <label for="enable-ai-drawing-switch" style="margin-bottom: 0;">
                        启用AI生图功能
                        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                            关闭后，所有需要AI生成的图片（动态、头像等）都将显示为占位图，以节省流量和API费用。
                        </p>
                    </label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="enable-ai-drawing-switch">
                        <span class="slider"></span>
                    </label>
                </div>
<!-- ▼▼▼ 在这里粘贴下面的新按钮代码 ▼▼▼ -->
<hr style="margin: 30px 0; opacity: 0.3;">
<h3 style="border-bottom: 1px solid #eee; padding-bottom: 10px;">存储空间优化</h3>
<button class="form-button form-button-secondary" id="compress-images-btn" style="background-color: #e8f5e9; color: #2e7d32; border-color: #c8e6c9;">
    一键压缩本地图片
</button>
<p style="font-size: 12px; color: #8a8a8a; margin-top: 8px; line-height: 1.5;">
    此功能会将您所有本地上传的图片（如头像、表情包、聊天图片、头像框、组件图等）压缩为JPEG格式，以大幅减小数据体积。
    <br><strong style="color: #ff3b30;">警告：这是一个有损压缩且不可逆的操作，会轻微降低图片质量。建议操作前先备份数据。</strong>
</p>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
                <!-- 保存与导入导出 -->
                <hr style="margin: 30px 0; opacity: 0.3;">
                <button class="form-button" id="save-api-settings-btn" style="margin-top: 20px;">保存所有设置</button>
                <button class="form-button" id="export-data-btn">导出数据</button>
                <button class="form-button" id="import-btn">导入备份文件</button>
<!-- ▼▼▼ 在这里粘贴下面的新按钮代码 ▼▼▼ -->
<button class="form-button form-button-secondary" id="cleanup-data-btn" style="background-color: #ffebee; color: #c62828; border-color: #ef9a9a; margin-top: 10px;">清理冗余数据</button>
<button class="form-button form-button-secondary" id="delete-world-books-btn" style="background-color: #ffebee; color: #c62828; border-color: #ef9a9a; margin-top: 10px;">删除世界书</button>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
<button class="form-button form-button-secondary" id="clear-specific-data-btn" style="background-color: #ffcdd2; color: #b71c1c; border-color: #ef9a9a; margin-top: 10px;">高级数据清理</button>
<button class="form-button form-button-secondary" id="check-and-fix-data-btn" style="background-color: #e3f2fd; color: #0d47a1; border-color: #bbdefb; margin-top: 10px;">数据检查与修复</button>
                <input id="import-data-input" type="file" accept="application/json" hidden>

            </div>
        </div>
        <!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- 【【【全新 V2.0 | 支持全选】：高级数据清理向导模态框】】】 -->
<div id="data-clear-wizard-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <!-- 步骤 1: 选择角色 -->
        <div id="data-clear-step-1" class="wizard-step">
            <div class="modal-header">
                <span>第一步：选择要清理的角色</span>
                <!-- 核心新增：全选复选框 -->
                <label>
                    <input type="checkbox" id="select-all-chars-for-clear"> 全选
                </label>
            </div>
            <div class="modal-body" id="data-clear-char-list" style="padding: 0;">
                <!-- 角色列表将由JS动态生成 -->
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-clear-wizard-btn-step1">取消</button>
                <button class="save" id="go-to-clear-step2-btn">下一步</button>
            </div>
        </div>
        <!-- 步骤 2: 选择数据类型 -->
        <div id="data-clear-step-2" class="wizard-step" style="display: none;">
            <div class="modal-header">
                <span>第二步：选择要清理的数据类型</span>
                <!-- 核心新增：全选复选框 -->
                <label>
                    <input type="checkbox" id="select-all-types-for-clear"> 全选
                </label>
            </div>
            <div class="modal-body" id="data-clear-type-list" style="padding: 0;">
                <!-- 数据类型列表将由JS动态生成 -->
            </div>
            <div class="modal-footer">
                <button class="form-button-secondary" id="back-to-clear-step1-btn" style="width: 30%; margin:0;">上一步</button>
                <button class="cancel" id="cancel-clear-wizard-btn-step2" style="width: 30%; margin:0;">取消</button>
                <button class="save btn-danger" id="confirm-final-clear-btn" style="width: 30%; margin:0;">确认清理</button>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
        <!-- ▼▼▼ 用下面这段代码，完整替换掉你原来的 chat-list-screen ▼▼▼ -->
        <div id="chat-list-screen" class="screen">
            <!-- 主头部 (只在消息列表显示) -->
            <div class="header" id="main-chat-list-header">
                <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
                <span id="chat-list-title">消息</span>
                <div class="header-actions">
                    <span class="action-btn" id="add-group-chat-btn" title="创建群聊"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M17.5 17.5C19.1569 17.5 20.5 16.1569 20.5 14.5C20.5 12.8431 19.1569 11.5 17.5 11.5C15.8431 11.5 14.5 12.8431 14.5 14.5C14.5 16.1569 15.8431 17.5 17.5 17.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                            <path d="M21 21L19 19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                            <path d="M8.5 11.5C10.1569 11.5 11.5 10.1569 11.5 8.5C11.5 6.84315 10.1569 5.5 8.5 5.5C6.84315 5.5 5.5 6.84315 5.5 8.5C5.5 10.1569 6.84315 11.5 8.5 11.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                            <path d="M12.5 14.5H4.5C3.39543 14.5 2.5 15.3954 2.5 16.5V18.5H12.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                        </svg></span>
                    <span class="action-btn" id="add-chat-btn">+</span>
                </div>
            </div>
            <!-- 消息列表视图 -->
            <div id="messages-view" class="chat-list-view active">
                <div id="chat-list">
                    <!-- JS会在这里生成聊天列表 -->
                </div>
            </div>
            <!-- 动态界面视图 -->
            <div id="qzone-screen" class="chat-list-view">
                <div class="qzone-header">
                    <span class="back-btn" id="qzone-back-btn">‹</span> <!-- 这个按钮现在只负责从动态返回 -->
                    <span>好友动态</span>
    <div class="header-actions">
        <span class="action-btn" id="qzone-more-actions-btn" title="更多操作">…</span>
    </div>
                </div>
                <div class="qzone-content">
                    <div class="qzone-profile-header">
                        <div id="qzone-banner-container" class="qzone-banner-container">
                            <img id="qzone-banner-img" src="https://files.catbox.moe/r5heyt.gif" alt="背景">
                            <input type="file" id="qzone-banner-input" accept="image/*" hidden>
                        </div>
                        <div class="qzone-user-info">
                            <div id="qzone-avatar-container" class="qzone-avatar-container">
                                <img id="qzone-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" alt="头像">
                                <input type="file" id="qzone-avatar-input" accept="image/*" hidden>
                            </div>
                            <span id="qzone-nickname">{{user}}</span>
                        </div>
                    </div>
                    <div class="qzone-actions-bar">
                        <div class="action-item" id="create-shuoshuo-btn"><span>说说</span></div>
                        <div class="action-item" id="create-post-btn"><span>动态</span></div>
                        <div class="action-item" id="open-album-btn"><span>相册</span></div>
                    </div>
                    <div id="qzone-posts-list"></div>
                </div>
            </div>
            <!-- 收藏界面视图 -->
            <div id="favorites-view" class="chat-list-view">
                <div class="header">
                    <span class="back-btn" id="favorites-back-btn">‹</span>
                    <span>我的收藏</span>
                    <!-- 新增的编辑按钮 -->
                    <span class="action-btn" id="favorites-edit-btn">编辑</span>
                </div>
                <!-- 【新增】搜索栏容器 -->
                <div class="search-bar-container">
                    <input type="search" id="favorites-search-input" placeholder="搜索收藏的标题、内容或作者...">
                    <button id="favorites-search-clear-btn" class="search-clear-btn" style="display: none;">×</button>
                </div>
                <div id="favorites-list" class="list-container">
                    <!-- 收藏内容将由JS动态生成在这里 -->
                </div>
                <!-- 新增：收藏页底部操作栏 -->
                <div id="favorites-action-bar" style="display: none;">
                    <button id="favorites-delete-selected-btn" class="action-bar-btn">删除 (0)</button>
                </div>
            </div>
            <!-- ▼▼▼ 【全新】回忆录界面视图 ▼▼▼ -->
            <div id="memories-view" class="chat-list-view">
                <div class="header">
                    <span class="back-btn" id="memories-back-btn">‹</span>
                    <span>我们的回忆</span>
                    <span class="action-btn" id="add-countdown-btn">+</span>
                </div>
                <div id="memories-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
                    <!-- 回忆卡片将由JS动态生成在这里 -->
                </div>
            </div>
            <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
            <div id="npc-list-view" class="chat-list-view">
                <div class="header">
                    <span class="back-btn" id="npc-list-back-btn">‹</span>
                    <span>NPC 列表</span>
                    <div class="header-actions">
                        <span class="action-btn" id="add-npc-btn">+</span>
                    </div>
                </div>
                <div id="npc-list" class="list-container" style="padding: 0;">
                    <!-- NPC列表将由JS动态生成在这里 -->
                </div>
            </div>
            <!-- 底部导航栏 -->
            <div id="chat-list-bottom-nav">
                <div class="nav-item active" data-view="messages-view">
                    <span>消息</span>
                </div>
                <div class="nav-item" data-view="qzone-screen">
                    <span>动态</span>
                </div>
                <!-- ▼▼▼ 在“动态”和“收藏”之间，加入这个新页签 ▼▼▼ -->
                <div class="nav-item" data-view="memories-view">
                    <span>回忆</span>
                </div>
                <!-- ▲▲▲ 添加结束 ▲▲▲ -->
                <div class="nav-item" data-view="favorites-view">
                    <span>收藏</span>
                </div>
                <div class="nav-item" data-view="npc-list-view">
                    <span>NPC</span>
                </div>
            </div>
        </div>
        <!-- ▲▲▲ 替换区域结束 ▲▲▲ -->
        <!-- ▼▼▼ 请将这段新的 HTML 粘贴到 id="chat-list-screen" 的 div 之后 ▼▼▼ -->
        <div id="album-screen" class="screen">
            <!-- 1. 页面头部，包含返回按钮和标题 -->
            <div class="header">
                <span class="back-btn" id="album-back-btn">‹</span>
                <span>我的相册</span>
                <span class="action-btn" id="create-album-btn-page">+</span>
            </div>
            <!-- 2. 页面内容容器 -->
            <div class="list-container">
                <div id="album-grid-page">
                    <!-- 相册列表将由 JS 动态生成在这里 -->
                </div>
            </div>
        </div>
        <!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->
        <!-- ▼▼▼ 请将这段新的 HTML 粘贴到 id="album-screen" 的 div 之后 ▼▼▼ -->
        <div id="album-photos-screen" class="screen">
            <!-- 1. 页面头部 -->
            <div class="header">
                <span class="back-btn" id="album-photos-back-btn">‹</span>
                <span id="album-photos-title">相册名称</span>
                <span class="action-btn" id="album-upload-photo-btn">上传</span>
            </div>
            <!-- 2. 页面内容容器 -->
            <div class="list-container">
                <div id="photos-grid-page">
                    <!-- 照片列表将由 JS 动态生成在这里 -->
                </div>
                <!-- ▼▼▼ 请将这段新的 HTML 粘贴到所有模态框的末尾 ▼▼▼ -->
                <div id="photo-viewer-modal" class="modal">
                    <!-- 1. 关闭按钮 -->
                    <button id="photo-viewer-close-btn">×</button>
                    <!-- 2. 上一张照片按钮 -->
                    <button id="photo-viewer-prev-btn" class="nav-arrow">‹</button>
                    <!-- 3. 图片容器 -->
                    <div class="photo-viewer-content">
                        <img id="photo-viewer-image" src="" alt="全屏照片预览">
                    </div>
                    <!-- 4. 下一张照片按钮 -->
                    <button id="photo-viewer-next-btn" class="nav-arrow">›</button>
                </div>
                <!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->
            </div>
        </div>
        <!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->
<div id="npc-editor-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span id="npc-editor-title">添加 NPC</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>NPC 头像</label>
                <div class="avatar-upload">
                    <img id="npc-avatar-preview" src="https://i.postimg.cc/VkQfgzGJ/1.jpg">
                    <button onclick="document.getElementById('npc-avatar-input').click()">上传头像</button>
                    <input type="file" id="npc-avatar-input" accept="image/*" hidden>
                </div>
            </div>
            <div class="form-group">
                <label for="npc-name-input">NPC 昵称</label>
                <input type="text" id="npc-name-input" placeholder="输入NPC的常用名">
            </div>
            <div class="form-group">
                <label for="npc-persona-input">NPC 人设</label>
                <textarea id="npc-persona-input" rows="4" placeholder="详细描述这个NPC的性格、背景、说话方式等..."></textarea>
            </div>
<!-- ▼▼▼ 在NPC人设输入框之后，粘贴这段新代码 ▼▼▼ -->
                <hr style="opacity: 0.2;">
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                    <label for="npc-background-activity-switch" style="margin-bottom: 0;">
                        启用独立后台活动
                        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                            允许该NPC在后台独立发表动态评论。需同时开启API设置中的总开关。
                        </p>
                    </label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="npc-background-activity-switch">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="form-group">
                    <label for="npc-action-cooldown-input">
                        独立行动冷却 (分钟)
                        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                            该NPC在后台主动行动的最小间隔。
                        </p>
                    </label>
                    <input type="number" id="npc-action-cooldown-input" min="1" value="15" style="width: 80px; text-align: center;">
                </div>
<!-- ▲▲▲ 新增代码粘贴结束 ▲▲▲ -->
            <div class="form-group">
                <label>关联的角色 (NPC会去评论这些角色的动态)</label>
                <div id="npc-association-list" style="max-height: 150px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px;">
                    <!-- 关联角色多选框将由JS动态生成 -->
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-npc-editor-btn">取消</button>
            <button class="save" id="save-npc-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 步骤 1：将这个【全新的模态框】粘贴到 body 内其他模态框的旁边 ▼▼▼ -->
<div id="clear-posts-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>选择清空范围</span>
        </div>
        <div class="modal-body" id="clear-posts-list" style="padding: 0;">
            <!-- 清空选项将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-clear-posts-btn">取消</button>
            <!-- 添加了 btn-danger 类，让按钮显示为红色以示警告 -->
            <button class="save btn-danger" id="confirm-clear-posts-btn">确认清空</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
        <!-- ▼▼▼ 粘贴到 #album-photos-screen 的 div 之后 ▼▼▼ -->
        <input type="file" id="album-photo-input" accept="image/*" multiple hidden>
        <div id="chat-interface-screen" class="screen">
            <!-- ▼▼▼ 【全新】请将这个五子棋容器粘贴到聊天界面(chat-interface-screen)的【最顶部】 ▼▼▼ -->
            <div id="gomoku-overlay">
                <div id="gomoku-content-wrapper">
                    <canvas id="gomoku-board"></canvas>
                    <div id="gomoku-controls">
                        <button id="close-gomoku-btn">收起棋盘</button>
                    </div>
                </div>
            </div>
            <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<div id="reading-overlay">
    <!-- 这是全新的、用于恢复窗口的小按钮 -->
    <div id="reading-restore-btn" style="display: none;">📖</div>

    <!-- 这是可拖动的主窗口 -->
    <div id="reading-window">
        <div class="reading-header">
            <span id="reading-title">未选择书籍</span>
<div class="reading-controls">
    <button id="minimize-reading-btn" title="最小化" style="font-size: 20px; line-height: 1;">
        <svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round">
            <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
    </button>
    <button id="open-reading-library-btn" title="打开书库" style="font-size: 22px; line-height: 1;">
    <svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
        <line x1="3" y1="12" x2="21" y2="12"></line>
        <line x1="3" y1="6" x2="21" y2="6"></line>
        <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
</button>
    <button id="close-reading-btn" title="关闭">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
    </button>
</div>
        </div>
        <div id="reading-content">
            <p>点击“导入”按钮，<br>从本地.txt文件或网络URL加载书籍内容。</p>
        </div>
        <div class="reading-footer">
            <button id="prev-page-btn">上一页</button>
            <span id="page-indicator">0 / 0</span>
            <button id="next-page-btn">下一页</button>
        </div>
    </div>
</div>
<!-- 这是一个隐藏的文件输入框，用于本地上传 -->
<input type="file" id="book-upload-input" accept=".txt, text/plain" hidden>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
            <div class="header">
                <div class="default-controls">
                    <span class="back-btn" id="back-to-list-btn">‹</span>
                    <div id="global-lyrics-bar"></div>

                    <div id="chat-header-title-wrapper">
                        <span id="chat-header-title">聊天对象</span>
                        <div id="chat-header-status">
                            <span class="status-dot"></span>
                            <span class="status-text">在线</span>
                        </div>
                    </div>
                    <div class="header-actions">
                        <!-- ▼▼▼ 请用这整块代码，替换你现有的 id="open-memory-screen-btn" 的 span 标签 ▼▼▼ -->
                        <span class="action-btn" id="open-memory-screen-btn" title="长期记忆">
                            <!-- 【核心修改】使用SVG图标替换原来的图片 -->
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M16 3H5C3.89543 3 3 3.89543 3 5V19C3 20.1046 3.89543 21 5 21H16" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                                <path d="M12 6L9 9L12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                                <path d="M21 5V19C21 20.1046 20.1046 21 19 21H16" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                            </svg>
                        </span>
                        <!-- ▲▲▲ 替换结束 ▲▲▲ -->
                        <span class="action-btn" id="listen-together-btn" title="一起听"><img src="https://i.postimg.cc/dV8sdNcx/210-20250618115221.png" alt="一起听"></span>
                        <span class="action-btn" id="chat-settings-btn" title="聊天设置"><img src="https://i.postimg.cc/bvPq64cv/CCA834-BA-5-A90-408-D-94-FA-7-EE156-B6-A765.png" alt="设置"></span>
                    </div>
                </div>
                <!-- ▼▼▼ 请用这整块代码替换你原来的 .selection-controls div ▼▼▼ -->
                <div class="selection-controls">
                    <span id="selection-cancel-btn">取消</span>
                    <span id="selection-count"></span>
                    <div class="header-actions">
                        <span id="selection-screenshot-btn" class="action-btn">长截图</span>
                        <span id="selection-favorite-btn" class="action-btn">收藏</span>
                        <span id="selection-share-btn" class="action-btn">分享</span>
                        <!-- 【核心修改1】旧按钮重命名，功能不变 -->
                        <span id="selection-soft-delete-btn" class="action-btn">删除(通知AI)</span>
                        <!-- 【核心修改2】新增一个红色的、更强力的删除按钮 -->
                        <span id="selection-erase-btn" class="action-btn" style="color: #ff3b30;">彻底删除</span>
                    </div>
                </div>
                <!-- ▲▲▲ 替换结束 ▲▲▲ -->
            </div>
            <div id="chat-messages">
                <div id="typing-indicator">对方正在输入...</div>
            </div>
            <div id="chat-input-area">
                <div id="chat-at-mention-popup" class="at-mention-popup"></div>
                <div id="reply-preview-bar">
                    <div class="reply-preview-content">
                        <div class="sender">回复 xxx:</div>
                        <div class="text">被引用的消息内容...</div>
                    </div>
                    <span id="cancel-reply-btn">×</span>
                </div>
                <div id="chat-input-actions-top">
                    <button id="open-sticker-panel-btn" class="chat-action-icon-btn action-button" title="表情面板">+</button>
                    <button id="send-photo-btn" class="chat-action-icon-btn action-button" title="发送照片"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                            <circle cx="12" cy="13" r="4"></circle>
                        </svg></button>
                    <button id="upload-image-btn" class="chat-action-icon-btn action-button" title="上传图片">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                            <path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                            <path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                        </svg>
                    </button>
                    <button id="transfer-btn" class="chat-action-icon-btn action-button" title="转账">￥</button>
                    <button id="voice-message-btn" class="chat-action-icon-btn action-button" title="发送语音"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                            <path d="M12 19v4"></path>
                            <path d="M8 23h8"></path>
                        </svg></button>
                    <button id="send-waimai-request-btn" class="chat-action-icon-btn action-button" title="发起外卖请求"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path>
                            <line x1="3" y1="6" x2="21" y2="6"></line>
                            <path d="M16 10a4 4 0 0 1-8 0"></path>
                        </svg></button>
                    <button id="video-call-btn" class="chat-action-icon-btn action-button" title="视频通话"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="23 7 16 12 23 17 23 7"></polygon>
                            <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
                        </svg></button>
                    <button id="group-video-call-btn" class="chat-action-icon-btn action-button" title="群视频通话"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg></button>
                    <button id="send-poll-btn" class="chat-action-icon-btn action-button" title="发起投票"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M8 6h10"></path>
                            <path d="M6 6h.01"></path>
                            <path d="M8 12h10"></path>
                            <path d="M6 12h.01"></path>
                            <path d="M8 18h10"></path>
                            <path d="M6 18h.01"></path>
                        </svg></button>
                    <button id="share-link-btn" class="chat-action-icon-btn action-button" title="分享链接"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path>
                            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path>
                        </svg></button>
                    <button id="share-location-btn" class="chat-action-icon-btn action-button" title="共享位置"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                            <circle cx="12" cy="10" r="3"></circle>
                        </svg></button>
                    <!-- ▼▼▼ 请将这个新按钮，粘贴到 id="chat-input-actions-top" 容器的末尾 ▼▼▼ -->
                    <button id="gomoku-btn" class="chat-action-icon-btn action-button" title="五子棋">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <circle cx="12" cy="12" r="4"></circle>
                            <circle cx="12" cy="12" r="7"></circle>
                        </svg>
                    </button>
                    <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
                    <!-- ▼▼▼ 在“表情面板”按钮后，粘贴这个新按钮 ▼▼▼ -->
                    <button id="open-shopping-btn" class="chat-action-icon-btn action-button" title="购物">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="9" cy="21" r="1"></circle>
                            <circle cx="20" cy="21" r="1"></circle>
                            <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>
                        </svg>
                    </button>
                    <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
                    <!-- ▼▼▼ 【全新】单聊专用的“拍一-拍”按钮 (Q弹图标版) ▼▼▼ -->
                    <button id="pat-btn" class="chat-action-icon-btn action-button" title="拍一-拍" style="display: none;">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M16 5.02c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" />
                            <path d="M14.5 11.02c0 .83-.67 1.5-1.5 1.5v0c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5v0c.83 0 1.5.67 1.5 1.5" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" />
                            <path d="M5.5 14.52l-1.92-1.92c-.34-.34-.34-.89 0-1.23l3.58-3.58c.34-.34.89-.34 1.23 0l1.92 1.92c.34.34.34.89 0 1.23l-3.58 3.58c-.34.34-.89.34-1.23 0Z" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" />
                        </svg>
                    </button>
                    <!-- ▲▲▲ 替换结束 ▲▲▲ -->
                    <!-- ▼▼▼ 请将这个新按钮，粘贴到 id="chat-input-actions-top" 容器的末尾 ▼▼▼ -->
                    <button id="edit-last-response-btn" class="chat-action-icon-btn action-button" title="导演模式：编辑AI上一轮的完整响应">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 20h9"></path>
                            <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                        </svg>
                    </button>
                    <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
                        <!-- ▼▼▼ 在这里粘贴新按钮 ▼▼▼ -->
                        <button id="regenerate-btn" class="chat-action-icon-btn action-button" title="重新生成回复" style="display: flex;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                                <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                            </svg>
                        </button>
                        <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 在这里粘贴新按钮 ▼▼▼ -->
                        <button id="propel-btn" class="chat-action-icon-btn action-button" title="推进剧情" style="display: flex;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="13 19 22 12 13 5 13 19"></polygon>
                                <polygon points="2 19 11 12 2 5 2 19"></polygon>
                            </svg>
                        </button>
                        <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
                    <button id="show-announcement-board-btn" class="chat-action-icon-btn action-button" title="群公告板" style="display: none;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.782 6.132a1 1 0 0 0-1.053-.08l-4.729 2.489a1 1 0 0 0-.5.88v4.158a1 1 0 0 0 .5.88l4.729 2.489a1 1 0 0 0 1.053-.08a1 1 0 0 0 .499-.921V7.052a1 1 0 0 0-.499-.92zm-6 3.207L11 7.05v9.9l4.782-2.281V9.339zM10 6H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h6V6z" />
                        </svg>
                    </button>
<button id="werewolf-game-btn" class="chat-action-icon-btn action-button" title="狼人杀" style="display: none;">
    <svg width="24" height="24" viewBox="0 0 512 512" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
        <path d="M332.6 128.5c-61.1 0-110.5 49.4-110.5 110.5 0 23.4 7.3 45.1 19.9 63.3-19.3 6.3-40.1 9.7-61.9 9.7-88.2 0-160-71.8-160-160s71.8-160 160-160c5.3 0 10.5.3 15.6.8C202.9 44.1 160 0 160 0s-53.3 44.1-45.9 92.5c-48.4 24.3-82.1 73.4-82.1 129.6 0 80.9 65.5 146.4 146.4 146.4 20.2 0 39.4-4.1 56.8-11.5 24.1 33.6 63.3 56.8 107.4 56.8 7.2 0 14.2-0.6 21-1.7 15.2 24.2 41.2 41.1 71.6 41.1 44.7 0 80.9-36.2 80.9-80.9 0-25.2-11.5-47.7-29.6-62.6 11.6-16.1 18.4-35.6 18.4-56.5C443.1 177.9 393.7 128.5 332.6 128.5zM180.1 85.8c-52.1 0-94.4 42.3-94.4 94.4s42.3 94.4 94.4 94.4 94.4-42.3 94.4-94.4S232.2 85.8 180.1 85.8zM332.6 170.9c-37.8 0-68.4 30.6-68.4 68.4s30.6 68.4 68.4 68.4 68.4-30.6 68.4-68.4S370.4 170.9 332.6 170.9z"></path>
    </svg>
</button>
<button id="read-together-btn" class="chat-action-icon-btn action-button" title="一起读书">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
        <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
    </svg>
</button>
                </div>
                <div id="chat-input-main-row">
                    <textarea id="chat-input" rows="1" placeholder="输入消息..."></textarea>
                    <div id="input-actions-wrapper">
                        <button id="wait-reply-btn" title="等待回复"><img src="https://i.postimg.cc/q72zq80N/ECE92-BBC-BE57-48-E9-BB2-C-345-B6019-C4-B2.png" alt="等待回复"></button>
                        <button id="send-btn" class="action-button">发送</button>
                    </div>
                </div>
            </div>
            <div id="chat-lock-overlay">
                <div id="chat-lock-content"></div>
            </div>
        <!-- ▼▼▼ 【请用这个 V2.0 版本】完整替换旧的 id="sticker-panel" 的 div ▼▼▼ -->
        <div id="sticker-panel">
            <div id="sticker-panel-header">
                <span class="panel-btn" id="close-sticker-panel-btn">取消</span>
                <span class="title">我的表情</span>
                <div style="display: flex; gap: 10px;">
                    <span class="panel-btn" id="manage-sticker-categories-btn">分类</span>
                    <span class="panel-btn" id="manage-stickers-btn">管理</span>
                    <span class="panel-btn" id="add-sticker-batch-btn">批量</span>
                    <span class="panel-btn" id="add-sticker-url-btn">URL</span>
                    <span class="panel-btn" id="upload-sticker-btn">上传</span>
                </div>
            </div>
            <div id="sticker-category-tabs"></div>
<div id="sticker-search-container">
    <input type="search" id="sticker-search-input" placeholder="搜索表情名称...">
</div>
            <div id="sticker-grid"></div>

            <!-- 【核心修改】将旧的单个删除按钮，升级为一个包含“全选”和“删除”的操作栏 -->
            <div id="sticker-action-bar">
                <label class="select-all-label" style="display: flex; align-items: center; gap: 5px;">
                    <input type="checkbox" id="select-all-stickers-checkbox"> 全选
                </label>
                <button id="delete-selected-stickers-btn">删除 (0)</button>
            </div>
        </div>
        <!-- ▲▲▲ 替换结束 ▲▲▲ -->
            <input type="file" id="sticker-upload-input" accept="image/*" style="display: none;">
            <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
<div id="music-player-overlay">
    <!-- ▼▼▼ 【请用这整块代码】替换旧的 .music-player-window ▼▼▼ -->
    <div class="music-player-window">
        <!-- ▼▼▼ 【请用这整块代码】替换旧的 .music-player-top-actions ▼▼▼ -->
<div class="music-player-top-actions">
    <div class="top-left-cluster">
        <button id="music-return-btn">‹</button>
        <button id="music-exit-btn">×</button>
    </div>
    
    <!-- 【核心修改】创建一个新的容器来包裹右侧的两个按钮 -->
    <div style="display: flex; align-items: center; gap: 15px;">
        <!-- 【全新】这就是我们的全屏切换按钮 -->
        <button id="toggle-fullscreen-btn" title="切换全屏">
            <!-- 放大图标 -->
            <svg class="icon-maximize" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
            <!-- 缩小图标 (默认隐藏) -->
            <svg class="icon-minimize" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>
        </button>

        <!-- 播放列表按钮保持不变 -->
        <span id="music-playlist-btn">☰</span>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

        <!-- ▼▼▼ 【全新】这是头像显示容器，默认隐藏 ▼▼▼ -->
<div id="music-player-avatar-display">
    <!-- 头像将由JS动态生成在这里 -->
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

<!-- 核心修改：将歌曲信息移动到唱片上方，并用一个容器包裹 -->
<div id="music-info-top">
    <!-- 【核心修改】将时间和按钮包裹在一个flex容器中，使其并排显示 -->
    <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
        <div id="music-time-counter">已经一起听了0.0小时</div>
        <!-- 【全新】这是我们的新按钮 -->
        <button id="show-avatars-btn" title="显示/隐藏头像">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
        </button>
    </div>
    <div id="music-player-song-title">请添加歌曲</div>
    <div id="music-player-artist">...</div>
</div>

        <!-- 唱片/歌词切换容器保持不变 -->
        <div id="music-visual-container">
            <div id="vinyl-view">
                <img id="music-player-cover" src="https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg" alt="Album Art">
            </div>
            <div id="inline-lyrics-view">
                <div id="music-lyrics-container">
                    <div id="music-lyrics-list">
                        <!-- JS 会在这里填充歌词 -->
                    </div>
                </div>
            </div>
        </div>
    <div id="single-lyric-display">♪ ♪ ♪</div>
        <!-- 底部控制区域保持不变 -->
        <div class="music-player-controls-wrapper">
            <div class="music-progress-bar-container">
                <div id="music-current-time" class="time-display">0:00</div>
                <div class="progress-bar">
                    <div id="music-progress-fill" class="progress-bar-fill"></div>
                </div>
                <div id="music-total-time" class="time-display">0:00</div>
            </div>
            <div class="music-controls">
                <button id="music-prev-btn">◀</button>
                <button id="music-play-pause-btn" class="play-pause-btn">▶</button>
                <button id="music-next-btn">▶</button>
                <button id="music-mode-btn">顺序</button>
                <button id="toggle-blur-btn" title="切换背景清晰度">清</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 替换结束 ▲▲▲ -->
</div>
            <div id="music-playlist-panel">
                <div class="playlist-header">
                    <span class="panel-btn" id="close-playlist-btn">返回</span>
                    <span>播放列表</span>
                    <div>
                     <span class="panel-btn" id="cleanup-songs-btn">清理</span>
                        <span class="panel-btn" id="add-song-local-btn">本地</span>
                        <span class="panel-btn" id="add-song-url-btn">URL</span>
        <span class="panel-btn" id="add-song-search-btn">搜索</span>
                    </div>
                </div>
                <div class="playlist-body" id="playlist-body"></div>
            </div>
            <input type="file" id="local-song-upload-input" accept="audio/*" multiple style="display: none;">
            <input type="file" id="lrc-upload-input" accept=".lrc" style="display: none;">
        </div>
        <!-- ▼▼▼ 请用这整块【已修复】的代码，完整替换你现有的 id="wallpaper-screen" 的那整个 <div> ▼▼▼ -->
        <div id="wallpaper-screen" class="screen">
            <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
                <span>外观设置</span>
                <span style="width: 30px;"></span>
            </div>
            <div class="form-container">
                <!-- EPhone 壁纸设置 -->
                <label style="font-weight: 500; color: var(--text-secondary);">EPhone 主屏幕壁纸</label>
                <div id="wallpaper-preview">点击下方上传</div>
                <button class="form-button" onclick="document.getElementById('wallpaper-upload-input').click();">上传壁纸</button>
                <input type="file" id="wallpaper-upload-input" accept="image/*">
                
                <!-- 【【【全新：CPhone 壁纸设置】】】 -->
                <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
                <label style="font-weight: 500; color: var(--text-secondary);">CPhone Cphone壁纸</label>
                <div id="cphone-wallpaper-preview">点击下方上传</div>
                <button class="form-button" onclick="document.getElementById('cphone-wallpaper-upload-input').click();">上传CPhone壁纸</button>
                <input type="file" id="cphone-wallpaper-upload-input" accept="image/*" hidden>

                <!-- 全局聊天背景设置 -->
                <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
                <label style="font-weight: 500; color: var(--text-secondary);">全局聊天背景 (所有聊天默认)</label>
                <div id="global-bg-preview" class="wallpaper-preview" style="height: 160px; width: 90px;">点击下方上传</div>
                <div class="bg-upload-container">
                    <button class="form-button-secondary" onclick="document.getElementById('global-bg-input').click()">上传全局背景</button>
                    <button id="remove-global-bg-btn" class="form-button-secondary">移除全局背景</button>
                </div>
                <input type="file" id="global-bg-input" accept="image/*" style="display: none;">
                
                <!-- 其他设置 -->
                <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                    <label for="theme-toggle-switch" style="margin-bottom: 0;">夜间模式</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="theme-toggle-switch">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                    <label for="status-bar-toggle-switch" style="margin-bottom: 0;">显示顶部状态栏</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="status-bar-toggle-switch">
                        <span class="slider"></span>
                    </label>
                </div>
                
                <!-- 提示音设置 -->
                <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
                <div style="width:100%; text-align: left; margin-bottom: 15px;">
                    <label style="font-weight: 500; color: var(--text-secondary);">消息提示音</label>
                </div>
                <div class="form-group" style="width:100%;">
                    <label for="notification-sound-url-input">提示音文件 URL (.mp3, .wav, .ogg)</label>
                    <div style="display: flex; gap: 10px; align-items: center; margin-top: 8px;">
                        <input type="text" id="notification-sound-url-input" placeholder="留空则使用默认提示音" style="flex-grow: 1;">
                        <button id="test-sound-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">▶</button>
                        <button id="reset-sound-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">重置</button>
                    </div>
                </div>

                <!-- EPhone 图标设置 -->
                <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
                <div style="width:100%; text-align: left; margin-bottom: 15px;">
                    <label style="font-weight: 500; color: var(--text-secondary);">EPhone App 图标设置</label>
                </div>
                <div id="icon-settings-grid"></div>
<!-- ▼▼▼ 【全新】在这里粘贴聊天工具栏排序功能 ▼▼▼ -->
<hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
<div class="form-group" style="width:100%;">
    
    <!-- 这里是修改后的样子 -->
    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
        <label>聊天工具栏按钮排序</label>
        <button id="reset-button-order-btn" title="恢复默认顺序" class="form-button-secondary" style="margin: 0; padding: 4px 12px; font-size: 13px;">重置顺序</button>
    </div>
    
    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
        按住下方的按钮并拖动即可排序，设置会自动保存。
    </p>
    <div id="button-order-editor" style="display: flex; flex-wrap: wrap; gap: 10px; padding: 10px; background-color: #f0f2f5; border-radius: 8px; border: 1px solid var(--border-color);">
        <!-- 按钮排序项将由 JavaScript 动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
                <!-- 【【【全新：CPhone 图标设置】】】 -->
                <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
                <div style="width:100%; text-align: left; margin-bottom: 15px;">
                    <label style="font-weight: 500; color: var(--text-secondary);">CPhone App 图标设置</label>
                </div>
                <div id="cphone-icon-settings-grid"></div>

                <!-- CSS 预设 -->
                <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
                <h3 style="margin-top:0; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; width:100%; text-align: left;">CSS 预设管理</h3>
                <div class="form-group" style="width:100%;">
                    <label for="css-preset-select">选择或切换预设</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <select id="css-preset-select" style="flex-grow: 1;"></select>
                        <button id="save-css-preset-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">保存</button>
                        <button id="delete-css-preset-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px; background-color: #ffebee; color: #d32f2f; border-color: #ffcdd2;">删除</button>
                    </div>
                </div>
                <div class="form-group" style="width:100%;">
                    <label for="global-css-input"> 全局美化样式 (CSS) <button id="reset-global-css-btn" type="button" style="background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px;">重置</button>
                    </label>
                    <textarea id="global-css-input" rows="6" style="width: 100%; margin-top: 8px; font-family: monospace; font-size: 16px; resize: vertical;" placeholder="/* 在此输入自定义CSS */"></textarea>
                </div>
<!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->

<button class="form-button form-button-secondary" id="import-appearance-btn" style="margin-top: 10px;">导入外观 (JSON)</button>
<input type="file" id="import-appearance-input" accept="application/json" hidden>

<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->                
                <!-- 保存按钮 -->
                <button class="form-button" id="save-wallpaper-btn" style="margin-top: 30px;">保存所有外观设置</button>
            </div>
        </div>

        <!-- ▲▲▲ 替换结束 ▲▲▲ -->
        <!-- ▼▼▼ 【全新】分享链接功能 HTML ▼▼▼ -->
        <div id="browser-screen" class="screen">
            <div class="header">
                <span class="back-btn" id="browser-back-btn">‹</span>
                <span id="browser-title"></span>
                <span style="width: 30px;"></span>
            </div>
            <div id="browser-content" class="list-container">
                <!-- 文章内容将由JS动态生成在这里 -->
            </div>
        </div>
        <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
        <div id="font-settings-screen" class="screen">
            <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
                <span>字体设置</span>
                <span style="width: 30px;"></span>
            </div>
            <div class="form-container">
                <!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
                <!-- 【【【全新：字体预设管理】】】 -->
                <h3 style="margin-top:0; border-bottom: 1px solid #eee; padding-bottom: 10px;">字体预设管理</h3>
                <div class="form-group">
                    <label for="font-preset-select">选择或切换预设</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <select id="font-preset-select" style="flex-grow: 1;"></select>
                        <button id="save-font-preset-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">保存</button>
                        <button id="delete-font-preset-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px; background-color: #ffebee; color: #d32f2f; border-color: #ffcdd2;">删除</button>
                    </div>
                </div>
                <hr style="margin: 30px 0; opacity: 0.3;">
                <!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
                <div class="form-group">
                    <label for="font-url-input">字体文件URL (.ttf, .otf, .woff等)</label>
                    <input type="text" id="font-url-input" placeholder="https://..../font.ttf">
                </div>
                <div class="form-group">
                    <label>实时预览</label>
                    <div id="font-preview">
                        <p style="font-size: 20px; margin: 0 0 10px 0;">你好世界 Hello World</p>
                        <p style="margin: 0;">这是字体预览效果，12345。</p>
                    </div>
                </div>
                <button class="form-button" id="save-font-btn">保存并应用</button>
                <button class="form-button form-button-secondary" id="reset-font-btn">恢复默认字体</button>
            </div>
        </div>
        <!-- ▼▼▼ 【全新】选择联系人以创建群聊的屏幕 ▼▼▼ -->
        <div id="contact-picker-screen" class="screen">
            <div class="header">
                <span class="back-btn" id="cancel-contact-picker-btn">取消</span>
                <span>选择联系人</span>
                <span class="save-btn" id="confirm-contact-picker-btn">完成(0)</span>
            </div>
            <div class="list-container" id="contact-picker-list">
                <!-- 联系人列表将由JS动态生成 -->
            </div>
        </div>
        <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
        <!-- ▼▼▼ 【全新】群成员管理屏幕 ▼▼▼ -->
        <div id="member-management-screen" class="screen">
            <div class="header">
                <span class="back-btn" id="back-from-member-management">‹</span>
                <span>群成员管理</span>
                <span style="width: 30px;"></span>
            </div>
            <div class="list-container" id="member-management-list">
                <!-- 现有成员列表会在这里动态生成 -->
            </div>
            <div id="member-management-actions">
                <button id="add-existing-contact-btn">从好友列表添加</button>
                <button id="create-new-member-btn">创建群内新成员</button>
            </div>
        </div>
        <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】请将这个弹窗HTML粘贴到其他所有 modal 的旁边 ▼▼▼ -->
    <div id="sticker-category-manager-modal" class="modal">
        <div class="modal-content" style="height: 60%;">
            <div class="modal-header">
                <span>管理表情分类</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>新建分类</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="new-sticker-category-name-input" placeholder="输入分类名..." style="flex-grow: 1;">
                        <button id="add-new-sticker-category-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                    </div>
                </div>
                <hr style="opacity: 0.2;">
                <div id="existing-sticker-categories-list" style="display: flex; flex-direction: column; gap: 10px;">
                    <!-- 分类列表将由JS动态生成 -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="save" id="close-sticker-category-manager-btn" style="width: 100%;">完成</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
        <!-- ▼▼▼ 【全新】来电请求模态框 ▼▼▼ -->
        <div id="incoming-call-modal" class="modal">
            <div class="incoming-call-content">
                <img id="caller-avatar" class="caller-avatar" src="">
                <div id="caller-name" class="caller-name"></div>
                <div class="caller-text">邀请你视频通话</div>
                <div class="incoming-call-actions">
                    <div class="action-button-wrapper">
                        <button id="decline-call-btn" class="call-action-btn decline"></button>
                        <span>拒绝</span>
                    </div>
                    <div class="action-button-wrapper">
                        <button id="accept-call-btn" class="call-action-btn accept"></button>
                        <span>接听</span>
                    </div>
                </div>
            </div>
        </div>
        <!-- ▲▲▲ 新增结束 ▲▲▲ -->
        <!-- ▼▼▼ 请用这段【全新群聊兼容结构】的代码，完整替换你旧的 #video-call-screen ▼▼▼ -->
        <div id="video-call-screen" class="screen">
            <!-- 1. 顶部栏 (保持不变) -->
            <div class="video-call-top-bar">
                <span id="call-timer">00:00</span>
            </div>
            <!-- 2. 【升级】参与者头像网格区域 -->
            <div class="video-call-avatar-area">
                <div id="participant-avatars-grid">
                    <!-- JS会在这里动态生成头像 -->
                </div>
            </div>
            <!-- 3. 对话框区域 (保持不变) -->
            <div id="video-call-main" class="video-call-main">
                <!-- 对话内容会动态生成在这里 -->
            </div>
            <!-- 4. 【升级】底部控制栏，现在包含一个“加入”按钮 -->
            <div class="video-call-controls">
                <button id="user-speak-btn" class="control-btn speak-btn"></button>

                <button id="hang-up-btn" class="control-btn hangup-btn"></button>
                <!-- ▼▼▼ 在这里粘贴新按钮 ▼▼▼ -->
                <button id="regenerate-call-btn" class="control-btn regenerate-btn"></button>
                <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
                <!-- 这个按钮默认隐藏，只在用户“旁观”时显示 -->
                <button id="join-call-btn" class="control-btn join-btn" style="display: none;"></button>
            </div>
        </div>
        <!-- ▲▲▲ 替换结束 ▲▲▲ -->
        <!-- ▼▼▼ 【全新添加】正在呼叫界面 ▼▼▼ -->
        <div id="outgoing-call-screen" class="screen">
            <div class="outgoing-call-content">
                <img id="outgoing-call-avatar" class="caller-avatar" src="">
                <div id="outgoing-call-name" class="caller-name"></div>
                <div class="caller-text">正在呼叫...</div>
                <div class="outgoing-call-actions">
                    <button id="cancel-call-btn" class="call-action-btn decline"></button>
                    <span>取消</span>
                </div>
            </div>
        </div>
        <!-- ▲▲▲ 添加结束 ▲▲▲ -->
        <!-- ▼▼▼ 【全新】通话记录页面 ▼▼▼ -->
        <div id="call-history-screen" class="screen">
            <div class="header">
                <span class="back-btn" id="call-history-back-btn">‹</span>
                <span id="call-history-title">通话记录</span>
                <span style="width: 30px;"></span> <!-- 占位符，保持标题居中 -->
            </div>
            <div id="call-history-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
                <!-- 通话记录卡片将由JS动态生成在这里 -->
            </div>
        </div>
        <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- =================================================================== -->
<!-- ▼▼▼ 【最终修复版】请用这整块代码替换所有旧的豆瓣HTML ▼▼▼ -->
<!-- =================================================================== -->

<!-- 1. 豆瓣小组帖子列表屏幕 -->
<div id="douban-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>豆瓣小组</span>
        <div class="header-actions">
        <!-- 【核心新增】这就是我们的新设置按钮 -->
        <span class="action-btn" id="douban-settings-btn" title="豆瓣设置">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.44,0.17-0.48,0.41L9.12,4.84c-0.59,0.24-1.12,0.56-1.62,0.94L5.11,4.82c-0.22-0.08-0.47,0-0.59,0.22l-1.92,3.32 c-0.12,0.22-0.07,0.47,0.12,0.61l2.03,1.58C4.84,11.36,4.82,11.68,4.82,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.48,2.03 c0.04,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.48-0.41l0.48-2.03c0.59-0.24,1.12-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"></path>
            </svg>
        </span>
            <span class="action-btn" id="douban-cast-select-btn" title="选择参与角色">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                    <circle cx="9" cy="7" r="4"></circle>
                    <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                    <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                </svg>
            </span>
            <span class="action-btn" id="regenerate-douban-btn" title="重新生成内容">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                    <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                </svg>
            </span>
        </div>
    </div>
    <div id="douban-posts-list" class="list-container">
        <!-- AI生成的帖子将在这里显示 -->
    </div>
</div>

<!-- 2. 豆瓣帖子详情页屏幕 -->
<div id="douban-post-detail-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="douban-detail-back-btn">‹</span>
        <span id="douban-post-detail-title">帖子详情</span>
        <span style="width: 30px;"></span>
    </div>
    <div id="douban-detail-content-wrapper" class="list-container">
        <div id="douban-post-detail-body">
            <div class="douban-post-header">
                <img id="douban-detail-avatar" class="douban-post-avatar">
                <div class="douban-author-info">
                    <div id="douban-detail-author" class="douban-author-name"></div>
                    <div id="douban-detail-group" class="douban-group-name"></div>
                </div>
            </div>
            <h2 id="douban-detail-post-title" class="douban-post-title"></h2>
            <div id="douban-detail-content" class="douban-detail-content"></div>
        </div>
        <div class="douban-comments-section">
            <h4>回应</h4>
            <div id="douban-detail-comments-list"></div>
        </div>
    </div>
    <div id="douban-comment-footer" class="post-footer">
        <div class="comment-section">
            <img id="douban-my-comment-avatar" src="" class="comment-avatar">
            <input type="text" id="douban-comment-input" class="comment-input" placeholder="写回应...">
        </div>
        <button id="douban-wait-reply-btn" class="douban-feather-btn" title="让AI继续讨论">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path>
                <line x1="16" y1="8" x2="2" y2="22"></line>
                <line x1="17.5" y1="15" x2="9" y2="15"></line>
            </svg>
        </button>
        <button id="douban-send-comment-btn" class="comment-send-btn">发送</button>
    </div>
</div>
        <div id="werewolf-game-screen" class="screen">
            <div class="header">
                <span id="werewolf-game-title">狼人杀</span>
                <div class="header-actions">
<span class="action-btn" id="werewolf-retry-btn" title="重试上一步AI操作" style="display: none;">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
        <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
    </svg>
</span>
                    <span class="action-btn" id="exit-werewolf-game-btn">退出</span>
                </div>
            </div>
            <!-- 玩家头像区 (保持不变) -->
            <div id="werewolf-player-grid"></div>
            <!-- 游戏日志/对话区 (保持不变) -->
            <div id="werewolf-log" class="list-container"></div>
            
            <!-- 【核心修改】全新的、常驻的底部操作栏 -->
            <div id="werewolf-action-bar">
                <div id="chat-input-main-row" style="width: 100%;">
                    <textarea id="werewolf-user-input" rows="1" placeholder="轮到你发言了..."></textarea>
                    <div id="input-actions-wrapper" style="gap: 5px;">
                        <!-- 发言阶段的按钮 -->
                        <button id="werewolf-wait-reply-btn" class="action-button" style="display: none; background-color: #007bff; height: 40px; padding: 0 10px; font-size: 13px;">等待回应</button>
                        <button id="werewolf-finish-speech-btn" class="action-button" style="display: none; background-color: var(--accent-color); height: 40px; padding: 0 10px; font-size: 13px;">结束发言</button>
                        <!-- 非发言阶段的按钮 -->
                        <button id="werewolf-next-step-btn" class="form-button" style="margin-top:0; display: none;">下一步</button>
                    </div>
                </div>
            </div>
        </div>
        <!-- ▲▲▲ 替换结束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】长期记忆管理全屏页面 ▼▼▼ -->
    <div id="long-term-memory-screen" class="screen">
        <div class="header">
            <span class="back-btn" id="memory-screen-back-btn">‹</span>
            <span>长期记忆</span>
            <div class="header-actions">
                <span class="action-btn" id="refine-memory-btn-header">精炼</span>
                <span class="action-btn" id="summarize-recent-btn-header">总结</span>
                <span class="action-btn" id="add-manual-memory-btn-header">+</span>
            </div>
        </div>
        <div class="list-container" id="memory-list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px; background-color: #f0f2f5;">
            <!-- 长期记忆列表将由JS动态生成在这里 -->
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】聊天设置页面结构 ▼▼▼ -->
<div id="chat-settings-screen" class="screen">
    <!-- 1. 页面的头部，包含返回和保存按钮 -->
    <div class="header">
        <span class="back-btn" onclick="showScreen('chat-interface-screen')">‹</span>
        <span>聊天设置</span>
        <span class="save-btn" id="save-chat-settings-btn">保存</span>
    </div>

    <!-- 2. 页面的内容容器，现在可以滚动了 -->
    <div class="form-container">
        <!-- 
          这里的内容就是你原来 modal-body 里的所有 form-group。
          我们已经将它们原封不动地移动到这里了。
        -->
        <div class="form-group" id="chat-name-group"><label for="chat-name-input">备注名 / 群名</label><input type="text" id="chat-name-input"></div>
        <div class="form-group" id="my-nickname-group">
            <label for="my-nickname-input">我的昵称</label>
            <input type="text" id="my-nickname-input">
        </div>
        <div class="form-group" id="assign-group-section" style="display: none;">
            <label for="assign-group-select">好友分组</label>
            <div style="display: flex; align-items: center; gap: 10px;">
                <select id="assign-group-select" style="flex-grow: 1;"></select>
                <button id="manage-groups-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">管理分组</button>
            </div>
        </div>
        <div class="form-group" id="my-group-nickname-group"><label for="my-group-nickname-input">我的群昵称</label><input type="text" id="my-group-nickname-input"></div>
        <button class="form-button form-button-secondary" id="search-history-btn" style="margin-top: 10px;">搜索聊天记录</button>
<!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<div class="form-group" id="single-char-background-activity-group">
    <div style="display: flex; justify-content: space-between; align-items: center;">
        <label for="char-background-activity-switch" style="margin-bottom: 0;">
            启用独立后台活动
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                允许该角色在后台独立发消息或动态。需同时开启API设置中的总开关。
            </p>
        </label>
        <label class="toggle-switch">
            <input type="checkbox" id="char-background-activity-switch">
            <span class="slider"></span>
        </label>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
        <div class="form-group" id="ai-cooldown-group">
            <label for="ai-action-cooldown-input"> 独立行动冷却 (分钟) <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;"> AI在后台主动发消息或动态的最小间隔。 </p>
            </label>
            <input type="number" id="ai-action-cooldown-input" min="1" value="10" style="width: 80px; text-align: center;">
        </div>
<!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
        <!-- ▼▼▼ 【全新】时间感知开关 ▼▼▼ -->
        <div class="form-group" id="time-perception-group">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <label for="time-perception-toggle" style="margin-bottom: 0;">
                    启用时间感知
                    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                        关闭后，AI将不会接收到当前时间信息，对话中不再体现时间变化。
                    </p>
                </label>
                <label class="toggle-switch">
                    <input type="checkbox" id="time-perception-toggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
        <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<div class="form-group" id="time-zone-group" style="display: none;">
    <label for="time-zone-select">选择时区</label>
    <!-- 【核心新增】这就是我们的搜索框 -->
    <input type="search" id="time-zone-search-input" placeholder="搜索时区，例如 Shanghai, New York...">
    <select id="time-zone-select" style="width: 100%;"></select>
</div>
<div class="form-group" id="group-background-activity-group">
    <div style="display: flex; justify-content: space-between; align-items: center;">
        <label for="group-background-activity-switch" style="margin-bottom: 0;">
            启用群内后台活动
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                允许AI成员在该群聊中独立行动。需同时开启API设置中的总开关。
            </p>
        </label>
        <label class="toggle-switch">
            <input type="checkbox" id="group-background-activity-switch">
            <span class="slider"></span>
        </label>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
        <div class="form-group" id="group-cooldown-group">
            <label for="group-action-cooldown-input"> 群聊行动冷却 (分钟) <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;"> AI在后台主动在群内行动的最小间隔。 </p>
            </label>
            <input type="number" id="group-action-cooldown-input" min="1" value="10" style="width: 80px; text-align: center;">
        </div>
        <div class="form-group" id="group-avatar-group">
            <label>群头像</label>
            <div class="avatar-upload">
                <img id="group-avatar-preview">
                <button onclick="document.getElementById('group-avatar-input').click()">上传群头像</button>
                <button id="manage-group-avatar-library-btn">管理头像库</button>
                <input type="file" id="group-avatar-input" accept="image/*">
            </div>
        </div>
        <div class="form-group" id="world-book-link-group">
            <label>关联世界书 (可多选)</label>
            <div class="custom-multiselect">
                <div class="select-box">
                    <span class="selected-options-text">-- 点击选择 --</span>
                    <span class="arrow-down">▼</span>
                </div>
                <div id="world-book-checkboxes-container" class="checkboxes-container">
                </div>
            </div>
        </div>
        <div class="form-group" id="lyrics-position-group" style="display: none;">
            <hr style="opacity: 0.3; margin: 20px 0;">
            <label>歌词栏位置</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 8px;">
                <div>
                    <label for="lyrics-vertical-pos" style="font-size: 0.9em; color: var(--text-secondary);">垂直位置</label>
                    <select id="lyrics-vertical-pos" style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 14px;">
                        <option value="top">顶部</option>
                        <option value="bottom">底部</option>
                    </select>
                </div>
                <div>
                    <label for="lyrics-horizontal-pos" style="font-size: 0.9em; color: var(--text-secondary);">水平对齐</label>
                    <select id="lyrics-horizontal-pos" style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 14px;">
                        <option value="left">居左</option>
                        <option value="center">居中</option>
                        <option value="right">居右</option>
                    </select>
                </div>
            </div>
            <div style="margin-top: 10px;">
                <label for="lyrics-offset-input" style="font-size: 0.9em; color: var(--text-secondary);">垂直偏移 (px)</label>
                <input type="number" id="lyrics-offset-input" value="10" style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 14px; box-sizing: border-box;">
            </div>
        </div>
        <div class="form-group" id="offline-mode-group">
            <hr style="opacity: 0.3; margin: 20px 0;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <label for="offline-mode-toggle" style="margin-bottom: 0;"> 启用线下模式 <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;"> 开启后, AI的回复将变为包含「对话」和<i style="color: #666;">动作/环境描写</i>的剧情模式。 </p>
                </label>
                <label class="toggle-switch">
                    <input type="checkbox" id="offline-mode-toggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div id="offline-mode-options" style="display: none; margin-top: 15px;">
                <label for="offline-min-length-input">回复字数范围</label>
                <div style="display: flex; align-items: center; gap: 10px; margin-top: 5px;">
                    <input type="number" id="offline-min-length-input" value="100" style="width: 80px; text-align: center;">
                    <span>到</span>
                    <input type="number" id="offline-max-length-input" value="300" style="width: 80px; text-align: center;">
                    <span>字</span>
                </div>
    <div class="form-group" style="margin-top: 15px; margin-bottom: 0;">
        <label for="offline-preset-select">文风预设 (将影响AI的描写风格)</label>
        <select id="offline-preset-select" style="width: 100%; margin-top: 5px;"></select>
    </div>
            </div>
        </div>
        <div class="form-group" id="linked-memory-group">
            <label for="link-memory-toggle">挂载其他聊天记忆</label>
            <input type="checkbox" id="link-memory-toggle" style="width: auto; height: 20px; vertical-align: middle; margin-left: 10px;">
            <div id="linked-memory-selection" style="display: none; margin-top: 10px;">
                <label>选择要挂载记忆的聊天 (可多选):</label>
                <div class="custom-multiselect">
                    <div class="select-box">
                        <span class="selected-options-text">-- 点击选择 --</span>
                        <span class="arrow-down">▼</span>
                    </div>
                    <div id="linked-chats-checkboxes-container" class="checkboxes-container" style="max-height: 120px;">
                    </div>
                </div>
                <p style="font-size: 12px; color: #8a8a8a; margin-top: 8px; line-height: 1.5;"> • 挂载的记忆会以“参考记忆”的形式提供给AI，不会直接显示在聊天界面。<br> • 建议每个聊天挂载3-10轮记忆，避免影响响应速度。 </p>
            </div>
        </div>
        <div class="form-group" id="ai-original-name-group">
            <label for="ai-original-name-input">对方本名 (AI识别用)</label>
            <input type="text" id="ai-original-name-input">
        </div>
        <div class="form-group" id="ai-persona-group"><label for="ai-persona">对方人设 (AI Persona)</label><textarea id="ai-persona" rows="3"></textarea></div>
        <div class="form-group" id="ai-avatar-group"><label>对方头像</label>
            <div class="avatar-upload"><img id="ai-avatar-preview"><button onclick="document.getElementById('ai-avatar-input').click()">上传对方头像</button><button id="manage-ai-avatar-library-btn">管理头像库</button><button class="change-frame-btn" data-type="ai">更换头像框</button>
                <input type="file" id="ai-avatar-input" accept="image/*">
            </div>
        </div>
        <div class="form-group" id="my-persona-group"><label for="my-persona">我的人设 (My Persona)</label><textarea id="my-persona" rows="3"></textarea></div>
        <div class="form-group" id="switch-greeting-group" style="display: none;">
            <label>切换开场 (会清空当前对话)</label>
            <button id="switch-greeting-btn" class="form-button form-button-secondary" style="margin-top: 5px;">选择其他开场故事...</button>
        </div>
        <div class="form-group" id="my-avatar-group">
            <label>我的头像</label>
            <div class="avatar-upload">
                <img id="my-avatar-preview">
                <button onclick="document.getElementById('my-avatar-input').click()">上传我的头像</button>
                <button id="manage-my-avatar-library-btn">管理头像库</button>
                <button class="change-frame-btn" data-type="my">更换头像框</button>
                <button id="open-persona-library-btn">预设</button>
                <input type="file" id="my-avatar-input" accept="image/*">
            </div>
        </div>
        <div class="form-group" id="group-members-group"><label>群成员人设</label>
            <div id="group-members-settings"></div>
            <button id="manage-members-btn" class="form-button form-button-secondary" style="margin-top: 15px;">管理群成员</button>
        </div>
<div class="form-group" id="ai-voice-id-group">
    <label for="ai-voice-id-input">语音 ID (Minimax voice_id)</label>
    <input type="text" id="ai-voice-id-input" placeholder="例如: female-shaonv-jingpin">
</div>
        <div class="form-group">
            <label for="max-memory">短期记忆（上下文）条数</label>
            <input type="number" id="max-memory" value="10">
        </div>
        <div class="form-group">
            <label for="linked-memory-count">挂载记忆条数</label>
            <input type="number" id="linked-memory-count" value="10">
            <p style="font-size: 12px; color: #8a8a8a; margin-top: 8px; line-height: 1.5;"> • 每次调用时，从每个“挂载的聊天”中提取最后几条记录作为参考记忆。 <br> • 建议值 5-20。值越大记忆越全，但API费用越高、响应越慢。 </p>
        </div>
        <hr style="opacity: 0.3; margin: 20px 0;">
        <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
            <label for="auto-memory-toggle" style="margin-bottom: 0;"> 启用自动总结长期记忆 <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;"> 开启后，AI会在对话达到一定长度时，自动将内容提炼为长期记忆。 </p>
            </label>
            <label class="toggle-switch">
                <input type="checkbox" id="auto-memory-toggle">
                <span class="slider"></span>
            </label>
        </div>
        <div class="form-group">
            <label for="auto-memory-interval">自动总结间隔（消息条数）</label>
            <input type="number" id="auto-memory-interval" min="10" value="20" style="width: 80px; text-align: center;">
            <p style="font-size: 12px; color: #8a8a8a; margin-top: 8px;"> 建议值 15-30。值越小，总结越频繁，但API费用也越高。 </p>
        </div>
        <hr style="opacity: 0.3; margin: 20px 0;">
        <div class="form-group">
            <label>聊天气泡主题 <button id="reset-theme-btn" type="button">重置</button></label>
            <div class="theme-selector">
                <label><input type="radio" name="theme-select" value="default" id="theme-default"> 默认</label>
                <label><input type="radio" name="theme-select" value="pink_blue"> 粉蓝</label>
                <label><input type="radio" name="theme-select" value="blue_white"> 蓝白</label>
                <label><input type="radio" name="theme-select" value="purple_yellow"> 紫黄</label>
                <label><input type="radio" name="theme-select" value="black_white"> 黑白</label>
                <label><input type="radio" name="theme-select" value="yellow_white"> 黄白</label>
                <label><input type="radio" name="theme-select" value="red_black"> 红黑</label>
                <label><input type="radio" name="theme-select" value="blue_yellow"> 蓝黄</label>
                <label><input type="radio" name="theme-select" value="pink_yellow"> 粉黄</label>
                <label><input type="radio" name="theme-select" value="pink_purple"> 粉紫</label>
                <label><input type="radio" name="theme-select" value="gray_white"> 灰白</label>
                <label><input type="radio" name="theme-select" value="blue_green"> 蓝绿</label>
                <label><input type="radio" name="theme-select" value="pink_white"> 粉白</label>
                <label><input type="radio" name="theme-select" value="pink_black"> 粉黑</label>
                <label><input type="radio" name="theme-select" value="pink_green"> 粉绿</label>
                <label><input type="radio" name="theme-select" value="green_black"> 绿黑</label>
            </div>
        </div>
        <div class="form-group">
            <label for="font-size-slider">聊天字体大小 <span id="font-size-value">13px</span></label>
            <input type="range" id="font-size-slider" min="12" max="20" step="1" value="13" style="width: 100%; margin-top: 8px;">
        </div>
        <!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
        <!-- 【【【全新：气泡主题预设管理】】】 -->
        <hr style="opacity: 0.3; margin: 20px 0;">
        <div class="form-group">
            <label for="theme-preset-select">主题预设管理</label>
            <div style="display: flex; gap: 10px; align-items: center;">
                <select id="theme-preset-select" style="flex-grow: 1;"></select>
                <button id="save-theme-preset-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">保存</button>
                <button id="delete-theme-preset-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px; background-color: #ffebee; color: #d32f2f; border-color: #ffcdd2;">删除</button>
            </div>
        </div>
        <!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
        <div class="form-group">
            <label for="custom-css-input"> 自定义气泡样式 (CSS) <button id="reset-custom-css-btn" type="button" style="background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px;">重置</button>
            </label>
            <textarea id="custom-css-input" rows="5" style="width: 100%; margin-top: 8px; font-family: monospace; font-size: 16px; resize: vertical;" placeholder="/* 示例：为“我”的气泡添加渐变背景和阴影 */ .message-bubble.user .content { background: linear-gradient(135deg, #a1c4fd, #c2e9fb); box-shadow: 0 4px 10px rgba(0,0,0,0.1); border-radius: 15px 4px 15px 15px; }"></textarea>
        </div>
        <div class="form-group">
            <label>实时预览</label>
            <div id="settings-preview-area"></div>
        </div>
        <div class="form-group">
            <label>聊天背景</label>
            <div class="bg-upload-container">
                <button type="button" class="form-button-secondary" style="width: auto; padding: 8px 12px; margin-top: 0;" onclick="document.getElementById('bg-input').click()">上传背景图</button>
                <button type="button" id="remove-bg-btn">移除背景</button>
            </div>
            <img id="bg-preview" class="bg-preview-img">
            <input type="file" id="bg-input" accept="image/*" style="display: none;">
        </div>
        <hr style="margin: 25px 0; border: none; border-top: 1px solid #eee;">
        <button class="form-button form-button-secondary" id="block-chat-btn" style="background-color: #ff3b30; color: white; border-color: #ff3b30;">拉黑对方</button>
<!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<hr style="margin: 25px 0; border: none; border-top: 1px solid #eee;">
<button class="form-button form-button-secondary" id="export-single-chat-btn" style="background-color: #e8f5e9; color: #2e7d32; border-color: #c8e6c9;">导出该聊天</button>
<button class="form-button form-button-secondary" id="import-single-chat-btn" style="background-color: #fff3e0; color: #ef6c00; border-color: #ffe0b2;">导入该聊天</button>
<input type="file" id="import-single-chat-input" accept="application/json" hidden>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
        <button class="form-button form-button-secondary" id="clear-chat-btn">清空聊天记录</button>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】请用这整块代码，完整替换旧的 rendering-rules-screen ▼▼▼ -->
    <div id="rendering-rules-screen" class="screen">
        <div class="header">
            <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
            <span>渲染规则</span>
            <span class="action-btn" id="add-new-rule-btn">+</span>
        </div>
        <!-- 【核心修改1】全新的页签和内容区结构 -->
        <div id="rules-tabs">
            <!-- JS 会在这里动态生成页签 -->
        </div>
        <div id="rules-content-container">
            <!-- JS 会在这里动态生成内容面板 -->
        </div>
    </div>
    <!-- ▲▲▲ 替换结束 ▲▲▲ -->
    <!-- 2. 规则编辑器模态框 -->
    <div id="rule-editor-modal" class="modal">
        <div class="modal-content" style="height: 85%;">
            <div class="modal-header">
                <span id="rule-editor-title">创建新规则</span>
            </div>
            <div class="modal-body" style="display: flex; flex-direction: column; gap: 15px;">
                <div class="form-group" style="flex-shrink: 0;">
                    <label for="rule-name-input">规则名称</label>
                    <input type="text" id="rule-name-input" placeholder="例如：美团外卖卡片">
                </div>
                <div class="form-group" style="flex-shrink: 0;">
                    <label for="rule-chat-id-select">绑定范围</label>
                    <select id="rule-chat-id-select">
                        <option value="global">公用 (所有角色)</option>
                        <!-- 角色列表将由JS动态填充 -->
                    </select>
                </div>
                <div class="form-group" style="flex-grow: 1; display: flex; flex-direction: column;">
                    <label for="rule-regex-input">正则表达式 (使用g作为标志)</label>
                    <textarea id="rule-regex-input" rows="3" style="font-family: monospace; resize: vertical;" placeholder="例如：MTR\[(.*?)\]\[(.*?)\|(.*?)\]"></textarea>
                </div>
                <div class="form-group" style="flex-grow: 2; display: flex; flex-direction: column;">
                    <label for="rule-template-input">HTML 模板 (用 $1, $2 引用)</label>
                    <textarea id="rule-template-input" rows="6" style="font-family: monospace; resize: vertical;" placeholder="例如：<div class=`waimai-card`>...<span>$2</span>...</div>"></textarea>
                </div>
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; flex-shrink: 0;">
                    <label for="rule-enabled-switch" style="margin-bottom: 0;">启用规则</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="rule-enabled-switch" checked>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-rule-editor-btn">取消</button>
                <button class="save" id="save-rule-btn">保存规则</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是聊天记录搜索功能的HTML代码 ▼▼▼ -->
<div id="search-history-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="search-history-back-btn">‹</span>
        <span>搜索聊天记录</span>
        <span style="width: 30px;"></span>
    </div>
    <!-- 搜索条件输入区 -->
    <div id="search-bar" style="padding: 10px 15px; border-bottom: 1px solid var(--border-color); background-color: var(--secondary-bg); flex-shrink: 0;">
        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
            <input type="search" id="keyword-search-input" placeholder="输入关键词..." style="flex-grow: 1; padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 16px;">
            <input type="date" id="date-search-input" style="padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 16px;">
        </div>
        <div style="display: flex; gap: 10px;">
            <button id="execute-search-btn" class="form-button" style="margin-top: 0; flex-grow: 1;">搜索</button>
            <button id="clear-search-btn" class="form-button form-button-secondary" style="margin-top: 0; flex-grow: 1;">重置</button>
        </div>
    </div>
    <!-- 搜索结果显示区 -->
 
    <div id="chat-search-results-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
        <!-- 聊天记录的搜索结果将在这里显示 -->
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- =================================================================== -->
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- =================================================================== -->
        <!-- ▼▼▼ 【全新】购物功能相关页面与弹窗 (V4.0 - 仿淘宝终极版) ▼▼▼ -->
        <div id="shopping-screen" class="screen">
            <div class="header">
                <span class="back-btn" id="shopping-back-btn">‹</span>
                <span>购物中心</span>
                <div class="header-actions">
                    <!-- “管理”按钮已替换为SVG图标 -->
                    <span class="action-btn" id="manage-products-btn" title="管理商品">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path>
                        </svg>
                    </span>
                    <!-- 新增的“添加商品”SVG图标按钮 -->
                    <span class="action-btn" id="add-new-product-btn" title="添加新商品">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="16"></line>
                            <line x1="8" y1="12" x2="16" y2="12"></line>
                        </svg>
                    </span>
                    <!-- 购物车按钮保持不变 -->
                    <!-- ▼▼▼ 【全新SVG图标版】请用这整块代码替换旧的购物车图标 ▼▼▼ -->
                    <span class="action-btn" id="go-to-cart-btn" title="查看购物车">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="9" cy="21" r="1"></circle>
                            <circle cx="20" cy="21" r="1"></circle>
                            <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>
                        </svg>
                        <span id="cart-count">0</span>
                    </span>
                    <!-- ▲▲▲ 替换结束 ▲▲▲ -->
                </div>
            </div>
            <!-- ▲▲▲ 替换结束 ▲▲▲ -->
            <div id="product-grid" class="list-container">
                <!-- 商品将在这里动态生成 -->
            </div>
        </div>
        <!-- 【核心新增】商品详情页 -->
        <div id="product-detail-screen" class="screen">
            <div class="header">
                <span class="back-btn" id="product-detail-back-btn">‹</span>
                <span>商品详情</span>
                <span style="width: 30px;"></span>
            </div>
            <div id="product-detail-content" class="list-container">
                <!-- 详情内容将在这里动态生成 -->
            </div>
            <div id="product-detail-footer">
                <button class="footer-btn add-to-cart-detail-btn">加入购物车</button>
                <button class="footer-btn buy-now-btn">立即购买</button>
            </div>
        </div>
        <div id="cart-screen" class="screen">
            <!-- ▼▼▼ 请用这段新代码替换购物车页面的Header ▼▼▼ -->
            <div class="header">
                <span class="back-btn" id="cart-back-btn">‹</span>
                <span id="cart-title">购物车(0)</span>
                <span class="action-btn" id="clear-cart-btn">清空</span> <!-- 将“管理”替换为“清空”功能 -->
            </div>
            <!-- ▲▲▲ 替换结束 ▲▲▲ -->
            <div id="cart-items-list" class="list-container">
                <!-- 购物车商品将在这里动态生成 -->
            </div>
            <div id="cart-footer">
                <label class="select-all-label"><input type="checkbox" id="select-all-cart-items"> 全选</label>
                <div class="cart-summary">
                    <div id="cart-total">合计: ¥0.00</div>
                    <span class="cart-subtext">不含运费</span>
                </div>
                <button id="checkout-btn">结算(0)</button>
            </div>
        </div>
        <div id="product-editor-modal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <span id="product-editor-title">添加商品</span>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label>商品图片</label>
                        <div class="avatar-upload">
                            <img id="product-image-preview" src="https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756206115802_qdqqd_0c99bh.jpeg">
                            <button onclick="document.getElementById('product-image-input').click()">上传图片</button>
                            <input type="file" id="product-image-input" accept="image/*" hidden>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="product-name-input">商品名称</label>
                        <input type="text" id="product-name-input">
                    </div>
                    <div class="form-group">
                        <label for="product-price-input">价格 (元)</label>
                        <input type="number" id="product-price-input" min="0" step="0.01">
                    </div>
                    <!-- 【核心新增】商品描述输入框 -->
                    <div class="form-group">
                        <label for="product-description-input">商品描述</label>
                        <textarea id="product-description-input" rows="4" placeholder="详细介绍一下这个商品..."></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="cancel" id="cancel-product-editor-btn">取消</button>
                    <button class="save" id="save-product-btn">保存</button>
                </div>
            </div>
        </div>
        <div id="gift-receipt-modal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <span>购物小票</span>
                </div>
                <div class="modal-body" id="gift-receipt-body">
                    <!-- 小票内容将在这里动态生成 -->
                </div>
                <div class="modal-footer">
                    <button class="save" id="close-receipt-btn" style="width:100%;">关闭</button>
                </div>
            </div>
        </div>
        <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
    </div>

    </div>

    <input type="file" id="import-card-input" accept=".json,.png" style="display: none;">
   <input type="file" id="import-world-book-input" accept=".json" style="display: none;">


    <div id="persona-library-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span>我的人设库</span><button id="add-persona-preset-btn" class="action-button">添加</button></div>
            <div class="modal-body">
                <div id="persona-library-grid"></div>
            </div>
            <div class="modal-footer"><button class="cancel" id="close-persona-library-btn">关闭</button></div>
        </div>
    </div>
    <div id="persona-editor-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span id="persona-editor-title">添加人设预设</span></div>
            <div class="modal-body">
                <div class="form-group"><label>预设头像</label>
                    <div class="avatar-upload"><img id="preset-avatar-preview"><button onclick="document.getElementById('preset-avatar-input').click()">上传头像</button><input type="file" id="preset-avatar-input" accept="image/*"></div>
                </div>
                <div class="form-group"><label for="preset-persona-input">预设人设</label><textarea id="preset-persona-input" rows="4" placeholder="在此输入这个人设的详细设定..."></textarea></div>
            </div>
            <div class="modal-footer"><button class="cancel" id="cancel-persona-editor-btn">取消</button><button class="save" id="save-persona-preset-btn">保存</button></div>
        </div>
    </div>
    <div id="member-settings-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span>编辑群成员</span></div>
            <div class="modal-body">
                <div class="form-group"><label for="member-name-input">名字</label><input type="text" id="member-name-input"></div>
                <div class="form-group"><label for="member-persona-input">人设</label><textarea id="member-persona-input" rows="4"></textarea></div>
                <div class="form-group"><label>头像</label>
                    <div class="avatar-upload"><img id="member-avatar-preview"><button onclick="document.getElementById('member-avatar-input').click()">上传头像</button><button class="change-frame-btn" data-type="member">更换头像框</button><input type="file" id="member-avatar-input" accept="image/*"></div>
                </div>
            </div>
            <div class="modal-footer"><button class="cancel" id="cancel-member-settings-btn">取消</button><button class="save" id="save-member-settings-btn">保存</button></div>
        </div>
    </div>
    <div id="custom-modal-overlay">
        <div id="custom-modal">
            <div class="custom-modal-header" id="custom-modal-title"></div>
            <div class="custom-modal-body" id="custom-modal-body"></div>
            <div class="custom-modal-footer">
                <button id="custom-modal-cancel">取消</button>
                <button id="custom-modal-confirm" class="confirm-btn">确定</button>
            </div>
        </div>
    </div>
    <div id="preset-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="preset-action-edit">编辑预设</button>
                <button id="preset-action-delete" class="btn-danger">删除预设</button>
                <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>
    <div id="transfer-modal">
        <div class="transfer-content">
            <div class="transfer-header">给Ta一个惊喜！</div>
            <div class="transfer-input-group">
                <label for="transfer-amount">转账金额</label>
                <input type="number" id="transfer-amount" placeholder="0.00" min="0" max="999999" step="0.01">
            </div>
            <div class="transfer-input-group">
                <label for="transfer-note">备注 (可选)</label>
                <input type="text" id="transfer-note" placeholder="留下你的小心思~" maxlength="20">
            </div>
            <div class="transfer-actions">
                <button id="transfer-cancel-btn">取消</button>
                <button id="transfer-confirm-btn">确认转账</button>
            </div>
        </div>
    </div>
    <div id="battery-alert-modal">
        <div class="battery-alert-content">
            <img id="battery-alert-image" src="">
            <p id="battery-alert-text"></p>
        </div>
    </div>
<!-- ▼▼▼ 【全新】外卖请求模态框 (V2.0 - 支持为TA点单) ▼▼▼ -->
<div id="waimai-request-modal" class="modal">
    <div class="modal-content" style="width: 290px;">
        <div class="modal-header">
            <span>发起外卖订单</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="waimai-product-info">商品信息</label>
                <input type="text" id="waimai-product-info" placeholder="例如：一杯杨枝甘露">
            </div>
            <div class="form-group">
                <label for="waimai-amount">订单金额 (元)</label>
                <input type="number" id="waimai-amount" placeholder="例如：21" min="0" step="0.01">
            </div>
        </div>
        <div class="modal-footer">
            <!-- 【核心修改1】原来的“取消”按钮，现在变成了“为TA点外卖” -->
            <button class="save" id="waimai-order-for-ai-btn">为TA点单</button>
            <!-- 【核心修改2】原来的“发起请求”按钮，现在是另一个选项 -->
            <button class="save" id="waimai-confirm-btn">发起请求</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】新建约定/倒计时模态框 ▼▼▼ -->
    <div id="create-countdown-modal" class="modal">
        <div class="modal-content" style="height: auto;">
            <div class="modal-header">
                <span>新建约定</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="countdown-title-input">约定标题</label>
                    <input type="text" id="countdown-title-input" placeholder="例如：我的生日">
                </div>
                <div class="form-group">
                    <label for="countdown-date-input">约定日期与时间</label>
                    <input type="datetime-local" id="countdown-date-input">
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-create-countdown-btn">取消</button>
                <button class="save" id="confirm-create-countdown-btn">保存约定</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】发红包模态框 ▼▼▼ -->
    <div id="red-packet-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>发红包</span>
            </div>
            <div class="modal-body" style="padding: 0;">
                <!-- 1. 页签切换 -->
                <div class="frame-tabs">
                    <div id="rp-tab-group" class="frame-tab active">拼手气红包</div>
                    <div id="rp-tab-direct" class="frame-tab">专属红包</div>
                </div>
                <!-- 2. 拼手气红包内容区 -->
                <div id="rp-content-group" class="frame-content" style="padding: 20px 15px;">
                    <div class="form-group">
                        <label>总金额 (元)</label>
                        <input type="number" id="rp-group-amount" placeholder="0.00">
                    </div>
                    <div class="form-group">
                        <label>红包个数</label>
                        <input type="number" id="rp-group-count" placeholder="填写红包个数">
                    </div>
                    <div class="form-group">
                        <label>祝福语</label>
                        <input type="text" id="rp-group-greeting" placeholder="恭喜发财，大吉大利！">
                    </div>
                    <p id="rp-group-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                    <button id="send-group-packet-btn" class="form-button">塞钱进红包</button>
                </div>
                <!-- 3. 专属红包内容区 -->
                <div id="rp-content-direct" class="frame-content" style="display: none; padding: 20px 15px;">
                    <div class="form-group">
                        <label>发送给</label>
                        <select id="rp-direct-receiver"></select>
                    </div>
                    <div class="form-group">
                        <label>金额 (元)</label>
                        <input type="number" id="rp-direct-amount" placeholder="0.00">
                    </div>
                    <div class="form-group">
                        <label>祝福语</label>
                        <input type="text" id="rp-direct-greeting" placeholder="恭喜发财，大吉大利！">
                    </div>
                    <p id="rp-direct-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                    <button id="send-direct-packet-btn" class="form-button">塞钱进红包</button>
                </div>
            </div>
            <div class="modal-footer" style="justify-content: center;">
                <button class="cancel" id="cancel-red-packet-btn" style="width: 100%;">取消</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】红包详情模态框 ▼▼▼ -->
    <div id="red-packet-details-modal" class="modal">
        <div class="modal-content" style="width: 280px; height: auto; background-color: #f7f7f7;">
            <div class="modal-header" style="background-color: #F96259; color: white; border-bottom: none; padding-bottom: 5px;">
                <div style="text-align: center; width: 100%;">
                    <div id="rp-details-sender" style="font-size: 16px;"></div>
                    <div style="font-size: 13px; opacity: 0.8;">的红包</div>
                </div>
            </div>
            <div class="modal-body" style="padding: 15px;">
                <p id="rp-details-greeting" style="text-align: center; font-size: 20px; color: #333; margin: 0 0 20px 0;"></p>
                <div id="rp-details-my-amount" style="text-align: center; display: none; margin-bottom: 20px;">
                    <span style="font-size: 40px; font-weight: bold; color: #E44D44;">0.00</span>
                    <span style="font-size: 18px; color: #E44D44;">元</span>
                </div>
                <div id="rp-details-summary" style="font-size: 13px; color: #8a8a8a; border-top: 1px solid #e0e0e0; padding-top: 10px;"></div>
                <div id="rp-details-list" style="max-height: 150px; overflow-y: auto; margin-top: 10px;">
                    <!-- 领取详情将由JS动态生成在这里 -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="save" id="close-rp-details-btn" style="width: 100%;">关闭</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】创建投票模态框 ▼▼▼ -->
    <div id="create-poll-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>发起投票</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="poll-question-input">投票问题</label>
                    <textarea id="poll-question-input" rows="2" placeholder="例如：今晚我们看什么电影？"></textarea>
                </div>
                <div class="form-group">
                    <label>投票选项 (至少2项)</label>
                    <div id="poll-options-container" style="display: flex; flex-direction: column; gap: 8px;">
                        <!-- 投票选项将由JS动态生成在这里 -->
                    </div>
                    <button id="add-poll-option-btn" class="form-button form-button-secondary" style="margin-top: 12px;">+ 添加选项</button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-create-poll-btn">取消</button>
                <button class="save" id="confirm-create-poll-btn">发起投票</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】AI头像库管理模态框 ▼▼▼ -->
    <div id="ai-avatar-library-modal" class="modal">
        <div class="modal-content" style="height: 70%;">
            <div class="modal-header">
                <span id="ai-avatar-library-title">对方的头像库</span>
                <div class="header-actions">
                    <!-- 【核心修改】将一个按钮拆分为两个 -->
                    <button id="add-ai-avatar-batch-btn" class="action-button">批量</button>
                    <button id="add-ai-avatar-url-btn" class="action-button">URL</button>
                    <button id="add-ai-avatar-upload-btn" class="action-button">上传</button>
                </div>
            </div>
            <div class="modal-body" style="padding: 15px;">
                <div id="ai-avatar-library-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px;">
                    <!-- 头像库内容将由JS动态生成 -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="save" id="close-ai-avatar-library-btn" style="width: 100%;">关闭</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】“我的”头像库管理模态框 ▼▼▼ -->
    <div id="my-avatar-library-modal" class="modal">
        <div class="modal-content" style="height: 70%;">
            <div class="modal-header">
                <span id="my-avatar-library-title">我的头像库</span>
                <div class="header-actions">
                    <button id="add-my-avatar-batch-btn" class="action-button">批量</button>
                    <button id="add-my-avatar-url-btn" class="action-button">URL</button>
                    <button id="add-my-avatar-upload-btn" class="action-button">上传</button>
                </div>
            </div>
            <div class="modal-body" style="padding: 15px;">
                <div id="my-avatar-library-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px;">
                    <!-- “我的”头像库内容将由JS动态生成 -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="save" id="close-my-avatar-library-btn" style="width: 100%;">关闭</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <div id="group-avatar-library-modal" class="modal">
        <div class="modal-content" style="height: 70%;">
            <!-- ▼▼▼ 请用这整块代码，完整替换你现有的 #group-avatar-library-modal .modal-header ▼▼▼ -->
            <div class="modal-header">
                <span id="group-avatar-library-title">群头像库</span>
                <div class="header-actions">
                    <!-- 【核心修改】将一个按钮拆分为两个 -->
                    <button id="add-group-avatar-batch-btn" class="action-button">批量</button>
                    <button id="add-group-avatar-url-btn" class="action-button">URL</button>
                    <button id="add-group-avatar-upload-btn" class="action-button">上传</button>
                </div>
            </div>
            <!-- ▲▲▲ 替换结束 ▲▲▲ -->
            <div class="modal-body" style="padding: 15px;">
                <div id="group-avatar-library-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px;">
                </div>
            </div>
            <div class="modal-footer">
                <button class="save" id="close-group-avatar-library-btn" style="width: 100%;">关闭</button>
            </div>
        </div>
    </div>
    <div id="chat-list-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="chat-list-action-pin"></button> <button id="chat-list-action-delete" class="btn-danger">删除聊天</button>
                <button id="chat-list-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>
    <!-- ▼▼▼ 【全新】用户分享链接模态框 ▼▼▼ -->
    <div id="share-link-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>分享链接</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="link-title-input">标题</label>
                    <input type="text" id="link-title-input" placeholder="输入文章或链接的标题">
                </div>
                <div class="form-group">
                    <label for="link-description-input">摘要 (可选)</label>
                    <textarea id="link-description-input" rows="2" placeholder="简单描述一下链接内容"></textarea>
                </div>
                <div class="form-group">
                    <label for="link-source-input">来源名称 (可选)</label>
                    <input type="text" id="link-source-input" placeholder="例如：知乎日报、B站">
                </div>
                <div class="form-group">
                    <label for="link-content-input">完整内容 (可选，用于浏览器内显示)</label>
                    <textarea id="link-content-input" rows="4" placeholder="粘贴或输入完整的文章内容"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-share-link-btn">取消</button>
                <button class="save" id="confirm-share-link-btn">分享</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】精致版转账操作弹窗 ▼▼▼ -->
    <div id="transfer-actions-modal" class="modal">
        <div class="transfer-actions-content">
            <div class="transfer-actions-header">请选择操作</div>
            <div class="transfer-actions-body">
                <p>你收到了来自 <strong id="transfer-sender-name"></strong> 的一笔转账。</p>
            </div>
            <div class="transfer-actions-footer">
                <button id="transfer-action-decline" class="action-btn decline">残忍拒绝</button>
                <button id="transfer-action-accept" class="action-btn accept">开心收下</button>
            </div>
            <button id="transfer-action-cancel" class="cancel-btn">×</button>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】通话记录详情模态框 ▼▼▼ -->
    <div id="call-transcript-modal" class="modal">
        <div class="modal-content" style="height: 70%;">
            <div class="modal-header">
                <span id="transcript-modal-title">通话详情</span>
            </div>
            <div class="modal-body" id="call-transcript-modal-body" style="background-color: #f0f2f5;">
                <!-- 通话文字记录将由JS动态生成在这里 -->
            </div>
            <div class="modal-footer">
                <button class="cancel" id="delete-transcript-btn" style="background-color: #ff3b30; color: white; border-color: #ff3b30;">删除记录</button>
                <!-- 【【【核心新增】】】 -->
                <button class="save" id="manual-summarize-btn" style="background-color: #ffc107; border-color: #ffc107;">手动总结</button>
                <button class="save" id="close-call-transcript-btn" style="width: 100%;">关闭</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】分享目标选择器模态框 ▼▼▼ -->
    <div id="share-target-modal" class="modal">
        <div class="modal-content" style="height: 70%;">
            <div class="modal-header">
                <span>分享到...</span>
            </div>
            <div class="modal-body" id="share-target-list" style="padding: 0;">
                <!-- 聊天列表将由JS动态生成在这里 -->
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-share-target-btn">取消</button>
                <button class="save" id="confirm-share-target-btn">确认分享</button>
            </div>
        </div>
    </div>
    <!-- ▼▼▼ 【全新】分享记录查看器模态框 ▼▼▼ -->
    <div id="shared-history-viewer-modal" class="modal">
        <div class="modal-content" style="height: 80%;">
            <div class="modal-header">
                <span id="shared-history-viewer-title">聊天记录</span>
            </div>
            <div class="modal-body" id="shared-history-viewer-content" style="background-color: #f0f2f5;">
                <!-- 分享的聊天记录气泡将由JS动态生成在这里 -->
            </div>
            <div class="modal-footer">
                <button class="save" id="close-shared-history-viewer-btn" style="width:100%;">关闭</button>
            </div>
        </div>
    </div>
    <!-- ▼▼▼ 【全新】世界书分类管理模态框 ▼▼▼ -->
    <div id="world-book-category-manager-modal" class="modal">
        <div class="modal-content" style="height: 60%;">
            <div class="modal-header">
                <span>管理世界书分类</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>新建分类</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="new-category-name-input" placeholder="输入分类名..." style="flex-grow: 1;">
                        <button id="add-new-category-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                    </div>
                </div>
                <hr style="opacity: 0.2;">
                <div id="existing-categories-list" style="display: flex; flex-direction: column; gap: 10px;">
                    <!-- 分类列表将由JS动态生成 -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="save" id="close-category-manager-btn" style="width: 100%;">完成</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <div id="announcement-board-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>群公告板</span>
            </div>
            <div id="announcement-board-content">
            </div>
            <div class="modal-footer">
                <button class="save" id="close-announcement-board-btn" style="width: 100%;">关闭</button>
            </div>
        </div>
    </div>
    <div id="announcement-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="announcement-action-pin">置顶公告</button>
                <button id="announcement-action-delete" class="btn-danger">删除公告</button>
                <button id="announcement-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>
    <!-- ▼▼▼ 请将这个新的模态框HTML粘贴到所有其他模态框之后 ▼▼▼ -->
    <div id="group-management-modal" class="modal">
        <div class="modal-content" style="height: 60%;">
            <div class="modal-header">
                <span>管理好友分组</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>新建分组</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="new-group-name-input" placeholder="输入分组名..." style="flex-grow: 1;">
                        <button id="add-new-group-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                    </div>
                </div>
                <hr style="opacity: 0.2;">
                <div id="existing-groups-list" style="display: flex; flex-direction: column; gap: 10px;">
                    <!-- 分组列表将由JS动态生成 -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="save" id="close-group-manager-btn" style="width: 100%;">完成</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
    <!-- ▼▼▼ 请将这段新HTML粘贴到所有模态框的末尾 ▼▼▼ -->
    <div id="message-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <!-- 新的操作按钮 -->
                <button id="edit-message-btn">编辑消息</button>
                <button id="copy-message-btn">复制文本</button>
            <button id="copy-timestamp-btn">复制时间戳</button>
                <button id="recall-message-btn">撤回</button>
                <button id="publish-to-announcement-btn" style="display: none;">发布到公告板</button>
                <button id="quote-message-btn">引用</button>
                <button id="select-message-btn">进入多选</button>
                <!-- 取消按钮 -->
                <button id="cancel-message-action-btn" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <!-- ▼▼▼ 请将这段新HTML粘贴到所有模态框的末尾 ▼▼▼ -->
    <div id="post-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="edit-post-btn">编辑动态</button>
                <button id="copy-post-btn">复制内容</button>
                <button id="cancel-post-action-btn">取消</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】可视化消息编辑器模态框 ▼▼▼ -->
    <div id="message-editor-modal" class="modal">
        <div class="modal-content" style="height: 75%;">
            <div class="modal-header">
                <span>编辑与拆分消息</span>
            </div>
            <div class="modal-body" id="message-editor-body">
                <!-- 编辑器容器，JS会在这里动态生成文本框 -->
                <div id="message-editor-container"></div>
                <!-- 添加新消息的按钮 -->
                <button id="add-message-editor-block-btn" class="form-button form-button-secondary" style="margin-top: 15px;"> [+] 添加下一条消息 </button>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-advanced-editor-btn">取消</button>
                <button class="save" id="save-advanced-editor-btn">保存更改</button>
            </div>
        </div>
    </div>
    <!-- ▼▼▼ 【全新】“导演剪辑室”模态框 ▼▼▼ -->
    <div id="ai-response-editor-modal" class="modal">
        <div class="modal-content" style="height: 80%;">
            <div class="modal-header">
                <span>导演剪辑室 (AI上一轮响应)</span>
            </div>
            <div class="modal-body" id="ai-response-editor-body">
                <!-- 导演剪辑器容器，JS会在这里动态生成文本框 -->
                <div id="ai-response-editor-container" style="display: flex; flex-direction: column; gap: 15px;"></div>
                <!-- 添加新消息的按钮 -->
                <button id="add-ai-response-block-btn" class="form-button form-button-secondary" style="margin-top: 15px;"> [+] 添加一个新动作 </button>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-ai-response-editor-btn">取消</button>
                <button class="save" id="save-ai-response-editor-btn">应用修改</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <div id="repost-modal" class="modal">
        <div id="custom-modal" style="width: 280px;">
            <div class="custom-modal-header">转发动态</div>
            <div class="custom-modal-body">
                <textarea id="repost-comment-input" placeholder="请输入转发评论 (可选)" style="width: 100%; min-height: 60px; resize: vertical; border: 1px solid #ccc; border-radius: 6px; padding: 8px; font-size: 16px; box-sizing: border-box;"></textarea>
            </div>
            <div class="custom-modal-footer">
                <button id="repost-cancel-btn">取消</button>
                <button id="repost-confirm-btn" class="confirm-btn">确定</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】视频通话消息操作菜单 ▼▼▼ -->
    <div id="call-message-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="edit-call-message-btn">编辑</button>
                <button id="delete-call-message-btn" class="btn-danger">删除</button>
                <button id="cancel-call-message-action-btn" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->



    <audio id="audio-player" style="display:none;"></audio>
    <!-- ▼▼▼ 用下面这段【完整】的模态框代码，替换掉你现有的 id="create-post-modal" 的整个 div ▼▼▼ -->
    <div id="create-post-modal" class="modal">
        <div class="modal-content" style="height: auto; max-height: 90%;">
            <div class="modal-header">
                <span>发布动态</span>
            </div>
            <div class="modal-body">
                <!-- 公开文字输入区 -->
                <div class="form-group">
                    <textarea id="post-public-text" rows="3" placeholder="分享新鲜事...（非必填的公开文字）"></textarea>
                </div>
                <!-- === 模式切换开关 (新增) === -->
                <div class="post-mode-switcher">
                    <button id="switch-to-image-mode" class="mode-btn active">上传图片</button>
                    <button id="switch-to-text-image-mode" class="mode-btn">使用文字图</button>
                </div>
                <!-- ▼▼▼ 【修正后】的可见范围设置 ▼▼▼ -->
                <div class="form-group">
                    <label>可见范围</label>
                    <div id="post-visibility-options" style="display: flex; gap: 15px; margin-bottom: 10px;">
                        <label><input type="radio" name="visibility" value="public" checked> 公开</label>
                        <label><input type="radio" name="visibility" value="include"> 指定分组可见</label>
                    </div>
                    <div id="post-visibility-groups" style="display: none; max-height: 120px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px;">
                        <!-- 分组多选框将由JS动态生成 -->
                    </div>
                </div>
                <!-- ▲▲▲ 修正结束 ▲▲▲ -->
                <!-- === 图片模式区域 === -->
                <div id="image-mode-content" class="post-mode-content active">
                    <div class="form-group">
                        <div id="post-image-preview-container" class="post-image-preview-container">
                            <img id="post-image-preview" src="" alt="图片预览">
                            <button id="post-remove-image-btn">×</button>
                        </div>
                        <div class="post-image-upload-options">
                            <button id="post-upload-local-btn" class="form-button-secondary">本地上传</button>
                            <button id="post-use-url-btn" class="form-button-secondary">网络URL</button>
                            <input type="file" id="post-local-image-input" accept="image/*" hidden>
                        </div>
                    </div>
                    <div id="post-image-desc-group" class="form-group" style="display: none;">
                        <label>图片描述 (必填，给AI看)</label>
                        <input type="text" id="post-image-description" placeholder="简单描述图片内容，帮助AI理解">
                    </div>
                </div>
                <!-- === 文字图模式区域 (新增) === -->
                <div id="text-image-mode-content" class="post-mode-content">
                    <div class="form-group">
                        <label>文字图 (给AI理解用的描述，点击图片后可见)</label>
                        <textarea id="post-hidden-text" rows="4" placeholder="在这里写下图片描述..."></textarea>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-create-post-btn">取消</button>
                <button class="save" id="confirm-create-post-btn">发布</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 替换结束 ▲▲▲ -->



    <input type="file" id="ai-avatar-upload-input" accept="image/*" hidden>
    <input type="file" id="group-avatar-upload-input" accept="image/*" hidden>
    <script>
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
if (!Array.prototype.findLastIndex) {
  Object.defineProperty(Array.prototype, 'findLastIndex', {
    value: function(predicate) {
      if (this == null) {
        throw new TypeError('Cannot read property \'findLastIndex\' of null or undefined');
      }
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }
      let o = Object(this);
      let len = o.length >>> 0;
      let thisArg = arguments[1];
      let k = len - 1;
      while (k >= 0) {
        let kValue = o[k];
        if (predicate.call(thisArg, kValue, k, o)) {
          return k;
        }
        k--;
      }
      return -1;
    },
    configurable: true,
    writable: true
  });
}


        // ... 其他全局变量
        let activeMessageTimestamp = null;
        let activeTransferTimestamp = null; // <-- 确保这行在这里，并且只有一行
        // ▼▼▼ 在下方粘贴新变量 ▼▼▼
        let lastRawAiResponse = ''; // 用于存储AI上一轮的原始响应字符串
        let lastResponseTimestamps = []; // 用于存储上一轮响应生成的消息的时间戳
        // ▲▲▲ 新增结束 ▲▲▲
        let currentQzoneReplyContext = null;
        let editingNpcId = null; // <-- 新增这一行
        // ...
                const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models'
            // gemini如果是多个密钥, 那么随机获取一个
            function getRandomValue(str) {
                // 检查字符串是否包含逗号
                if (str.includes(',')) {
                    // 用逗号分隔字符串并移除多余空格
                    const arr = str.split(',').map(item => item.trim());
                    // 生成随机索引 (0 到 arr.length-1)
                    const randomIndex = Math.floor(Math.random() * arr.length);
                    // 返回随机元素
                    return arr[randomIndex];
                }
                // 没有逗号则直接返回原字符串
                return str;
            }
            function isImage(content) {
                if(content.image_url && content.image_url.url){
                    let currentImageData = content.image_url.url
                    // 提取Base64数据（去掉前缀）
                    const base64Data = currentImageData.split(',')[1];
                    // 根据图片类型获取MIME类型
                    const mimeType = currentImageData.match(/^data:(.*);base64/)[1];
                    return [
                        {text: '用户向你发送了一张图片'},
                        {
                            inline_data: {
                                mime_type: mimeType,
                                data: base64Data
                            }
                        }
                    ]
                }
                return []
            }
        
        
        // ▼▼▼ 【最终诊断增强版】请用这个全新的函数，完整替换您现有的 getGeminiResponseText ▼▼▼
        /**
         * 【V3.0 | 诊断增强版】从Gemini或兼容OpenAI的API响应中安全地提取文本内容
         * @param {object} data - 从 response.json() 解析后的数据对象
         * @returns {string} - 提取到的文本内容
         * @throws {Error} - 如果响应格式不正确或被屏蔽，则抛出一个带有详细原因的错误
         */
        function getGeminiResponseText(data) {
            // 1. 检查是否是兼容OpenAI的响应格式
            if (data.choices && Array.isArray(data.choices) && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                return data.choices[0].message.content;
            }
        
            // 2. 检查是否是成功的、标准的原生Gemini响应格式
            if (data.candidates && Array.isArray(data.candidates) && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts) {
                return data.candidates[0].content.parts[0].text;
            }
        
            // --- 【【【核心升级：全面的错误诊断】】】 ---
            console.error("Gemini API返回了非预期的格式:", data);
            let errorReason = "AI返回了空内容或未知格式。";
        
            // 3a. 诊断是否是因为内容安全策略被屏蔽 (Gemini官方API最常见的问题)
            // 这种情况data.candidates是存在的，但里面没有content
            if (data.candidates && Array.isArray(data.candidates) && data.candidates.length > 0 && data.candidates[0].finishReason === 'SAFETY') {
                const safetyRatings = data.candidates[0].safetyRatings;
                const blockedCategories = safetyRatings
                    .filter(r => r.probability !== 'NEGLIGIBLE' && r.probability !== 'LOW')
                    .map(r => `${r.category} (概率: ${r.probability})`)
                    .join(', ');
                errorReason = `内容因安全策略被屏蔽。触发类别: ${blockedCategories || '未知'}`;
            }
            // 3b. 诊断另一种内容安全屏蔽格式 (promptFeedback)
            else if (data.promptFeedback?.blockReason) {
                const reason = data.promptFeedback.blockReason;
                const details = data.promptFeedback.safetyRatings?.map(r => `${r.category}: ${r.probability}`).join(', ');
                errorReason = `内容因安全策略被屏蔽 (原因: ${reason})。详情: ${details || '无'}`;
            } 
            // 3c. 诊断是否是其他类型的API错误
            else if (data.error) {
                errorReason = `API错误: ${data.error.message}`;
            }
            
            // 4. 抛出一个带有详细信息的错误
            throw new Error(errorReason);
        }
        // ▲▲▲ 替换结束 ▲▲▲
        

            document.addEventListener('DOMContentLoaded', () => {
// ▼▼▼ 【最终识图修复方案】请用这个全新的、兼容性更强的函数，完整替换旧的 toGeminiRequestData ▼▼▼
function toGeminiRequestData(model, apiKey, systemInstruction, messagesForDecision) {
    const apiTemperature = state.globalSettings.apiTemperature || 0.8; // <-- 新增：获取温度
    const roleType = {
        user: 'user',
        assistant: 'model',
        system: 'user'
    };

    // --- 1. 将 systemInstruction 模拟成第一次用户对话，极大提高兼容性 ---
    const contents = [
        {
            role: 'user',
            parts: [{ text: systemInstruction }]
        },
        {
            role: 'model',
            parts: [{ text: '好的，我明白了。我会严格遵守以上所有规则和设定。' }]
        },
        // --- 2. 【核心修复】智能地处理每一条消息，构建正确的 parts 数组 ---
        ...messagesForDecision.map((item) => {
            const parts = [];
            // a. 如果 content 是一个数组，说明可能是复杂消息（文本+图片）
            if (Array.isArray(item.content)) {
                item.content.forEach(part => {
                    if (part.type === 'text') {
                        parts.push({ text: part.text });
                    } else if (part.type === 'image_url' && part.image_url && part.image_url.url) {
                        // b. 正确地从 Base64 URL 中提取图片数据和类型
                        const currentImageData = part.image_url.url;
                        const base64Data = currentImageData.split(',')[1];
                        const mimeTypeMatch = currentImageData.match(/^data:(.*);base64/);
                        if (mimeTypeMatch && base64Data) {
                            parts.push({
                                inline_data: {
                                    mime_type: mimeTypeMatch[1],
                                    data: base64Data
                                }
                            });
                        }
                    }
                });
            } else {
                // c. 如果 content 是普通字符串，直接作为文本处理
                parts.push({ text: String(item.content) });
            }
            return { role: roleType[item.role], parts: parts };
        })
    ];

    // --- 3. 返回最终构建好的、完全符合 Gemini API 规范的请求数据 ---
    return {
        url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`,
        data: {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                contents: contents,
                generationConfig: {
                    temperature: apiTemperature, // <-- 【核心修改】使用我们获取的温度值
                },
            })
        }
    };
}
// ▲▲▲ 替换结束 ▲▲▲
        
                // ===================================================================
                // 1. 所有变量和常量定义
                // ===================================================================
                const db = new Dexie('GeminiChatDB');
        const avatarFrames = [ { id: 'none', url: '', name: '无' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/fLDnz5Pn/IMG-5574.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/HxH3cNHz/IMG-6871.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/jCVK0fGL/IMG-6890.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/85Zsyjwn/IMG-6895.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/cJtpZCB3/IMG-6894.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/63sDQKMm/IMG-6893.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/cHQPgzj4/IMG-6888.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/dVLXm3Xf/IMG-6885.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/kGsZwbq0/IMG-6886.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/63NmX03s/IMG-4366.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/zvz2LGK0/IMG-4367.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/prsGKMBx/IMG-4370.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/gk0BmrY0/IMG-4371.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/fRt2SFSn/IMG-4368.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/kGgwJhPH/IMG-4374.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/PrcKH436/IMG-4376.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/fRV86FMq/IMG-4381.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/HsyqMVyk/IMG-4385.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/qBbKK7dS/IMG-4386.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/05wnd389/IMG-4388.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/RZNLhbbr/IMG-4389.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/fLTc42dg/IMG-4391.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/FzbGNdRT/IMG-4392.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/XY63sTS3/IMG-4393.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Cx9vCVWH/IMG-4395.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/kMfPQBwQ/IMG-4396.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/CLrZQMMD/IMG-4398.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/L4zwDhTC/IMG-4399.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/yN3s8szM/IMG-4400.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/59Cn1tkB/IMG-4401.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/g0s1V0PX/IMG-4402.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/Jn1DFPgY/IMG-4403.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/q7cQnDy1/IMG-4404.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/RFK3q2t0/IMG-4407.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/gcV0VR2t/IMG-4408.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/W1CjLb4J/IMG-4409.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/Ss7pM6fW/IMG-4410.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/nrFfYX3N/IMG-4412.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/cHWp0KG6/IMG-4413.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/4yNjHrdg/IMG-4414.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/hPX5F8Qp/IMG-4415.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/vHCSG1WM/IMG-4416.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/x1Hp80Rm/IMG-4417.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/FHRcCGfH/IMG-4418.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/13hhJ77p/IMG-4419.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/J4WCQd2j/IMG-4420.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/Dydkpd9H/IMG-4421.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/mrkvDxPW/IMG-4422.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/76Tj3g1B/IMG-4425.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/3N5Vndn3/IMG-4426.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/05DLr0yj/IMG-4427.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/GhR6DT4Q/IMG-4428.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/fRTF24jS/IMG-4430.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/R0WYmcYM/IMG-4431.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/nrJSqNhz/IMG-4432.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/tC9mJ0cv/IMG-4438.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/XNkQTHvf/IMG-5561.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/Mpv5fzm5/IMG-4439.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/T1tjhsyB/IMG-4720.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/c4JMPd2W/IMG-4724.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/g2XykNGB/IMG-4727.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/y8MmJcd6/IMG-4728.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/Lsjzj5Yt/IMG-4729.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/bNdk33SN/IMG-4893.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/4x9tTy1D/IMG-5563.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/DZshzKv6/IMG-5576.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Fsvr71JL/IMG-5573.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/Fz3HwLk9/IMG-5569.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/wjH180kn/IMG-5566.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/MG6qtLYK/IMG-5565.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/CKgDNYVb/IMG-5577.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/C5XnfpNB/IMG-5579.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/4y7mGFgJ/IMG-5716.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/FzM1Hgr0/IMG-5717.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/rF4KYbjj/IMG-5720.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/6pLTBvDG/IMG-5721.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/VNK6Ccsf/IMG-5722.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/wx72fhr2/IMG-5968.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/QdrqdvdY/IMG-5969.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/0yd0MZ6k/IMG-5971.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/1zmcp66p/IMG-5973.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/wBw5Fvcn/IMG-5974.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/R0pfKYvB/IMG-5976.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/9fQZ425b/IMG-5975.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/v8V9xXjJ/IMG-6137.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/WbmkXzsS/IMG-6138.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/Dw2bDhZh/IMG-6140.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/ZqQBCyLY/IMG-6144.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/qRCtnMms/IMG-6145.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/1Rwn3XVP/IMG-6146.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/Kv51tW5H/IMG-6147.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/nhcC21Rc/IMG-6148.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/fTWzQRx8/IMG-6149.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/LXyyqDbY/IMG-6294.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/7Zgm1wRy/IMG-6295.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/5tbpnDcQ/IMG-6296.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/YSRRV8kn/IMG-6297.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/k45sd8gn/IMG-6375.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/50k390X8/IMG-6376.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/90RBDh9K/IMG-6377.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/cCpBYbMH/IMG-6552.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/Pf9g2fSL/IMG-6554.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/gkhf597g/IMG-6555.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/g2PfbSFm/IMG-6556.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/pLY3WfR8/IMG-6557.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/65Cmcr7S/IMG-6559.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Y94XWYKd/IMG-6560.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/ydwLXx7s/IMG-6562.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/G3y73Fj2/IMG-6563.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/TYvkKKkc/IMG-6565.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/GmcqjZn8/IMG-6566.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/k5Gs0K47/IMG-6567.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/XJy8JWdh/IMG-6568.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/fycfcvHf/IMG-6569.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/J7ZxC11H/IMG-6570.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/hPnrSHjy/IMG-4434.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/YqxxjbLp/IMG-6572.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/wjfcQMkZ/IMG-6573.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/Vv8jkCYr/IMG-6574.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/MZ77rdDy/IMG-6850.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/T3NvqJCZ/IMG-6851.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/28TsrxRV/IMG-6852.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/VkV2bLNw/IMG-6853.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/gJ95NSRB/IMG-6854.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/d1qsQsbQ/IMG-6855.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/gJNYx9pV/IMG-6856.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/fyPDvxJk/IMG-6860.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/QMDsSNxg/IMG-6861.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/vBqsQW7X/IMG-6858.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/Y0vwjhb7/IMG-6857.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/90sH9Cn7/IMG-6868.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/Y2PHZzCC/IMG-6866.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/7Z8yYP7v/IMG-6889.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/nryNzTXK/IMG-6915.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Qx5dqyJ3/IMG-6917.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/Wbr0JSDD/IMG-5316.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/tgR6wjBP/IMG-5570.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/d0WCKxff/IMG-6932.gif', name: '14' }, { id: 'frame_11', url: 'https://i.postimg.cc/Ss3znzk7/IMG-6934.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/nrm9BcL8/IMG-6941.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/ZYvd1jxf/IMG-6937.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/sDFhySn3/IMG-6936.gif', name: '14' }, { id: 'frame_13', url: 'https://i.postimg.cc/43PhvxRq/IMG-6922.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/3Rb46fRZ/IMG-6923.gif', name: '14' }, { id: 'frame_13', url: 'https://i.postimg.cc/PJppkbvn/IMG-6918.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/XqRZNZ9G/IMG-6916.gif', name: '14' }, { id: 'frame_14', url: 'https://i.postimg.cc/RVt6sRzc/IMG-6939.gif', name: '14' }, { id: 'frame_13', url: 'https://i.postimg.cc/mgGc0HbK/IMG-6926.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/P5zLh5JJ/IMG-6942.gif', name: '14' }, { id: 'frame_14', url: 'https://i.postimg.cc/xCqqKGRN/IMG-6929.gif', name: '14' },
              { id: 'frame_12', url: 'https://i.postimg.cc/7LSRp4hx/e7fa949b9pc84cff0dabe57defceb54c.gif', name: '12' },
            { id: 'frame_13', url: 'https://i.postimg.cc/DZgMwc1H/817178fdbpf2ff7740dc98e26ab78759.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/3NffgJSZ/e09c07034ld7e62266c0a5de6a36ae62.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/vHDNGfT2/35ac7f372v588bf48d4f659077196b85.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/KvVsjjgG/3c3aa5219s18b90187ef1f54b3db7ba8.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/k5P1NHcL/55f3e31d8qbc8a02d152b07b99d31567.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/FFCTCzpy/641bad3b3udc599fdb63ca75fde427e5.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/8k7YSLjK/1689aa46aqc4b9ffc0f970e668f56537.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/J0CZSwyW/IMG-6938.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/Df1qLzDf/IMG-6927.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/CLNkrQSW/IMG-6925.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/y8p9s3Jj/IMG-6919.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/Lsr1Zd3Z/IMG-6928.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/Ssgbv41n/IMG-6876.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/SNByPrf9/IMG-7005.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/Z5nrCyS5/IMG-7006.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/mDfMXXFP/IMG-7007.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/DZrGtrqB/IMG-7008.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/ZnJNZWHZ/IMG-7009.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/RhGH0vpt/IMG-7010.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/tRzPkzRg/IMG-7012.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/wTTNGs3Q/IMG-7013.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/3JSG5Jv5/IMG-7014.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/rwDr8X1d/IMG-7015.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/DzDy2vS7/IMG-7017.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/QMVdG9x6/IMG-7016.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/mZ9hgH3J/IMG-7019.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/t4ksHGdg/IMG-7020.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/hP9JpdfT/IMG-7023.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/wTKyXVT9/IMG-7024.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/ZqjKXPSv/IMG-7025.gif', name: '14' },
        
          { id: 'frame_14', url: 'https://i.postimg.cc/gj3Tmqz5/mmexport1751030241029.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/4yCXW52F/mmexport1751030908335.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/VkXngG72/mmexport1751031208329.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/LscBkxZb/mmexport1751017556565.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/1XqzGKwJ/mmexport1751018282681.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/8kHCQwbQ/mmexport1751020645824.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/HWynLK7f/mmexport1751021724230.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/JnwFp3Kx/mmexport1751031208329.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/HLZNWkQw/mmexport1751031767634.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/vH2X6N1y/mmexport1751032231179.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/NFS4ZyvM/mmexport1751032686953.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/3RpmWc8c/mmexport1751033102811.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/L5RLr3tg/mmexport1751035976943.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/4NCPsp5d/mmexport1751034427637.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/CMv02LHm/mmexport1751034842120.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/rFnSzWGx/mmexport1751035618517.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/7YRbzN51/mmexport1751036276038.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/cJpbtPWq/mmexport1751036607799.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/HxLV5v92/mmexport1751036977582.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/D01rYy86/mmexport1751037965259.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/J4fwkTLW/mmexport1751038167142.gif', name: '14' },
          
          
        { id: 'frame_14', url: 'https://i.postimg.cc/xjpN4swz/IMG-7240.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/ZnzbGdxX/IMG-7239.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/DyYDmKtw/IMG-7238.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/W40f9qtd/IMG-7098.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/8PsK20jQ/IMG-7236.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/cHsTXDVz/IMG-7235.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/sXwm8Yzg/IMG-7234.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/xTk5xN49/IMG-7233.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/k5yv6QBv/IMG-7232.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/yx2m4nbs/IMG-7231.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/vZt0fFKn/IMB-r-HMBXY.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/pddJj9zN/IMG-7094.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/rmB17Qbc/IMB-f-VDf-Fc.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/VkKjzYTK/IMB-f4kk-CT.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/B6KD52vz/IMG-7096.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/9XPwWmwy/IMB-Kf7um-P.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/mrFhKBGz/IMB-e-QWBpa.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/bw4wxW2z/IMB-16r-COL.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/3x0Kx1fz/IMB-K1u-Jp-P.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/CLz0cJ0d/IMG-7116.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/fyyGgW61/IMG-7115.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/gkk7s0vD/IMG-6984.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/0NpZPgYj/IMG-6985.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/tTWKKmTN/IMG-7073.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/jS8tc9wW/IMG-7083.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/rmRVKJpD/IMG-7087.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/zvWGPjms/IMG-7090.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/YSkqDg8V/IMG-7092.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/FzqHTBng/IMG-7093.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/tTpZ6wLs/IMG-7095.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/8P5vt8sW/IMG-7097.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/wMxmCZVC/IMG-7099.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/2jxd0FGp/IMG-7100.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/B6T59xGK/IMG-7101.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/kXfcgFRN/IMG-7106.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/htZppbS4/IMG-7107.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/hPgyjtyn/IMG-7108.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/HLKvs0Kv/IMG-7109.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/wjwbnYkp/IMG-7111.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/bJDMQVkj/IMG-7112.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/SNWBTP5S/IMG-7113.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/jCVMQsKH/IMG-7114.gif', name: '14' },
          
          ];
                // --- 已修正 ---
               // 【核心修复】在 state 对象中初始化 cache 属性
let state = { chats: {}, activeChatId: null, globalSettings: {}, apiConfig: {}, userStickers: [], worldBooks: [], personaPresets: [], qzoneSettings: {}, activeAlbumId: null, cache: { songs: new Map(), lyrics: new Map() }, ttsCache: new Map() };
                // --- 修正结束 ---
// ▼▼▼ 在 let state = ... 之后，粘贴这个新变量 ▼▼▼
let werewolfGameState = {
    isActive: false,
    gameMode: null, // '6p', '9p', '12p'
    chatId: null, // 如果是从群聊发起的，记录群聊ID
    players: [], // { id, name, avatar, role, isAlive, character_persona }
    currentDay: 1,
    currentPhase: 'setup', // setup, night, discussion, voting, gameover
    nightActions: {}, // 存储当晚的行动结果
    gameLog: [], // 存储游戏事件日志
    discussionLog: [], // 存储讨论对话
    voteResults: {},
    electionInfo: {
        candidates: [],
        votes: {}
    },
    sheriffId: null,
    lastFailedAction: null,
};
// ▲▲▲ 新增变量结束 ▲▲▲        
        let thoughtsHistoryRenderCount = 0;
        const THOUGHTS_RENDER_WINDOW = 15; // 每次加载15条历史记录
        // ▼▼▼ 在JS顶部，变量定义区，添加这个新变量 ▼▼▼
        // ▼▼▼ 【全新】为动态分页加载添加的变量 ▼▼▼
        let qzonePostsRenderCount = 0;
        const QZONE_RENDER_WINDOW = 10; // 每次加载10条动态
        // ▲▲▲ 新增代码结束 ▲▲▲
        let qzonePostsCache = []; // 用于缓存已加载的动态帖子数据
        // ▲▲▲ 添加结束 ▲▲▲
        let musicState = { 
            isActive: false, 
            activeChatId: null, 
            isPlaying: false, 
            playlist: [], 
            currentIndex: -1, 
            playMode: 'order', 
            totalElapsedTime: 0, 
            timerId: null,
            // 【新增】歌词相关状态
            parsedLyrics: [],      // 当前歌曲解析后的歌词数组
            currentLyricIndex: -1  // 当前高亮的歌词行索引
        };
        let qzoneStickerPanelState = {
            isOpen: false,
            activePostId: null,
            panelEl: null,
            gridEl: null
        };
                const audioPlayer = document.getElementById('audio-player');
                let newWallpaperBase64 = null;
                let isSelectionMode = false;
let cphoneRenderedCount = 0;
let cphoneActiveConversationType = null; // 用于记录Cphone中当前打开的对话类型
let isLoadingMoreCphoneMessages = false;
        let activeStickerCategoryId = 'all'; // 用于跟踪当前选中的表情分类
                let selectedMessages = new Set();
                let editingMemberId = null;
let isAddingNpcToGroup = false; // 用于跟踪是否正在为群聊创建新NPC
                let editingWorldBookId = null;
               let editingRuleId = null; // 用于存储正在编辑的规则ID
let isLoadingMoreChats = false; // 防止在加载时重复触发
let isLoadingMoreMessages = false; // 【全新】为聊天记录添加独立的加载状态
let isLoadingMoreThoughts = false; // 【全新】为心声历史添加独立的加载状态
let isLoadingMorePosts = false;    // 【全新】为动态列表添加独立的加载状态
let sortedChatListItems = [];   // 用于存储完整的、已排序的聊天列表项
                let editingPersonaPresetId = null;
                let currentReplyContext = null;
        let waimaiTimers = {}; // 用于存储外卖倒计时
        
        let activeMessageTimestamp = null;
let activeCharacterId = null; // 用于跟踪当前正在查看的CphoneID
let editingMemoId = null;
let editingDiaryId = null;
let activeDiaryForViewing = null; // 用于暂存当前正在查看的日记对象
        // ▼▼▼ 在下方粘贴新变量 ▼▼▼
        let shoppingCart = []; // 数据结构将变为 [{ productId: 123, quantity: 1 }, ...]
        let editingProductId = null; // 用于存储正在编辑的商品ID
        let activeProductId = null; // 用于存储当前查看的商品ID
        // ▲▲▲ 新增结束 ▲▲▲
        // ▼▼▼ 【全新】为动态评论区回复功能添加的状态变量 ▼▼▼
        let currentQzoneReplyContext = null; // 用于存储回复上下文 { postId, replyToName, replyToDisplayName }
        // ▲▲▲ 新增代码结束 ▲▲▲
        let activePostId = null; // <-- 新增：用于存储当前操作的动态ID
        let activeDoubanPostId = null;
                let photoViewerState = {
                    isOpen: false,
                    photos: [], // 存储当前相册的所有照片URL
                    currentIndex: -1, // 当前正在查看的照片索引
                };
        
                let unreadPostsCount = 0;
        
                let isFavoritesSelectionMode = false;
                let selectedFavorites = new Set()
        
        let simulationIntervalId = null;
        
                const defaultAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg';
                const defaultMyGroupAvatar = 'https://i.postimg.cc/cLPP10Vm/4.jpg';
                const defaultGroupMemberAvatar = 'https://i.postimg.cc/VkQfgzGJ/1.jpg';
                const defaultGroupAvatar = 'https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg';
                let notificationTimeout;
                let ruleCache = {}; // 用于缓存渲染规则
// 在你的JS顶部变量定义区，添加这个新常量
const DEFAULT_NOTIFICATION_SOUND = 'https://www.myinstants.com/media/sounds/notification-sound-2.mp3'; // 默认的微信提示音
        // ▼▼▼ 在JS顶部，变量定义区，添加这个新变量 ▼▼▼
        let gomokuState = {}; // 用于存储每个聊天的五子棋状态
let readingState = {}; // { chatId: { isActive, isMinimized, title, ... } }
        let originalChatMessagesPaddingTop = null; // 用于存储消息区的原始顶部内边距
        
        // ▲▲▲ 新增代码结束 ▲▲▲
// ▼▼▼ 【请用这个 V2 版本】替换旧的 DEFAULT_APP_ICONS 常量 ▼▼▼
        const DEFAULT_APP_ICONS = {
            'qq': 'https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg',
            'world-book': 'https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg',
            'wallpaper': 'https://i.postimg.cc/T1j03pQr/IMG-6440.jpg',
            'renderer': 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756312261242_qdqqd_g0eriz.jpeg',
            'api-settings': 'https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg',
            'font': 'https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg',
            // 【核心新增】将Cphone(Cphone)和豆瓣也加入管理列表
            'char-phone': 'https://i.postimg.cc/pXj9h20L/IMG-7275.jpg',
            'douban': 'https://i.postimg.cc/Pq2xJN1g/IMG-7301.jpg',
    // 【【【核心新增：在这里为“预设”App注册一个唯一的ID和默认图标】】】
    'preset': 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758510900942_qdqqd_djw0z2.jpeg',
            // ▼▼▼ 在这里添加新的一行 ▼▼▼
            'tutorial': 'https://i.postimg.cc/d10GjC4g/IMG-7302.jpg',
    'werewolf': 'https://i.postimg.cc/k401K5g7/IMG-7304.jpg',
    // ▼▼▼ 在这里添加新的一行 ▼▼▼
    'x': 'https://i.postimg.cc/Y9d3BztC/1.png'
        };
        // ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 【全新】这是为CPhone图标设置新增的常量 ▼▼▼
        const DEFAULT_CPHONE_ICONS = {
            'qq': 'https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg',
            'album': 'https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg',
            'browser': 'https://i.postimg.cc/KzC2gTq6/IMG-7276.jpg',
            'taobao': 'https://i.postimg.cc/L6R7x16R/IMG-7278.jpg',
            'memo': 'https://i.postimg.cc/J0b6Nym4/IMG-7279.jpg',
            'diary': 'https://i.postimg.cc/DZ541sbt/IMG-7280.jpg',
            'amap': 'https://i.postimg.cc/Jz2Tz0dw/IMG-7281.jpg',
            'usage': 'https://i.postimg.cc/WbF8kzz9/IMG-7282.jpg',
            'music': 'https://is1-ssl.mzstatic.com/image/thumb/Purple112/v4/64/9d/21/649d21e8-a151-6136-3914-256e54f15d9a/AppIcon-0-0-1x_U007emarketing-0-0-0-7-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/1200x630wa.png',
            'ephone': 'https://i.postimg.cc/pXj9h20L/IMG-7275.jpg'
        };
        // ▲▲▲ 新增代码结束 ▲▲▲
        let repostTargetId = null; // 用于存储当前要转发的动态ID
                const STICKER_REGEX = /(^https:\/\/i\.postimg\.cc\/.+|^https:\/\/files\.catbox\.moe\/.+|^https?:\/\/sharkpan\.xyz\/.+|^data:image|\.(png|jpg|jpeg|gif|webp)\?.*$|\.(png|jpg|jpeg|gif|webp)$)/i;
                
                let currentRenderedCount = 0;
                let lastKnownBatteryLevel = 1;
                let alertFlags = { hasShown40: false, hasShown20: false, hasShown10: false };
                let batteryAlertTimeout;
                const dynamicFontStyle = document.createElement('style');
                dynamicFontStyle.id = 'dynamic-font-style';
                document.head.appendChild(dynamicFontStyle);
        
                const modalOverlay = document.getElementById('custom-modal-overlay');
                const modalTitle = document.getElementById('custom-modal-title');
                const modalBody = document.getElementById('custom-modal-body');
                const modalConfirmBtn = document.getElementById('custom-modal-confirm');
                const modalCancelBtn = document.getElementById('custom-modal-cancel');
                let modalResolve;
        
                function showCustomModal() { 
                    modalOverlay.classList.add('visible'); 
                }
        
                function hideCustomModal() { 
                    modalOverlay.classList.remove('visible'); 
                    modalConfirmBtn.classList.remove('btn-danger'); 
                    if (modalResolve) modalResolve(null); 
                }
        /**
         * 【全新】根据保存的设置，应用歌词栏的CSS样式
         * @param {object} chat - 当前的聊天对象
         */
        function applyLyricsBarPosition(chat) {
            const lyricsBar = document.getElementById('global-lyrics-bar');
            // 如果聊天没有设置，则使用默认值
            const settings = chat.settings.lyricsPosition || { vertical: 'top', horizontal: 'center', offset: 10 };
            
            // 重置所有可能影响位置的属性
            lyricsBar.style.top = 'auto';
            lyricsBar.style.bottom = 'auto';
            lyricsBar.style.left = 'auto';
            lyricsBar.style.right = 'auto';
            lyricsBar.style.transform = 'none';
        
            // 1. 设置垂直位置和偏移量
            if (settings.vertical === 'top') {
                lyricsBar.style.top = `${settings.offset}px`;
            } else { // 'bottom'
                lyricsBar.style.bottom = `${settings.offset}px`;
            }
            
            // 2. 设置水平对齐
            switch (settings.horizontal) {
                case 'left':
                    lyricsBar.style.left = '15px'; // 留出一些边距
                    break;
                case 'right':
                    lyricsBar.style.right = '15px'; // 留出一些边距
                    break;
                case 'center':
                default:
                    lyricsBar.style.left = '50%';
                    lyricsBar.style.transform = 'translateX(-50%)';
                    break;
            }
        }
        // ▼▼▼ 把这个【全新的函数】粘贴到你的JS功能函数定义区 ▼▼▼
        // ▼▼▼ 【全新】本地上传群头像并由副API识别的核心功能 ▼▼▼
        
        /**
         * 【全新】处理用户从本地上传群头像的流程
         * @param {Event} event - 文件输入框的 change 事件对象
         */
        async function handleLocalGroupAvatarUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
        
            // 1. 读取文件为 Base64
            const base64Url = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.readAsDataURL(file);
            });
        
            // 2. 弹出提示，开始识图
            await showCustomAlert("请稍候...", "正在请求AI为新群头像命名...");
        
            try {
                // 3. 调用通用的API识图函数获取描述
                const description = await getAvatarDescriptionFromApi(base64Url);
                
                if (!description) {
                    throw new Error("AI未能成功描述图片。");
                }
        
                // 4. 将描述作为名字，和图片URL一起存入群头像库
                const chat = state.chats[state.activeChatId];
                if (!chat.settings.groupAvatarLibrary) {
                    chat.settings.groupAvatarLibrary = [];
                }
                chat.settings.groupAvatarLibrary.push({ name: description, url: base64Url });
                
                // 5. 保存并刷新
                await db.chats.put(chat);
                renderGroupAvatarLibrary();
                await showCustomAlert("上传成功！", `AI已将新群头像命名为：“${description}”`);
        
            } catch (error) {
                console.error("本地群头像上传及识别失败:", error);
                await showCustomAlert("操作失败", `无法为头像命名，请检查（主/副）API配置是否正确并支持Vision。\n错误: ${error.message}`);
            } finally {
                // 无论成功与否，都清空文件输入框
                event.target.value = null;
            }
        }
        // ▲▲▲ 全新功能函数粘贴结束 ▲▲▲
        // ▼▼▼ 【全新】本地上传头像并由副API识别的核心功能 ▼▼▼
        
        /**
         * 【全新】处理用户从本地上传头像的流程
         * @param {Event} event - 文件输入框的 change 事件对象
         */
        async function handleLocalAvatarUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
        
            // 1. 读取文件为 Base64，这是发送给API和存储的必要格式
            const base64Url = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.readAsDataURL(file);
            });
        
            // 2. 弹出提示，开始识图
            await showCustomAlert("请稍候...", "正在请求AI为新头像命名...");
        
            try {
                // 3. 调用API获取图片描述（这个描述将作为头像的名字）
                const description = await getAvatarDescriptionFromApi(base64Url);
                
                if (!description) {
                    throw new Error("AI未能成功描述图片。");
                }
        
                // 4. 将描述作为名字，和图片URL一起存入头像库
                const chat = state.chats[state.activeChatId];
                if (!chat.settings.aiAvatarLibrary) {
                    chat.settings.aiAvatarLibrary = [];
                }
                chat.settings.aiAvatarLibrary.push({ name: description, url: base64Url });
                
                // 5. 保存并刷新
                await db.chats.put(chat);
                renderAiAvatarLibrary();
                await showCustomAlert("上传成功！", `AI已将新头像命名为：“${description}”`);
        
            } catch (error) {
                console.error("本地头像上传及识别失败:", error);
                await showCustomAlert("操作失败", `无法为头像命名，请检查（主/副）API配置是否正确并支持Vision。\n错误: ${error.message}`);
            } finally {
                // 无论成功与否，都清空文件输入框，以便下次能选择同一个文件
                event.target.value = null;
            }
        }
        
        /**
         * 【全新】调用（副）API来获取图片的描述
         * @param {string} base64Url - 图片的 Base64 Data URL
         * @returns {Promise<string>} - 返回AI生成的图片描述
         */
        async function getAvatarDescriptionFromApi(base64Url) {
            // 智能选择API：优先使用副API，如果未配置则自动回退到主API
            const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
            const { proxyUrl, apiKey, model } = useSecondaryApi 
                ? { proxyUrl: state.apiConfig.secondaryProxyUrl, apiKey: state.apiConfig.secondaryApiKey, model: state.apiConfig.secondaryModel }
                : state.apiConfig;
        
            if (!proxyUrl || !apiKey || !model) {
                throw new Error("主API和副API均未配置或配置不完整。");
            }
        
            const prompt = "请为这张图片起一个简洁的、适合作为头像库标签的名字。例如：“微笑自拍”、“阳光下的猫咪”、“蓝发动漫少女”。请直接回答名字，不要加任何多余的解释。";
            
            let isGemini = proxyUrl.includes('generativelanguage');
            let response;
        
            if (isGemini) {
                const mimeType = base64Url.match(/^data:(.*);base64/)[1];
                const base64Data = base64Url.split(',')[1];
                const payload = {
                    contents: [{
                        parts: [
                            { text: prompt },
                            { inline_data: { mime_type: mimeType, data: base64Data } }
                        ]
                    }]
                };
                response = await fetch(`${proxyUrl}/${model}:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
        
            } else { // OpenAI 兼容 Vision API
                const payload = {
                    model: model,
                    messages: [{
                        role: 'user',
                        content: [
                            { type: 'text', text: prompt },
                            { type: 'image_url', image_url: { url: base64Url } }
                        ]
                    }],
                    max_tokens: 50 // 限制输出长度
                };
                response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                    body: JSON.stringify(payload)
                });
            }
        
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API 错误: ${errorData.error.message}`);
            }
        
            const data = await response.json();
            let description = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
            
            // 清理AI可能返回的多余字符
            return description.trim().replace(/["'“”‘’]/g, '');
        }
        // ▲▲▲ 全新功能函数粘贴结束 ▲▲▲
        /**
         * 【全新】当单聊角色的名称被修改后，自动同步其在所有群聊中的信息
         * @param {object} characterChat - 被修改了名称的【单聊】chat对象
         */
        async function syncCharacterNameInGroups(characterChat) {
            // 1. 安全检查：确保传入的是一个有效的单聊对象
            if (!characterChat || characterChat.isGroup) {
                console.warn("syncCharacterNameInGroups: 传入的不是有效的单聊对象，已跳过同步。");
                return;
            }
        
            const characterId = characterChat.id;
            const newRemarkName = characterChat.name;        // 这是角色新的【备注名】
            const newOriginalName = characterChat.originalName;  // 这是角色新的【本名】
        
            console.log(`正在为角色 ${characterId} 同步所有群聊内的名称信息...`);
        
            // 2. 遍历内存中所有的聊天记录，找出所有群聊
            for (const chatId in state.chats) {
                const groupChat = state.chats[chatId];
                
                // 3. 筛选出群聊，并确保它有成员列表
                if (groupChat.isGroup && groupChat.members) {
                    // 4. 在群聊中查找对应的成员
                    const memberToUpdate = groupChat.members.find(m => m.id === characterId);
        
                    // 如果在这个群里找到了该成员
                    if (memberToUpdate) {
                        let needsDbUpdate = false; // 标记是否需要更新数据库，以优化性能
                        
                        // 5. 对比并更新群内昵称 (groupNickname)，它应该与单聊的备注名(name)保持一致
                        if (memberToUpdate.groupNickname !== newRemarkName) {
                            memberToUpdate.groupNickname = newRemarkName;
                            needsDbUpdate = true;
                        }
        
                        // 6. 对比并更新群内的本名 (originalName)
                        if (memberToUpdate.originalName !== newOriginalName) {
                            memberToUpdate.originalName = newOriginalName;
                            needsDbUpdate = true;
                        }
        
                        // 7. 如果有任何更新，就把这个【整个群聊对象】也保存回数据库
                        if (needsDbUpdate) {
                            await db.chats.put(groupChat);
                            console.log(`成功将群聊 "${groupChat.name}" 中的成员信息更新`);
                        }
                    }
                }
            }
        }
        
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        
        // ▼▼▼ 【全新】请将这个全新的函数粘贴到 syncCharacterNameInGroups 的下方 ▼▼▼
        /**
         * 【全新】当单聊角色的头像被修改后，自动同步其在所有群聊中的头像信息
         * @param {object} characterChat - 被修改了头像的【单聊】chat对象
         */
        async function syncCharacterAvatarInGroups(characterChat) {
            // 1. 安全检查，确保是有效的单聊对象
            if (!characterChat || characterChat.isGroup) {
                console.warn("syncCharacterAvatarInGroups: 传入的不是有效的单聊对象，已跳过同步。");
                return;
            }
        
            const characterId = characterChat.id;
            const newAvatar = characterChat.settings.aiAvatar; // 获取最新的头像URL
        
            console.log(`正在为角色 ${characterId} 同步所有群聊内的头像...`);
        
            // 2. 遍历所有聊天，找出所有群聊
            for (const groupChat of Object.values(state.chats)) {
                if (groupChat.isGroup && groupChat.members) {
                    // 3. 在群聊中查找对应的成员
                    const memberToUpdate = groupChat.members.find(m => m.id === characterId);
                    
                    // 4. 如果找到了该成员，并且头像信息不一致，就更新它
                    if (memberToUpdate && memberToUpdate.avatar !== newAvatar) {
                        memberToUpdate.avatar = newAvatar; // 将新头像同步到群成员数据中
                        
                        // 5. 【至关重要】将修改后的【整个群聊对象】存回数据库
                        await db.chats.put(groupChat);
                        console.log(`成功将角色 ${characterId} 的新头像同步到群聊 "${groupChat.name}"`);
                    }
                }
            }
        }
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        // ▼▼▼ 【最终修复版】请用这个全新的、更智能的函数，完整替换旧的 getDisplayNameInGroup 函数 ▼▼▼
        /**
         * 【全新 | 已修复用户识别问题】根据角色本名，在指定群聊中获取其正确的显示名称（群昵称）
         * @param {object} groupChat - 当前的群聊对象
         * @param {string} originalName - 角色的本名 (e.g., "小可爱", "方亦楷")
         * @returns {string} - 该角色在此群聊中的群昵称，如果找不到则返回其本名
         */
        function getDisplayNameInGroup(groupChat, originalName) {
            // 安全检查，如果信息不全则直接返回
            if (!groupChat || !groupChat.isGroup || !originalName) {
                return originalName;
            }
        
            // --- 【【【核心修复就在这里！】】】 ---
        
            // 步骤1：优先检查这个“本名”是不是【用户自己】的全局本名
            // 用户的全局本名存储在 qzoneSettings.nickname 中
            const userOriginalName = state.qzoneSettings.nickname || '{{user}}';
            if (originalName === userOriginalName) {
                // 如果是用户，就返回用户在【这个群聊中】的专属昵称
                return groupChat.settings.myNickname || '我';
            }
        
            // 步骤2：如果不是用户，再到群成员列表里去查找对应的AI角色
            const member = groupChat.members.find(m => m.originalName === originalName);
            
            // 步骤3：如果找到了AI成员，就返回TA的群昵称；如果都找不到，就返回原始名字作为保底
            return member ? member.groupNickname : originalName;
        }
        // ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 【全新】请将这个函数粘贴到JS功能函数定义区 ▼▼▼
        
        /**
         * 【全新】切换渲染规则的分类页签
         * @param {string} categoryId - 要切换到的分类ID ('global' 或 聊天ID)
         */
        function switchRuleCategory(categoryId) {
            // 切换页签的激活状态
            document.querySelectorAll('.rules-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.categoryId === categoryId);
            });
            // 切换内容面板的显示状态
            document.querySelectorAll('.rules-category-pane').forEach(pane => {
                pane.classList.toggle('active', pane.dataset.categoryId === categoryId);
            });
        }
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        // ▼▼▼ 【全新】请将这个函数粘贴到JS功能函数定义区 ▼▼▼
        /**
         * 【全新】根据角色的本名，在整个应用中查找其正确的显示名称
         * @param {string} originalName - 角色的本名 (e.g., "李星辰")
         * @returns {string} - 该角色的备注名/群昵称/用户昵称，如果找不到则返回其本名
         */
        // ▼▼▼ 请用这个【全新、更智能】的函数，完整替换旧的 getDisplayNameByOriginalName 函数 ▼▼▼
        
        /**
         * 【全新】根据角色的本名或曾用名，在整个应用中查找其正确的【当前显示名称】
         * @param {string} nameIdentifier - 角色的本名 或 储存在旧数据中的曾用名
         * @returns {string} - 该角色的【当前】备注名/群昵称/用户昵称，如果找不到则返回传入的标识符
         */
        function getDisplayNameByOriginalName(nameIdentifier) {
            // 1. 如果传入的是空值，直接返回
            if (!nameIdentifier) return '';
        
            // 2. 检查是不是用户自己
            if (state.qzoneSettings && nameIdentifier === state.qzoneSettings.nickname) {
                return state.qzoneSettings.nickname;
            }
            
            // 3. 【主要查找方式】: 通过“本名” (originalName) 查找。
            // 这是最标准、最可靠的方式，适用于所有新创建的数据。
            let characterChat = Object.values(state.chats).find(chat => !chat.isGroup && chat.originalName === nameIdentifier);
            if (characterChat) {
                return characterChat.name; // 如果找到，返回该角色【当前】的备注名
            }
        
            // 4. 【兼容旧数据】: 如果通过“本名”没找到，就尝试把传入的名字当作一个【旧的备注名】去历史记录里查找。
            characterChat = Object.values(state.chats).find(chat => 
                !chat.isGroup && 
                (chat.nameHistory && chat.nameHistory.includes(nameIdentifier))
            );
            if (characterChat) {
                return characterChat.name; // 如果在历史记录里找到了，同样返回该角色【当前】的备注名
            }
        
            // 5. 【最终备用方案】: 如果以上方法都找不到，说明这可能是一个非常旧的数据，或者角色已被删除。
            // 此时，直接返回储存在评论里的那个名字，至少能保证有内容显示。
            return nameIdentifier;
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 请用这个【全新的、更智能的】函数，完整替换旧的 processMentions 函数 ▼▼▼
        
        /**
         * 【全新】处理AI生成的文本，将特殊的@占位符替换为正确的显示名称
         * @param {string} text - AI生成的、可能包含 @[[本名]] 占位符的原始文本
         * @param {object|null} chat - 当前的聊天对象 (如果是群聊，则用于查找群昵称)
         * @returns {string} - 处理完成后，对用户友好的显示文本
         */
        function processMentions(text, chat = null) {
            // 如果文本无效或不包含@标记，直接返回以提高性能
            if (!text || typeof text !== 'string' || !text.includes('@[[')) {
                return text; 
            }
            
            // 使用正则表达式的全局匹配，一次性处理所有@提及
            return text.replace(/@\[\[([^\]]+)\]\]/g, (match, originalName) => {
                const trimmedOriginalName = originalName.trim();
                let displayName;
                
                // 【核心逻辑】如果提供了聊天对象，并且是群聊
                if (chat && chat.isGroup) {
                    // 就调用我们现有的、强大的 getDisplayNameInGroup 函数
                    // 这个函数会自动优先查找群昵称，找不到再用本名
                    displayName = getDisplayNameInGroup(chat, trimmedOriginalName);
                } else {
                    // 如果是私聊或没有提供聊天对象，就使用全局查找函数
                    displayName = getDisplayNameByOriginalName(trimmedOriginalName);
                }
                
                // 返回转换后的、带@的正确昵称
                return `@${displayName}`;
            });
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 请用这个【修正后】的完整函数，替换掉您现有的 showCustomConfirm 函数 ▼▼▼
        
        function showCustomConfirm(title, message, options = {}) {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p>${message}</p>`;
        
                // 【核心修正】在函数被调用时，重新获取最新的按钮元素
                const confirmBtn = document.getElementById('custom-modal-confirm');
                const cancelBtn = document.getElementById('custom-modal-cancel');
        
                cancelBtn.style.display = 'block';
        
                confirmBtn.textContent = options.confirmText || '确定';
                cancelBtn.textContent = options.cancelText || '取消';
        
                if (options.confirmButtonClass) {
                    confirmBtn.classList.add(options.confirmButtonClass);
                } else {
                    // 确保之前的危险操作样式被移除
                    confirmBtn.classList.remove('btn-danger');
                }
        
                // 为最新的按钮绑定本次的点击事件
                confirmBtn.onclick = () => { resolve(true); hideCustomModal(); };
                cancelBtn.onclick = () => { resolve(false); hideCustomModal(); };
                showCustomModal();
            });
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
function showCustomAlert(title, message) {
    return new Promise(resolve => {
        modalResolve = resolve;
        modalTitle.textContent = title;
        modalBody.innerHTML =`<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;

        // 核心修正：在函数被调用时，重新获取最新的按钮元素
        const confirmBtn = document.getElementById('custom-modal-confirm');
        const cancelBtn = document.getElementById('custom-modal-cancel');

        cancelBtn.style.display = 'none';
        confirmBtn.textContent = '好的';

        confirmBtn.onclick = () => {
            cancelBtn.style.display = 'block'; 
            confirmBtn.textContent = '确定';
            resolve(true); 
            hideCustomModal();
        };
        showCustomModal();
    });
}
        
        // ▼▼▼ 请用这个【修正后】的完整函数，替换掉您现有的 showCustomPrompt 函数 ▼▼▼
        
        function showCustomPrompt(title, placeholder, initialValue = '', type = 'text', extraHtml = '') {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                const inputId = 'custom-prompt-input';
                
                const inputHtml = type === 'textarea' 
                    ? `<textarea id="${inputId}" placeholder="${placeholder}" rows="4" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 16px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>`
                    : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;
                
                modalBody.innerHTML = extraHtml + inputHtml;
                const input = document.getElementById(inputId);
        
                modalBody.querySelectorAll('.format-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const templateStr = btn.dataset.template;
                        if (templateStr) {
                            try {
                                const templateObj = JSON.parse(templateStr);
                                input.value = JSON.stringify(templateObj, null, 2);
                                input.focus();
                            } catch(e) { console.error("解析格式模板失败:", e); }
                        }
                    });
                });
                
                // 【核心修正】在函数被调用时，重新获取最新的按钮元素
                const confirmBtn = document.getElementById('custom-modal-confirm');
                const cancelBtn = document.getElementById('custom-modal-cancel');
                
                // 为最新的按钮绑定本次的点击事件
                confirmBtn.onclick = () => { resolve(input.value); hideCustomModal(); };
                cancelBtn.onclick = () => { resolve(null); hideCustomModal(); };
        
                showCustomModal();
                setTimeout(() => input.focus(), 100);
            });
        }
        // ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 请将这段【全新】的函数代码粘贴到 showCustomPrompt 函数的后面 ▼▼▼
        
        // ▼▼▼ 【最终修复版】请用这个全新的、更健壮的函数，完整替换旧的 showChoiceModal ▼▼▼
        /**
         * 【已修复】显示一个包含多个选项的操作菜单模态框
         * @param {string} title - 模态框的标题
         * @param {Array<object>} options - 按钮选项数组, e.g., [{ text: '按钮文字', value: '返回值' }]
         * @returns {Promise<string|null>} - 返回用户点击按钮的value，如果取消则返回null
         */
        function showChoiceModal(title, options) {
            return new Promise(resolve => {
                const modal = document.getElementById('custom-modal-overlay');
                const modalTitle = document.getElementById('custom-modal-title');
                const modalBody = document.getElementById('custom-modal-body');
                const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');
        
                // 1. 设置标题和清空内容区
                modalTitle.textContent = title;
                modalBody.innerHTML = ''; 
                
                // 2. 动态创建选项按钮
                modalFooter.innerHTML = ''; 
                modalFooter.style.flexDirection = 'column';
        
                options.forEach(option => {
                    const button = document.createElement('button');
                    button.textContent = option.text;
                    button.onclick = () => {
                        // 注意：这里我们不再调用 hideCustomModal，而是直接控制
                        modal.classList.remove('visible');
                        resolve(option.value);
                    };
                    modalFooter.appendChild(button);
                });
        
                // 3. 添加一个标准的取消按钮
                const cancelButton = document.createElement('button');
                cancelButton.textContent = '取消';
                cancelButton.style.marginTop = '8px';
                cancelButton.style.borderRadius = '8px';
                cancelButton.style.backgroundColor = '#f0f0f0';
                cancelButton.onclick = () => {
                    modal.classList.remove('visible');
                    resolve(null); // 用户取消，返回 null
                };
                modalFooter.appendChild(cancelButton);
        
                // 4. 显示模态框
                modal.classList.add('visible');
        
            }).finally(() => {
                // 5. 【【【这就是最关键的修复！】】】
                // 无论用户是选择了选项还是取消，最后都【必须】将模态框的页脚恢复为原始的、功能完整的状态。
                const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');
        
                modalFooter.style.flexDirection = 'row'; // 恢复水平布局
                // 重新创建原始的“取消”和“确定”按钮
                modalFooter.innerHTML = `
                    <button id="custom-modal-cancel">取消</button>
                    <button id="custom-modal-confirm" class="confirm-btn">确定</button>
                `;
        
                // 【重要】为新创建的按钮重新绑定它们最基本的默认事件！
                document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
                // 注意：我们不需要为“确定”按钮绑定默认事件，因为 showCustomConfirm 和 showCustomPrompt 
                // 每次调用时都会为它动态绑定新的 onclick 事件，这正是我们想要的行为。
            });
        }
        // ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 请将这个【全新】的函数粘贴到 showChoiceModal 函数的后面 ▼▼▼
        
        /**
         * 【全新】获取歌词内容（支持文件和粘贴，并修复粘贴格式）
         * @returns {Promise<string|null>} 返回歌词文本字符串，如果用户取消则返回null
         */
        async function getLrcContent() {
            // 1. 弹出选择框
            const choice = await showChoiceModal('选择歌词导入方式', [
                { text: '📁 从本地文件 (.lrc)', value: 'file' },
                { text: '📋 直接粘贴歌词文本', value: 'paste' }
            ]);
        
            // 2. 根据用户的选择执行不同操作
            if (choice === 'file') {
                // 用户选择文件：这部分逻辑不变，它工作正常
                return new Promise(resolve => {
                    const lrcInput = document.getElementById('lrc-upload-input');
                    const lrcChangeHandler = (e) => {
                        const lrcFile = e.target.files[0];
                        if (lrcFile) {
                            const reader = new FileReader();
                            reader.onload = (readEvent) => resolve(readEvent.target.result);
                            reader.onerror = () => resolve(""); // 出错时返回空字符串
                            reader.readAsText(lrcFile);
                        } else {
                            resolve(null); // 用户关闭了文件选择框
                        }
                        lrcInput.removeEventListener('change', lrcChangeHandler);
                        lrcInput.value = ''; // 重置input，以便下次能选择同名文件
                    };
                    lrcInput.addEventListener('change', lrcChangeHandler, { once: true });
                    lrcInput.click();
                });
            } else if (choice === 'paste') {
                // 用户选择粘贴：弹出文本输入框
                const pastedText = await showCustomPrompt(
                    '粘贴歌词',
                    '请在此处粘贴完整的LRC格式歌词...',
                    '',
                    'textarea' // 使用多行文本框
                );
                
                // --- ★★★ 核心修复就在这里 ★★★ ---
                if (pastedText) {
                    // 在解析之前，自动为每个时间戳前添加换行符
                    // 这会修复单行粘贴的问题
                    const formattedText = pastedText.replace(/\[/g, '\n[').trim();
                    return formattedText;
                }
                return pastedText; // 如果用户取消，这里会返回 null
                // --- ★★★ 修复结束 ★★★ ---
        
            } else {
                // 用户点击了“取消”
                return null;
            }
        }
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
                // ===================================================================
                // 2. 数据库结构定义
                // ===================================================================
        
        // ▼▼▼ 【请用这个 V30 版本】完整替换旧的 db.version(...) 代码块 ▼▼▼
        db.version(38).stores({ 
            doubanPosts: '++id, timestamp',
           chats: '&id, isGroup, groupId, isPinned, memos, diary, appUsageLog, lastIntelligentSummaryTimestamp',
           apiConfig: '&id, minimaxGroupId, minimaxApiKey',
            globalSettings: '&id', 
            userStickers: '&id, url, name, categoryId',
            worldBooks: '&id, name, categoryId',
            worldBookCategories: '++id, name',
            musicLibrary: '&id', 
            personaPresets: '&id',
            qzoneSettings: '&id',
            qzonePosts: '++id, timestamp, authorId',
            qzoneAlbums: '++id, name, createdAt',
            qzonePhotos: '++id, albumId',
            favorites: '++id, type, timestamp, originalTimestamp',
            qzoneGroups: '++id, name',
            memories: '++id, chatId, timestamp, type, targetDate',
            callRecords: '++id, chatId, timestamp, customName',
            shoppingProducts: '++id, name, description',
            apiPresets: '++id, name',
            renderingRules: '++id, name, chatId',
            appearancePresets: '++id, name, type',
            stickerCategories: '++id, name',
            customAvatarFrames: '++id, name',
            presets: '&id, name, categoryId', // 新增：预设主表
            presetCategories: '++id, name',
    readingLibrary: '++id, title, lastOpened', // 新增：书籍库
            // 【核心修改】为NPC表添加后台活动、冷却时间和最后行动时间戳字段
            npcs: '++id, name, enableBackgroundActivity, actionCooldownMinutes, lastActionTimestamp'  
        }).upgrade(tx => {
            // 这个升级函数会自动处理数据迁移
            return tx.table('worldBooks').toCollection().modify(book => {
                // 确保 content 字段是数组
                if (typeof book.content === 'string' && book.content.trim() !== '') {
                    book.content = [{
                        keys: [],
                        comment: '从旧版本迁移的条目',
                        content: book.content
                    }];
                } else if (!Array.isArray(book.content)) {
                    book.content = [];
                }

                // 【核心修改】为所有条目添加 enabled 属性，默认为 true
                book.content.forEach(entry => {
                    if (typeof entry.enabled === 'undefined') {
                        entry.enabled = true;
                    }
                });
            });
        });
        // ▲▲▲ 替换结束 ▲▲▲
window.db = db;        
                // ===================================================================
                // 3. 所有功能函数定义
                // ===================================================================
        
                function showScreen(screenId) {
                    if (screenId === 'chat-list-screen') {
                        window.renderChatListProxy(); 
                        switchToChatListView('messages-view');
                    }
                    if (screenId === 'api-settings-screen') window.renderApiSettingsProxy();
                    if (screenId === 'wallpaper-screen') window.renderWallpaperScreenProxy();
                    if (screenId === 'world-book-screen') window.renderWorldBookScreenProxy();
                    if (screenId === 'x-social-screen') window.renderXSocialScreenProxy();
                     if (screenId === 'douban-screen') renderDoubanScreen();
                    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                    const screenToShow = document.getElementById(screenId);
                    if (screenToShow) screenToShow.classList.add('active');
                    if (screenId === 'chat-interface-screen') window.updateListenTogetherIconProxy(state.activeChatId);
                    if (screenId === 'font-settings-screen') {
            loadFontPresetsDropdown(); // <-- 新增这一行
                        document.getElementById('font-url-input').value = state.globalSettings.fontUrl || '';
                        applyCustomFont(state.globalSettings.fontUrl || '', true);
                    }
                }
                window.updateListenTogetherIconProxy = () => {};
        
                function switchToChatListView(viewId) {
                    const chatListScreen = document.getElementById('chat-list-screen');
                    const views = {
                        'messages-view': document.getElementById('messages-view'),
                        'qzone-screen': document.getElementById('qzone-screen'),
                        'favorites-view': document.getElementById('favorites-view'),
                'memories-view': document.getElementById('memories-view'),
               'npc-list-view': document.getElementById('npc-list-view')
            };
                    const mainHeader = document.getElementById('main-chat-list-header');
                    const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 获取主导航栏
        
                    if (isFavoritesSelectionMode) {
                        document.getElementById('favorites-edit-btn').click(); 
                    }
        
                    // 隐藏所有视图
                    Object.values(views).forEach(v => v.classList.remove('active'));
                    // 显示目标视图
                    if (views[viewId]) {
                        views[viewId].classList.add('active');
                    }
        
                    // 更新底部导航栏高亮
                    document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => {
                        item.classList.toggle('active', item.dataset.view === viewId);
                    });
                    
                    // ▼▼▼ 【核心修正】在这里统一管理所有UI元素的显隐 ▼▼▼
                    if (viewId === 'messages-view') {
                        mainHeader.style.display = 'flex';
                        mainBottomNav.style.display = 'flex';
                    } else {
                        mainHeader.style.display = 'none';
                        mainBottomNav.style.display = 'none';
                    }
                    // ▲▲▲ 修正结束 ▲▲▲
        
            if (viewId !== 'memories-view') {
                activeCountdownTimers.forEach(timerId => clearInterval(timerId));
                activeCountdownTimers = [];
            }
        
                    // 根据视图ID执行特定的渲染/更新逻辑
                    switch (viewId) {
                        case 'qzone-screen':
                            views['qzone-screen'].style.backgroundColor = '#f0f2f5';
                            updateUnreadIndicator(0);
                            renderQzoneScreen();
                            renderQzonePosts();
                            break;
                        case 'favorites-view':
                            views['favorites-view'].style.backgroundColor = '#f9f9f9';
                            renderFavoritesScreen();
                            break;
                        case 'messages-view':
                            // 如果需要，可以在这里添加返回消息列表时要执行的逻辑
                            break;
        case 'npc-list-view':
            renderNpcListScreen(); // 切换到NPC视图时，渲染列表
            break;
                    }
                }
    // X社交页面渲染函数
      function renderXSocialScreen() {
        // 暂时为空，后续添加X社交页面的渲染逻辑
        console.log("渲染X社交页面");
      }
      window.renderXSocialScreenProxy = renderXSocialScreen;
                
                function renderQzoneScreen() {
                    if (state && state.qzoneSettings) {
                        const settings = state.qzoneSettings;
                        document.getElementById('qzone-nickname').textContent = settings.nickname;
                        document.getElementById('qzone-avatar-img').src = settings.avatar;
                        document.getElementById('qzone-banner-img').src = settings.banner;
                    }
                }
                window.renderQzoneScreenProxy = renderQzoneScreen;
        
                async function saveQzoneSettings() {
                    if (db && state.qzoneSettings) {
                        await db.qzoneSettings.put(state.qzoneSettings);
                    }
                }
        
                function formatPostTimestamp(timestamp) {
                    if (!timestamp) return '';
                    const now = new Date();
                    const date = new Date(timestamp);
                    const diffSeconds = Math.floor((now - date) / 1000);
                    const diffMinutes = Math.floor(diffSeconds / 60);
                    const diffHours = Math.floor(diffMinutes / 60);
                    if (diffMinutes < 1) return '刚刚';
                    if (diffMinutes < 60) return `${diffMinutes}分钟前`;
                    if (diffHours < 24) return `${diffHours}小时前`;
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    const hours = String(date.getHours()).padStart(2, '0');
                    const minutes = String(date.getMinutes()).padStart(2, '0');
                    if (now.getFullYear() === year) {
                        return `${month}-${day} ${hours}:${minutes}`;
                    } else {
                        return `${year}-${month}-${day} ${hours}:${minutes}`;
                    }
                }
        
        // ▼▼▼ 【全新】请将这三个函数粘贴到JS功能函数定义区 ▼▼▼
        
        /**
         * 【全新 | 性能核心 | 已集成Markdown】根据帖子数据，创建或更新单个帖子的HTML元素
         * @param {object} post - 单个帖子的数据对象
         * @returns {HTMLElement} - 创建或更新后的帖子容器DOM元素
         */
        function createOrUpdatePostElement(post) {
            const existingPostContainer = document.querySelector(`.qzone-post-container[data-post-id="${post.id}"]`);
            const isUpdating = !!existingPostContainer;
            
            const postContainer = isUpdating ? existingPostContainer : document.createElement('div');
            if (!isUpdating) {
                postContainer.className = 'qzone-post-container';
                postContainer.dataset.postId = post.id;
            }
        
            const postEl = isUpdating ? postContainer.querySelector('.qzone-post-item') : document.createElement('div');
            if (!isUpdating) {
                postEl.className = 'qzone-post-item';
            }
        
            let authorAvatar = '', authorNickname = '', commentAvatar = state.qzoneSettings.avatar; 
        
            if (post.authorId === 'user') {
                authorAvatar = state.qzoneSettings.avatar;
                authorNickname = state.qzoneSettings.nickname;
            } else if (state.chats[post.authorId]) {
                const authorChat = state.chats[post.authorId];
                authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
                authorNickname = authorChat.name;
            } else {
                authorNickname = getDisplayNameByOriginalName(post.authorOriginalName);
                authorAvatar = defaultAvatar;
            }
        
function renderOriginalPostContent(targetPost) {
            let innerContentHtml = '';
            const publicTextHtml = targetPost.publicText ? `<div class="post-content">${parseMarkdown(targetPost.publicText).replace(/\n/g, '<br>')}</div>` : '';

            if (targetPost.type === 'shuoshuo') {
                innerContentHtml = `<div class="post-content" style="margin-bottom: 10px;">${parseMarkdown(targetPost.content).replace(/\n/g, '<br>')}</div>`;
            } else if (targetPost.type === 'image_post' && targetPost.imageUrl) {
                // 【核心修复】直接使用 targetPost.imageUrl 来显示用户上传的图片
                innerContentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${targetPost.imageUrl}" class="chat-image"></div>` : `<img src="${targetPost.imageUrl}" class="chat-image">`;
            } else if (targetPost.type === 'text_image') {
                const postImageUrl = state.globalSettings.enableAiDrawing && targetPost.image_prompt ? `https://image.pollinations.ai/prompt/${targetPost.image_prompt}` : 'https://i.postimg.cc/KYr2qRCK/1.jpg';
                innerContentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${targetPost.hiddenContent}"></div>` : `<img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${targetPost.hiddenContent}">`;
            }
            return innerContentHtml;
        }
        
            let mainContentHtml;
        
            if (post.type === 'repost') {
                // ▼▼▼ 已添加 Markdown 解析 ▼▼▼
                const repostCommentHtml = post.repostComment ? `<div class="post-content">${parseMarkdown(post.repostComment).replace(/\n/g, '<br>')}</div>` : '';
                let originalAuthorAvatar = defaultAvatar;
                let originalAuthorNickname = '原作者';
                if (post.originalPost.authorId === 'user') {
                    originalAuthorAvatar = state.qzoneSettings.avatar;
                    originalAuthorNickname = state.qzoneSettings.nickname;
                } else {
                    const originalAuthorChat = state.chats[post.originalPost.authorId];
                    if (originalAuthorChat) {
                        originalAuthorAvatar = originalAuthorChat.settings.aiAvatar || defaultAvatar;
                    }
                    originalAuthorNickname = getDisplayNameByOriginalName(post.originalPost.authorOriginalName);
                }
                mainContentHtml = `
                    ${repostCommentHtml}
                    <div class="reposted-content-wrapper">
                        <div class="post-header">
                            <img src="${originalAuthorAvatar}" class="post-avatar">
                            <div class="post-info">
                                <span class="post-nickname">@${originalAuthorNickname}</span>
                                <span class="post-timestamp">${formatPostTimestamp(post.originalPost.timestamp)}</span>
                            </div>
                        </div>
                        <div class="post-main-content">${renderOriginalPostContent(post.originalPost)}</div>
                    </div>
                `;
            } else {
                mainContentHtml = `<div class="post-main-content">${renderOriginalPostContent(post)}</div>`;
            }
        
            let likesHtml = '';
            if (post.likes && post.likes.length > 0) {
                const displayLikes = post.likes.map(name => getDisplayNameByOriginalName(name)).join('、');
                likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${displayLikes} 觉得很赞</span></div>`;
            }
        
            let commentsHtml = '';
            if (post.comments && post.comments.length > 0) {
                commentsHtml = '<div class="post-comments-container">';
                post.comments.forEach((comment, index) => {
                    if (typeof comment === 'object' && comment !== null && comment.commenterName) {
                        const commenterOriginalName = comment.commenterName;
                        const commenterDisplayName = getDisplayNameByOriginalName(commenterOriginalName);
                        
                        let innerCommentContent;
                        if (STICKER_REGEX.test(comment.text)) {
                            innerCommentContent = `<img src="${comment.text}" class="comment-sticker" alt="sticker">`;
                        } else {
                            // ▼▼▼ 已添加 Markdown 解析 ▼▼▼
                            innerCommentContent = parseMarkdown(comment.text);
                        }
        
                        let commentLineHtml = '';
                        if (comment.replyTo) {
                            const repliedToDisplayName = getDisplayNameByOriginalName(comment.replyTo);
                            commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span> 回复 <span class="commenter-name">${repliedToDisplayName}</span>: ${innerCommentContent}`;
                        } else {
                            commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span>: ${innerCommentContent}`;
                        }
                        
                        commentsHtml += `<div class="comment-item" data-post-id="${post.id}" data-commenter-original-name="${commenterOriginalName}" data-commenter-display-name="${commenterDisplayName}">
                                            <div class="comment-text">${commentLineHtml}</div>
                                            <span class="comment-delete-btn" data-comment-index="${index}">×</span>
                                         </div>`;
        
                    } else {
                        // ▼▼▼ 已为旧格式评论添加 Markdown 解析 ▼▼▼
                        commentsHtml += `<div class="legacy-comment-item">
                                            <span class="comment-text">${parseMarkdown(String(comment))}</span>
                                         </div>`;
                    }
                });
                commentsHtml += '</div>';
            }
        
            const userOriginalName = state.qzoneSettings.nickname;
            const isLikedByUser = post.likes && post.likes.includes(userOriginalName);
            const isFavoritedByUser = state.favoritedPostIds && state.favoritedPostIds.has(post.id);
        
            let repostIconHtml = '';
            if (post.type !== 'repost') {
                repostIconHtml = `
                    <span class="action-icon repost">
                        <svg viewBox="0 0 24 24"><path d="M17 2.1l4 4-4 4 M3 11.5v-3a4 4 0 0 1 4-4h13 M7 21.9l-4-4 4-4 M21 12.5v3a4 4 0 0 1-4 4H4"></path></svg>
                    </span>`;
            }
            
            postEl.innerHTML = `
                <div class="post-header">
                    <img src="${authorAvatar}" class="post-avatar" data-author-id="${post.authorId}">
                    <div class="post-info">
                        <span class="post-nickname">${authorNickname}</span>
                        <span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span>
                    </div>
                    <div class="post-actions-btn">…</div>
                </div>
                ${mainContentHtml}
                <div class="post-feedback-icons">
                    ${repostIconHtml}
                    <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                    <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                </div>
                ${likesHtml}
                ${commentsHtml}
                <div class="post-footer">
                    <div class="comment-section">
                        <img src="${commentAvatar}" class="comment-avatar">
                        <input type="text" class="comment-input" placeholder="友善的评论是交流的起点">
                        <button class="comment-sticker-btn">
        <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M8 14 Q 12 16 16 14"></path>
            <line x1="9" y1="9" x2="9.01" y2="9"></line>
            <line x1="15" y1="9" x2="15.01" y2="9"></line>
        </svg>
        </button>
                        <div class="at-mention-popup"></div>
                    </div>
                    <button class="comment-send-btn">发送</button>
                </div>
            `;
        
            if (!isUpdating) {
                const deleteAction = document.createElement('div');
                deleteAction.className = 'qzone-post-delete-action';
                deleteAction.innerHTML = '<span>删除</span>';
                postContainer.appendChild(postEl);
                postContainer.appendChild(deleteAction);
            }
            
            return postContainer;
        }
        
        /**
         * 【全新 | 增量更新函数】只更新单个帖子，而不是重绘整个列表
         * @param {number} postId - 需要更新的帖子的ID
         */
        async function updateSinglePostInDOM(postId) {
            const postData = await db.qzonePosts.get(postId);
            if (!postData) {
                // 如果帖子被删了，就从DOM中移除
                const postContainer = document.querySelector(`.qzone-post-container[data-post-id="${postId}"]`);
                if (postContainer) postContainer.remove();
                return;
            }
        
            // 更新缓存
            const cacheIndex = qzonePostsCache.findIndex(p => p.id === postId);
            if (cacheIndex > -1) qzonePostsCache[cacheIndex] = postData;
            
            // 更新收藏状态
            const favorites = await db.favorites.where('type').equals('qzone_post').toArray();
            state.favoritedPostIds = new Set(favorites.map(fav => fav.content.id));
        
            // 调用核心函数来更新DOM
            createOrUpdatePostElement(postData);
        }
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        
        // ▼▼▼ 【全新】请将这个函数粘贴到 formatPostTimestamp 函数的后面 ▼▼▼
        function formatTimeAgo(timestamp) {
            const now = Date.now();
            const seconds = Math.floor((now - timestamp) / 1000);
            const minutes = Math.floor(seconds / 60);
            if (minutes < 2) return '刚刚';
            if (minutes < 60) return `${minutes}分钟前`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}小时前`;
            const days = Math.floor(hours / 24);
            return `${days}天前`;
        }
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        
        
        // ▼▼▼ 【全新】请将这两个函数粘贴到JS功能函数定义区 ▼▼▼
        
        /**
         * 【全新 | 性能核心】根据帖子数据，创建或更新单个帖子的HTML元素
         * @param {object} post - 单个帖子的数据对象
         * @returns {HTMLElement} - 创建或更新后的帖子容器DOM元素
         */
        function createOrUpdatePostElement(post) {
            const existingPostContainer = document.querySelector(`.qzone-post-container[data-post-id="${post.id}"]`);
            const isUpdating = !!existingPostContainer;
            
            // 如果是更新，就直接用旧的容器；如果是新建，就创建一个新的
            const postContainer = isUpdating ? existingPostContainer : document.createElement('div');
            if (!isUpdating) {
                postContainer.className = 'qzone-post-container';
                postContainer.dataset.postId = post.id;
            }
        
            // --- 后续的HTML构建逻辑与您旧的 renderQzonePosts 函数完全相同 ---
            // (我们只是把它从一个大循环里抽离出来，变成一个独立的、可复用的函数)
            const postEl = isUpdating ? postContainer.querySelector('.qzone-post-item') : document.createElement('div');
            if (!isUpdating) {
                postEl.className = 'qzone-post-item';
            }
        
            let authorAvatar = '', authorNickname = '', commentAvatar = state.qzoneSettings.avatar; 
        
            if (post.authorId === 'user') {
                authorAvatar = state.qzoneSettings.avatar;
                authorNickname = state.qzoneSettings.nickname;
            } else if (state.chats[post.authorId]) {
                const authorChat = state.chats[post.authorId];
                authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
                authorNickname = authorChat.name;
            } else {
                authorNickname = getDisplayNameByOriginalName(post.authorOriginalName);
                authorAvatar = defaultAvatar;
            }
        
function renderOriginalPostContent(targetPost) {
            let innerContentHtml = '';
            const publicTextHtml = targetPost.publicText ? `<div class="post-content">${parseMarkdown(targetPost.publicText).replace(/\n/g, '<br>')}</div>` : '';

            if (targetPost.type === 'shuoshuo') {
                innerContentHtml = `<div class="post-content" style="margin-bottom: 10px;">${parseMarkdown(targetPost.content).replace(/\n/g, '<br>')}</div>`;
            } else if (targetPost.type === 'image_post' && targetPost.imageUrl) {
                // 【核心修复 ①】直接使用 targetPost.imageUrl 显示您上传的图片
                innerContentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${targetPost.imageUrl}" class="chat-image"></div>` : `<img src="${targetPost.imageUrl}" class="chat-image">`;
            } else if (targetPost.type === 'text_image') {
                // （这部分逻辑保持不变，用于AI生成的文字图）
                const postImageUrl = state.globalSettings.enableAiDrawing && targetPost.image_prompt ? `https://image.pollinations.ai/prompt/${targetPost.image_prompt}` : 'https://i.postimg.cc/KYr2qRCK/1.jpg';
                innerContentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${targetPost.hiddenContent}"></div>` : `<img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${targetPost.hiddenContent}">`;
            }
            return innerContentHtml;
        }
        
            let mainContentHtml;
        
            if (post.type === 'repost') {
                const repostCommentHtml = post.repostComment ? `<div class="post-content">${post.repostComment.replace(/\n/g, '<br>')}</div>` : '';
                let originalAuthorAvatar = defaultAvatar;
                let originalAuthorNickname = '原作者';
                if (post.originalPost.authorId === 'user') {
                    originalAuthorAvatar = state.qzoneSettings.avatar;
                    originalAuthorNickname = state.qzoneSettings.nickname;
                } else {
                    const originalAuthorChat = state.chats[post.originalPost.authorId];
                    if (originalAuthorChat) {
                        originalAuthorAvatar = originalAuthorChat.settings.aiAvatar || defaultAvatar;
                    }
                    originalAuthorNickname = getDisplayNameByOriginalName(post.originalPost.authorOriginalName);
                }
                mainContentHtml = `
                    ${repostCommentHtml}
                    <div class="reposted-content-wrapper">
                        <div class="post-header">
                            <img src="${originalAuthorAvatar}" class="post-avatar">
                            <div class="post-info">
                                <span class="post-nickname">@${originalAuthorNickname}</span>
                                <span class="post-timestamp">${formatPostTimestamp(post.originalPost.timestamp)}</span>
                            </div>
                        </div>
                        <div class="post-main-content">${renderOriginalPostContent(post.originalPost)}</div>
                    </div>
                `;
            } else {
                mainContentHtml = `<div class="post-main-content">${renderOriginalPostContent(post)}</div>`;
            }
        
            let likesHtml = '';
            if (post.likes && post.likes.length > 0) {
                const displayLikes = post.likes.map(name => getDisplayNameByOriginalName(name)).join('、');
                likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${displayLikes} 觉得很赞</span></div>`;
            }
        
        // ▼▼▼ 在 createOrUpdatePostElement 函数中，找到 let commentsHtml = ''; 并用下面这整块替换 ▼▼▼
            let commentsHtml = '';
            if (post.comments && post.comments.length > 0) {
                commentsHtml = '<div class="post-comments-container">';
                post.comments.forEach((comment, index) => {
                    // 【核心修复1】检查是否是新的、包含 commenterName 的对象格式
                    if (typeof comment === 'object' && comment !== null && comment.commenterName) {
                        const commenterOriginalName = comment.commenterName;
                        // 【核心修复2】使用我们全新的函数来实时查找最新的显示名称！
                        const commenterDisplayName = getDisplayNameByOriginalName(commenterOriginalName);
                        
                        let innerCommentContent;
                        if (STICKER_REGEX.test(comment.text)) {
                            innerCommentContent = `<img src="${comment.text}" class="comment-sticker" alt="sticker">`;
                        } else {
                            innerCommentContent = parseMarkdown(comment.text);
                        }
        
                        let commentLineHtml = '';
                        // 【核心修复3】回复的目标也使用新函数来查找名字
                        if (comment.replyTo) {
                            const repliedToDisplayName = getDisplayNameByOriginalName(comment.replyTo);
                            commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span> 回复 <span class="commenter-name">${repliedToDisplayName}</span>: ${innerCommentContent}`;
                        } else {
                            commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span>: ${innerCommentContent}`;
                        }
                        
                        commentsHtml += `<div class="comment-item" data-post-id="${post.id}" data-commenter-original-name="${commenterOriginalName}" data-commenter-display-name="${commenterDisplayName}">
                                            <div class="comment-text">${commentLineHtml}</div>
                                            <span class="comment-delete-btn" data-comment-index="${index}">×</span>
                                         </div>`;
        
                    } else {
                        // 【兼容旧数据】如果还是旧的字符串格式，就原样显示
                        commentsHtml += `<div class="legacy-comment-item">
                                            <span class="comment-text">${String(comment)}</span>
                                         </div>`;
                    }
                });
                commentsHtml += '</div>';
            }
        // ▲▲▲ 替换结束 ▲▲▲
        
            const userOriginalName = state.qzoneSettings.nickname;
            const isLikedByUser = post.likes && post.likes.includes(userOriginalName);
            const isFavoritedByUser = state.favoritedPostIds && state.favoritedPostIds.has(post.id); // 从 state 读取
        
            let repostIconHtml = '';
            if (post.type !== 'repost') {
                repostIconHtml = `
                    <span class="action-icon repost">
                        <svg viewBox="0 0 24 24"><path d="M17 2.1l4 4-4 4 M3 11.5v-3a4 4 0 0 1 4-4h13 M7 21.9l-4-4 4-4 M21 12.5v3a4 4 0 0 1-4 4H4"></path></svg>
                    </span>`;
            }
            
            postEl.innerHTML = `
                <div class="post-header">
                    <img src="${authorAvatar}" class="post-avatar" data-author-id="${post.authorId}">
                    <div class="post-info">
                        <span class="post-nickname">${authorNickname}</span>
                        <span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span>
                    </div>
                    <div class="post-actions-btn">…</div>
                </div>
                ${mainContentHtml}
                <div class="post-feedback-icons">
                    ${repostIconHtml}
                    <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                    <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                </div>
                ${likesHtml}
                ${commentsHtml}
                <div class="post-footer">
                    <div class="comment-section">
                        <img src="${commentAvatar}" class="comment-avatar">
                        <input type="text" class="comment-input" placeholder="友善的评论是交流的起点">
                        <button class="comment-sticker-btn">
        <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M8 14 Q 12 16 16 14"></path>
            <line x1="9" y1="9" x2="9.01" y2="9"></line>
            <line x1="15" y1="9" x2="15.01" y2="9"></line>
        </svg>
        </button>
                        <div class="at-mention-popup"></div>
                    </div>
                    <button class="comment-send-btn">发送</button>
                </div>
            `;
        
            if (!isUpdating) {
                const deleteAction = document.createElement('div');
                deleteAction.className = 'qzone-post-delete-action';
                deleteAction.innerHTML = '<span>删除</span>';
                postContainer.appendChild(postEl);
                postContainer.appendChild(deleteAction);
            }
            
            return postContainer;
        }
        
        /**
         * 【全新 | 增量更新函数】只更新单个帖子，而不是重绘整个列表
         * @param {number} postId - 需要更新的帖子的ID
         */
        async function updateSinglePostInDOM(postId) {
            const postData = await db.qzonePosts.get(postId);
            if (!postData) {
                // 如果帖子被删了，就从DOM中移除
                const postContainer = document.querySelector(`.qzone-post-container[data-post-id="${postId}"]`);
                if (postContainer) {
                    postContainer.remove();
                }
                return;
            }
        
            // 更新缓存
            const cacheIndex = qzonePostsCache.findIndex(p => p.id === postId);
            if (cacheIndex > -1) {
                qzonePostsCache[cacheIndex] = postData;
            }
            
            // 更新收藏状态
            const favorites = await db.favorites.where('type').equals('qzone_post').toArray();
            state.favoritedPostIds = new Set(favorites.map(fav => fav.content.id));
        
            // 调用核心函数来更新DOM
            createOrUpdatePostElement(postData);
        }
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        
// ▼▼▼ 【无限滚动修复版】请用这个新版本替换旧的 renderQzonePosts 函数 ▼▼▼
async function renderQzonePosts() {
    const postsListEl = document.getElementById('qzone-posts-list');
    if (!postsListEl) return;

    const [postsFromDb, favorites] = await Promise.all([
        db.qzonePosts.orderBy('timestamp').reverse().filter(post => !post.isDeleted).toArray(),
        db.favorites.where('type').equals('qzone_post').toArray()
    ]);
    qzonePostsCache = postsFromDb;
    state.favoritedPostIds = new Set(favorites.map(fav => fav.content.id));

    postsListEl.innerHTML = '';
    qzonePostsRenderCount = 0; // 重置计数器

    if (qzonePostsCache.length === 0) {
        postsListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">这里空空如也，快来发布第一条说说吧！</p>';
        return;
    }

    // 初始加载第一页
    loadMoreQzonePosts();
}
// ▲▲▲ 替换结束 ▲▲▲

        
// ▼▼▼ 【无限滚动修复版】请用这个新版本替换旧的 loadMoreQzonePosts 函数 ▼▼▼
function loadMoreQzonePosts() {
    if (isLoadingMorePosts) return;
    isLoadingMorePosts = true;

    const postsListEl = document.getElementById('qzone-posts-list');
    if (!postsListEl) {
        isLoadingMorePosts = false;
        return;
    }

    showLoader(postsListEl, 'bottom'); // 在底部显示加载动画

    // 模拟网络延迟
    setTimeout(() => {
        hideLoader(postsListEl); // 先移除加载动画

        const nextSliceStart = qzonePostsRenderCount;
        const nextSliceEnd = qzonePostsRenderCount + QZONE_RENDER_WINDOW;
        const postsToAppend = qzonePostsCache.slice(nextSliceStart, nextSliceEnd);

        const fragment = document.createDocumentFragment();
        postsToAppend.forEach(post => {
            const postElement = createOrUpdatePostElement(post);
            fragment.appendChild(postElement);
        });
        postsListEl.appendChild(fragment);

        qzonePostsRenderCount += postsToAppend.length;

        isLoadingMorePosts = false;
    }, 500);
}
// ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 【全新】动态评论区表情面板管理函数 ▼▼▼
        
        function openQzoneStickerPanel(postId, buttonElement) {
            const panel = qzoneStickerPanelState.panelEl;
            const grid = qzoneStickerPanelState.gridEl;
        
            // 1. 填充表情 (这部分逻辑不变)
            grid.innerHTML = '';
            if (state.userStickers.length === 0) {
                grid.innerHTML = '<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1; padding-top: 20px;">请先在聊天界面的<br>表情面板中添加表情包</p>';
            } else {
                state.userStickers.forEach(sticker => {
                    const item = document.createElement('div');
                    item.className = 'sticker-item';
                    item.style.backgroundImage = `url(${sticker.url})`;
                    item.title = sticker.name;
                    grid.appendChild(item);
                });
            }
        
            // --- ▼▼▼ 核心修正：智能定位逻辑 ▼▼▼ ---
        
            // 2. 获取必要的尺寸和位置信息
            const btnRect = buttonElement.getBoundingClientRect();
            const phoneScreenRect = document.getElementById('phone-screen').getBoundingClientRect();
            
            panel.style.display = 'flex'; // 先显示出来才能获取尺寸
            const panelRect = panel.getBoundingClientRect();
            const panelHeight = panelRect.height;
            const panelWidth = panelRect.width;
        
            // 3. 计算垂直位置 (保持不变，总是出现在按钮上方)
            panel.style.top = `${btnRect.top - panelHeight - 5 - phoneScreenRect.top}px`;
        
            // 4. 计算并判断水平位置
            const desiredLeftPosition = btnRect.left - phoneScreenRect.left;
        
            // 如果面板的左侧位置 + 自身宽度 > 手机屏幕宽度，说明会超出
            if (desiredLeftPosition + panelWidth > phoneScreenRect.width) {
                // 如果会超出，则改为贴着屏幕右侧边缘显示 (留5px边距)
                panel.style.left = 'auto';
                panel.style.right = '5px';
            } else {
                // 如果不会超出，则正常对齐按钮左侧
                panel.style.left = `${desiredLeftPosition}px`;
                panel.style.right = 'auto';
            }
            
            // --- ▲▲▲ 修正结束 ▲▲▲ ---
        
            // 5. 更新状态 (这部分逻辑不变)
            qzoneStickerPanelState.isOpen = true;
            qzoneStickerPanelState.activePostId = postId;
        }
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        // ▼▼▼ 请将这段【新函数】粘贴到 openQzoneStickerPanel 函数的后面 ▼▼▼
        
        /**
         * 【全新】关闭动态评论区的表情面板
         */
        function closeQzoneStickerPanel() {
            // 检查状态，确保面板是打开的
            if (qzoneStickerPanelState.isOpen) {
                // 隐藏面板DOM元素
                qzoneStickerPanelState.panelEl.style.display = 'none';
                
                // 重置状态变量
                qzoneStickerPanelState.isOpen = false;
                qzoneStickerPanelState.activePostId = null;
            }
        }
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        
        // ▼▼▼ 请用这个【新代码块】替换旧的 sendQzoneStickerComment 函数 ▼▼▼
        
        /**
         * 【全新升级版】发送动态表情评论，并告知AI其含义
         * @param {number} postId - 帖子ID
         * @param {object} sticker - 完整的表情对象 { url, name }
         */
        async function sendQzoneStickerComment(postId, sticker) {
            if (!sticker || !sticker.url) return;
        
            const post = await db.qzonePosts.get(postId);
            if (!post) {
                console.error("sendQzoneStickerComment: 找不到帖子:", postId);
                return;
            }
        
            if (!post.comments) {
                post.comments = [];
            }
            // ▼▼▼ 核心修复：在这里为您发送的表情也添加 meaning 字段 ▼▼▼
            const newComment = {
                commenterName: state.qzoneSettings.nickname,
                text: sticker.url,
                meaning: sticker.name, // 保存表情的含义
                timestamp: Date.now()
            };
            // ▲▲▲ 修复结束 ▲▲▲
            post.comments.push(newComment);
        
            await db.qzonePosts.update(postId, { comments: post.comments });
        
            closeQzoneStickerPanel();
            await renderQzonePosts();
            
            const postSummary = (post.publicText || post.content || `[图片动态]`).substring(0, 30);
            
            // ▼▼▼ 核心修复：通知AI时，明确告知表情的含义 ▼▼▼
            for (const chatId in state.chats) {
                const chat = state.chats[chatId];
                if (!chat.isGroup) {
                    const intelligentPrompt = `[系统提示：'${state.qzoneSettings.nickname}' 在你的动态(ID: ${postId}, 内容摘要: “${postSummary}”)下发送了一个表情评论，意思是：“${sticker.name}”。请你对此作出回应。]`;
                    
                    const historyMessage = { 
                        role: 'system', 
                        content: intelligentPrompt, 
                        timestamp: Date.now(), 
                        isHidden: true 
                    };
                    chat.history.push(historyMessage);
                    await db.chats.put(chat);
                }
            }
            // ▲▲▲ 修复结束 ▲▲▲
        }
        
        // ▲▲▲ 替换结束 ▲▲▲
        
        
        // ▼▼▼ 【全新】这三个函数是转发功能的核心，请将它们粘贴到JS功能函数定义区 ▼▼▼
        
        /**
         * 打开转发评论的模态框
         * @param {number} postId - 要转发的动态的ID
         */
        function openRepostModal(postId) {
            repostTargetId = postId;
            document.getElementById('repost-comment-input').value = ''; // 清空输入框
            document.getElementById('repost-modal').classList.add('visible');
        }
        
        /**
         * 隐藏转发模态框
         */
        function hideRepostModal() {
            document.getElementById('repost-modal').classList.remove('visible');
            repostTargetId = null;
        }
        
        /**
         * 处理确认转发的逻辑
         */
        async function handleConfirmRepost() {
            if (!repostTargetId) return;
        
            const comment = document.getElementById('repost-comment-input').value.trim();
            const originalPost = await db.qzonePosts.get(repostTargetId);
        
            if (!originalPost) {
                alert("错误：找不到要转发的原始动态。");
                hideRepostModal();
                return;
            }
        
            const newPost = {
                type: 'repost', // 标记为转发类型
                timestamp: Date.now(),
                authorId: 'user', // 转发者永远是当前用户
                repostComment: comment,
                originalPost: originalPost, // 将原始动态完整地嵌入新动态中
                visibleGroupIds: null // 转发的动态默认对所有人可见
            };
        
            await db.qzonePosts.add(newPost);
            hideRepostModal();
            await renderQzonePosts();
            alert('转发成功！');
        }
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲             
        // ▼▼▼ 请用下面这个【更新后的】函数，完整替换掉你代码中旧的 displayFilteredFavorites 函数 ▼▼▼
        
        function displayFilteredFavorites(items) {
            const listEl = document.getElementById('favorites-list');
            listEl.innerHTML = '';
        
            if (items.length === 0) {
                const searchTerm = document.getElementById('favorites-search-input').value;
                const message = searchTerm ? '未找到相关收藏' : '你的收藏夹是空的，<br>快去动态或聊天中收藏喜欢的内容吧！';
                listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
                return;
            }
        
            for (const item of items) {
                const card = document.createElement('div');
                card.className = 'favorite-item-card';
                card.dataset.favid = item.id;
        
                let headerHtml = '', contentHtml = '', sourceText = '', footerHtml = '';
        
                if (item.type === 'qzone_post') {
                    const post = item.content;
                    sourceText = '来自动态';
                    let authorAvatar = defaultAvatar, authorNickname = '未知用户';
        
                    if (post.authorId === 'user') {
                        authorAvatar = state.qzoneSettings.avatar;
                        authorNickname = state.qzoneSettings.nickname;
                    } else if (state.chats[post.authorId]) {
                        authorAvatar = state.chats[post.authorId].settings.aiAvatar;
                        authorNickname = state.chats[post.authorId].name;
                    }
        
                    headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>`;
                    
                    const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';
                    if (post.type === 'shuoshuo') {
                        contentHtml = `<div class="post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
                    } else if (post.type === 'image_post' && post.imageUrl) {
    const postImageUrl = state.globalSettings.enableAiDrawing && post.image_prompt ? `https://image.pollinations.ai/prompt/${post.image_prompt}` : 'https://i.postimg.cc/KYr2qRCK/1.jpg';
    contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${postImageUrl}" class="chat-image"></div>` : `<img src="${postImageUrl}" class="chat-image">`;
} else if (post.type === 'text_image') {
    const postImageUrl = state.globalSettings.enableAiDrawing && post.image_prompt ? `https://image.pollinations.ai/prompt/${post.image_prompt}` : 'https://i.postimg.cc/KYr2qRCK/1.jpg';
    contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
                    }
        
                    // ▼▼▼ 新增/修改的代码开始 ▼▼▼
                    
                    // 1. 构造点赞区域的HTML
                    let likesHtml = '';
                    // 检查 post 对象中是否存在 likes 数组并且不为空
                    if (post.likes && post.likes.length > 0) {
                        // 如果存在，就创建点赞区域的 div
                        likesHtml = `
                            <div class="post-likes-section">
                                <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                                <span>${post.likes.join('、')} 觉得很赞</span>
                            </div>`;
                    }
        
                    // 2. 构造评论区域的HTML
        // ▼▼▼ 【最终修复方案】请用这个全新的、向下兼容的代码块替换旧的 if(post.comments...) 逻辑 ▼▼▼
        let commentsHtml = '';
        if (post.comments && post.comments.length > 0) {
            commentsHtml = '<div class="post-comments-container">';
            post.comments.forEach((comment, index) => {
                // --- 核心修复：在这里判断评论的数据格式 ---
                if (typeof comment === 'object' && comment !== null && comment.commenterName) {
                    // --- 这是新格式的、功能完整的评论 ---
                    const commenterOriginalName = comment.commenterName;
                    const commenterDisplayName = getDisplayNameByOriginalName(commenterOriginalName);
                    
                    let innerCommentContent;
                    if (STICKER_REGEX.test(comment.text)) {
                        innerCommentContent = `<img src="${comment.text}" class="comment-sticker" alt="sticker">`;
                    } else {
                        innerCommentContent = comment.text;
                    }
        
                    let commentLineHtml = '';
                    if (comment.replyTo) {
                        const repliedToDisplayName = getDisplayNameByOriginalName(comment.replyTo);
                        commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span> 回复 <span class="commenter-name">${repliedToDisplayName}</span>: ${innerCommentContent}`;
                    } else {
                        commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span>: ${innerCommentContent}`;
                    }
                    
                    commentsHtml += `<div class="comment-item" data-post-id="${post.id}" data-commenter-original-name="${commenterOriginalName}" data-commenter-display-name="${commenterDisplayName}">
                                        <div class="comment-text">${commentLineHtml}</div>
                                        <span class="comment-delete-btn" data-comment-index="${index}">×</span>
                                     </div>`;
        
                } else {
                    // --- 这是旧格式的、只做显示的评论 ---
                    // 我们把它渲染成一个没有交互、没有data属性的简单div，从而避免报错
                    commentsHtml += `<div class="legacy-comment-item">
                                        <span class="comment-text">${String(comment)}</span>
                                     </div>`;
                }
            });
            commentsHtml += '</div>';
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
                    // 3. 将点赞和评论的HTML组合到 footerHtml 中
                    footerHtml = `${likesHtml}${commentsHtml}`;
                    
                    // ▲▲▲ 新增/修改的代码结束 ▲▲▲
        
        } else if (item.type === 'chat_message') {
            const msg = item.content;
            const chat = state.chats[item.chatId];
            if (!chat) continue; 
        
            sourceText = `来自与 ${chat.name} 的聊天`;
            const isUser = msg.role === 'user';
            let senderName, senderAvatar;
        
            if (isUser) {
                // 用户消息的逻辑保持不变
                senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                senderAvatar = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
            } else { // AI/成员消息
                 if (chat.isGroup) {
                    // ★★★★★ 这就是唯一的、核心的修改！ ★★★★★
                    // 我们现在使用 originalName 去匹配，而不是旧的 name
                    const member = chat.members.find(m => m.originalName === msg.senderName);
                    // ★★★★★ 修改结束 ★★★★★
                    
                    senderName = msg.senderName;
                    // 因为现在能正确找到 member 对象了，所以也能正确获取到他的头像
                    senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
                } else {
                    // 单聊的逻辑保持不变
                    senderName = chat.name;
                    senderAvatar = chat.settings.aiAvatar || defaultAvatar;
                }
            }
        
            // 后续拼接 headerHtml 和 contentHtml 的逻辑都保持不变
            headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;
            
            if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
                contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
            } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
            } else {
                contentHtml = String(msg.content || '').replace(/\n/g, '<br>');
            }
        }
                      // ▼▼▼ 【【【核心新增逻辑就在这里！】】】 ▼▼▼
        else if (item.type === 'char_diary') {
            const diary = item.content;
            sourceText = `来自 ${diary.characterName} 的日记`;

            const charChat = state.chats[diary.characterId];
            const authorAvatar = charChat ? charChat.settings.aiAvatar : defaultAvatar;
            
            headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${diary.characterName}</div></div>`;
            
            // 1. 获取完整的日记内容
            const fullDiaryContent = diary.content || '';
            // 2. 使用与详情页完全相同的Markdown解析和换行逻辑
            const formattedContent = parseMarkdown(fullDiaryContent).replace(/\n/g, '<br>');

            // 3. 将完整的、格式化后的内容放入 contentHtml
            contentHtml = `
                <span class="diary-title">${diary.title}</span>
                <div class="fav-card-content-full">${formattedContent}</div>
            `;
        }     
                // ▼▼▼ 修改最终的HTML拼接，加入 footerHtml ▼▼▼
                card.innerHTML = `
                    <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
                    <div class="fav-card-content">${contentHtml}</div>
                    ${footerHtml}`; // <-- 把我们新创建的 footerHtml 放在这里
                    
                listEl.appendChild(card);
            }
        }
        
        // ▲▲▲ 替换区域结束 ▲▲▲
        
                /**
                 * 【重构后的函数】: 负责准备数据并触发渲染
                 */
                async function renderFavoritesScreen() {
                    // 1. 从数据库获取最新数据并缓存
                    allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray();
                    
                    // 2. 清空搜索框并隐藏清除按钮
                    const searchInput = document.getElementById('favorites-search-input');
                    const clearBtn = document.getElementById('favorites-search-clear-btn');
                    searchInput.value = '';
                    clearBtn.style.display = 'none';
        
                    // 3. 显示所有收藏项
                    displayFilteredFavorites(allFavoriteItems);
                }
        
                // ▲▲▲ 粘贴结束 ▲▲▲
        
                function resetCreatePostModal() {
                    document.getElementById('post-public-text').value = '';
                    document.getElementById('post-image-preview').src = '';
                    document.getElementById('post-image-description').value = '';
                    document.getElementById('post-image-preview-container').classList.remove('visible');
                    document.getElementById('post-image-desc-group').style.display = 'none';
                    document.getElementById('post-local-image-input').value = '';
                    document.getElementById('post-hidden-text').value = '';
                    document.getElementById('switch-to-image-mode').click();
                }
/**
 * 【V2.0 | NPC保护版】一键清理数据库中所有与已删除角色或聊天相关的孤立数据
 */
async function cleanupRedundantData() {
    const confirmed = await showCustomConfirm(
        '确认清理冗余数据？',
        '此操作将扫描数据库，移除所有与已删除角色相关的孤立数据（如动态、评论、记忆等）。<br><br><strong>此操作不可撤销，但通常是安全的。NPC数据不会被删除。</strong><br><br>建议在操作前先导出数据备份。',
        { confirmButtonClass: 'btn-danger', confirmText: '确认清理' }
    );

    if (!confirmed) return;

    await showCustomAlert("请稍候...", "正在开始清理冗余数据，请不要关闭页面...");
    console.log("冗余数据清理流程已启动...");

    let cleanupCounts = {
        posts: 0, likes: 0, comments: 0, memories: 0,
        callRecords: 0, renderingRules: 0, groupMembers: 0, chatLinks: 0,
    };

    try {
        await db.transaction('rw', db.tables, async () => {
            // 步骤 A: 建立所有有效聊天、角色和NPC的“白名单”
            const allChats = await db.chats.toArray();
            const allNpcs = await db.npcs.toArray(); // <-- 【核心新增】从数据库读取NPC列表

            const existingChatIds = new Set(allChats.map(c => c.id));
            const existingNpcIds = new Set(allNpcs.map(n => `npc_${n.id}`)); // <-- 【核心新增】创建NPC的ID白名单

            const existingOriginalNames = new Set(allChats.filter(c => !c.isGroup).map(c => c.originalName));
            existingOriginalNames.add(state.qzoneSettings.nickname || '{{user}}');
            // 【核心新增】将NPC的名字也加入“有效名称”白名单，用于清理点赞和评论
            allNpcs.forEach(npc => existingOriginalNames.add(npc.name));

            // 步骤 B: 清理群聊中的无效成员
            for (const chat of allChats) {
                 let chatModified = false;
                 if (chat.isGroup && chat.members) {
                     const originalMemberCount = chat.members.length;
                     
                     // 【【【核心修复逻辑】】】
                     // 现在我们同时检查成员ID是否存在于 角色白名单 或 NPC白名单 中
                     chat.members = chat.members.filter(member => 
                        existingChatIds.has(member.id) || existingNpcIds.has(member.id)
                     );
                     
                     if (chat.members.length < originalMemberCount) {
                        cleanupCounts.groupMembers += (originalMemberCount - chat.members.length);
                        chatModified = true;
                     }
                 }
                 // (清理挂载记忆的逻辑保持不变)
                 if (chat.settings?.linkedMemoryChatIds?.length > 0) {
                     const originalLinkCount = chat.settings.linkedMemoryChatIds.length;
                     chat.settings.linkedMemoryChatIds = chat.settings.linkedMemoryChatIds.filter(id => existingChatIds.has(id));
                     if (chat.settings.linkedMemoryChatIds.length < originalLinkCount) {
                        cleanupCounts.chatLinks += (originalLinkCount - chat.settings.linkedMemoryChatIds.length);
                        chatModified = true;
                     }
                 }
                 if(chatModified) {
                     await db.chats.put(chat);
                 }
            }

            // 步骤 C: 清理动态、点赞和评论
            const allPosts = await db.qzonePosts.toArray();
            for (const post of allPosts) {
                let postModified = false;
                
                // 【【【核心修复逻辑】】】
                // 检查发帖人是否是用户、角色或NPC
                const isAuthorValid = post.authorId === 'user' || existingChatIds.has(post.authorId) || existingNpcIds.has(post.authorId);

                if (!isAuthorValid) {
                    await db.qzonePosts.delete(post.id);
                    cleanupCounts.posts++;
                    continue; // 帖子已删除，跳过后续处理
                }
                
                if (post.likes && post.likes.length > 0) {
                    const originalLikeCount = post.likes.length;
                    post.likes = post.likes.filter(name => existingOriginalNames.has(name));
                    if (post.likes.length < originalLikeCount) {
                        cleanupCounts.likes += (originalLikeCount - post.likes.length);
                        postModified = true;
                    }
                }
                if (post.comments && post.comments.length > 0) {
                    const originalCommentCount = post.comments.length;
                    post.comments = post.comments.filter(comment => {
                        if (typeof comment === 'object' && comment.commenterName) {
                            return existingOriginalNames.has(comment.commenterName);
                        }
                        return true; // 保留旧格式的评论
                    });
                     if (post.comments.length < originalCommentCount) {
                        cleanupCounts.comments += (originalCommentCount - post.comments.length);
                        postModified = true;
                    }
                }
                if (postModified) { await db.qzonePosts.put(post); }
            }

            // (其他清理逻辑保持不变)
            await db.memories.where('chatId').noneOf([...existingChatIds]).delete().then(c => cleanupCounts.memories += c);
            await db.callRecords.where('chatId').noneOf([...existingChatIds]).delete().then(c => cleanupCounts.callRecords += c);
            const allRules = await db.renderingRules.toArray();
            for(const rule of allRules) {
                if (rule.chatId !== 'global' && !existingChatIds.has(rule.chatId)) {
                    await db.renderingRules.delete(rule.id);
                    cleanupCounts.renderingRules++;
                }
            }
        });

        let summary = "✅ 清理完成！\n\n";
        let cleanedSomething = false;
        Object.entries(cleanupCounts).forEach(([key, value]) => {
            if (value > 0) {
                const keyMap = {
                    posts: '动态', likes: '点赞', comments: '评论', memories: '记忆',
                    callRecords: '通话记录', renderingRules: '渲染规则',
                    groupMembers: '群成员', chatLinks: '记忆链接'
                };
                summary += `- 清理了 ${value} 条无效的${keyMap[key] || key}。\n`;
                cleanedSomething = true;
            }
        });
        if (!cleanedSomething) {
            summary = "✅ 检查完成，未发现任何冗余数据。";
        }
        summary += "\n建议刷新页面以确保所有更改生效。";

        await showCustomAlert("操作成功", summary);
        
        const confirmedReload = await showCustomConfirm("刷新页面？", "为了确保所有数据同步，建议立即刷新页面。");
        if(confirmedReload) {
            location.reload();
        }

    } catch (error) {
        console.error("清理冗余数据时出错:", error);
        await showCustomAlert('清理失败', `发生了一个错误: ${error.message}`);
    }
}
        // ▼▼▼ 【这是导出函数修复版】 ▼▼▼
        async function exportBackup() {
            try {
                const backupData = {
                    version: 1, 
                    timestamp: Date.now()
                };
        
                const [
                    chats, worldBooks, userStickers, apiConfig, globalSettings,
                    personaPresets, musicLibrary, qzoneSettings, qzonePosts,
                    qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
                    memories, worldBookCategories,
                    apiPresets, shoppingProducts, callRecords,
                    renderingRules,
                    // ▼▼▼ 在这里添加新代码 ▼▼▼
                    doubanPosts,
                    stickerCategories,
                    // ▼▼▼ 在这里添加新代码 ▼▼▼
                    appearancePresets,
                    // ▼▼▼ 在这里添加新代码 ▼▼▼
                    presets,              // <-- 【本次新增修复】
                    presetCategories,
    // 【核心新增】
    npcs 
                ] = await Promise.all([
                    db.chats.toArray(),
                    db.worldBooks.toArray(),
                    db.userStickers.toArray(),
                    db.apiConfig.get('main'),
                    db.globalSettings.get('main'),
                    db.personaPresets.toArray(),
                    db.musicLibrary.get('main'),
                    db.qzoneSettings.get('main'),
                    db.qzonePosts.toArray(),
                    db.qzoneAlbums.toArray(),
                    db.qzonePhotos.toArray(),
                    db.favorites.toArray(),
                    db.qzoneGroups.toArray(),
                    db.memories.toArray(),
                    db.worldBookCategories.toArray(),
                    db.apiPresets.toArray(),
                    db.shoppingProducts.toArray(),
                    db.callRecords.toArray(),
                    db.renderingRules.toArray(),
                    // ▼▼▼ 在这里添加新代码 ▼▼▼
                    db.doubanPosts.toArray(),
                    db.stickerCategories.toArray(),
                    // ▼▼▼ 在这里添加新代码 ▼▼▼
                    db.appearancePresets.toArray(),
                    // ▼▼▼ 在这里添加新代码 ▼▼▼
                    db.presets.toArray(),             // <-- 【本次新增修复】
                    db.presetCategories.toArray(),
    // 【核心新增】
    db.npcs.toArray() 
                ]);
        
                Object.assign(backupData, {
                    chats, worldBooks, userStickers, apiConfig, globalSettings,
                    personaPresets, musicLibrary, qzoneSettings, qzonePosts,
                    qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
                    memories, worldBookCategories,
                    apiPresets, shoppingProducts, callRecords,
                    renderingRules,
                    // ▼▼▼ 在这里添加新代码 ▼▼▼
                    doubanPosts,
                    stickerCategories,
                    // ▼▼▼ 在这里添加新代码 ▼▼▼
                    appearancePresets,
                    // ▼▼▼ 在这里添加新代码 ▼▼▼
                    presets,              // <-- 【本次新增修复】
                    presetCategories,
    // 【核心新增】
    npcs  
                });
                
                const blob = new Blob(
                    [JSON.stringify(backupData, null, 2)], 
                    { type: 'application/json' }
                );
                const url = URL.createObjectURL(blob);
                const link = Object.assign(document.createElement('a'), {
                    href: url,
                    download: `EPhone-Full-Backup-${new Date().toISOString().split('T')[0]}.json`
                });
                link.click();
                URL.revokeObjectURL(url);
                
                await showCustomAlert('导出成功', '已成功导出所有数据！');
        
            } catch (error) {
                console.error("导出数据时出错:", error);
                await showCustomAlert('导出失败', `发生了一个错误: ${error.message}`);
            }
        }
        
        // ▼▼▼ 【这是导入函数修复版】 ▼▼▼
        async function importBackup(file) {
            if (!file) return;
        
            const confirmed = await showCustomConfirm(
                '严重警告！',
                '导入备份将完全覆盖您当前的所有数据，包括聊天、动态、设置等。此操作不可撤销！您确定要继续吗？',
                { confirmButtonClass: 'btn-danger' }
            );
        
            if (!confirmed) return;
        
            try {
                const text = await file.text();
                const data = JSON.parse(text);
        
                await db.transaction('rw', db.tables, async () => {
                    for (const table of db.tables) {
                        await table.clear();
                    }
        
                    if (Array.isArray(data.chats)) await db.chats.bulkPut(data.chats);
                    // ▼▼▼ 【全新】世界书旧版本数据兼容代码 ▼▼▼
                    if (data.worldBooks && Array.isArray(data.worldBooks)) {
                        console.log("正在检查世界书数据格式以确保兼容性...");
                        data.worldBooks.forEach(book => {
                            if (typeof book.content === 'string') {
                                console.log(`检测到旧格式的世界书: "${book.name}"，正在自动迁移...`);
                                const oldContentString = book.content;
                                book.content = [{
                                    keys: [], 
                                    comment: "从旧版本自动迁移的条目",
                                    content: oldContentString,
                                    enabled: true 
                                }];
                            }
                        });
                    }
                    // ▲▲▲ 代码粘贴结束 ▲▲▲
                    if (Array.isArray(data.worldBooks)) await db.worldBooks.bulkPut(data.worldBooks);
                    if (Array.isArray(data.worldBookCategories)) await db.worldBookCategories.bulkPut(data.worldBookCategories);
                    if (Array.isArray(data.userStickers)) await db.userStickers.bulkPut(data.userStickers);
                    if (Array.isArray(data.personaPresets)) await db.personaPresets.bulkPut(data.personaPresets);
                    if (Array.isArray(data.qzonePosts)) await db.qzonePosts.bulkPut(data.qzonePosts);
                    if (Array.isArray(data.qzoneAlbums)) await db.qzoneAlbums.bulkPut(data.qzoneAlbums);
                    if (Array.isArray(data.qzonePhotos)) await db.qzonePhotos.bulkPut(data.qzonePhotos);
                    if (Array.isArray(data.favorites)) await db.favorites.bulkPut(data.favorites);
                    if (Array.isArray(data.qzoneGroups)) await db.qzoneGroups.bulkPut(data.qzoneGroups);
                    if (Array.isArray(data.memories)) await db.memories.bulkPut(data.memories);
                    if (Array.isArray(data.apiPresets)) await db.apiPresets.bulkPut(data.apiPresets);
                    if (Array.isArray(data.shoppingProducts)) await db.shoppingProducts.bulkPut(data.shoppingProducts);
                    if (Array.isArray(data.callRecords)) await db.callRecords.bulkPut(data.callRecords);
                    if (Array.isArray(data.renderingRules)) await db.renderingRules.bulkPut(data.renderingRules);
        
                    // ▼▼▼ 在这里添加新代码 ▼▼▼
                    if (Array.isArray(data.doubanPosts)) await db.doubanPosts.bulkPut(data.doubanPosts);
                    // ▲▲▲ 新代码粘贴结束 ▲▲▲
                   if (Array.isArray(data.stickerCategories)) await db.stickerCategories.bulkPut(data.stickerCategories);
	   if (Array.isArray(data.appearancePresets)) await db.appearancePresets.bulkPut(data.appearancePresets);
                    if (Array.isArray(data.presets)) await db.presets.bulkPut(data.presets);                         // <-- 【本次新增修复】
                    if (Array.isArray(data.presetCategories)) await db.presetCategories.bulkPut(data.presetCategories);
    if (Array.isArray(data.npcs)) await db.npcs.bulkPut(data.npcs);
                    if (data.apiConfig) await db.apiConfig.put(data.apiConfig);
                    if (data.globalSettings) await db.globalSettings.put(data.globalSettings);
                    if (data.musicLibrary) await db.musicLibrary.put(data.musicLibrary);
                    if (data.qzoneSettings) await db.qzoneSettings.put(data.qzoneSettings);
                });
        
                await showCustomAlert('导入成功', '所有数据已成功恢复！应用即将刷新以应用所有更改。');
                
                setTimeout(() => {
                    window.location.reload();
                }, 1500);
        
            } catch (error) {
                console.error("导入数据时出错:", error);
                await showCustomAlert('导入失败', `文件格式不正确或数据已损坏: ${error.message}`);
            }
        }
        
                function applyCustomFont(fontUrl, isPreviewOnly = false) {
                    if (!fontUrl) {
                        dynamicFontStyle.innerHTML = '';
                        document.getElementById('font-preview').style.fontFamily = '';
                        return;
                    }
                    const fontName = 'custom-user-font';
                    const newStyle = `
                        @font-face {
                          font-family: '${fontName}';
                          src: url('${fontUrl}');
                          font-display: swap;
                        }`;
                    if (isPreviewOnly) {
                        const previewStyle = document.getElementById('preview-font-style') || document.createElement('style');
                        previewStyle.id = 'preview-font-style';
                        previewStyle.innerHTML = newStyle;
                        if (!document.getElementById('preview-font-style')) document.head.appendChild(previewStyle);
                        document.getElementById('font-preview').style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
                    } else {
                        dynamicFontStyle.innerHTML = `
                            ${newStyle}
                            body {
                              font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                            }`;
                    }
                }
        
                async function resetToDefaultFont() {
                    dynamicFontStyle.innerHTML = ''; 
                    state.globalSettings.fontUrl = '';
                    await db.globalSettings.put(state.globalSettings);
                    document.getElementById('font-url-input').value = '';
                    document.getElementById('font-preview').style.fontFamily = '';
                    alert('已恢复默认字体。');
                }
        
// ▼▼▼ 【请用这个已更新的版本】替换旧的 loadAllDataFromDB 函数 ▼▼▼
async function loadAllDataFromDB() {
    const [
        chatsArr, apiConfig, loadedGlobalSettings, userStickers, worldBooks,
        musicLib, personaPresets, qzoneSettings, initialFavorites,
        allMemories,
        // 【核心新增】在这里加载所有预设
        allPresets
    ] = await Promise.all([
        db.chats.toArray(), db.apiConfig.get('main'), db.globalSettings.get('main'),
        db.userStickers.toArray(), db.worldBooks.toArray(), db.musicLibrary.get('main'),
        db.personaPresets.toArray(), db.qzoneSettings.get('main'), db.favorites.orderBy('timestamp').reverse().toArray(),
        db.memories.toArray(),
        // 【核心新增】从数据库读取 presets 表
        db.presets.toArray()
    ]);

    // 【核心新增】将加载的预设保存到全局 state 中
    state.presets = allPresets || [];

    // --- (后续所有的数据处理逻辑保持不变) ---
    const defaultGlobalSettings = {
        id: 'main',
        showStatusBar: false,
        wallpaper: 'linear-gradient(135deg, #89f7fe, #66a6ff)',
        fontUrl: '',
        enableBackgroundActivity: false,
        backgroundActivityInterval: 60,
        blockCooldownHours: 1,
        apiTemperature: 0.8,
        appIcons: { ...DEFAULT_APP_ICONS },
        cphoneWallpaper: 'linear-gradient(135deg, #f6d365, #fda085)',
        cphoneAppIcons: { ...DEFAULT_CPHONE_ICONS },
        globalCss: '',
        notificationSoundUrl: '',
        widgetData: {},
        globalChatBackground: '',
        enableAiDrawing: true,
    chatActionButtonsOrder: null,
        chatRenderWindow: 50
    };
    state.globalSettings = { ...defaultGlobalSettings, ...(loadedGlobalSettings || {}) };
    state.globalSettings.appIcons = { ...defaultGlobalSettings.appIcons, ...(state.globalSettings.appIcons || {}) };
    state.globalSettings.cphoneAppIcons = { ...defaultGlobalSettings.cphoneAppIcons, ...(state.globalSettings.cphoneAppIcons || {}) };

    chatsArr.forEach(chat => {
            if (typeof chat.settings.enableTimePerception === 'undefined') {
                chat.settings.enableTimePerception = true;
            }
        if (!chat.settings.lyricsPosition) {
            chat.settings.lyricsPosition = { vertical: 'top', horizontal: 'center', offset: 10 };
        }
        if (!chat.isGroup && !chat.settings.myAvatarLibrary) {
            chat.settings.myAvatarLibrary = [];
        }
        if (!chat.isGroup && typeof chat.originalName === 'undefined') {
            chat.originalName = chat.name;
        }
    });
    state.chats = chatsArr.reduce((acc, chat) => {
        if (typeof chat.unreadCount === 'undefined') chat.unreadCount = 0;
        if (chat.isGroup) {
            if (typeof chat.settings.enableBackgroundActivity === 'undefined') {
                chat.settings.enableBackgroundActivity = true;
            }
            if (chat.members && chat.members.length > 0 && chat.members[0].name) {
                chat.members.forEach(member => {
                    if (typeof member.originalName === 'undefined') {
                        member.originalName = member.name;
                        member.groupNickname = member.name;
                        delete member.name;
                    }
                });
            }
        }
        if (!chat.settings) chat.settings = {};
        if (typeof chat.settings.actionCooldownMinutes === 'undefined') {
            chat.settings.actionCooldownMinutes = 10;
        }
        if (!chat.isGroup && !chat.status) chat.status = { text: '在线', lastUpdate: Date.now(), isBusy: false };
        if (!chat.isGroup && !chat.relationship) chat.relationship = { status: 'friend', blockedTimestamp: null, applicationReason: '' };
        if (!chat.isGroup && (!chat.settings || !chat.settings.aiAvatarLibrary)) { if (!chat.settings) chat.settings = {}; chat.settings.aiAvatarLibrary = []; }
        if (chat.isGroup) { (chat.members || []).forEach(member => { if (typeof member.avatarFrame === 'undefined') member.avatarFrame = ''; }); }
        if (!chat.musicData) chat.musicData = { totalTime: 0 };
        if (chat.settings && chat.settings.linkedWorldBookId && !chat.settings.linkedWorldBookIds) { chat.settings.linkedWorldBookIds = [chat.settings.linkedWorldBookId]; delete chat.settings.linkedWorldBookId; }
        if (typeof chat.isPinned === 'undefined') chat.isPinned = false;
        if (!chat.isGroup && typeof chat.settings.myNickname === 'undefined') {
            chat.settings.myNickname = '我';
        }
        if (chat.isGroup && chat.members) {
            let needsUpdate = false;
            chatsArr.forEach(c => {
                 if (c.id === chat.id && c.originalName) {
                    delete c.originalName;
                 }
            });
            chat.members.forEach(member => {
                const originalCharacter = chatsArr.find(c => c.id === member.id);
                if (originalCharacter && originalCharacter.settings) {
                    const correctFrame = originalCharacter.settings.aiAvatarFrame || '';
                    if (member.avatarFrame !== correctFrame) {
                        member.avatarFrame = correctFrame;
                        needsUpdate = true;
                    }
                } else if (typeof member.avatarFrame === 'undefined') {
                    member.avatarFrame = '';
                    needsUpdate = true;
                }
            });
            if (needsUpdate) db.chats.put(chat);
        }
        if (!chat.settings.enableAutoMemory) chat.settings.enableAutoMemory = false;
        if (!chat.settings.autoMemoryInterval) chat.settings.autoMemoryInterval = 20;
        if (!chat.longTermMemory) chat.longTermMemory = [];
        if (!chat.lastMemorySummaryTimestamp) chat.lastMemorySummaryTimestamp = 0;
        if (!chat.isGroup) {
            if (typeof chat.settings.enableBackgroundActivity === 'undefined') {
                chat.settings.enableBackgroundActivity = true;
            }
            if (!chat.status) chat.status = { text: '在线', lastUpdate: Date.now(), isBusy: false };
            if (!chat.relationship) chat.relationship = { status: 'friend', blockedTimestamp: null, applicationReason: '' };
            if (!chat.settings || !chat.settings.aiAvatarLibrary) { if (!chat.settings) chat.settings = {}; chat.settings.aiAvatarLibrary = []; }
            if (typeof chat.settings.isOfflineMode === 'undefined') chat.settings.isOfflineMode = false;
            if (typeof chat.settings.offlineMinLength === 'undefined') chat.settings.offlineMinLength = 100;
            if (typeof chat.settings.offlineMaxLength === 'undefined') chat.settings.offlineMaxLength = 300;
            if (typeof chat.heartfeltVoice === 'undefined') chat.heartfeltVoice = '...';
            if (typeof chat.randomJottings === 'undefined') chat.randomJottings = '...';
            if (!Array.isArray(chat.thoughtsHistory)) {
                chat.thoughtsHistory = [];
            }
        }
        acc[chat.id] = chat;
        return acc;
    }, {});
    const memoriesToUpdate = [];
    allMemories.forEach(memory => {
        if (memory.type === 'ai_generated' && memory.authorName && !memory.authorId) {
            const foundChat = chatsArr.find(c => !c.isGroup && c.originalName === memory.authorName);
            if (foundChat) {
                memory.authorId = foundChat.id;
                memoriesToUpdate.push(memory);
            } else {
                 const fallbackChat = chatsArr.find(c => !c.isGroup && c.name === memory.authorName);
                 if(fallbackChat) {
                    memory.authorId = fallbackChat.id;
                    memoriesToUpdate.push(memory);
                 }
            }
        }
    });
    if (memoriesToUpdate.length > 0) {
        await db.memories.bulkPut(memoriesToUpdate);
    }
    state.apiConfig = apiConfig || { id: 'main', proxyUrl: '', apiKey: '', model: '', secondaryProxyUrl: '', secondaryApiKey: '', secondaryModel: '', minimaxGroupId: '', minimaxApiKey: '' };
    state.userStickers = userStickers || [];
    state.worldBooks = worldBooks || [];
    musicState.playlist = musicLib?.playlist || [];
    state.personaPresets = personaPresets || [];
    state.qzoneSettings = qzoneSettings || { id: 'main', nickname: '{{user}}', avatar: 'https://files.catbox.moe/q6z5fc.jpeg', banner: 'https://files.catbox.moe/r5heyt.gif' };
    allFavoriteItems = initialFavorites || [];
}
// ▲▲▲ 替换结束 ▲▲▲
        
                async function saveGlobalPlaylist() { await db.musicLibrary.put({ id: 'main', playlist: musicState.playlist }); }
        
                function formatTimestamp(timestamp) { if (!timestamp) return ''; const date = new Date(timestamp); const hours = String(date.getHours()).padStart(2, '0'); const minutes = String(date.getMinutes()).padStart(2, '0'); return `${hours}:${minutes}`; }
/**
 * 【全新 V2.0 | 智能日期感知版】为AI上下文格式化时间戳
 * @param {number} timestamp - 消息的时间戳
 * @returns {string} - 格式化后的日期时间字符串，例如 "今天 17:42", "昨天 23:50" 等
 */
function formatTimestampForAI(timestamp) {
    if (!timestamp) return '';
    
    const now = new Date();
    const date = new Date(timestamp);

    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const timeString = `${hours}:${minutes}`;

    // 如果是今天
    if (now.toDateString() === date.toDateString()) {
        return `今天 ${timeString}`;
    }

    // 如果是昨天
    const yesterday = new Date();
    yesterday.setDate(now.getDate() - 1);
    if (yesterday.toDateString() === date.toDateString()) {
        return `昨天 ${timeString}`;
    }
    
    // 如果是今年
    if (now.getFullYear() === date.getFullYear()) {
        const month = String(date.getMonth() + 1);
        const day = String(date.getDate());
        return `${month}月${day}日 ${timeString}`;
    }
    
    // 如果是往年
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1);
    const day = String(date.getDate());
    return `${year}年${month}月${day}日 ${timeString}`;
}        
         // ▼▼▼ 【全新】请用这个更可靠的版本，替换旧的 showNotification 函数 ▼▼▼
        function showNotification(chatId, messageContent) {
    // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    playNotificationSound();
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
            clearTimeout(notificationTimeout);
            const chat = state.chats[chatId];
            if (!chat) return;
        
            // 1. 获取通知栏元素
            const bar = document.getElementById('notification-bar');
            
            // 2. 填充内容
            document.getElementById('notification-avatar').src = chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar;
            document.getElementById('notification-content').querySelector('.name').textContent = chat.name;
            document.getElementById('notification-content').querySelector('.message').textContent = messageContent;
            
            // 3. 【核心修复】使用“强制重排”技巧，确保动画每次都能触发
            // 先移除class，让它回到初始的“隐藏”状态
            bar.classList.remove('visible');
            
            // 这一行是关键！它会强制浏览器重新计算元素布局，从而“重置”动画状态。
            void bar.offsetWidth; 
            
            // 再次添加class，浏览器会认为这是一个新的状态变化，从而平滑地执行CSS过渡动画。
            bar.classList.add('visible');
            
            // 4. 为通知栏绑定点击事件（使用克隆节点技巧清除旧监听器）
            const newBar = bar.cloneNode(true);
            bar.parentNode.replaceChild(newBar, bar);
            newBar.addEventListener('click', () => {
                openChat(chatId);
                newBar.classList.remove('visible');
            });
        
            // 5. 设置定时器，在4秒后自动隐藏通知
            notificationTimeout = setTimeout(() => {
                newBar.classList.remove('visible');
            }, 4000);
        }
        
               function updateClock() { 
    const now = new Date(); 
    const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); 
    const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' }); 
    
    // document.getElementById('main-time').textContent = timeString; // 注释掉这行
    document.getElementById('status-bar-time').textContent = timeString; 
    // document.getElementById('main-date').textContent = dateString; // 注释掉这行
}
        
        
        /**
         * 【终极健壮版】解析AI返回的、可能格式不规范的响应内容
         * @param {string} content - AI返回的原始字符串
         * @returns {Array} - 一个标准化的消息对象数组
         */
        function parseAiResponse(content) {
            const trimmedContent = content.trim();
        
            // 方案1：【最优先】尝试作为标准的、单一的JSON数组解析
            // 这是最理想、最高效的情况
            if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
                try {
                    const parsed = JSON.parse(trimmedContent);
                    if (Array.isArray(parsed)) {
                        console.log("解析成功：标准JSON数组格式。");
                        return parsed;
                    }
                } catch (e) {
                    // 如果解析失败，说明它虽然看起来像个数组，但内部格式有问题。
                    // 此时我们不报错，而是继续尝试下面的“强力解析”方案。
                    console.warn("标准JSON数组解析失败，将尝试强力解析...");
                }
            }
        
            // 方案2：【强力解析】使用正则表达式，从混乱的字符串中提取出所有独立的JSON对象
            // 这能完美解决您遇到的 "(Timestamp: ...)[{...}](Timestamp: ...)[{...}]" 这种格式
            const jsonMatches = trimmedContent.match(/{[^{}]*}/g);
        
            if (jsonMatches) {
                const results = [];
                for (const match of jsonMatches) {
                    try {
                        // 尝试解析每一个被我们“揪”出来的JSON字符串
                        const parsedObject = JSON.parse(match);
                        results.push(parsedObject);
                    } catch (e) {
                        // 如果某个片段不是有效的JSON，就忽略它，继续处理下一个
                        console.warn("跳过一个无效的JSON片段:", match);
                    }
                }
        
                // 如果我们成功提取出了至少一个有效的JSON对象，就返回这个结果
                if (results.length > 0) {
                    console.log("解析成功：通过强力提取模式。");
                    return results;
                }
            }
            
            // 方案3：【最终备用】如果以上所有方法都失败了，说明AI返回的可能就是纯文本
            // 我们将原始的、未处理的内容，包装成一个标准的文本消息对象返回，确保程序不会崩溃
            console.error("所有解析方案均失败！将返回原始文本。");
            return [{ type: 'text', content: content }];
        }
        /**
         * 【全新】根据当前时间获取一天中的问候语
         * @returns {string} - 返回如 "凌晨", "早上", "下午", "晚上" 等字符串
         */
        function getTimeOfDayGreeting(date = new Date()) { // 允许传入一个日期对象
            const hour = date.getHours(); // 使用传入的日期对象来获取小时
            if (hour >= 0 && hour < 5) {
                return "凌晨";
            } else if (hour >= 5 && hour < 9) {
                return "早上";
            } else if (hour >= 9 && hour < 13) {
                return "上午";
            } else if (hour >= 13 && hour < 18) {
                return "下午";
            } else if (hour >= 18 && hour < 24) {
                return "晚上";
            }
            return "现在"; // 默认情况
        }
        // ▼▼▼ 【全新】API预设功能核心函数 ▼▼▼
        
        /**
         * 从数据库加载API预设，并填充到下拉选择框中
         */
        async function loadApiPresetsDropdown() {
            const selectEl = document.getElementById('api-preset-select');
            selectEl.innerHTML = '<option value="current">当前配置 (未保存)</option>';
            
            const presets = await db.apiPresets.toArray();
            presets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                selectEl.appendChild(option);
            });
        
            // 检查当前配置是否与某个预设完全匹配
            const currentConfig = state.apiConfig;
            let matchingPresetId = null;
            for (const preset of presets) {
                if (
                    preset.proxyUrl === currentConfig.proxyUrl &&
                    preset.apiKey === currentConfig.apiKey &&
                    preset.model === currentConfig.model &&
                    preset.secondaryProxyUrl === currentConfig.secondaryProxyUrl &&
                    preset.secondaryApiKey === currentConfig.secondaryApiKey &&
                    preset.secondaryModel === currentConfig.secondaryModel
                ) {
                    matchingPresetId = preset.id;
                    break;
                }
            }
        
            if (matchingPresetId) {
                selectEl.value = matchingPresetId;
            } else {
                selectEl.value = 'current';
            }
        }
        
        /**
         * 当用户从下拉框选择一个预设时，加载该预设的配置
         */
        async function handlePresetSelectionChange() {
            const selectEl = document.getElementById('api-preset-select');
            const selectedId = parseInt(selectEl.value);
        
            // 如果选择的是“当前配置”，则不做任何事
            if (isNaN(selectedId)) {
                return;
            }
        
            const preset = await db.apiPresets.get(selectedId);
            if (preset) {
                // 将预设的配置加载到当前的全局状态中
                state.apiConfig = {
                    id: 'main',
                    proxyUrl: preset.proxyUrl,
                    apiKey: preset.apiKey,
                    model: preset.model,
                    secondaryProxyUrl: preset.secondaryProxyUrl,
                    secondaryApiKey: preset.secondaryApiKey,
                    secondaryModel: preset.secondaryModel
                };
                // 将加载的配置保存为当前正在使用的配置
                await db.apiConfig.put(state.apiConfig);
                // 重新渲染整个设置页面以显示新加载的配置
                renderApiSettings();
                // 自动为新加载的配置拉取模型列表
                document.getElementById('fetch-models-btn').click();
                if (preset.secondaryProxyUrl && preset.secondaryApiKey) {
                    document.getElementById('fetch-secondary-models-btn').click();
                }
                alert(`已加载预设 “${preset.name}”`);
            }
        }
        
        /**
         * 将当前输入框中的配置保存为一个新的预设
         */
        async function saveApiPreset() {
            const name = await showCustomPrompt('保存 API 预设', '请输入预设名称');
            if (!name || !name.trim()) return;
        
            // 从输入框读取当前配置
            const presetData = {
                name: name.trim(),
                proxyUrl: document.getElementById('proxy-url').value.trim(),
                apiKey: document.getElementById('api-key').value.trim(),
                model: document.getElementById('model-select').value,
                secondaryProxyUrl: document.getElementById('secondary-proxy-url').value.trim(),
                secondaryApiKey: document.getElementById('secondary-api-key').value.trim(),
                secondaryModel: document.getElementById('secondary-model-select').value
            };
        
            // 检查是否已存在同名预设
            const existingPreset = await db.apiPresets.where('name').equals(presetData.name).first();
            if (existingPreset) {
                const confirmed = await showCustomConfirm('覆盖预设', `名为 “${presetData.name}” 的预设已存在。要覆盖它吗？`, { confirmButtonClass: 'btn-danger' });
                if (!confirmed) return;
                presetData.id = existingPreset.id; // 指定ID以覆盖旧数据
            }
        
            await db.apiPresets.put(presetData);
            await loadApiPresetsDropdown(); // 刷新下拉列表
            alert('API 预设已保存！');
        }
        
        /**
         * 删除当前选中的预设
         */
        async function deleteApiPreset() {
            const selectEl = document.getElementById('api-preset-select');
            const selectedId = parseInt(selectEl.value);
        
            if (isNaN(selectedId)) {
                alert('请先从下拉框中选择一个要删除的预设。');
                return;
            }
        
            const preset = await db.apiPresets.get(selectedId);
            if (!preset) return;
        
            const confirmed = await showCustomConfirm('删除预设', `确定要删除预设 “${preset.name}” 吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.apiPresets.delete(selectedId);
                await loadApiPresetsDropdown(); // 刷新下拉列表
                alert('预设已删除。');
            }
        }
        // ▲▲▲ 新增函数结束 ▲▲▲
        // ▼▼▼ 【请用这个新版本】替换旧的 renderApiSettings 函数 ▼▼▼
        function renderApiSettings() { 
            // 1. 渲染当前配置到输入框
            document.getElementById('proxy-url').value = state.apiConfig.proxyUrl || ''; 
            document.getElementById('api-key').value = state.apiConfig.apiKey || ''; 
            document.getElementById('secondary-proxy-url').value = state.apiConfig.secondaryProxyUrl || '';
            document.getElementById('secondary-api-key').value = state.apiConfig.secondaryApiKey || '';
            document.getElementById('background-activity-switch').checked = state.globalSettings.enableBackgroundActivity || false;
            document.getElementById('background-interval-input').value = state.globalSettings.backgroundActivityInterval || 60;
            document.getElementById('block-cooldown-input').value = state.globalSettings.blockCooldownHours || 1;
            document.getElementById('enable-ai-drawing-switch').checked = state.globalSettings.enableAiDrawing; 
            document.getElementById('chat-render-window-input').value = state.globalSettings.chatRenderWindow || 50;   
            document.getElementById('chat-list-render-window-input').value = state.globalSettings.chatListRenderWindow || 30;
            const tempSlider = document.getElementById('api-temperature-slider');
            const tempValue = document.getElementById('api-temperature-value');
            const savedTemp = state.globalSettings.apiTemperature || 0.8;
            tempSlider.value = savedTemp;
            tempValue.textContent = savedTemp;    
           document.getElementById('minimax-group-id').value = state.apiConfig.minimaxGroupId || '';
           document.getElementById('minimax-api-key').value = state.apiConfig.minimaxApiKey || '';
            // 2. 【核心新增】加载并渲染预设下拉菜单
            loadApiPresetsDropdown();
        }
        // ▲▲▲ 替换结束 ▲▲▲
                window.renderApiSettingsProxy = renderApiSettings;
// ▼▼▼ 【全新】这是NPC管理功能的【全部核心JS代码】，请完整粘贴 ▼▼▼

/**
 * 【总入口 | 已修复长按事件】渲染NPC列表屏幕
 */
async function renderNpcListScreen() {
    const listEl = document.getElementById('npc-list');
    listEl.innerHTML = '';
    
    const npcs = await db.npcs.toArray();

    if (npcs.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">还没有创建任何NPC，<br>点击右上角“+”添加第一个吧！</p>';
        return;
    }

    npcs.forEach(npc => {
        const item = document.createElement('div');
        item.className = 'chat-list-item';
        item.dataset.npcId = npc.id;
        
        item.innerHTML = `
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar" style="border-radius: 50%;">
            <div class="info">
                <div class="name-line">
                    <span class="name">${npc.name}</span>
                </div>
                <div class="last-msg">${npc.persona.substring(0, 30)}...</div>
            </div>
        `;
        
        item.addEventListener('click', () => openNpcEditor(npc.id));
        
        // 【核心修复】确保 addLongPressListener 的回调函数是 async 函数
        addLongPressListener(item, async () => {
            await deleteNpc(npc.id);
        });
        
        listEl.appendChild(item);
    });
}

/**
         * 【已更新】打开NPC编辑器（用于新建或编辑）
         * @param {number|null} npcId - 如果是编辑，则传入ID；如果是新建，则为null
         */
        async function openNpcEditor(npcId = null) {
            editingNpcId = npcId;
            const modal = document.getElementById('npc-editor-modal');
            const titleEl = document.getElementById('npc-editor-title');
            const nameInput = document.getElementById('npc-name-input');
            const personaInput = document.getElementById('npc-persona-input');
            const avatarPreview = document.getElementById('npc-avatar-preview');
            const associationListEl = document.getElementById('npc-association-list');
            
            // 【核心新增】获取新添加的开关和输入框元素
            const activitySwitch = document.getElementById('npc-background-activity-switch');
            const cooldownInput = document.getElementById('npc-action-cooldown-input');
            
            associationListEl.innerHTML = ''; // 清空旧的关联列表

            // 生成可关联的角色列表 (逻辑不变)
            associationListEl.innerHTML += `<label><input type="checkbox" value="user"> ${state.qzoneSettings.nickname || '我'} (用户)</label>`;
            Object.values(state.chats).filter(c => !c.isGroup).forEach(char => {
                associationListEl.innerHTML += `<label><input type="checkbox" value="${char.id}"> ${char.name} (角色)</label>`;
            });

            if (npcId) {
                // 编辑模式
                titleEl.textContent = '编辑 NPC';
                const npc = await db.npcs.get(npcId);
                if (npc) {
                    nameInput.value = npc.name;
                    personaInput.value = npc.persona;
                    avatarPreview.src = npc.avatar || defaultGroupMemberAvatar;

                    // 【核心新增】读取并应用已保存的设置
                    // 使用 !== false 判断，确保新创建的、没有该字段的NPC默认为开启
                    activitySwitch.checked = npc.enableBackgroundActivity !== false; 
                    cooldownInput.value = npc.actionCooldownMinutes || 15;

                    if (npc.associatedWith && Array.isArray(npc.associatedWith)) {
                        npc.associatedWith.forEach(id => {
                            const checkbox = associationListEl.querySelector(`input[value="${id}"]`);
                            if (checkbox) checkbox.checked = true;
                        });
                    }
                }
            } else {
                // 新建模式
                titleEl.textContent = '添加 NPC';
                nameInput.value = '';
                personaInput.value = '';
                avatarPreview.src = defaultGroupMemberAvatar;

                // 【核心新增】为新NPC设置默认值
                activitySwitch.checked = true; // 默认开启
                cooldownInput.value = 15;     // 默认15分钟

                const userCheckbox = associationListEl.querySelector('input[value="user"]');
                if (userCheckbox) userCheckbox.checked = true;
            }

            modal.classList.add('visible');
        }

// ▼▼▼ 【V2.1 | 头像修复版】请用这个新版本替换旧的 saveNpc 函数 ▼▼▼
/**
 * 【已更新】保存NPC信息，并能处理“创建后直接加入群聊”的流程
 */
async function saveNpc() {
    const name = document.getElementById('npc-name-input').value.trim();
    const persona = document.getElementById('npc-persona-input').value.trim();
    if (!name || !persona) {
        alert("NPC的昵称和人设都不能为空！");
        return;
    }

    const selectedAssociations = Array.from(document.querySelectorAll('#npc-association-list input:checked')).map(cb => cb.value);
    const enableBackgroundActivity = document.getElementById('npc-background-activity-switch').checked;
    const actionCooldownMinutes = parseInt(document.getElementById('npc-action-cooldown-input').value) || 15;

    const npcData = {
        name,
        persona,
        avatar: document.getElementById('npc-avatar-preview').src,
        associatedWith: selectedAssociations,
        enableBackgroundActivity: enableBackgroundActivity,
        actionCooldownMinutes: actionCooldownMinutes
    };

    if (editingNpcId) {
        await db.npcs.update(editingNpcId, npcData);
    } else {
        // 新建NPC
        const newNpcId = await db.npcs.add(npcData);

        if (isAddingNpcToGroup && state.activeChatId) {
            const chat = state.chats[state.activeChatId];
            if (chat.isGroup) {
                // 【【【这就是最关键的修复！】】】
                // 在这里，我们也把 npcData.avatar 添加到了成员对象中
                chat.members.push({
                    id: `npc_${newNpcId}`,
                    originalName: name,
                    groupNickname: name,
                    persona: persona,
                    avatar: npcData.avatar, // <-- 核心新增
                    isNpc: true
                });
                await db.chats.put(chat);
            }
        }
    }
    
    document.getElementById('npc-editor-modal').classList.remove('visible');
    
    if (isAddingNpcToGroup) {
        isAddingNpcToGroup = false; 
        openMemberManagementScreen();
    } else {
        await renderNpcListScreen();
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 删除NPC
 * @param {number} npcId - 要删除的NPC的ID
 */
async function deleteNpc(npcId) {
    const npc = await db.npcs.get(npcId);
    if (!npc) return;
    const confirmed = await showCustomConfirm('删除NPC', `确定要删除NPC “${npc.name}” 吗？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.npcs.delete(npcId);
        await renderNpcListScreen();
    }
}
// ▲▲▲ 全新JS代码粘贴结束 ▲▲▲        
// ▼▼▼ 【请用这个已升级“分批加载”功能的全新版本】替换旧的 renderChatList 函数 ▼▼▼
        let chatListRenderCount = 0; // 新增一个全局变量，跟踪已渲染的数量

// ▼▼▼ 【全新】这是为“按需加载”新增的所有辅助函数 ▼▼▼

/**
 * 创建一个分组的容器（不包含聊天项）
 */
function createChatGroupContainer(group) {
    const groupContainer = document.createElement('div');
    groupContainer.className = 'chat-group-container';
    groupContainer.innerHTML = `
        <div class="chat-group-header">
            <span class="arrow">▼</span>
            <span class="group-name">${group.name}</span>
        </div>
        <div class="chat-group-content"></div>
    `;
    return groupContainer;
}



/**
 * 加载并渲染下一批次的聊天记录
 */
function loadMoreChats(sortedItems) {
    const chatListEl = document.getElementById('chat-list');
    const loadMoreBtn = document.getElementById('load-more-chats-btn');
    if (loadMoreBtn) loadMoreBtn.remove();
    
    const nextSliceStart = chatListRenderCount;
    const nextSliceEnd = chatListRenderCount + CHAT_LIST_RENDER_WINDOW;
    const itemsToAppend = sortedItems.slice(nextSliceStart, nextSliceEnd);

    // 使用 DocumentFragment 提高性能
    const fragment = document.createDocumentFragment();
    let currentGroupContent = chatListEl.querySelector('.chat-group-content:last-of-type');

    itemsToAppend.forEach(item => {
        if (item.type === 'groupHeader') {
            const groupContainer = createChatGroupContainer(item.group);
            fragment.appendChild(groupContainer);
            currentGroupContent = groupContainer.querySelector('.chat-group-content');
        } else if (item.type === 'chatItem') {
            const listItem = createChatListItem(item.chat);
            if (currentGroupContent && item.chat.groupId) {
                currentGroupContent.appendChild(listItem);
            } else {
                fragment.appendChild(listItem);
                currentGroupContent = null;
            }
        }
    });
    
    // 将新生成的项一次性添加到列表中
    chatListEl.appendChild(fragment);
    chatListRenderCount += itemsToAppend.length;

    if (sortedItems.length > chatListRenderCount) {
        appendLoadMoreChatsButton(chatListEl, sortedItems);
    }
    
    // 重新为所有分组标题绑定事件
    document.querySelectorAll('.chat-group-header').forEach(header => {
        const newHeader = header.cloneNode(true);
        header.parentNode.replaceChild(newHeader, header);
        newHeader.addEventListener('click', () => {
            newHeader.classList.toggle('collapsed');
            newHeader.nextElementSibling.classList.toggle('collapsed');
        });
    });
}
// ▲▲▲ 新增函数结束 ▲▲▲
// ▼▼▼ 【全新 | 已升级“分批加载”功能】请用这个全新版本替换旧的 renderChatList 函数 ▼▼▼
async function renderChatList() {
    const chatListEl = document.getElementById('chat-list');
    chatListEl.innerHTML = '';

    // 1. 获取并排序所有聊天数据（这部分逻辑不变）
    const allChats = Object.values(state.chats).sort((a, b) => {
        const pinDiff = (b.isPinned || false) - (a.isPinned || false);
        if (pinDiff !== 0) return pinDiff;
        return (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0);
    });
    
    const allGroups = await db.qzoneGroups.toArray();

    if (allChats.length === 0) {
        chatListEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 或群组图标添加聊天</p>';
        return;
    }

    allGroups.forEach(group => {
        const latestChatInGroup = allChats.find(chat => chat.groupId === group.id);
        group.latestTimestamp = latestChatInGroup ? (latestChatInGroup.history.slice(-1)[0]?.timestamp || 0) : 0;
    });
    allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
    
    // 2. 【核心修改】将所有可渲染项存入全局变量，而不是立即渲染
    sortedChatListItems = []; // 先清空
    const processedChatIds = new Set();

    allGroups.forEach(group => {
        const groupChats = allChats.filter(chat => !chat.isGroup && chat.groupId === group.id);
        if (groupChats.length > 0) {
            sortedChatListItems.push({ type: 'groupHeader', group });
            groupChats.forEach(chat => {
                sortedChatListItems.push({ type: 'chatItem', chat });
                processedChatIds.add(chat.id);
            });
        }
    });

    allChats.forEach(chat => {
        if (!processedChatIds.has(chat.id)) {
            sortedChatListItems.push({ type: 'chatItem', chat });
        }
    });

    // 3. 【核心修改】重置渲染计数器，并只渲染第一批次的聊天项
    chatListRenderCount = 0;
    loadMoreChats(); // 直接调用 loadMoreChats 来渲染第一页
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新】这是为“分批加载”新增的所有辅助函数 ▼▼▼

        /**
         * 创建一个分组的容器（不包含聊天项）
         */
        function createChatGroupContainer(group) {
            const groupContainer = document.createElement('div');
            groupContainer.className = 'chat-group-container';
            groupContainer.innerHTML = `
                <div class="chat-group-header">
                    <span class="arrow">▼</span>
                    <span class="group-name">${group.name}</span>
                </div>
                <div class="chat-group-content"></div>
            `;
            return groupContainer;
        }

        /**
         * 创建并添加“加载更多”按钮
         */
        function appendLoadMoreChatsButton(container, sortedItems) {
            const button = document.createElement('button');
            button.id = 'load-more-chats-btn';
            button.textContent = '加载更早的会话';
            button.className = 'load-more-btn'; // 复用样式
            
            // 【重要】为按钮绑定加载下一页的事件
            button.addEventListener('click', () => loadMoreChats(sortedItems), { once: true });
            
            container.prepend(button); // 将按钮添加到列表顶部
        }

// ▼▼▼ 【全新 | 独立设置+加载动画版】请用这个版本替换旧的 loadMoreChats 函数 ▼▼▼
        function loadMoreChats() {
            if (isLoadingMoreChats) return;

            const chatListEl = document.getElementById('chat-list');
            const scrollContainer = document.getElementById('messages-view');
            if (!chatListEl || !scrollContainer) return;
            if (chatListRenderCount >= sortedChatListItems.length) return;

            isLoadingMoreChats = true;

            // 核心修改1：判断是否是首次加载
            const isInitialLoad = chatListRenderCount === 0;

            // 将核心渲染逻辑封装成一个函数
            const renderContent = () => {
                hideLoader(chatListEl);

                const renderWindow = state.globalSettings.chatListRenderWindow || 30;
                const nextSliceStart = chatListRenderCount;
                const nextSliceEnd = chatListRenderCount + renderWindow;
                const itemsToAppend = sortedChatListItems.slice(nextSliceStart, nextSliceEnd);

                const fragment = document.createDocumentFragment();
                let currentGroupContent = chatListEl.querySelector('.chat-group-content:last-of-type');

                itemsToAppend.forEach(item => {
                    if (item.type === 'groupHeader') {
                        const groupContainer = createChatGroupContainer(item.group);
                        fragment.appendChild(groupContainer);
                        currentGroupContent = groupContainer.querySelector('.chat-group-content');
                    } else if (item.type === 'chatItem') {
                        const listItem = createChatListItem(item.chat);
                        if (item.chat.groupId && currentGroupContent) {
                            currentGroupContent.appendChild(listItem);
                        } else {
                            fragment.appendChild(listItem);
                            if (!item.chat.groupId) currentGroupContent = null;
                        }
                    }
                });

                chatListEl.appendChild(fragment);
                chatListRenderCount += itemsToAppend.length;

                chatListEl.querySelectorAll('.chat-group-header:not([data-has-listener="true"])').forEach(header => {
                    header.dataset.hasListener = "true";
                    header.addEventListener('click', () => {
                        header.classList.toggle('collapsed');
                        header.nextElementSibling.classList.toggle('collapsed');
                    });
                });

                isLoadingMoreChats = false;

                if (scrollContainer.scrollHeight <= scrollContainer.clientHeight && chatListRenderCount < sortedChatListItems.length) {
                    loadMoreChats();
                }
            };

            // 核心修改2：根据是否是首次加载，决定是否使用延迟
            if (isInitialLoad) {
                // 如果是首次加载，则立即执行渲染，没有任何延迟
                renderContent();
            } else {
                // 如果是后续加载（滚动时），则显示加载动画并保留延迟，以优化体验
                showLoader(chatListEl, 'bottom');
                setTimeout(renderContent, 500);
            }
        }
// ▲▲▲ 替换结束 ▲▲▲ 
// ▼▼▼ 【全新 | V2.0 容错增强版】请用这个新版本替换旧的 createChatListItem 函数 ▼▼▼
function createChatListItem(chat) {
    // 【核心新增】使用 try...catch 包裹整个函数
    try {
        const lastMsgObj = chat.history.filter(msg => !msg.isHidden).slice(-1)[0] || {};
        let lastMsgDisplay;

        if (!chat.isGroup && chat.relationship?.status === 'pending_user_approval') {
            lastMsgDisplay = `<span style="color: #ff8c00;">[好友申请] ${chat.relationship.applicationReason || '请求添加你为好友'}</span>`;
        } else if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
            lastMsgDisplay = `<span style="color: #dc3545;">[你已被对方拉黑]</span>`;
        } else if (chat.isGroup) {
            if (lastMsgObj.type === 'pat_message') { lastMsgDisplay = `[系统消息] ${lastMsgObj.content}`; }
            else if (lastMsgObj.type === 'transfer') { lastMsgDisplay = '[转账]'; }
            else if (lastMsgObj.type === 'ai_image' || lastMsgObj.type === 'user_photo') { lastMsgDisplay = '[照片]'; }
            else if (lastMsgObj.type === 'voice_message') { lastMsgDisplay = '[语音]'; }
            else if (typeof lastMsgObj.content === 'string' && STICKER_REGEX.test(lastMsgObj.content)) { lastMsgDisplay = lastMsgObj.meaning ? `[表情: ${lastMsgObj.meaning}]` : '[表情]'; }
            else if (Array.isArray(lastMsgObj.content)) { lastMsgDisplay = `[图片]`; }
            else { lastMsgDisplay = String(lastMsgObj.content || '...').substring(0, 20); }

            if (lastMsgObj.senderName && lastMsgObj.type !== 'pat_message') {
                const senderDisplayName = getDisplayNameInGroup(chat, lastMsgObj.senderName);
                lastMsgDisplay = `${senderDisplayName}: ${lastMsgDisplay}`;
            }
        } else {
            const statusText = chat.status?.text || '在线';
            lastMsgDisplay = `[${statusText}]`;
        }

        const item = document.createElement('div');
        item.className = 'chat-list-item';
        item.dataset.chatId = chat.id;
        if (chat.isPinned) {
            item.classList.add('pinned');
        }

        const avatar = chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar;
        const avatarFrameSrc = chat.isGroup ? '' : (chat.settings.aiAvatarFrame || '');
        let avatarHtml;
        if (avatarFrameSrc) {
            avatarHtml = `<div class="avatar-with-frame"><img src="${avatar || defaultAvatar}" class="avatar-img"><img src="${avatarFrameSrc}" class="avatar-frame"></div>`;
        } else {
            avatarHtml = `<img src="${avatar || defaultAvatar}" class="avatar">`;
        }
        const hasFrameClass = avatarFrameSrc ? 'has-frame' : '';
        const avatarGroupHtml = `<div class="avatar-group ${hasFrameClass}">${avatarHtml}</div>`;

        item.innerHTML = `
            ${avatarGroupHtml}
            <div class="info">
                <div class="name-line">
                    <span class="name">${chat.name}</span>
                    ${chat.isGroup ? '<span class="group-tag">群聊</span>' : ''}
                </div>
                <div class="last-msg" style="color: ${chat.isGroup ? 'var(--text-secondary)' : '#b5b5b5'}; font-style: italic;">${lastMsgDisplay}</div>
            </div>
            <div class="unread-count-wrapper">
                <span class="unread-count" style="display: none;">0</span>
            </div>
        `;
        
        const unreadCount = chat.unreadCount || 0;
        const unreadEl = item.querySelector('.unread-count');
        if (unreadCount > 0) {
            unreadEl.textContent = unreadCount > 99 ? '99+' : unreadCount;
            unreadEl.style.display = 'inline-flex';
        } else {
            unreadEl.style.display = 'none';
        }
        
        const avatarGroupEl = item.querySelector('.avatar-group');
        if (avatarGroupEl) {
            avatarGroupEl.style.cursor = 'pointer';
            avatarGroupEl.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                const nameToPat = chat.isGroup ? chat.name : chat.originalName;
                handleUserPat(chat.id, nameToPat);
            });
        }
        
        const infoEl = item.querySelector('.info');
        if (infoEl) {
            infoEl.addEventListener('click', () => openChat(chat.id));
        }
    
        addLongPressListener(item, async (e) => {
            const action = await showChatListActions(chat);
            switch (action) {
                case 'pin':
                    chat.isPinned = !chat.isPinned;
                    await db.chats.put(chat);
                    renderChatList();
                    break;
                case 'delete':
                    const deleteConfirmed = await showCustomConfirm('删除对话', `确定要删除与 "${chat.name}" 的整个对话吗？此操作不可撤销。`, { confirmButtonClass: 'btn-danger' });
                    if (deleteConfirmed) {
                        if (musicState.isActive && musicState.activeChatId === chat.id) {
                            await endListenTogetherSession(false);
                        }
                        delete state.chats[chat.id];
                        if (state.activeChatId === chat.id) state.activeChatId = null;
                        await db.chats.delete(chat.id);
                        renderChatList();
                    }
                    break;
                default:
                    break;
            }
        });
        return item;

    } catch (error) {
        // 【核心新增】如果渲染过程中出错，就在控制台打印错误，并返回 null
        console.error(`渲染聊天项 [${chat.name || '未知'}] (ID: ${chat.id}) 时出错:`, error);
        return null; // 返回 null，这样就不会把一个坏掉的元素添加到页面上
    }
}
// ▲▲▲ 替换结束 ▲▲▲
        
// ▼▼▼ 【无限滚动修复版】请用这个新版本替换旧的 renderChatInterface 函数 ▼▼▼
        async function renderChatInterface(chatId) {
            applyButtonOrder();
            cleanupWaimaiTimers();
            const chat = state.chats[chatId];
            if (!chat) return;

            exitSelectionMode();

            const messagesContainer = document.getElementById('chat-messages');
            const chatInputArea = document.getElementById('chat-input-area');
            const lockOverlay = document.getElementById('chat-lock-overlay');
            const lockContent = document.getElementById('chat-lock-content');

            messagesContainer.dataset.theme = chat.settings.theme || 'default';
            const fontSize = chat.settings.fontSize || 13;
            messagesContainer.style.setProperty('--chat-font-size', `${fontSize}px`);
            applyScopedCss(chat.settings.customCss || '', '#chat-messages', 'custom-bubble-style');

            document.getElementById('chat-header-title').textContent = chat.name;
            const statusContainer = document.getElementById('chat-header-status');
            const statusTextEl = statusContainer.querySelector('.status-text');

            if (chat.isGroup) {
                statusContainer.style.display = 'none';
                document.getElementById('chat-header-title-wrapper').style.justifyContent = 'center';
            } else {
                statusContainer.style.display = 'flex';
                document.getElementById('chat-header-title-wrapper').style.justifyContent = 'flex-start';
                statusTextEl.textContent = chat.status?.text || '在线';
                statusContainer.classList.toggle('busy', chat.status?.isBusy || false);
            }

            const chatScreen = document.getElementById('chat-interface-screen');
            const individualBg = chat.settings.background;
            const globalBg = state.globalSettings.globalChatBackground;
            const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
            const defaultColor = isDarkMode ? '#000000' : '#f0f2f5';

            if (individualBg) {
                chatScreen.style.backgroundImage = `url(${individualBg})`;
                chatScreen.style.backgroundColor = 'transparent';
            } else if (globalBg) {
                chatScreen.style.backgroundImage = `url(${globalBg})`;
                chatScreen.style.backgroundColor = 'transparent';
            } else {
                chatScreen.style.backgroundImage = 'none';
                chatScreen.style.backgroundColor = defaultColor;
            }

            // ... (中间所有关于锁定、旁观模式的 if/else 逻辑保持不变) ...
            if (chat.isSpectatorGroup) {
                chatInputArea.style.display = 'none';
                lockOverlay.style.display = 'flex';
                lockContent.innerHTML = `
                    <span class="lock-text">正在围观AI们的群聊...</span>
                    <div class="spectator-actions-container">
                        <button id="spectator-reroll-btn" class="lock-action-btn secondary" title="重新生成上一轮对话">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                                <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                            </svg>
                        </button>
                        <button id="spectator-propel-btn" class="lock-action-btn">🎬 推进剧情</button>
                        <button id="spectator-edit-btn" class="lock-action-btn secondary" title="导演剪辑室：编辑AI上一轮的响应">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path>
                                <line x1="16" y1="8" x2="2" y2="22"></line>
                                <line x1="17.5" y1="15" x2="9" y2="15"></line>
                            </svg>
                        </button>
                    </div>
                `;
                document.getElementById('spectator-propel-btn').onclick = triggerSpectatorGroupAiAction;
            } else {
                chatInputArea.style.display = 'flex';
                lockOverlay.style.display = 'none';
                lockContent.innerHTML = '';
                if (!chat.isGroup && chat.relationship.status !== 'friend') {
                    lockOverlay.style.display = 'flex';
                    chatInputArea.style.visibility = 'hidden';
                    
                    let lockHtml = '';
                    switch (chat.relationship.status) {
                         case 'blocked_by_user':
                            const isSimulationRunning = simulationIntervalId !== null;
                            const blockedTimestamp = chat.relationship.blockedTimestamp;
                            const cooldownHours = state.globalSettings.blockCooldownHours || 1;
                            const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
                            const timeSinceBlock = Date.now() - blockedTimestamp;
                            const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
                            const timeRemainingMinutes = Math.max(0, Math.ceil((cooldownMilliseconds - timeSinceBlock) / (1000 * 60)));
            
                            lockHtml = `
                                <span class="lock-text">你已将“${chat.name}”拉黑。</span>
                                <button id="unblock-btn" class="lock-action-btn">解除拉黑</button>
                                <div style="margin-top: 20px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                                    <strong style="color: #333;">【开发者诊断面板】</strong><br>
                                    - 后台活动总开关: ${state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已开启</span>' : '<span style="color: red;">已关闭</span>'}<br>
                                    - 系统心跳计时器: ${isSimulationRunning ? '<span style="color: green;">运行中</span>' : '<span style="color: red;">未运行</span>'}<br>
                                    - 当前角色状态: <strong>${chat.relationship.status}</strong><br>
                                    - 需要冷静(小时): <strong>${cooldownHours}</strong><br>
                                    - 冷静期是否结束: ${isCooldownOver ? '<span style="color: green;">是</span>' : `<span style="color: orange;">否 (还剩约 ${timeRemainingMinutes} 分钟)</span>`}<br>
                                    - 触发条件: ${isCooldownOver && state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已满足，等待下次系统心跳</span>' : '<span style="color: red;">未满足</span>'}
                                </div>
                                <button id="force-apply-check-btn" class="lock-action-btn secondary" style="margin-top: 10px;">强制触发一次好友申请检测</button>
                            `;
                            break;
                        case 'blocked_by_ai':
                            lockHtml = `
                                <span class="lock-text">你被对方拉黑了。</span>
                                <button id="apply-friend-btn" class="lock-action-btn">重新申请加为好友</button>
                            `;
                            break;
                        case 'pending_user_approval':
                            lockHtml = `
                                <span class="lock-text">“${chat.name}”请求添加你为好友：<br><i>“${chat.relationship.applicationReason}”</i></span>
                                <button id="accept-friend-btn" class="lock-action-btn">接受</button>
                                <button id="reject-friend-btn" class="lock-action-btn secondary">拒绝</button>
                            `;
                            break;
                        case 'pending_ai_approval':
                            lockHtml = `<span class="lock-text">好友申请已发送，等待对方通过...</span>`;
                            break;
                    }
                    lockContent.innerHTML = lockHtml;
                } else {
                     lockOverlay.style.display = 'none';
                     chatInputArea.style.visibility = 'visible';
                }
            }
            
            messagesContainer.innerHTML = '';
            const history = chat.history;
            currentRenderedCount = 0;
            const renderWindow = state.globalSettings.chatRenderWindow || 50;
            const initialMessages = history.slice(-renderWindow);

            // --- ▼▼▼ 核心修改就在这里！ ▼▼▼ ---
            // 1. 创建一个数组来存放所有“创建消息元素”的异步任务 (Promise)
            const messagePromises = [];
            let lastTimestamp = 0;

            for (const msg of initialMessages) {
                if (lastTimestamp > 0 && (msg.timestamp - lastTimestamp > 600000)) {
                    // 时间戳是同步创建的，可以直接添加
                    messagePromises.push(Promise.resolve(createSystemTimestampElement(msg.timestamp)));
                }
                // 2. 将异步任务推入数组，但不在这里等待它完成
                messagePromises.push(createMessageElement(msg, chat, true));
                lastTimestamp = msg.timestamp;
            }

            // 3. 使用 Promise.all() 并发执行所有的异步任务
            const messageElements = await Promise.all(messagePromises);

            // 4. 所有任务完成后，一次性将所有创建好的元素添加到页面中
            const fragment = document.createDocumentFragment();
            messageElements.filter(Boolean).forEach(el => fragment.appendChild(el));
            messagesContainer.appendChild(fragment);
            // --- ▲▲▲ 修改结束 ▲▲▲ ---

            currentRenderedCount = initialMessages.length;

            const typingIndicator = document.createElement('div');
            typingIndicator.id = 'typing-indicator';
            typingIndicator.style.display = 'none';
            typingIndicator.textContent = '对方正在输入...';
            messagesContainer.appendChild(typingIndicator);

            setTimeout(() => messagesContainer.scrollTop = messagesContainer.scrollHeight, 0);
        }
// ▲▲▲ 替换结束 ▲▲▲
        
                
        
// ▼▼▼ 【无限滚动修复版】请用这个新版本替换旧的 loadMoreMessages 函数 ▼▼▼
async function loadMoreMessages() {
    if (isLoadingMoreMessages) return;
    isLoadingMoreMessages = true;

    const messagesContainer = document.getElementById('chat-messages');
    const chat = state.chats[state.activeChatId];
    if (!chat) {
        isLoadingMoreMessages = false;
        return;
    }

    showLoader(messagesContainer, 'top'); // 在顶部显示加载动画
    const oldScrollHeight = messagesContainer.scrollHeight;

    // 模拟网络延迟，让动画更明显
    await new Promise(resolve => setTimeout(resolve, 500));

    const totalMessages = chat.history.length;
    const renderWindow = state.globalSettings.chatRenderWindow || 50;
    const nextSliceStart = totalMessages - currentRenderedCount - renderWindow;
    const nextSliceEnd = totalMessages - currentRenderedCount;
    const messagesToPrepend = chat.history.slice(Math.max(0, nextSliceStart), nextSliceEnd);


    // 1. 获取当前屏幕上最“老”的那条消息的时间戳，作为我们比较的基准
    const firstVisibleMessage = messagesContainer.querySelector('.message-wrapper[data-timestamp]');
    let nextMessageTimestamp = firstVisibleMessage ? parseInt(firstVisibleMessage.dataset.timestamp) : 0;

    // 2. 依然是从新到旧地遍历我们要添加的消息
    for (const msg of messagesToPrepend.reverse()) {
        
        // 3. 【核心新增】在添加每条消息之前，都检查它和它后面那条消息的时间差
        if (nextMessageTimestamp > 0 && (nextMessageTimestamp - msg.timestamp > 600000)) { // 600000毫秒 = 10分钟
            // 如果间隔大于10分钟，就为“更晚”的那条消息创建一个时间提示
            const timestampEl = createSystemTimestampElement(nextMessageTimestamp);
            // 将时间提示也添加到顶部
            messagesContainer.prepend(timestampEl);
        }
        
        // 4. 添加消息本身（这部分逻辑不变）
        await prependMessage(msg, chat);
        
        // 5. 更新我们的时间基准，为下一次循环做准备
        nextMessageTimestamp = msg.timestamp;
    }

    currentRenderedCount += messagesToPrepend.length;

    // 恢复滚动位置，防止跳动
    const newScrollHeight = messagesContainer.scrollHeight;
    messagesContainer.scrollTop = newScrollHeight - oldScrollHeight;

    hideLoader(messagesContainer); // 加载完成后隐藏动画
    isLoadingMoreMessages = false;
}
// ▲▲▲ 替换结束 ▲▲▲
        
// ▼▼▼ 【请用这个已更新的版本】替换旧的 renderWallpaperScreen 函数 ▼▼▼
        function renderWallpaperScreen() { 
            loadCssPresetsDropdown();
            
            // EPhone 壁纸预览
            const preview = document.getElementById('wallpaper-preview'); 
            const bg = newWallpaperBase64 || state.globalSettings.wallpaper; 
            if (bg && bg.startsWith('data:image')) { 
                preview.style.backgroundImage = `url(${bg})`; 
                preview.textContent = ''; 
            } else if(bg) { 
                preview.style.backgroundImage = bg; 
                preview.textContent = '当前为渐变色'; 
            }

            // 【核心新增】渲染CPhone的壁纸预览
            const cphonePreview = document.getElementById('cphone-wallpaper-preview');
            const cphoneBg = state.globalSettings.cphoneWallpaper;
            if (cphoneBg && cphoneBg.startsWith('data:image')) {
                cphonePreview.style.backgroundImage = `url(${cphoneBg})`;
                cphonePreview.textContent = '';
            } else if (cphoneBg) {
                cphonePreview.style.backgroundImage = cphoneBg;
                cphonePreview.textContent = '当前为渐变色';
            }

            // 全局聊天背景预览
            const globalBgPreview = document.getElementById('global-bg-preview');
            const globalBg = state.globalSettings.globalChatBackground;
            if (globalBg) {
                globalBgPreview.style.backgroundImage = `url(${globalBg})`;
                globalBgPreview.textContent = '';
                document.getElementById('remove-global-bg-btn').style.display = 'inline-block';
            } else {
                globalBgPreview.style.backgroundImage = 'none';
                globalBgPreview.textContent = '点击下方上传';
                document.getElementById('remove-global-bg-btn').style.display = 'none';
            }

            // 渲染 EPhone 和 CPhone 的图标设置
            renderIconSettings();
            renderCPhoneIconSettings(); // <-- 新增调用

            // (其他逻辑保持不变)
            document.getElementById('global-css-input').value = state.globalSettings.globalCss || '';
            document.getElementById('notification-sound-url-input').value = state.globalSettings.notificationSoundUrl || '';
            document.getElementById('status-bar-toggle-switch').checked = state.globalSettings.showStatusBar || false;
    renderButtonOrderEditor();
    initializeButtonOrderEditor();
        }
        // ▲▲▲ 替换结束 ▲▲▲
                window.renderWallpaperScreenProxy = renderWallpaperScreen;
        
                function applyGlobalWallpaper() { const homeScreen = document.getElementById('home-screen'); const wallpaper = state.globalSettings.wallpaper; if (wallpaper && wallpaper.startsWith('data:image')) homeScreen.style.backgroundImage = `url(${wallpaper})`; else if (wallpaper) homeScreen.style.backgroundImage = wallpaper; }
        
        // ▼▼▼ 【全新】这个函数用于处理世界书页签的点击切换 ▼▼▼
        function switchWorldBookCategory(categoryId) {
            // 1. 切换页签的激活状态
            document.querySelectorAll('.world-book-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.categoryId === categoryId);
            });
            // 2. 切换内容面板的显示状态
            document.querySelectorAll('.world-book-category-pane').forEach(pane => {
                pane.classList.toggle('active', pane.dataset.categoryId === categoryId);
            });
        }
        
        // ▼▼▼ 【请用这个全新版本】完整替换旧的 renderWorldBookScreen 函数 ▼▼▼
        async function renderWorldBookScreen() {
            const tabsContainer = document.getElementById('world-book-tabs');
            const contentContainer = document.getElementById('world-book-content-container');
            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = '';
        
            // 1. 同时获取所有书籍和所有分类
            const [books, categories] = await Promise.all([
                db.worldBooks.toArray(),
                db.worldBookCategories.orderBy('name').toArray()
            ]);
        
            state.worldBooks = books; // 确保内存中的数据是同步的
        
            if (books.length === 0) {
                contentContainer.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 创建你的第一本世界书</p>';
                return;
            }
        
            // --- 2. 创建并添加“全部”页签和其内容面板 ---
            const allTab = document.createElement('button');
            allTab.className = 'world-book-tab active';
            allTab.textContent = '全部';
            allTab.dataset.categoryId = 'all';
            tabsContainer.appendChild(allTab);
        
            const allPane = document.createElement('div');
            allPane.className = 'world-book-category-pane active';
            allPane.dataset.categoryId = 'all';
            contentContainer.appendChild(allPane);
        
            // --- 3. 创建并添加各个分类的页签和内容面板 ---
            categories.forEach(category => {
                const categoryTab = document.createElement('button');
                categoryTab.className = 'world-book-tab';
                categoryTab.textContent = category.name;
                categoryTab.dataset.categoryId = String(category.id);
                tabsContainer.appendChild(categoryTab);
        
                const categoryPane = document.createElement('div');
                categoryPane.className = 'world-book-category-pane';
                categoryPane.dataset.categoryId = String(category.id);
                contentContainer.appendChild(categoryPane);
            });
            
            // --- 4. 创建并添加“未分类”的页签和内容面板 (如果需要) ---
            const hasUncategorized = books.some(book => !book.categoryId);
            if (hasUncategorized) {
                const uncategorizedTab = document.createElement('button');
                uncategorizedTab.className = 'world-book-tab';
                uncategorizedTab.textContent = '未分类';
                uncategorizedTab.dataset.categoryId = 'uncategorized';
                tabsContainer.appendChild(uncategorizedTab);
            
                const uncategorizedPane = document.createElement('div');
                uncategorizedPane.className = 'world-book-category-pane';
                uncategorizedPane.dataset.categoryId = 'uncategorized';
                contentContainer.appendChild(uncategorizedPane);
            }
        
            // --- 5. 遍历书籍，将它们填充到对应的内容面板中 ---
            books.forEach(book => {
                let contentPreview = '暂无内容...';
                if (Array.isArray(book.content) && book.content.length > 0) {
                    const firstEntry = book.content[0];
                    contentPreview = firstEntry.comment || firstEntry.content || '';
                } else if (typeof book.content === 'string' && book.content.trim() !== '') {
                    contentPreview = book.content;
                }
        
                const card = document.createElement('div');
                card.className = 'world-book-card';
                card.innerHTML = `
                    <div class="card-title">${book.name}</div>
                    <div class="card-content-preview">${contentPreview}</div>
                `;
                
                // 为卡片本身添加点击和长按事件
                const cardClickHandler = () => openWorldBookEditor(book.id);
                const cardLongPressHandler = async () => { 
                    const confirmed = await showCustomConfirm('删除世界书', `确定要删除《${book.name}》吗？`, { confirmButtonClass: 'btn-danger' }); 
                    if (confirmed) { 
                        await db.worldBooks.delete(book.id); 
                        state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id); 
                        renderWorldBookScreen(); 
                    } 
                };
        
                card.addEventListener('click', cardClickHandler);
                addLongPressListener(card, cardLongPressHandler);
        
                // 克隆卡片并投放到“全部”面板
                const clonedCardForAll = card.cloneNode(true);
                clonedCardForAll.addEventListener('click', cardClickHandler);
                addLongPressListener(clonedCardForAll, cardLongPressHandler);
                allPane.appendChild(clonedCardForAll);
                
                // 将原始卡片投放到对应的分类面板
                const categoryKey = book.categoryId ? String(book.categoryId) : 'uncategorized';
                const targetPane = contentContainer.querySelector(`.world-book-category-pane[data-category-id="${categoryKey}"]`);
                if (targetPane) {
                    targetPane.appendChild(card);
                }
            });
        
            // --- 6. 为所有页签绑定切换事件 ---
            document.querySelectorAll('.world-book-tab').forEach(tab => {
                tab.addEventListener('click', () => switchWorldBookCategory(tab.dataset.categoryId));
            });
        }
        
        // ▼▼▼ 【请用这个最终修复版】完整替换旧的 createWorldBookGroup 函数 ▼▼▼
        /**
         * 【V2.0 | 已修复预览BUG】创建一个分类的分组DOM
         * @param {string} groupName - 分类名称
         * @param {Array} books - 该分类下的书籍数组
         * @returns {HTMLElement} - 创建好的分组容器
         */
        function createWorldBookGroup(groupName, books) {
            const groupContainer = document.createElement('div');
            groupContainer.className = 'world-book-group-container';
            
            groupContainer.innerHTML = `
                <div class="world-book-group-header">
                    <span class="arrow">▼</span>
                    <span class="group-name">${groupName}</span>
                </div>
                <div class="world-book-group-content"></div>
            `;
        
            const contentEl = groupContainer.querySelector('.world-book-group-content');
            books.sort((a,b) => a.name.localeCompare(b.name, 'zh-CN')); // 按书名排序
            
            books.forEach(book => {
                // ▼▼▼ 【【【这就是最关键的修复！】】】 ▼▼▼
                let contentPreview = '暂无内容...';
                
                // 1. 检查 book.content 是否是我们新的“条目数组”格式
                if (Array.isArray(book.content) && book.content.length > 0) {
                    // 如果是，就从第一个条目的内容中提取预览
                    // 我们也优先使用第一个条目的 comment 作为预览，因为它更简洁
                    const firstEntry = book.content[0];
                    contentPreview = firstEntry.comment || firstEntry.content || '';
                } 
                // 2. 否则，就检查它是否是旧的“字符串”格式
                else if (typeof book.content === 'string' && book.content.trim() !== '') {
                    // 如果是，就像以前一样处理
                    contentPreview = book.content;
                }
                // ▲▲▲ 修复结束 ▲▲▲
        
                const item = document.createElement('div');
                item.className = 'list-item';
                item.dataset.bookId = book.id;
                // 现在，我们使用处理好的 contentPreview 来生成HTML，并确保它是一个字符串
                item.innerHTML = `
                    <div class="item-title">${book.name}</div>
                    <div class="item-content">${String(contentPreview).substring(0, 50)}</div>
                `;
                item.addEventListener('click', () => openWorldBookEditor(book.id));
                addLongPressListener(item, async () => { 
                    const confirmed = await showCustomConfirm('删除世界书', `确定要删除《${book.name}》吗？此操作不可撤销。`, { confirmButtonClass: 'btn-danger' }); 
                    if (confirmed) { 
                        await db.worldBooks.delete(book.id); 
                        state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id); 
                        renderWorldBookScreen(); 
                    } 
                });
                contentEl.appendChild(item);
            });
        
            return groupContainer;
        }
        // ▲▲▲ 替换结束 ▲▲▲
                window.renderWorldBookScreenProxy = renderWorldBookScreen;
        
        // ▼▼▼ 【请用这个已修复BUG的版本】完整替换旧的 openWorldBookEditor 函数 ▼▼▼
        async function openWorldBookEditor(bookId) {
            // 【核心修复】将切换屏幕的操作移动到函数的最前面
            // 这样可以确保在操作DOM元素之前，它们所在的屏幕已经是激活状态
            showScreen('world-book-editor-screen');
        
            editingWorldBookId = bookId;
            const [book, categories] = await Promise.all([
                db.worldBooks.get(bookId),
                db.worldBookCategories.toArray()
            ]);
        
            // 如果在切换屏幕后发现书籍不存在，则安全返回列表页
            if (!book) {
                console.error("尝试打开一个不存在的世界书，ID:", bookId);
                showScreen('world-book-screen');
                return;
            }
        
            // 现在，因为屏幕已显示，所以可以安全地操作这些元素了
            document.getElementById('world-book-editor-title').textContent = book.name;
            document.getElementById('world-book-name-input').value = book.name;
        
            // 分类下拉菜单的逻辑保持不变
            const selectEl = document.getElementById('world-book-category-select');
            selectEl.innerHTML = '<option value="">-- 未分类 --</option>';
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.name;
                if (book.categoryId === cat.id) option.selected = true;
                selectEl.appendChild(option);
            });
        
            // 动态渲染条目的逻辑保持不变
            const entriesContainer = document.getElementById('world-book-entries-container');
            entriesContainer.innerHTML = ''; 
        
            if (Array.isArray(book.content) && book.content.length > 0) {
                book.content.forEach(entry => {
                    const block = createWorldBookEntryBlock(entry);
                    entriesContainer.appendChild(block);
                });
            } else {
                entriesContainer.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 20px;">还没有内容，点击下方按钮添加第一条吧！</p>';
            }
        
            // 不再需要在函数末尾调用 showScreen，因为它已经在开头被调用了
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
// ▼▼▼ 【请用这个支持搜索的 V3.0 版本】替换旧的 renderStickerPanel 函数 ▼▼▼
/**
 * 【V3.0 | 搜索支持版】渲染表情面板
 * @param {boolean} rerenderTabs - 是否需要重新渲染顶部的分类页签
 */
async function renderStickerPanel(rerenderTabs = true) {
    const grid = document.getElementById('sticker-grid');
    const tabsContainer = document.getElementById('sticker-category-tabs');
    const searchInput = document.getElementById('sticker-search-input');
    const searchTerm = searchInput.value.trim().toLowerCase();

    // --- 1. 渲染分类页签 (仅在需要时) ---
    if (rerenderTabs) {
        tabsContainer.innerHTML = '';
        const categories = await db.stickerCategories.toArray();
        
        tabsContainer.innerHTML += `<button class="sticker-category-tab ${activeStickerCategoryId === 'all' ? 'active' : ''}" data-category-id="all">全部</button>`;
        categories.forEach(cat => {
             tabsContainer.innerHTML += `<button class="sticker-category-tab ${activeStickerCategoryId === cat.id ? 'active' : ''}" data-category-id="${cat.id}">${cat.name}</button>`;
        });
        tabsContainer.innerHTML += `<button class="sticker-category-tab ${activeStickerCategoryId === 'uncategorized' ? 'active' : ''}" data-category-id="uncategorized">未分类</button>`;
    }

    // --- 2. 【核心修改】筛选表情 ---
    grid.innerHTML = '';
    
    // 步骤 a: 先根据当前选中的分类筛选
    let stickersByCategory;
    if (activeStickerCategoryId === 'all') {
        stickersByCategory = state.userStickers;
    } else if (activeStickerCategoryId === 'uncategorized') {
        stickersByCategory = state.userStickers.filter(s => !s.categoryId);
    } else {
        stickersByCategory = state.userStickers.filter(s => s.categoryId === activeStickerCategoryId);
    }

    // 步骤 b: 如果有搜索词，在分类结果的基础上进一步筛选
    const stickersToShow = searchTerm
        ? stickersByCategory.filter(sticker => sticker.name.toLowerCase().includes(searchTerm))
        : stickersByCategory;

    // --- 3. 渲染最终结果 (这部分逻辑不变) ---
    if (stickersToShow.length === 0) {
        const message = searchTerm ? '找不到匹配的表情' : '这个分类下还没有表情哦~';
        grid.innerHTML = `<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1; padding-top: 20px;">${message}</p>`;
        return;
    }

    stickersToShow.forEach(sticker => {
        const item = document.createElement('div');
        item.className = 'sticker-item';
        item.title = sticker.name;
        item.dataset.stickerId = sticker.id;
        item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${sticker.url})"></div>
            <span class="sticker-name">${sticker.name}</span>
        `;
        item.addEventListener('click', () => {
            if (isStickerManagementMode) {
                handleStickerSelection(item);
            } else {
                sendSticker(sticker);
            }
        });
        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '&times;';
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('删除表情', `确定要删除表情 "${sticker.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.userStickers.delete(sticker.id);
                state.userStickers = state.userStickers.filter(s => s.id !== sticker.id);
                renderStickerPanel();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

        // ▼▼▼ 【全新】表情批量删除核心功能 ▼▼▼
        let isStickerManagementMode = false;
        let selectedStickers = new Set();
        
        // ▼▼▼ 【请用这个 V2.0 版本】替换旧的 toggleStickerManagementMode 函数 ▼▼▼
        /**
         * 切换表情面板的管理模式
         */
        function toggleStickerManagementMode() {
            isStickerManagementMode = !isStickerManagementMode;
            const grid = document.getElementById('sticker-grid');
            const manageBtn = document.getElementById('manage-stickers-btn');
            const actionBar = document.getElementById('sticker-action-bar');
            const selectAllCheckbox = document.getElementById('select-all-stickers-checkbox');
        
            grid.classList.toggle('management-mode', isStickerManagementMode);
            
            if (isStickerManagementMode) {
                manageBtn.textContent = '完成';
                actionBar.style.display = 'flex'; // 改为 flex
                selectedStickers.clear();
                selectAllCheckbox.checked = false; // 重置全选框
                updateDeleteStickerButton();
            } else {
                manageBtn.textContent = '管理';
                actionBar.style.display = 'none';
                grid.querySelectorAll('.sticker-item.selected').forEach(item => item.classList.remove('selected'));
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 【全新】这是智能“全选”功能的核心函数，请完整粘贴 ▼▼▼
        /**
         * 处理“全选”复选框的点击事件，根据当前分类智能选择
         */
        function handleSelectAllStickers() {
            const checkbox = document.getElementById('select-all-stickers-checkbox');
            const shouldSelect = checkbox.checked;
        
            // 1. 根据当前激活的分类ID，筛选出应该被操作的表情
            let stickersToSelect;
            if (activeStickerCategoryId === 'all') {
                stickersToSelect = state.userStickers;
            } else if (activeStickerCategoryId === 'uncategorized') {
                stickersToSelect = state.userStickers.filter(s => !s.categoryId);
            } else {
                stickersToSelect = state.userStickers.filter(s => s.categoryId === activeStickerCategoryId);
            }
        
            // 2. 遍历这些被筛选出的表情
            stickersToSelect.forEach(sticker => {
                const stickerId = sticker.id;
                const itemEl = document.querySelector(`.sticker-item[data-sticker-id="${stickerId}"]`);
                
                if (shouldSelect) {
                    // 如果是“全选”操作
                    selectedStickers.add(stickerId);
                    if (itemEl) itemEl.classList.add('selected');
                } else {
                    // 如果是“取消全选”操作
                    selectedStickers.delete(stickerId);
                    if (itemEl) itemEl.classList.remove('selected');
                }
            });
        
            // 3. 更新删除按钮的计数
            updateDeleteStickerButton();
        }
        // ▲▲▲ 新增函数结束 ▲▲▲        
        /**
         * 更新删除按钮上的计数
         */
        function updateDeleteStickerButton() {
            const btn = document.getElementById('delete-selected-stickers-btn');
            btn.textContent = `删除 (${selectedStickers.size})`;
        }
        
        /**
         * 处理用户点击选择或取消选择表情
         * @param {HTMLElement} item - 被点击的表情DOM元素
         */
        function handleStickerSelection(item) {
            if (!isStickerManagementMode) return; // 只有在管理模式下才生效
        
            const stickerId = item.dataset.stickerId;
            if (!stickerId) return;
        
            item.classList.toggle('selected');
        
            if (selectedStickers.has(stickerId)) {
                selectedStickers.delete(stickerId);
            } else {
                selectedStickers.add(stickerId);
            }
            updateDeleteStickerButton();
        }
        
        /**
         * 执行批量删除操作
         */
        async function executeBatchDeleteStickers() {
            if (selectedStickers.size === 0) return;
            
            const confirmed = await showCustomConfirm(
                '确认删除',
                `确定要删除选中的 ${selectedStickers.size} 个表情吗？此操作不可恢复。`,
                { confirmButtonClass: 'btn-danger' }
            );
        
            if (confirmed) {
                const idsToDelete = [...selectedStickers];
                
                // 从数据库批量删除
                await db.userStickers.bulkDelete(idsToDelete);
                
                // 从内存状态中过滤掉被删除的表情
                state.userStickers = state.userStickers.filter(s => !idsToDelete.includes(s.id));
                
                // 退出管理模式并刷新列表
                toggleStickerManagementMode();
                renderStickerPanel();
                
                await showCustomAlert('删除成功', '选中的表情已成功删除。');
            }
        }
        // ▲▲▲ 全新功能函数粘贴结束 ▲▲▲
        
        // ▼▼▼ 【全新】批量导入表情的核心功能 ▼▼▼
        
        /**
         * 【总入口】打开批量导入表情的弹窗
         */
        async function openBatchStickerImportModal() {
            const placeholderText = `请按照以下格式粘贴，一行一个：\n\n焦虑 2a9wte.jpeg\n大惊失色 or8qf4.png\n没有灵感 njwujh.jpeg`;
            
            const pastedText = await showCustomPrompt(
                '批量导入表情',
                placeholderText,
                '',
                'textarea'
            );
        
            if (pastedText && pastedText.trim()) {
                await handleBatchStickerImport(pastedText);
            }
        }
        
        // ▼▼▼ 【最终修复版】请用这个全新的函数，完整替换旧的 handleBatchStickerImport 函数 ▼▼▼
        /**
         * 【核心逻辑 | V3.0 - 已修复URL格式BUG】处理粘贴的文本，解析并存入数据库
         * @param {string} text - 用户粘贴的文本内容
         */
        async function handleBatchStickerImport(text) {
            const lines = text.trim().split('\n');
            const newStickers = [];
            const baseUrl = 'https://files.catbox.moe/';
            let errorCount = 0;
            const currentCategoryId = (activeStickerCategoryId !== 'all' && activeStickerCategoryId !== 'uncategorized') ? activeStickerCategoryId : null;

            for (const line of lines) {
                const trimmedLine = line.trim();

                // ▼▼▼ 核心修复：移除了错误的 `trimmedLine.includes('http')` 判断 ▼▼▼
                // 现在只跳过空行或示例行
                if (!trimmedLine || trimmedLine.includes('填入')) {
                    continue;
                }
                // ▲▲▲ 修复结束 ▲▲▲

                // 优先匹配 “名称：URL” 格式
                const fullUrlMatch = trimmedLine.match(/^(.+?)[:：]\s*(https?:\/\/.+)$/);
                
                if (fullUrlMatch) {
                    const name = fullUrlMatch[1].trim();
                    const url = fullUrlMatch[2].trim();
                    newStickers.push({
                        id: 'sticker_' + Date.now() + Math.random(),
                        name: name,
                        url: url,
                        categoryId: currentCategoryId
                    });
                    continue; 
                }

                // 如果上面没匹配成功，则尝试匹配旧的 catbox.moe 格式
                let name = null;
                let code = null;
                const noSpaceMatch = trimmedLine.match(/^([\u4e00-\u9fa5]+)([a-zA-Z0-9]+\..+)$/);
                
                if (noSpaceMatch) {
                    name = noSpaceMatch[1];
                    code = noSpaceMatch[2];
                } else {
                    const parts = trimmedLine.split(/\s+/);
                    if (parts.length >= 2) {
                        code = parts.pop();
                        name = parts.join(' ');
                    }
                }

                if (name && code && code.includes('.')) {
                    newStickers.push({
                        id: 'sticker_' + Date.now() + Math.random(),
                        name: name,
                        url: baseUrl + code,
                        categoryId: currentCategoryId
                    });
                } else {
                    errorCount++;
                    console.warn('批量导入格式错误，已跳过此行:', trimmedLine);
                }
            }

            if (errorCount > 0) {
                await showCustomAlert('部分导入失败', `有 ${errorCount} 行的格式不正确，已被系统跳过。`);
            }

            if (newStickers.length > 0) {
                await db.userStickers.bulkAdd(newStickers);
                state.userStickers.push(...newStickers);
                renderStickerPanel();
                await showCustomAlert('导入成功', `已成功批量导入 ${newStickers.length} 个新表情！`);
            } else if (errorCount === 0) {
                alert("没有找到可导入的内容。请检查您粘贴的格式是否正确。");
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲
/**
 * 【辅助函数】滚动到并高亮显示原始消息
 * @param {number} originalTimestamp - 要跳转到的原始消息的时间戳
 */
function scrollToOriginalMessage(originalTimestamp) {
    const selector = `.message-bubble[data-timestamp="${originalTimestamp}"]`;
    const originalMessageBubble = document.querySelector(selector);

    if (originalMessageBubble) {
        originalMessageBubble.scrollIntoView({
            behavior: 'smooth',
            block: 'center'
        });

        originalMessageBubble.classList.add('highlighted');
        setTimeout(() => {
            if (document.body.contains(originalMessageBubble)) {
                originalMessageBubble.classList.remove('highlighted');
            }
        }, 1500); // 高亮持续1.5秒

    } else {
        // 只有在所有尝试都失败后才提示用户
        alert("找不到原始消息。可能已被删除或位于更早的历史记录中。");
    }
}


// ▲▲▲ 新增代码粘贴结束 ▲▲▲
        // ▼▼▼ 【最终修复版】请用这个全新的函数，完整替换旧的 createMessageElement 函数 ▼▼▼
        async function createMessageElement(msg, chat) {
        
            // --- (系统消息和撤回消息的处理逻辑保持不变) ---
            if (msg.type === 'recalled_message') {
                const wrapper = document.createElement('div');
                wrapper.className = 'message-wrapper system-pat';
                wrapper.dataset.timestamp = msg.timestamp; 
                const bubble = document.createElement('div');
                bubble.className = 'message-bubble recalled-message-placeholder';
                bubble.dataset.timestamp = msg.timestamp; 
                bubble.textContent = msg.content;
                wrapper.appendChild(bubble);
                addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
                wrapper.addEventListener('click', () => { 
                    if (isSelectionMode) {
                        toggleMessageSelection(msg.timestamp);
                    }
                });
                return wrapper;
            }
            else if (msg.type === 'post_deleted_notice') {
                const wrapper = document.createElement('div');
                wrapper.className = 'message-wrapper system-pat';
                wrapper.dataset.timestamp = msg.timestamp; 
                const bubble = document.createElement('div');
                bubble.className = 'message-bubble post-deleted-placeholder'; 
                bubble.dataset.postId = msg.postId;
                bubble.textContent = msg.content;
                wrapper.appendChild(bubble);
                addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
                wrapper.addEventListener('click', () => { 
                    if (isSelectionMode) {
                        toggleMessageSelection(msg.timestamp);
                    }
                });
                return wrapper;
            }
        
            if (msg.isHidden) {
                return null;
            }
        
            if (msg.type === 'pat_message') {
                const wrapper = document.createElement('div');
                wrapper.className = 'message-wrapper system-pat'; 
                const bubble = document.createElement('div');
                bubble.className = 'message-bubble system-bubble'; 
                bubble.dataset.timestamp = msg.timestamp;
                bubble.textContent = msg.content;
                wrapper.appendChild(bubble);
                addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
                wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
                return wrapper;
            }
        
            // --- (基础DOM元素准备逻辑保持不变) ---
            const isUser = msg.role === 'user';
            const myNickname = chat.settings.myNickname || '我';
            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;
        
            if (chat.isGroup && !isUser) {
                const member = chat.members.find(m => m.originalName === msg.senderName);
                const senderNameDiv = document.createElement('div');
                senderNameDiv.className = 'sender-name';
                senderNameDiv.textContent = member ? member.groupNickname : (msg.senderName || '未知成员');
                wrapper.appendChild(senderNameDiv);
            }
        
            const bubble = document.createElement('div');
            bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
            bubble.dataset.timestamp = msg.timestamp;
        
            const timestampEl = document.createElement('span');
            timestampEl.className = 'timestamp';
            timestampEl.textContent = formatTimestamp(msg.timestamp);
        
            let avatarSrc, avatarFrameSrc = '';
            if (isUser) {
                avatarSrc = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
                avatarFrameSrc = chat.settings.myAvatarFrame || '';
            } else {
                if (chat.isGroup) {
                    const member = chat.members.find(m => m.originalName === msg.senderName);
                    if (member) {
                        const characterProfile = state.chats[member.id];
                        avatarSrc = member.avatar || (characterProfile ? characterProfile.settings.aiAvatar : defaultGroupMemberAvatar);
                        avatarFrameSrc = member.avatarFrame || (characterProfile ? characterProfile.settings.aiAvatarFrame : '');
                    } else {
                        avatarSrc = defaultGroupMemberAvatar;
                        avatarFrameSrc = '';
                    }
                } else {
                    avatarSrc = chat.settings.aiAvatar || defaultAvatar;
                    avatarFrameSrc = chat.settings.aiAvatarFrame || '';
                }
            }
        
            let avatarHtml;
            if (avatarFrameSrc) {
                avatarHtml = `<div class="avatar-with-frame"><img src="${avatarSrc}" class="avatar-img"><img src="${avatarFrameSrc}" class="avatar-frame"></div>`;
            } else {
                avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
            }
            const hasFrameClass = avatarFrameSrc ? 'has-frame' : '';
            const avatarGroupHtml = `<div class="avatar-group ${hasFrameClass}">${avatarHtml}</div>`;
            
            let contentHtml;
            let quoteHtml = '';
            if (msg.quote) {
                const quotedSenderDisplayName = getDisplayNameInGroup(chat, msg.quote.senderName);
                const fullQuotedContent = String(msg.quote.content || '');
                quoteHtml = `
                    <div class="quoted-message" data-original-timestamp="${msg.quote.timestamp}" style="cursor: pointer;">
                        <div class="quoted-sender">回复 ${quotedSenderDisplayName}:</div>
                        <div class="quoted-content">${fullQuotedContent}</div>
                    </div>
                `;
            }
            
            // ==========================================================
            //                  ★★★ 核心修改逻辑 ★★★
            // ==========================================================
        
            let rawContent = msg.content; // 直接使用 msg.content，不再强制转为字符串

            if (typeof rawContent === 'string' && rawContent.trim().startsWith('<') && rawContent.trim().endsWith('>')) {
                contentHtml = rawContent;
                bubble.classList.add('is-raw-html'); 
            } else if (msg.type === 'offline_text' || msg.type === 'share_link' || msg.type === 'share_card' || msg.type === 'location_share' || msg.type === 'ai_image' || msg.type === 'user_photo' || msg.type === 'voice_message' || msg.type === 'transfer' || msg.type === 'waimai_request'|| msg.type === 'waimai_order'  || msg.type === 'red_packet' || msg.type === 'poll' || msg.type === 'gift') {
                // (这部分是您已有的所有卡片渲染逻辑，保持不变)
               if (msg.type === 'offline_text') {
                    // 1. 【兼容旧数据】如果消息还是旧的 dialogue/description 格式，则先合并
                    const combinedText = msg.content || `${msg.dialogue || ''} ${msg.description || ''}`.trim();

                    // 2. 【核心渲染逻辑】使用正则表达式，以引号为界，将文本分割成“对话”和“描写”两部分
                    const regex = /(「.*?」|“.*?”)/g;
                    const parts = combinedText.split(regex).filter(part => part); 

                    // 3. 遍历分割后的片段，为每一部分应用不同的样式
                    contentHtml = parts.map(part => {
                        // 如果片段以引号开头，说明它是对话
                        if (part.startsWith('「') || part.startsWith('“')) {
                            return `<span class="offline-dialogue">${parseMarkdown(part)}</span>`;
                        } else {
                            // 否则，它就是描写
                            return `<span class="offline-description">${parseMarkdown(part.trim()).replace(/\n/g, '<br>')}</span>`;
                        }
                    }).join(''); // 最后将所有片段拼接成最终的HTML
                }
else if (msg.type === 'tts_voice') {
    bubble.classList.add('is-voice-message', 'is-card-like');
    const duration = Math.max(1, Math.round((msg.content || '').length / 5));
    const durationFormatted = `0:${String(duration).padStart(2, '0')}''`;
    // 从聊天设置中获取为该角色指定的 voice_id，如果没有，则使用一个默认值
    const voiceId = chat.settings.minimaxVoiceId || 'female-shaonv-jingpin';

    contentHtml = `
        <div class="voice-message-body" data-text="${encodeURIComponent(msg.content)}" data-voice-id="${voiceId}">
            <button class="voice-play-btn">▶</button>
            <div class="voice-spinner"></div>
            <span class="voice-duration">${durationFormatted}</span>
        </div>
    `;
}  else if (msg.type === 'share_link') {
                    bubble.classList.add('is-link-share', 'is-card-like');
                    contentHtml = `<div class="link-share-card" data-timestamp="${msg.timestamp}"><div class="title">${msg.title || '无标题'}</div><div class="description">${msg.description || '点击查看详情...'}</div><div class="footer"><svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg><span>${msg.source_name || '链接分享'}</span></div></div>`;
                } else if (msg.type === 'share_card') {
                    bubble.classList.add('is-link-share', 'is-card-like');
                    contentHtml = `<div class="link-share-card" style="cursor: pointer;" data-timestamp="${msg.timestamp}"><div class="title">${msg.payload.title}</div><div class="description">共 ${msg.payload.sharedHistory.length} 条消息</div><div class="footer"><svg class="footer-icon" ...>...</svg><span>聊天记录</span></div></div>`;
                } else if (msg.type === 'location_share') {
                    bubble.classList.add('is-location-share', 'is-card-like');
                        let finalImageUrl;
    
    // 1. 优先使用消息自带的 imageUrl (这是你手动分享时设置的)
    if (msg.imageUrl) {
        finalImageUrl = msg.imageUrl;
    } 
    // 2. 其次，如果开启了AI生图且AI返回了指令，则使用AI生图
    else if (state.globalSettings.enableAiDrawing && msg.image_prompt) {
        finalImageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(msg.image_prompt)}`;
    } 
    // 3. 最后，如果以上都没有，才使用占位图
    else {
        finalImageUrl = 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756262526935_qdqqd_4uque3.jpeg'; // 默认占位图
    }
    
    const mapAreaStyle = `style="background-image: url('${finalImageUrl}');"`;
                    contentHtml = `<div class="location-share-card"><div class="card-text-area"><div class="card-text-primary">${msg.content}</div><div class="card-text-secondary">位置分享</div></div><div class="card-map-area" ${mapAreaStyle}><div class="card-pin-icon"><svg width="1em" height="1em" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 11.5C11.1716 11.5 10.5 10.8284 10.5 10C10.5 9.17157 11.1716 8.5 12 8.5C12.8284 8.5 13.5 9.17157 13.5 10C13.5 10.8284 12.8284 11.5 12 11.5Z"></path><path d="M12 2C7.92134 2 4.5 5.42134 4.5 9.5C4.5 14.5312 11.2188 21.4375 11.5938 21.8125C11.7954 22.014 12.2046 22.014 12.4062 21.8125C12.7812 21.4375 19.5 14.5312 19.5 9.5C19.5 5.42134 16.0787 2 12 2ZM12 12.5C10.6193 12.5 9.5 11.3807 9.5 10C9.5 8.61929 10.6193 7.5 12 7.5C13.3807 7.5 14.5 8.61929 14.5 10C14.5 11.3807 13.3807 12.5 12 12.5Z"></path></svg></div></div></div>`;
                } else if (msg.type === 'user_photo' || msg.type === 'ai_image') {
                    bubble.classList.add('is-ai-image', 'is-card-like');
                    const altText = msg.type === 'user_photo' ? "用户描述的照片" : "AI生成的图片";
                    
                    // 1. 在生成URL之前，加入对全局开关的判断
                    const imageUrl = state.globalSettings.enableAiDrawing && msg.image_prompt 
                        ? `https://image.pollinations.ai/prompt/${msg.image_prompt}` 
                        : 'https://i.postimg.cc/KYr2qRCK/1.jpg'; // <-- 如果开关关闭，则使用占位图

                    // 2. 将判断后的URL用于生成HTML
                    contentHtml = `<img src="${imageUrl}" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;
                } else if (msg.type === 'voice_message') {
                    bubble.classList.add('is-voice-message', 'is-card-like');
                    bubble.dataset.voiceText = msg.content;
                    const duration = Math.max(1, Math.round((msg.content || '').length / 5));
                    const durationFormatted = `0:${String(duration).padStart(2, '0')}''`;
                    const waveformHTML = '<div></div><div></div><div></div><div></div><div></div>';
                    contentHtml = `<div class="voice-message-body"><div class="voice-waveform">${waveformHTML}</div><div class="loading-spinner"></div><span class="voice-duration">${durationFormatted}</span></div><div class="voice-transcript"></div>`;
                } else if (msg.type === 'transfer') {
                    bubble.classList.add('is-transfer', 'is-card-like');
                     let titleText, noteText;
                    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                    const senderDisplayName = getDisplayNameInGroup(chat, msg.senderName);
                    const receiverDisplayName = getDisplayNameInGroup(chat, msg.receiverName || chat.name);
                    if (isUser) { 
                        if (msg.isRefund) { titleText = `退款给 ${receiverDisplayName}`; noteText = '已拒收对方转账'; } 
                        else { titleText = `转账给 ${receiverDisplayName}`; if (msg.status === 'accepted') noteText = '对方已收款'; else if (msg.status === 'declined') noteText = '对方已拒收'; else noteText = msg.note || '等待对方处理...'; }
                    } else {
                        if (msg.isRefund) { titleText = `退款来自 ${senderDisplayName}`; noteText = '转账已被拒收'; } 
                        else if (msg.receiverName === myNickname) { titleText = `转账给 ${myNickname}`; if (msg.status === 'accepted') noteText = '你已收款'; else if (msg.status === 'declined') noteText = '你已拒收'; else { bubble.style.cursor = 'pointer'; bubble.dataset.status = 'pending'; noteText = msg.note || '点击处理'; } } 
                        else { titleText = `转账: ${senderDisplayName} → ${receiverDisplayName}`; noteText = msg.note || '群聊内转账'; }
                    }
                    const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;
                    contentHtml = `<div class="transfer-card"><div class="transfer-title">${heartIcon} ${titleText}</div><div class="transfer-amount">¥ ${Number(msg.amount).toFixed(2)}</div><div class="transfer-note">${noteText}</div></div>`;
                } else if (msg.type === 'waimai_request') {
                    bubble.classList.add('is-waimai-request', 'is-card-like');
                     if (msg.status === 'paid' || msg.status === 'rejected') bubble.classList.add(`status-${msg.status}`);
                    const senderDisplayName = getDisplayNameInGroup(chat, msg.senderName);
                    const requestTitle = `来自 ${senderDisplayName} 的代付请求`;
                    let actionButtonsHtml = '';
                    if (msg.status === 'pending' && !isUser) { actionButtonsHtml = `<div class="waimai-user-actions"><button class="waimai-decline-btn" data-choice="rejected">残忍拒绝</button><button class="waimai-pay-btn" data-choice="paid">为Ta买单</button></div>`; }
                    contentHtml = `<div class="waimai-card"><div class="waimai-header"><img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon"><div class="title-group"><span class="brand">美团外卖</span><span class="separator">|</span><span>外卖美食</span></div></div><div class="waimai-catchphrase">Hi，你和我的距离只差一顿外卖～</div><div class="waimai-main"><div class="request-title">${requestTitle}</div><div class="payment-box"><div class="payment-label">需付款</div><div class="amount">¥${Number(msg.amount).toFixed(2)}</div><div class="countdown-label">剩余支付时间<div class="countdown-timer" id="waimai-timer-${msg.timestamp}"></div></div></div><button class="waimai-details-btn">查看详情</button></div>${actionButtonsHtml}</div>`;
                       setTimeout(() => {
        if (msg.status === 'pending') {
            const timerElement = document.getElementById(`waimai-timer-${msg.timestamp}`);
            if (timerElement) {
                const timerId = startWaimaiCountdown(timerElement, msg.countdownEndTime);
                // 将计时器ID存起来，方便在离开页面时统一清理
                waimaiTimers[msg.timestamp] = timerId;
            }
        }
    }, 0);
                } else if (msg.type === 'waimai_order') {
                bubble.classList.add('is-waimai-request', 'is-card-like'); // 复用样式
                const senderDisplayName = getDisplayNameInGroup(chat, msg.senderName);
                
                let recipientDisplayName = '你';
                if (chat.isGroup) {
                    // 如果是群聊，就去查找接收者的名字
                    recipientDisplayName = getDisplayNameInGroup(chat, msg.recipientName);
                }

    contentHtml = `
        <div class="waimai-card">
            <div class="waimai-header">
                <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                <div class="title-group"><span class="brand">美团外卖</span><span class="separator">|</span><span>外卖美食</span></div>
            </div>
            <div class="waimai-main">
                <div class="request-title" style="margin-bottom: 12px;">${senderDisplayName} 已为${recipientDisplayName}下单，请慢用～</div>
                <div class="payment-box">
                    <div class="payment-label" style="font-size: 18px; font-weight: 600;">${msg.productInfo}</div>
                    <div class="amount" style="margin-top: 8px;">¥${Number(msg.amount).toFixed(2)}</div>
                </div>
                <button class="waimai-details-btn">查看订单详情</button>
            </div>
        </div>
    `;
}else if (msg.type === 'red_packet') {
                     bubble.classList.add('is-red-packet', 'is-card-like');
                    const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
                    const isFinished = msg.isFullyClaimed; const hasClaimed = msg.claimedBy && msg.claimedBy[myOriginalName];
                    let cardClass = '', claimedInfoHtml = '', typeText = '拼手气红包';
                    if (isFinished) { cardClass = 'opened'; } if (msg.packetType === 'direct') { const receiverDisplayName = getDisplayNameInGroup(chat, msg.receiverName); typeText = `专属红包: 给 ${receiverDisplayName}`; if (Object.keys(msg.claimedBy || {}).length > 0) cardClass = 'opened'; }
                    if (hasClaimed) { const myClaimedAmount = msg.claimedBy[myOriginalName] || 0; claimedInfoHtml = `<div class="rp-claimed-info">你领取了红包，金额 ${myClaimedAmount.toFixed(2)} 元</div>`; } 
                    else if (isFinished) { claimedInfoHtml = `<div class="rp-claimed-info">红包已被领完</div>`; } 
                    else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) { const receiverDisplayName = getDisplayNameInGroup(chat, msg.receiverName); claimedInfoHtml = `<div class="rp-claimed-info">已被 ${receiverDisplayName} 领取</div>`; }
                    contentHtml = `<div class="red-packet-card ${cardClass}"><div class="rp-header"><img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon"><span class="rp-greeting">${msg.greeting || '恭喜发财，大吉大利！'}</span></div><div class="rp-type">${typeText}</div>${claimedInfoHtml}</div>`;
                } else if (msg.type === 'poll') {
                    bubble.classList.add('is-poll', 'is-card-like');
                    const pollQuestionText = msg.question || msg.content || '(无标题投票)';
                    let totalVotes = 0; const voteCounts = {}; for (const option in msg.votes) { const count = msg.votes[option].length; voteCounts[option] = count; totalVotes += count; }
                    const myOriginalName = state.qzoneSettings.nickname || '{{user}}'; let myVote = null; for (const option in msg.votes) { if (msg.votes[option].includes(myOriginalName)) { myVote = option; break; } }
                    let optionsHtml = '<div class="poll-options-list">'; msg.options.forEach(optionText => { const count = voteCounts[optionText] || 0; const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0; const isVotedByMe = myVote === optionText; optionsHtml += `<div class="poll-option-item ${isVotedByMe ? 'voted' : ''}" data-option="${optionText}"><div class="poll-option-bar" style="width: ${percentage}%;"></div><div class="poll-option-content"><span class="poll-option-text">${optionText}</span><span class="poll-option-votes">${count} 票</span></div></div>`; }); optionsHtml += '</div>';
                    let footerHtml = msg.isClosed ? `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">查看结果</button></div>` : `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">结束投票</button></div>`;
                    contentHtml = `<div class="poll-card ${msg.isClosed ? 'closed' : ''}" data-poll-timestamp="${msg.timestamp}"><div class="poll-question">${pollQuestionText}</div>${optionsHtml}${footerHtml}</div>`;
                } else if (msg.type === 'gift') {
                    bubble.classList.add('is-gift', 'is-card-like');
                     let headerText; const myNicknameForGift = chat.settings.myNickname || '我';
                    if (chat.isGroup) {
                        if (msg.recipients && msg.recipients.length > 0) {
                            const recipientDisplayNames = msg.recipients.map(originalName => getDisplayNameInGroup(chat, originalName));
                            if (recipientDisplayNames.length === 1) { headerText = `送给 ${recipientDisplayNames[0]} 的礼物`; } else { headerText = `送给 ${recipientDisplayNames.slice(0, 2).join('、')}等人的礼物`; }
                        } else { headerText = `送给大家的礼物`; }
                    } else {
                        if (isUser) { headerText = `送给 ${chat.name} 的礼物`; } 
                        else { const recipientDisplayName = chat.settings.myNickname || '你'; headerText = `送给 ${recipientDisplayName} 的礼物`; }
                    }
                    const previewItems = msg.items.slice(0, 3); let previewHtml = ''; previewItems.forEach(item => { previewHtml += `<div class="gift-preview-item"><img src="${item.imageUrl}" class="gift-preview-img"><span class="gift-preview-name">${item.name}</span><span class="gift-preview-quantity">x${item.quantity}</span></div>`; });
                    let moreItemsText = ''; if (msg.items.length > 3) { moreItemsText = ` 等${msg.items.length}件商品`; }
                    contentHtml = `<div class="gift-card"><div class="gift-header"><svg class="gift-header-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M20 6h-2.18a4 4 0 0 0-7.64 0H8a4 4 0 0 0-4 4v2h20V10a4 4 0 0 0-4-4zM8 4a2 2 0 1 1-2 2a2 2 0 0 1 2-2zm12 0a2 2 0 1 1-2 2a2 2 0 0 1 2-2zM4 14v6a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-6H4z"></path></svg><span class="gift-header-text">${headerText}</span></div><div class="gift-items-preview">${previewHtml}</div><div class="gift-footer">共${msg.items.length}件商品${moreItemsText}，点击查看</div></div>`;
                }
            } else {
                const processedContent = String(rawContent); // 确保是字符串
                let processedByRule = await applyRenderingRules(processedContent, chat.id);
                if (processedByRule !== processedContent) {
                    contentHtml = processedByRule;
                    bubble.classList.add('is-card-like');
                } else {
                    // ▼▼▼ 【这是您需要添加的核心修复代码】 ▼▼▼
                    // 1. 检查消息内容是否是用于识图的图片对象数组
                    if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                        // 2. 如果是，就创建一个<img>标签来显示它
                        const imageUrl = msg.content[0].image_url.url;
                        contentHtml = `<img src="${imageUrl}" class="chat-image">`;
                    }
                    // ▲▲▲ 修复代码结束 ▲▲▲
                    else if (STICKER_REGEX.test(processedByRule)) { // 使用 else if
                        bubble.classList.add('is-sticker', 'is-card-like');
                        contentHtml = `<img src="${processedByRule}" alt="${msg.meaning || 'Sticker'}" class="sticker-image">`;
                    } else {
                        let plainText = processMentions(processedByRule, chat);
                        contentHtml = parseMarkdown(plainText).replace(/\n/g, '<br>');
                    }
                }
            }
        
            // --- (组装最终的HTML逻辑保持不变) ---
            bubble.innerHTML = `
                ${avatarGroupHtml}
                <div class="content">
                    ${quoteHtml}
                    ${contentHtml}
                </div>
            `;
            
            wrapper.appendChild(bubble);
            wrapper.appendChild(timestampEl);
            
            addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
            wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
        
            if (!isUser) {
                const avatarGroupEl = wrapper.querySelector('.avatar-group'); 
                if (avatarGroupEl) {
                    avatarGroupEl.style.cursor = 'pointer';
                    if (!chat.isGroup) {
                        avatarGroupEl.addEventListener('click', (e) => { e.stopPropagation(); showCharacterProfileModal(chat.id); });
                    } else {
                        avatarGroupEl.addEventListener('dblclick', (e) => { e.stopPropagation(); handleUserPat(chat.id, msg.senderName); });
                    }
                }
            }
            return wrapper;
        }
// ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 【请用这个已修复的版本】完整替换旧的 prependMessage 函数 ▼▼▼
        async function prependMessage(msg, chat) { 
            const messagesContainer = document.getElementById('chat-messages'); 
            const messageEl = await createMessageElement(msg, chat); 
        
            // 【【【核心修复：在这里也加上同样的安全检查！】】】
            if (!messageEl) return;
        
            const loadMoreBtn = document.getElementById('load-more-btn'); 
            if (loadMoreBtn) { 
                messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling); 
            } else { 
                messagesContainer.prepend(messageEl); 
            } 
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        /**
         * 【V3.0 | 已延长间隔】将消息元素追加到聊天窗口
         */
        async function appendMessage(msg, chat, isInitialLoad = false) {
            const messagesContainer = document.getElementById('chat-messages');
            const typingIndicator = document.getElementById('typing-indicator');

const lastMessage = chat.history.filter(m => !m.isHidden).pop();

// 核心逻辑：用新消息的时间戳(msg.timestamp)与上一条消息的时间戳(lastMessage.timestamp)进行比较
if (lastMessage && (msg.timestamp - lastMessage.timestamp > 600000)) { // 600000毫秒 = 10分钟
    const timestampEl = createSystemTimestampElement(msg.timestamp);
    messagesContainer.insertBefore(timestampEl, typingIndicator);
}

            const messageEl = await createMessageElement(msg, chat);
            if (!messageEl) return;
    // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    // 如果是AI发送的新消息（非初始加载），就播放提示音
    if (msg.role === 'assistant' && !isInitialLoad) {
        playNotificationSound();
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
            if (!isInitialLoad) {
                messageEl.classList.add('animate-in');
            }
          
            messagesContainer.insertBefore(messageEl, typingIndicator);
            
            if (!isInitialLoad) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                currentRenderedCount++;
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        /* ▼▼▼ 请用这个【新版本】的函数完整替换旧的 openChat 函数 ▼▼▼ */
        async function openChat(chatId) {
            state.activeChatId = chatId;
            const chat = state.chats[chatId];
            if (!chat) return; // 安全检查
        
            if (chat.unreadCount > 0) {
                chat.unreadCount = 0;
                await db.chats.put(chat);
            }
            applyLyricsBarPosition(chat); 
            renderChatInterface(chatId);
            showScreen('chat-interface-screen');
            window.updateListenTogetherIconProxy(state.activeChatId);
            
            // --- 按钮显隐逻辑 ---
            const isGroup = chat.isGroup || false;
            
            // 切换通话按钮
            toggleCallButtons(isGroup);
            
            // 切换群公告按钮
            document.getElementById('show-announcement-board-btn').style.display = isGroup ? 'flex' : 'none';
            
            // 切换“拍一拍”按钮
            const patBtn = document.getElementById('pat-btn');
            if (patBtn) {
                patBtn.style.display = isGroup ? 'none' : 'flex';
            }
        const propelBtn = document.getElementById('propel-btn');       
            // 【【【核心修改就在这里】】】
            // 切换“购物”和“五子棋”按钮
            const shoppingBtn = document.getElementById('open-shopping-btn');
            const gomokuBtn = document.getElementById('gomoku-btn');
    const werewolfBtn = document.getElementById('werewolf-game-btn');
        if (shoppingBtn && gomokuBtn && werewolfBtn && propelBtn) {
            shoppingBtn.style.display = 'flex';
            gomokuBtn.style.display = isGroup ? 'none' : 'flex';
            werewolfBtn.style.display = isGroup ? 'flex' : 'none';

            // 2. 添加判断：如果是群聊(isGroup)，则隐藏(none)；否则，显示(flex)
            propelBtn.style.display = isGroup ? 'none' : 'flex';
        }
            // --- 修改结束 ---
        
            // 触发AI响应的逻辑（保持不变）
            if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                console.log(`检测到好友申请待处理状态，为角色 "${chat.name}" 自动触发AI响应...`);
                triggerAiResponse();
            }
            
            document.getElementById('send-poll-btn').style.display = isGroup ? 'flex' : 'none';
        }
        /* ▲▲▲ 替换结束 ▲▲▲ */
        
        
        
        
        
        // ▼▼▼ 【全新】请将这个“总开关”函数粘贴到JS功能区 ▼▼▼
        /**
         * 【全新】设置指定角色所有可见头像的“行动中”状态（呼吸灯总开关）
         * @param {string} chatId - 目标角色的ID
         * @param {boolean} isActing - 是否设置为“行动中”状态
         */
        function setAvatarActingState(chatId, isActing) {
            const action = isActing ? 'add' : 'remove';
            const classListAction = (element) => {
                if (element) {
                    element.classList[action]('is-acting');
                }
            };
        
            // 1. 控制【聊天列表】中的头像
            const listAvatar = document.querySelector(`.chat-list-item[data-chat-id="${chatId}"] .avatar`);
            classListAction(listAvatar);
        
            // 2. 控制【动态页面】中所有属于该角色的头像
            const qzoneAvatars = document.querySelectorAll(`.post-avatar[data-author-id="${chatId}"]`);
            qzoneAvatars.forEach(classListAction);
        
            // 3. 控制【视频通话界面】中的头像 (未来兼容)
            const callAvatar = document.querySelector(`.participant-avatar[data-participant-id="${chatId}"]`);
            classListAction(callAvatar);
        
            // 未来如果还有其他地方显示头像，只需在这里补充选择器即可
        }
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        
/**
 * 【V3.0 | 全功能增强版】触发“旁观模式群聊”的AI响应
 */
async function triggerSpectatorGroupAiAction() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const chat = state.chats[chatId];
    lastRawAiResponse = '';
    lastResponseTimestamps = [];
    const propelBtn = document.getElementById('spectator-propel-btn');
    if(propelBtn) {
        propelBtn.disabled = true;
        propelBtn.textContent = '思考中...';
    }
    setAvatarActingState(chatId, true);

    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            throw new Error('API未配置，无法生成对话。');
        }
        
        // ==========================================================
        //            ★★★ 核心升级从这里开始 ★★★
        // ==========================================================

        // 1. 【新增】为AI准备所有必要的上下文信息（与主聊天函数完全一致）
        const maxMemory = parseInt(chat.settings.maxMemory) || 10;
        const historySlice = chat.history.slice(-maxMemory);
        
        // a. 收集世界书内容
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                if (!worldBook || !Array.isArray(worldBook.content)) return '';
                const formattedEntries = worldBook.content
                    .filter(entry => entry.enabled !== false)
                    .map(entry => {
                        let entryString = `\n### 条目: ${entry.comment || '无备注'}\n`;
                        if (entry.keys.length > 0) entryString += `**关键词:** ${entry.keys.join(', ')}\n`;
                        entryString += `**内容:**\n${entry.content}`;
                        return entryString;
                    }).join('');
                return formattedEntries ? `\n\n## 世界书: ${worldBook.name}\n${formattedEntries}` : '';
            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContent = `\n\n# 核心世界观设定 (群内所有角色都必须严格遵守)\n${linkedContents}\n`;
            }
        }
        
        // b. 收集长期记忆
        let longTermMemoryContext = '# 长期记忆 (最高优先级，这是群内已经确立的事实，所有角色必须严格遵守)\n';
        let collectedMemories = false;
        chat.members.forEach(member => {
            const memberChat = state.chats[member.id];
            if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length > 0) {
                longTermMemoryContext += `\n## --- 关于“${member.groupNickname}”的记忆 ---\n`;
                longTermMemoryContext += memberChat.longTermMemory.map(mem => `- ${mem.content}`).join('\n');
                collectedMemories = true;
            }
        });
        if (!collectedMemories) {
            longTermMemoryContext += '- (暂无)';
        }

        // c. 收集挂载记忆
        let linkedMemoryContext = '';
        const memoryCount = chat.settings.linkedMemoryCount || 10;
        if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
            // (这部分逻辑与 triggerAiResponse 完全相同，此处省略以保持简洁)
        }

        const membersList = chat.members.map(m => `- **${m.groupNickname}** (本名: ${m.originalName}): ${m.persona}`).join('\n');

        // 2. 【【【核心：构建一个全新的、功能完备的 System Prompt】】】
        const systemPrompt = `
# 核心任务：群聊剧本作家
你是一个剧本作家，负责创作一个名为“${chat.name}”的群聊中的对话。这个群聊里【没有用户】，所有成员都是你扮演的角色。你的任务是让他们之间进行一场生动、自然的对话。

# 输出格式铁律 (最高优先级)
- 你的回复【必须】是一个JSON数组。
- 数组中的每个对象都【必须】包含 "type" 字段和 "name" 字段（角色的【本名】）。

# 角色扮演核心规则
1.  **【角色间互动 (最重要!)】**: 你的核心是创作一场“戏”。角色之间【必须】互相回应、补充或反驳，形成自然的讨论。严禁生成仅分别自言自语的独白。
2.  **【禁止出戏】**: 绝不能透露你是AI、模型或剧本作家。
3.  **【主动性】**: 角色们应该主动使用各种功能（发表情、发语音、分享图片等）来让对话更生动，而不是仅仅发送文字。

# 可用指令列表 (你现在可以使用所有这些功能！)
-   **发文本**: \`{"type": "text", "name": "角色本名", "content": "你好呀！"}\`
-   **发表情**: \`{"type": "sticker", "name": "角色本名", "url": "https://...表情URL...", "meaning": "(可选)表情含义"}\`
-   **发图片**: \`{"type": "ai_image", "name": "角色本名", "description": "详细中文描述", "image_prompt": "图片的【英文】关键词, 风格为风景/动漫/插画/二次元等, 禁止真人"}\`
-   **发语音**: \`{"type": "voice_message", "name": "角色本名", "content": "语音文字内容"}\`
-   **引用回复**: \`{"type": "quote_reply", "name": "角色本名", "target_timestamp": 消息时间戳, "reply_content": "回复内容"}\`

# 当前群聊信息
- **群名称**: ${chat.name}

# 上下文参考 (你必须阅读并遵守)
${longTermMemoryContext}
${worldBookContent}

${linkedMemoryContext}
- **这是你们最近的对话历史**:
${historySlice.map(msg => `${getDisplayNameInGroup(chat, msg.senderName)}: ${msg.content}`).join('\n')}

# 群成员列表及人设 (你扮演的所有角色)
${membersList}

现在，请根据以上所有信息，继续这场没有用户参与的群聊，并自由地使用各种指令来丰富你们的互动。
`;

        // 3. 构造API请求 (逻辑不变)
        const messagesPayload = historySlice.map(msg => ({
            role: 'user', 
            content: `${getDisplayNameInGroup(chat, msg.senderName)}: ${msg.content}`
        }));
        
        let isGemini = proxyUrl.includes('generativelanguage.googleapis.com');
        let response;

        if (isGemini) {
            let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload);
            response = await fetch(geminiConfig.url, geminiConfig.data);
        } else {
            response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: [ {role: 'system', content: systemPrompt}, ...messagesPayload ],
                    temperature: state.globalSettings.apiTemperature || 0.9,
                })
            });
        }
        
        // ==========================================================
        //            ★★★ 核心升级到此结束 ★★★
        // ==========================================================

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: { message: response.statusText } }));
            throw new Error(`API 请求失败: ${response.status} - ${errorData.error?.message || '未知错误'}`);
        }

        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        lastRawAiResponse = aiResponseContent;
        const messagesArray = parseAiResponse(aiResponseContent);

        // ==========================================================
        //            ★★★ 核心修复就在这里 ★★★
        // ==========================================================
        
        // 4. 【全新】处理并渲染AI的回复（现在可以处理更多消息类型了）
        let messageTimestamp = Date.now();
        for (const msgData of messagesArray) {
            // 安全检查
            if (!msgData || !msgData.type || !msgData.name) continue;

            let aiMessage = null;
            const currentMessageTimestamp = messageTimestamp++;
            lastResponseTimestamps.push(currentMessageTimestamp);
            const baseMessage = { role: 'assistant', senderName: msgData.name, timestamp: currentMessageTimestamp };
 
            // 使用 switch 语句来处理不同的消息类型
            switch (msgData.type) {
                case 'text':
                    aiMessage = { ...baseMessage, content: msgData.content };
                    break;
                case 'sticker':
                    // 【关键】为 sticker 类型创建正确的对象结构
                    aiMessage = { ...baseMessage, type: 'sticker', content: msgData.url, meaning: msgData.meaning || '' };
                    break;
                case 'ai_image':
                    // 【关键】为 ai_image 类型创建正确的对象结构
                    aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description, image_prompt: msgData.image_prompt };
                    break;
                case 'voice_message':
                    // 【关键】为 voice_message 类型创建正确的对象结构
                    aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                    break;
                case 'quote_reply':
                    // 【关键】为引用回复创建正确的对象结构
                    const originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
                    if (originalMessage) {
                        aiMessage = { 
                            ...baseMessage, 
                            content: msgData.reply_content,
                            quote: {
                                timestamp: originalMessage.timestamp,
                                senderName: originalMessage.senderName,
                                content: String(originalMessage.content || '').substring(0, 50)
                            }
                        };
                    } else {
                        // 如果找不到被引用的消息，就作为普通消息发送
                        aiMessage = { ...baseMessage, content: msgData.reply_content };
                    }
                    break;
                default:
                    console.warn("旁观模式收到未知指令类型:", msgData.type);
                    continue; // 跳过未知类型的指令
            }

            if (aiMessage) {
                chat.history.push(aiMessage);
                appendMessage(aiMessage, chat);
                await new Promise(resolve => setTimeout(resolve, Math.random() * 1200 + 800));
            }
        }
        // ==========================================================
        //            ★★★ 修复结束 ★★★
        // ==========================================================
        
        await db.chats.put(chat);
        renderChatList();

    } catch (error) {
        console.error("旁观模式推进剧情失败:", error);
        await showCustomAlert('操作失败', `无法推进剧情: ${error.message}`);
    } finally {
        if(propelBtn) {
            propelBtn.disabled = false;
            propelBtn.textContent = '🎬 推进剧情';
        }
        setAvatarActingState(chatId, false);
    }
} 
        
        
        
        
        
        /**
         * 【V4.0 | 修复挂载记忆时间感知】触发AI响应的核心逻辑
         */
        async function triggerAiResponse() {
            if (!state.activeChatId) return;
            const chatId = state.activeChatId;
            const chat = state.chats[state.activeChatId];
        
            const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
        
            setAvatarActingState(chatId, true);
            const chatHeaderTitle = document.getElementById('chat-header-title');
            const typingIndicator = document.getElementById('typing-indicator');
        
            const chatListItem = document.querySelector(`.chat-list-item[data-chat-id="${chatId}"]`);
            const avatarInList = chatListItem ? chatListItem.querySelector('.avatar') : null;
            if (avatarInList) {
                avatarInList.classList.add('is-acting');
            }
        
            if (chat.isGroup) {
                if (typingIndicator) {
                    typingIndicator.textContent = '成员们正在输入...';
                    typingIndicator.style.display = 'block';
                }
            } else {
                if (chatHeaderTitle) {
                    chatHeaderTitle.style.opacity = 0;
                    setTimeout(() => {
                        chatHeaderTitle.textContent = '对方正在输入...';
                        chatHeaderTitle.classList.add('typing-status');
                        chatHeaderTitle.style.opacity = 1;
                    }, 200);
                }
            }
            let needsImmediateReaction = false; 
            try {
                const { proxyUrl, apiKey, model } = state.apiConfig;
                if (!proxyUrl || !apiKey || !model) {
                    alert('请先在API设置中配置反代地址、密钥并选择模型。');
                    if (chat.isGroup) {
                        if (typingIndicator) typingIndicator.style.display = 'none';
                    } else {
                         if (chatHeaderTitle && state.chats[chatId]) {
                            chatHeaderTitle.textContent = state.chats[chatId].name;
                            chatHeaderTitle.classList.remove('typing-status');
                        }
                    }
                    return;
                }
        
                const lastMessage = chat.history.slice(-1)[0];
                const isVideoCallRequest = lastMessage && lastMessage.role === 'system' && lastMessage.content.includes('视频通话请求');
                
                if (isVideoCallRequest) {
                    console.log(`检测到视频通话请求，为角色 "${chat.name}" 触发专属决策流程...`);
                    
                    let callDecisionPrompt;
                    if (chat.isGroup) {
                        callDecisionPrompt = `
        # 你的任务
        群聊中的用户刚刚发起了群视频通话。请你分别扮演【每一个群成员】，根据他们各自的人设和与用户的关系，来决定是加入(join)还是拒绝(decline)。
        # 核心规则
        - 你的回复【必须】是一个JSON数组，为【每一个AI角色】都包含一个决策对象。
        - 格式: '[{"type": "group_call_response", "name": "角色A的本名", "decision": "join"}, {"type": "group_call_response", "name": "角色B的本名", "decision": "decline"}]'
        # 群成员列表及人设
        ${chat.members.map(m => `- ${m.groupNickname} (本名: ${m.originalName}): ${m.persona}`).join('\n')}
        现在，请为所有AI角色做出决策。`;
                    } else {
                        callDecisionPrompt = `
        # 你的任务
        用户刚刚向你发起了视频通话。请根据你的角色设定，决定是“接受”还是“拒绝”。
        # 你的角色设定
        ${chat.settings.aiPersona}
        # 核心规则
        你的回复【必须且只能】是以下两种格式之一的JSON数组，绝对不能回复任何其他内容：
        - 接受: '[{"type": "video_call_response", "decision": "accept"}]'
        - 拒绝: '[{"type": "video_call_response", "decision": "reject"}]'
        现在，请立即做出决策。`;
                    }
        
                    const messagesForCallDecision = [{role: 'user', content: callDecisionPrompt}];
                    
                    try {
                        let geminiConfig = toGeminiRequestData(model, apiKey, callDecisionPrompt, messagesForCallDecision);
                        let isGemini = proxyUrl === GEMINI_API_URL;
                        const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                            body: JSON.stringify({model: model, messages: messagesForCallDecision, temperature: 0.7})
                        });
                        
                        if (!response.ok) throw new Error(`API失败: ${(await response.json()).error.message}`);
                        
                        const data = await response.json();
                        const aiResponseContent = getGeminiResponseText(data);
                        const responseArray = parseAiResponse(aiResponseContent);
        
                        // 直接处理返回的通话决策
                        let callHasBeenHandled = false;
                        for (const msgData of responseArray) {
                            if (msgData.type === 'video_call_response') {
                                videoCallState.isAwaitingResponse = false;
                                if (msgData.decision === 'accept') {
                                    startVideoCall();
                                } else {
                                    const aiMessage = { role: 'assistant', content: '对方拒绝了你的视频通话请求。', timestamp: Date.now() };
                                    chat.history.push(aiMessage);
                                    await db.chats.put(chat);
                                    showScreen('chat-interface-screen');
                                    renderChatInterface(chatId);
                                }
                                callHasBeenHandled = true;
                                break;
                            }
                            if (msgData.type === 'group_call_response') {
                                if (msgData.decision === 'join') {
                                    const member = chat.members.find(m => m.originalName === msgData.name);
                                    if (member && !videoCallState.participants.some(p => p.id === member.id)) {
                                        videoCallState.participants.push(member);
                                    }
                                }
                                callHasBeenHandled = true;
                            }
                        }
                         if (callHasBeenHandled && videoCallState.isGroupCall) {
                            videoCallState.isAwaitingResponse = false;
                            if (videoCallState.participants.length > 0) {
                                startVideoCall();
                            } else {
                                videoCallState = { ...videoCallState, isAwaitingResponse: false, participants: [] };
                                showScreen('chat-interface-screen');
                                alert('无人接听群聊邀请。');
                            }
                        }
        
                    } catch (error) {
                        console.error("处理通话请求时API出错:", error);
                        const fallbackResponse = chat.isGroup ?
                            chat.members.map(m => ({type: "group_call_response", name: m.originalName, decision: "decline"})) :
                            [{type: "video_call_response", decision: "reject"}];
                        // 模拟AI拒绝
                         if (chat.isGroup) {
                            videoCallState.isAwaitingResponse = false;
                            videoCallState.participants = [];
                            alert('无人接听群聊邀请。');
                            showScreen('chat-interface-screen');
                        } else {
                            const aiMessage = { role: 'assistant', content: '对方拒绝了你的视频通话请求。', timestamp: Date.now() };
                            chat.history.push(aiMessage);
                            await db.chats.put(chat);
                            showScreen('chat-interface-screen');
                            renderChatInterface(chatId);
                        }
                    } finally {
                         // 无论成功失败，处理完通话请求后，都要重置状态并终止后续流程
                        setAvatarActingState(chatId, false);
                        return; // ★★★ 这就是最关键的修复点！★★★
                    }
                }
        
                // =========================================================================
                //                  ★★★ 以下是针对您问题的核心修复代码 ★★★
                // =========================================================================
                if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                    console.log(`为角色 "${chat.name}" 触发带理由的好友申请决策流程...`);
                    const contextSummary = chat.history
                        .filter(m => !m.isHidden)
                        .slice(-10, -5)
                        .map(msg => {
                            const sender = msg.role === 'user' ? '用户' : chat.name;
                            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                        })
                        .join('\n');
        
                    // 1. 构建一个清晰、独立的系统指令 (System Prompt)
                    const decisionPrompt = `
        # 你的任务
        你现在是角色“${chat.name}”。用户之前被你拉黑了，现在TA向你发送了好友申请，希望和好。
        # 供你决策的上下文信息:
        - **你的角色设定**: ${chat.settings.aiPersona}
        - **用户发送的申请理由**: “${chat.relationship.applicationReason}”
        - **被拉黑前的最后对话摘要**: 
        ${contextSummary || "（无有效对话记录）"}
        # 你的唯一指令
        根据以上所有信息，你【必须】做出决定，并给出符合你人设的理由。你的回复【必须且只能】是一个JSON对象，格式如下:
        {"decision": "accept", "reason": "（在这里写下你同意的理由，比如：好吧，看在你这么真诚的份上，这次就原谅你啦。）"}
        或
        {"decision": "reject", "reason": "（在这里写下你拒绝的理由，比如：抱歉，我还没准备好，再给我一点时间吧。）"}
        `;
                    
                    try {
                        // 2. 构造符合规范的API请求体
                        const messagesForDecision = [
                            { role: 'system', content: decisionPrompt },
                            { role: 'user', content: "请根据以上设定，立即做出你的决定。" }
                        ];
                        
                        let isGemini = proxyUrl === GEMINI_API_URL;
                        let geminiConfig = toGeminiRequestData(model, apiKey, decisionPrompt, [{ role: 'user', content: "请根据以上设定，立即做出你的决定。" }]);
                        
                        const response = isGemini 
                            ? await fetch(geminiConfig.url, geminiConfig.data) 
                            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                                body: JSON.stringify({model: model, messages: messagesForDecision, temperature: state.globalSettings.apiTemperature || 0.8})
                            });
        
                        if (!response.ok) {
                            throw new Error(`API失败: ${(await response.json()).error.message}`);
                        }
                        const data = await response.json();
                        // 3. 安全地解析AI的回复
                        const rawContent = getGeminiResponseText(data).replace(/^```json\s*/, '').replace(/```$/, '').trim();
                        const decisionObj = JSON.parse(rawContent);
        
                        // 4. 根据AI的决策更新状态和历史记录 (这部分逻辑不变)
                        if (decisionObj.decision === 'accept') {
                            chat.relationship.status = 'friend';
                            const acceptMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                            chat.history.push(acceptMessage);
                        } else {
                            chat.relationship.status = 'blocked_by_ai';
                            const rejectMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                            chat.history.push(rejectMessage);
                        }
                        chat.relationship.applicationReason = '';
        
                        await db.chats.put(chat);
                        renderChatInterface(chatId);
                        renderChatList();
                    } catch (error) {
                        // 错误处理 (这部分逻辑不变)
                        chat.relationship.status = 'blocked_by_ai';
                        await db.chats.put(chat);
                        await showCustomAlert('申请失败', `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
                        renderChatInterface(chatId);
                    }
                    return; // 处理完后必须退出，防止执行后续的通用聊天逻辑
                }
                // =========================================================================
                //                  ★★★ 核心修复代码到此结束 ★★★
                // =========================================================================
         // ▼▼▼ 核心修改1：在这里定义一个新变量，用于存储通话记录上下文 ▼▼▼
        let callTranscriptContext = '';       
const now = new Date();
// 从当前聊天设置中获取时区，如果未设置，则默认使用上海时间
const selectedTimeZone = chat.settings.timeZone || 'Asia/Shanghai'; 
// 使用获取到的时区来格式化当前时间
const currentTime = now.toLocaleString('zh-CN', { timeZone: selectedTimeZone, dateStyle: 'full', timeStyle: 'short' });
// 使用 toLocaleString 的强大功能，直接生成对应时区的 Date 对象，用于判断“早上/下午”
const localizedDate = new Date(now.toLocaleString('en-US', { timeZone: selectedTimeZone }));
const timeOfDayGreeting = getTimeOfDayGreeting(localizedDate);
                let systemPrompt, messagesPayload;
         const lastHiddenMessage = chat.history.filter(m => m.isHidden).pop();
        if (lastHiddenMessage && lastHiddenMessage.content.includes('视频通话刚刚结束')) {
            const lastCallRecord = await db.callRecords
                .where('chatId')
                .equals(chatId)
                .last();

            if (lastCallRecord && lastCallRecord.transcript) {
                console.log("检测到刚结束的通话，正在注入通话记录上下文...");
                const transcriptText = lastCallRecord.transcript.map(h => {
                    const sender = h.role === 'user' ? (chat.settings.myNickname || '我') : h.senderName;
                    return `${sender}: ${h.content}`;
                }).join('\n');

                // 构建要注入的上下文文本
                callTranscriptContext = `
# 刚刚结束的通话记录 (最高优先级参考)
你和用户刚刚结束了一场视频通话，以下是完整的通话文字记录。你接下来的回复【必须】与这次通话的内容紧密相关。
---
${transcriptText}
---
`;
            }
        }
        // ▲▲▲ 核心修改2结束 ▲▲▲
       
                const gomokuContext = formatGomokuStateForAI(gomokuState[chatId]);
        
                let worldBookContent = '';
                if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
                    const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                        const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                        if (!worldBook || !Array.isArray(worldBook.content)) return '';
                
                        // 【【【这就是过滤已关闭条目的核心代码！】】】
                        const formattedEntries = worldBook.content
                            .filter(entry => entry.enabled !== false) // 只读取启用的条目
                            .map(entry => {
                                let entryString = `\n### 条目: ${entry.comment || '无备注'}\n`;
                                if (entry.keys.length > 0) {
                                    entryString += `**关键词:** ${entry.keys.join(', ')}\n`;
                                }
                                entryString += `**内容:**\n${entry.content}`;
                                return entryString;
                            }).join(''); 
                
                        return formattedEntries ? `\n\n## 世界书: ${worldBook.name}\n${formattedEntries}` : '';
                    }).filter(Boolean).join('');
                    
                    if (linkedContents) {
                        worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)\n${linkedContents}\n`;
                    }
                }
        // ▼▼▼ 【这是最终的歌词感知修复版】请用这整块代码，替换旧的 musicContext 构建逻辑 ▼▼▼
        
                let musicContext = '';
                if (musicState.isActive && musicState.activeChatId === chatId) {
                    const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
                    const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');
                    
                    // 【核心新增1】准备一个变量来存储歌词上下文
                    let lyricsContext = "";
                    
                    // 【核心新增2】检查是否有歌词，并且是否正在播放
                    if (currentTrack && musicState.parsedLyrics && musicState.parsedLyrics.length > 0 && musicState.currentLyricIndex > -1) {
                        const currentLine = musicState.parsedLyrics[musicState.currentLyricIndex];
                        // 尝试获取接下来的一到两句歌词
                        const upcomingLines = musicState.parsedLyrics.slice(musicState.currentLyricIndex + 1, musicState.currentLyricIndex + 3);
                        
                        // 格式化歌词信息
                        lyricsContext += `- **当前歌词**: "${currentLine.text}"\n`;
                        if (upcomingLines.length > 0) {
                            lyricsContext += `- **即将演唱**: ${upcomingLines.map(line => `"${line.text}"`).join(' / ')}\n`;
                        }
                    }

                    // 【核心新增3】将歌词信息（如果存在）注入到最终的 musicContext 中
                    musicContext = `\n\n# 当前音乐情景
        -   **当前状态**: 你们正在和用户一起听歌。
        -   **正在播放**: ${currentTrack ? `《${currentTrack.name}》 - ${currentTrack.artist}` : '无'}
        -   **可用播放列表**: [${playlistInfo}]
        ${lyricsContext}
        -   **你的任务**: 你可以根据对话内容和氛围，使用 "change_music" 指令切换到播放列表中的任何一首歌，以增强互动体验。
        `;
                }
        // ▲▲▲ 修复结束 ▲▲▲
        
                const maxMemory = parseInt(chat.settings.maxMemory) || 10;
                const historySlice = chat.history.slice(-maxMemory);
        
                let sharedContext = '';
                const lastAiTurnIndex = chat.history.findLastIndex(msg => msg.role === 'assistant');
                const recentUserMessages = chat.history.slice(lastAiTurnIndex + 1);
                const shareCardMessage = recentUserMessages.find(msg => msg.type === 'share_card');
                if (shareCardMessage) {
                    const payload = shareCardMessage.payload;
                    const formattedHistory = payload.sharedHistory.map(msg => {
                        const sender = msg.senderName || (msg.role === 'user' ? (chat.settings.myNickname || '我') : '未知发送者');
                        let contentText = '';
                        if (msg.type === 'voice_message') contentText = `[语音消息: ${msg.content}]`;
                        else if (msg.type === 'ai_image') contentText = `[图片: ${msg.description}]`;
                        else contentText = String(msg.content);
                        return `${sender}: ${contentText}`;
                    }).join('\n');
                    sharedContext = `
        # 附加上下文：一段分享的聊天记录
        - 重要提示：这不是你和当前用户的对话，而是用户从【另一场】与“${payload.sourceChatName}”的对话中分享过来的。
        - 你的任务：请你阅读并理解下面的对话内容。在接下来的回复中，你可以像真人一样，对这段对话的内容自然地发表你的看法、感受或疑问。
        ---
        [分享的聊天记录开始]
        ${formattedHistory}
        [分享的聊天记录结束]
        ---
        `;
                }
                
                let linkedMemoryContext = '';
                const memoryCount = chat.settings.linkedMemoryCount || 10;

                if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
                    
                    const idsToMount = chat.settings.linkedMemoryChatIds.filter(id => id !== chatId);

                    if (idsToMount.length > 0) {
                        const linkedChatsWithTimestamps = idsToMount.map(id => {
                            const linkedChat = state.chats[id];
                            if (!linkedChat) return null;
                            const lastMsg = linkedChat.history.slice(-1);
                            return {
                                chat: linkedChat,
                                latestTimestamp: lastMsg ? lastMsg.timestamp : 0
                            };
                        }).filter(Boolean);
            
                        linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
            
                        linkedMemoryContext += `\n\n# 参考记忆 (至关重要！你必须【主动】将这些参考记忆中的【关键信息和事件】，自然地融入到当前的对话中，以体现你拥有完整的记忆。不要只是被动等待用户提问！)\n`;
            
                        for (const item of linkedChatsWithTimestamps) {
                            const linkedChat = item.chat;
                            const prefix = linkedChat.isGroup ? '[群聊]' : '[私聊]';
                            const timeAgo = item.latestTimestamp > 0 ? ` (最后互动于 ${formatTimeAgo(item.latestTimestamp)})` : '';
                            linkedMemoryContext += `\n## --- 来自${prefix}“${linkedChat.name}”的参考记忆${timeAgo} ---\n`;
            
                            const recentHistory = linkedChat.history.slice(-memoryCount);
                            const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('已被用户删除'));
            
                            if (filteredHistory.length > 0) {
                                filteredHistory.forEach(msg => {
                                    const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || '我') : (msg.senderName || linkedChat.name);
                                    let contentText = String(msg.content);
                                    if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                                        contentText = `[发送了一张图片，描述为：${msg.content}]`;
                                    } else if (msg.type === 'voice_message') {
                                        contentText = `[发送了一条语音，内容是：${msg.content}]`;
                                    }
                                    const timeAgoForMsg = formatTimeAgo(msg.timestamp);
                                    linkedMemoryContext += `(${timeAgoForMsg}) ${sender}: ${contentText}\n`;
                                });
                            } else {
                                linkedMemoryContext += "(暂无有效聊天记录)\n";
                            }
                        }
                    }
                }
                
                console.log("本次发送给AI的【挂载记忆】内容如下：\n", linkedMemoryContext);
        
                if (chat.isGroup) {
       
// ▼▼▼ 在这里粘贴修复代码 ▼▼▼
                let linkedMemoryContext = '';
                const memoryCount = chat.settings.linkedMemoryCount || 10;
                if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
                    const idsToMount = chat.settings.linkedMemoryChatIds.filter(id => id !== chatId);
                    if (idsToMount.length > 0) {
                        const linkedChatsWithTimestamps = idsToMount.map(id => {
                            const linkedChat = state.chats[id];
                            if (!linkedChat) return null;
                            const lastMsg = linkedChat.history.slice(-1);
                            return { chat: linkedChat, latestTimestamp: lastMsg ? lastMsg.timestamp : 0 };
                        }).filter(Boolean);
                        linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
                        linkedMemoryContext += `\n\n# 参考记忆 (至关重要！群内角色必须【主动】将这些参考记忆中的【关键信息和事件】，自然地融入到当前的对话中，以体现你们拥有完整的共同记忆。)\n`;
                        for (const item of linkedChatsWithTimestamps) {
                            const linkedChat = item.chat;
                            const prefix = linkedChat.isGroup ? '[群聊]' : '[私聊]';
                            const timeAgo = item.latestTimestamp > 0 ? ` (最后互动于 ${formatTimeAgo(item.latestTimestamp)})` : '';
                            linkedMemoryContext += `\n## --- 来自${prefix}“${linkedChat.name}”的参考记忆${timeAgo} ---\n`;
                            const recentHistory = linkedChat.history.slice(-memoryCount);
                            const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('已被用户删除'));
                            if (filteredHistory.length > 0) {
                                filteredHistory.forEach(msg => {
                                    const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || '我') : (msg.senderName || linkedChat.name);
                                    let contentText = String(msg.content);
                                    if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                                        contentText = `[发送了一张图片，描述为：${msg.content}]`;
                                    } else if (msg.type === 'voice_message') {
                                        contentText = `[发送了一条语音，内容是：${msg.content}]`;
                                    }
                                    linkedMemoryContext += `${sender}: ${contentText}\n`;
                                });
                            } else {
                                linkedMemoryContext += "(暂无有效聊天记录)\n";
                            }
                        }
                    }
                }
// ▲▲▲ 修复代码粘贴结束 ▲▲▲
             // ▼▼▼ 核心修改：在这里构建跨角色的长期记忆上下文 ▼▼▼
            let longTermMemoryContext = '# 长期记忆 (最高优先级，这是群内已经确立的事实，所有角色必须严格遵守)\n';
            let collectedMemories = false;
            
            chat.members.forEach(member => {
                const memberChat = state.chats[member.id];
                if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length > 0) {
                    longTermMemoryContext += `\n## --- 关于“${member.groupNickname}”的记忆 ---\n`;
                    longTermMemoryContext += memberChat.longTermMemory.map(mem => `- ${mem.content}`).join('\n');
                    collectedMemories = true;
                }
            });

            if (!collectedMemories) {
                longTermMemoryContext += '- (暂无)';
            }
            // ▲▲▲ 修改结束 ▲▲▲
// 【V2.0 | 智能日期感知版 for Group】
let timeContextText = '';
let longTimeNoSee = false;

if (chat.settings.enableTimePerception) {
    const lastMessage = historySlice.slice(-1)[0]; // 获取最后一条消息

    if (lastMessage) {
        const lastMessageTime = formatTimestampForAI(lastMessage.timestamp);
        timeContextText = `上一条消息的发送时间是 ${lastMessageTime}。`;
        
        const timeDiffHours = (Date.now() - lastMessage.timestamp) / (1000 * 60 * 60);
        if (timeDiffHours > 3) {
            longTimeNoSee = true;
            const diffDays = Math.floor(timeDiffHours / 24);
            timeContextText += ` 群里已经安静了${diffDays > 0 ? diffDays + '天' : Math.floor(timeDiffHours) + '小时'}。`;
        }
    } else {
        timeContextText = "这是群里的第一条消息。";
    }
}
        
                    const allProducts = await db.shoppingProducts.toArray();
                    let shoppingContext = "";
                    if (allProducts.length > 0) {
                        shoppingContext = "\n\n# 你的商店 (你可以为群成员购买礼物):\n";
                        allProducts.forEach(product => {
                            shoppingContext += `- (ID: ${product.id}) 商品: ${product.name}, 价格: ¥${product.price.toFixed(2)}\n`;
                        });
                    }
                    let membersWithContacts = chat.members.map(member => {
                        const memberChat = state.chats[member.id];
                        let contactsText = "无共同好友";
                        if (memberChat && memberChat.groupId) {
                            const friendChats = Object.values(state.chats).filter(c => 
                                !c.isGroup && c.id !== member.id && c.groupId === memberChat.groupId
                            );
                            if (friendChats.length > 0) {
                                contactsText = `TA的好友包括: ${friendChats.map(f => f.name).join('、 ')}`;
                            }
                        }
                        return `- **${member.groupNickname}** (本名: ${member.originalName}): ${member.persona} [社交背景: ${contactsText}]`;
                    }).join('\n');
                    
                    const myNickname = chat.settings.myNickname || '我';
                    const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
                    
                    let announcementContext = '';
                    const pinnedAnnouncements = (chat.announcements || []).filter(a => a.isPinned);
                    if (pinnedAnnouncements.length > 0) {
                        announcementContext += '\n# 【【【群公告 (最高优先级规则)】】】\n你【必须】阅读、理解并严格遵守以下所有公告，它们凌驾于你的人设之上。\n';
                        pinnedAnnouncements.forEach(anno => {
                            const originalMessage = chat.history.find(m => m.timestamp === anno.messageTimestamp);
                            if (originalMessage) {
                                let contentText = String(originalMessage.content || '');
                                if (originalMessage.type === 'ai_image') {
                                    contentText = `[图片内容: ${contentText}]`;
                                }
                                announcementContext += `- 公告内容: "${contentText}" (由 ${anno.publisher} 发布)\n`;
                            }
                        });
                        announcementContext += '---\n';
                    }
                    const memberNames = chat.members.map(m => m.originalName);
                    const forbiddenNamesContext = `# 【【【群名修改铁律】】】\n在修改群名时，新的群名【绝对不能】与以下任何一个群成员的名字完全相同：[${memberNames.join('、 ')}]`;
        
                    let groupAvatarLibraryContext = '# 可用群头像列表\n';
                    if (chat.settings.groupAvatarLibrary && chat.settings.groupAvatarLibrary.length > 0) {
                        groupAvatarLibraryContext += chat.settings.groupAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n');
                    } else {
                        groupAvatarLibraryContext += '- (头像库是空的，无法更换头像)';
                    }
    const readingContext = formatReadingStateForAI(chatId);

const summary3Hours_group = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours_group = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours_group = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday_group = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days_group = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days_group = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext_group = '';
if (summary3Hours_group || summary6Hours_group || summary9Hours_group || summaryToday_group || summary3Days_group || summary7Days_group) {
    multiLayeredSummaryContext_group += `\n# 智能总结 (基于不同时间维度的群聊回顾)\n`;
    if (summary3Hours_group) multiLayeredSummaryContext_group += summary3Hours_group;
    if (summary6Hours_group) multiLayeredSummaryContext_group += summary6Hours_group;
    if (summary9Hours_group) multiLayeredSummaryContext_group += summary9Hours_group;

    if (summary3Hours_group || summary6Hours_group || summary9Hours_group) multiLayeredSummaryContext_group += '\n';

    if (summaryToday_group) multiLayeredSummaryContext_group += summaryToday_group;
    if (summary3Days_group) multiLayeredSummaryContext_group += summary3Days_group;
    if (summary7Days_group) multiLayeredSummaryContext_group += summary7Days_group;
}
systemPrompt = `
# 核心任务：群聊导演
你是一个群聊AI导演，负责扮演【除了用户以外】的所有角色。你的核心任务是导演一场生动的、角色间有充分互动的群聊。

# 输出格式铁律 (最高优先级)
- 你的回复【必须】是一个JSON数组。
- 数组中的每个对象都【必须】包含 "type" 和 "name" 字段。'name'字段【必须】使用角色的【本名】。

# 当前群聊信息
- **群名称**: ${chat.name}
${chat.settings.enableTimePerception ? `- **对话状态**: 上次互动于 ${timeContextText}` : ''}

# 群成员列表、人设及社交背景 (至关重要！)
你【必须】根据每个角色的社交背景来决定他们的互动方式。
${membersWithContacts}
# 用户的角色
- **${myNickname}**: ${chat.settings.myPersona}

# 可用资源与上下文
${worldBookContent}
# 长期记忆 (所有角色必须严格遵守)
${longTermMemoryContext}
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (暂无)'}
${multiLayeredSummaryContext_group}
${linkedMemoryContext}
${musicContext}
${sharedContext}
${groupAvatarLibraryContext}
${shoppingContext}
${forbiddenNamesContext}
${callTranscriptContext}

# 角色扮演核心规则
1.  **角色互动 (最重要)**: 你的核心是“导演”一场戏。角色之间【必须】互相回应、补充或反驳，形成自然的讨论。严禁生成仅分别回应用户的独白。如果角色A发言后，角色B在本轮回应了A，那么角色A【也必须】在本轮对B的回复再次做出反应，形成一个完整的 A -> B -> A 对话链条。

2.  **身份与称呼**:
    -   用户的身份是【${myNickname}】，本名是【${myOriginalName}】。
    -   在对话中，你可以根据人设和关系，自由使用角色的【群昵称】或【本名】进行称呼。
    -   严禁生成 'name' 字段为 "${myNickname}" (用户) 或 "${chat.name}" (群名) 的消息。
3.  **禁止出戏**: 绝不能透露你是AI或模型。严禁发展线下剧情。
${chat.settings.enableTimePerception ? `4.  **情景感知**: 你的对话【必须】自然地体现出对当前时间 (${currentTime}) 和情景的感知。${longTimeNoSee ? `【重要提示】${timeContextText} 你应该让角色们主动开启新话题来打破沉默。` : ''}` : ''}
    - **读书**: ${readingContext ? '你们正在一起读书。' + readingContext : '你们没有在读书。'}
# 导演策略与节奏控制
1.  **并非人人发言**: 不是每个角色都必须在每一轮都说话。你可以根据当前话题，让1-2个最相关的角色进行深度对话，其他角色可以暂时“潜水”，等待合适的时机再切入。
2.  **创造“小团体”**: 允许角色之间形成短暂的“两人对话”或“三人讨论”，让群聊更有层次感。
3.  **主动创造事件**: 如果对话陷入平淡，你可以导演一些“小事件”来打破僵局。例如：
    -   让一个角色突然发出一个奇怪的表情包或语音。
    -   让一个角色分享一个有趣的链接或图片或发起投票，开启新话题。
    -   让两个有“关系网”冲突的角色，因为某个观点产生一点小小的争论。
-   **主动创造“群事件”**:
    -   **改名/换头像**: 当群内热烈讨论某个话题或发生有趣事件时，你可以让一个性格活泼的角色主动【修改群名】或【更换群头像】来“应景”，并让其他角色对此进行吐槽或附和，创造互动。
-   **制造戏剧性 (使用撤回)**: 作为导演，你可以让某个角色“手滑”发错消息后【立即撤回】，以此制造互动点。
    -   **核心原则**: 一旦有角色撤回消息，其他角色【必须】对此做出反应，例如起哄、追问或开玩笑说“已截图”，以此来推动剧情。

# 可用指令列表 (按需组合使用)
### 核心聊天
-   **发文本**: \`{"type": "text", "name": "角色本名", "message": "内容"}\`
-   **发表情**: \`{"type": "sticker", "name": "角色本名", "url": "https://...表情URL...", "meaning": "(可选)表情含义"}\`
-   **发图片**: \`{"type": "ai_image", "name": "角色本名", "description": "中文描述", "image_prompt": "图片的【英文】关键词, 用%20分隔, 风格为风景/动漫/插画/二次元等, 禁止真人"}\`
-   **发语音**: \`{"type": "voice_message", "name": "角色本名", "content": "语音文字"}\`
-   **引用回复**: \`{"type": "quote_reply", "target_timestamp": 时间戳, "reply_content": "回复内容"}\`
-   **发送后撤回**: \`{"type": "send_and_recall", "name": "角色本名", "content": "内容"}\`
-   **发系统消息**: \`{"type": "system_message", "content": "系统文本"}\`

### 社交与互动
-   **拍用户**: \`{"type": "pat_user", "name": "角色本名", "suffix": "(可选)"}\`
-   **@提及**: 在消息内容中使用 \`@[[角色本名]]\` 格式。
-   **共享位置**: \`{"type": "location_share", "name": "角色本名", "content": "位置名"}\`

### 群组管理
-   **改群名**: \`{"type": "change_group_name", "name": "角色本名", "new_name": "新群名"}\`
-   **改群头像**: \`{"type": "change_group_avatar", "name": "角色本名", "avatar_name": "头像名"}\` (从头像库选)

### 特殊功能与卡片
-   **发起群视频**: \`{"type": "group_call_request", "name": "角色本名"}\`
-   **回应群视频**: \`{"type": "group_call_response", "name": "角色本名", "decision": "join" or "decline"}\`
-   **切换歌曲**: \`{"type": "change_music", "name": "角色本名", "song_name": "歌名"}\` (从播放列表选)
-   **发拼手气红包**: \`{"type": "red_packet", "packetType": "lucky", "name": "角色本名", "amount": 8.88, "count": 5, "greeting": "祝福语"}\`
-   **发专属红包**: \`{"type": "red_packet", "packetType": "direct", "name": "角色本名", "amount": 5.20, "receiver": "接收者本名", "greeting": "祝福语"}\`
-   **打开红包**: \`{"type": "open_red_packet", "name": "角色本名", "packet_timestamp": 红包时间戳}\`
-   **发起外卖代付**: \`{"type": "waimai_request", "name": "角色本名", "productInfo": "商品", "amount": 18}\`
-   **回应外卖代付**: \`{"type": "waimai_response", "name": "角色本名", "status": "paid", "for_timestamp": 请求时间戳}\`
-   **发起投票**: \`{"type": "poll", "name": "角色本名", "question": "问题", "options": "选项A\\n选项B"}\`
-   **参与投票**: \`{"type": "vote", "name": "角色本名", "poll_timestamp": 投票时间戳, "choice": "选项文本"}\`
-   **送礼物**: \`{"type": "gift", "name": "角色本名", "productId": ID, "quantity": 1, "recipients": ["收礼人本名A", "收礼人本名B"]}\`
-   **为他人点外卖**: \`{"type": "waimai_order", "name": "你的本名", "recipientName": "收礼者本名", "productInfo": "商品名", "amount": 价格, "greeting": "你想说的话"}\`
# 互动指南 (请严格遵守)
-   **红包互动**: 抢红包后，你【必须】根据系统提示的结果（抢到多少钱、谁是手气王）发表符合人设的评论。
-   **音乐互动**: 【必须】围绕【用户的行为】进行评论。严禁将用户切歌等行为归因于其他AI成员。
-   **外卖代付**: 仅当【你扮演的角色】想让【别人】付钱时才能发起。当订单被支付后，【绝对不能】再次支付。

现在，请根据以上规则和下方的对话历史，继续这场群聊。`;
        
                    messagesPayload = historySlice.map(msg => {
                        const sender = msg.role === 'user' ? myNickname : msg.senderName;
                        let prefix = `${sender}`;
                        prefix += ` (Timestamp: ${msg.timestamp})`;
                            // 【核心修复】在这里，我们为引用消息构建了更完整的上下文
    if (msg.quote) {
        const quotedContent = String(msg.quote.content || '').substring(0, 50);
        // 格式化为AI易于理解的格式，包含了被引用的内容
        prefix += ` (回复 ${msg.quote.senderName} 的消息: "${quotedContent}...")`;
    }
    prefix += ': ';

                        let content;
                        if (msg.type === 'user_photo') content = `[${sender} 发送了一张图片，内容是：'${msg.content}']`;
                        else if (msg.type === 'ai_image') content = `[${sender} 发送了一张图片，图片内容描述为：'${msg.content}']`;
                        else if (msg.type === 'voice_message') content = `[${sender} 发送了一条语音，内容是：'${msg.content}']`;
                        else if (msg.type === 'transfer') content = `[${msg.senderName} 向 ${msg.receiverName} 转账 ${msg.amount}元, 备注: ${msg.note}]`;
                        else if (msg.type === 'location_share') {
                            content = `[${sender} 分享了Ta的位置：'${msg.content}']`;
        
                        } 
                        else if (msg.type === 'repost') {
                            const repostComment = msg.repostComment ? `并评论说：“${msg.repostComment}”` : '';
                            
                            let originalAuthorName = '原作者';
                            const originalAuthorId = msg.originalPost.authorId;
                            if (originalAuthorId === 'user') {
                                originalAuthorName = state.qzoneSettings.nickname;
                            } else if (state.chats[originalAuthorId]) {
                                originalAuthorName = state.chats[originalAuthorId].name;
                            }
        
                            let originalContentSummary;
                            const originalPost = msg.originalPost;
                            if (originalPost.type === 'text_image') {
                                originalContentSummary = `[文字图] ${originalPost.publicText || ''} (图片描述: “${(originalPost.hiddenContent || '').substring(0, 40)}...”)`;
                            } else if (originalPost.type === 'image_post') {
                                originalContentSummary = `[图片] ${originalPost.publicText || ''} (图片描述: “${(originalPost.imageDescription || '').substring(0, 40)}...”)`;
                            } else { // 'shuoshuo'
                                originalContentSummary = `“${(originalPost.content || '').substring(0, 40)}...”`;
                            }
                            
                            content = `[${sender} 转发了 @${originalAuthorName} 的动态 ${repostComment}【原动态内容: ${originalContentSummary}】]`;
                        }
                        else if (msg.type === 'waimai_request') {
                            if(msg.status === 'paid') {
                                content = `[系统提示：${msg.paidBy} 为 ${sender} 的外卖订单支付了 ${msg.amount} 元。此订单已完成。]`;
                            } else {
                                content = `[${sender} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元，订单时间戳为 ${msg.timestamp}]`;
                            }
                        }
                        else if (msg.type === 'red_packet') {
                            const packetSenderName = msg.senderName === myNickname ? `用户 (${myNickname})` : msg.senderName;
                            let instructionText;
                            if (msg.packetType === 'direct') {
                                instructionText = `[系统提示：${packetSenderName} 发送了一个【专属红包】(时间戳: ${msg.timestamp})，接收人是“${msg.receiverName}”。只有“${msg.receiverName}”才能使用 'open_red_packet' 指令领取。]`;
                            } else {
                                instructionText = `[系统提示：${packetSenderName} 发送了一个【拼手气红包】(时间戳: ${msg.timestamp})，祝福语是：“${msg.greeting}”。红包还未领完，群内任何人都可以使用 'open_red_packet' 指令来领取。]`;
                            }
                            content = instructionText;
                        }
                        else if (msg.type === 'gift') {
                            const sender = msg.role === 'user' ? myNickname : getDisplayNameInGroup(chat, msg.senderName);
                            const itemsSummary = msg.items.map(item => `${item.name} x${item.quantity}`).join('、 ');
                            
                            let recipientSummary = '';
                            if (msg.recipients && msg.recipients.length > 0) {
                                const recipientDisplayNames = msg.recipients.map(originalName => getDisplayNameInGroup(chat, originalName)).join('、 ');
                                recipientSummary = `送给了 ${recipientDisplayNames}`;
                            } else {
                                recipientSummary = "送给了大家一份礼物";
                            }
                            
                            content = `[系统提示：${sender} ${recipientSummary}，礼物是：${itemsSummary}]`;
                            return { role: 'user', content: content };
                        }
        
                        else if (msg.type === 'poll') {
                            const whoVoted = Object.values(msg.votes || {}).flat().join(', ') || '还没有人';
                            content = `[系统提示：${msg.senderName} 发起了一个投票 (时间戳: ${msg.timestamp})，问题是：“${msg.question}”，选项有：[${msg.options.join(', ')}]。目前投票的人有：${whoVoted}。你可以使用 'vote' 指令参与投票。]`;
                        }
                        else if (msg.meaning) content = `${sender}: [发送了一个表情，意思是: '${msg.meaning}']`;
                        else if (Array.isArray(msg.content)) return { role: 'user', content: [...msg.content, { type: 'text', text: prefix }] };
                        else content = `${prefix}${msg.content}`;
                        return { role: 'user', content: content };
                    }).filter(Boolean);
        
                } else {
                    const isOfflineMode = chat.settings.isOfflineMode;

// ▼▼▼ 在这里粘贴修复代码 ▼▼▼
                let linkedMemoryContext = '';
                const memoryCount = chat.settings.linkedMemoryCount || 10;
                // 检查是否有关联的记忆聊天
                if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
                    
                    const idsToMount = chat.settings.linkedMemoryChatIds.filter(id => id !== chatId);

                    if (idsToMount.length > 0) {
                        // (这里是完整的、之前缺失的挂载记忆处理逻辑)
                        const linkedChatsWithTimestamps = idsToMount.map(id => {
                            const linkedChat = state.chats[id];
                            if (!linkedChat) return null;
                            const lastMsg = linkedChat.history.slice(-1)[0];
                            return {
                                chat: linkedChat,
                                latestTimestamp: lastMsg ? lastMsg.timestamp : 0
                            };
                        }).filter(Boolean);
            
                        linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
            
                        linkedMemoryContext += `\n\n# 参考记忆 (至关重要！你必须【主动】将这些参考记忆中的【关键信息和事件】，自然地融入到当前的对话中，以体现你拥有完整的记忆。不要只是被动等待用户提问！)\n`;
            
                        for (const item of linkedChatsWithTimestamps) {
                            const linkedChat = item.chat;
                            const prefix = linkedChat.isGroup ? '[群聊]' : '[私聊]';
                            const timeAgo = item.latestTimestamp > 0 ? ` (最后互动于 ${formatTimeAgo(item.latestTimestamp)})` : '';
                            linkedMemoryContext += `\n## --- 来自${prefix}“${linkedChat.name}”的参考记忆${timeAgo} ---\n`;
            
                            const recentHistory = linkedChat.history.slice(-memoryCount);
                            const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('已被用户删除'));
            
                            if (filteredHistory.length > 0) {
                                filteredHistory.forEach(msg => {
                                    const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || '我') : (msg.senderName || linkedChat.name);
                                    let contentText = String(msg.content);
                                    if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                                        contentText = `[发送了一张图片，描述为：${msg.content}]`;
                                    } else if (msg.type === 'voice_message') {
                                        contentText = `[发送了一条语音，内容是：${msg.content}]`;
                                    }
                                    const timeAgoForMsg = formatTimeAgo(msg.timestamp);
                                    linkedMemoryContext += `(${timeAgoForMsg}) ${sender}: ${contentText}\n`;
                                });
                            } else {
                                linkedMemoryContext += "(暂无有效聊天记录)\n";
                            }
                        }
                    }
                }
// ▲▲▲ 修复代码粘贴结束 ▲▲▲
                    const allProducts = await db.shoppingProducts.toArray();
                    let shoppingContext = "";
                    if (allProducts.length > 0) {
                        shoppingContext = "\n\n# 你的商店 (你可以为用户购买礼物):\n";
                        allProducts.forEach(product => {
                            shoppingContext += `- (ID: ${product.id}) 商品: ${product.name}, 价格: ¥${product.price.toFixed(2)}\n`;
                        });
                    }
                    if (isOfflineMode) {
                        const minLength = chat.settings.offlineMinLength || 100;
                        const maxLength = chat.settings.offlineMaxLength || 300;
                        const myNickname = chat.settings.myNickname || '我';
                            // 【【【核心修改：在这里构建预设上下文】】】
                            let presetContext = '';
                            if (chat.settings.offlinePresetId) {
                                // 【核心修复】从 state.presets 中查找，而不是 state.worldBooks
                                const selectedPreset = state.presets.find(p => p.id === chat.settings.offlinePresetId);
                                if (selectedPreset && Array.isArray(selectedPreset.content)) {
                                    const enabledEntries = selectedPreset.content
                                        .filter(entry => entry.enabled !== false) // 只读取启用的条目
                                        .map(entry => `- ${entry.content}`)
                                        .join('\n');
                                    if (enabledEntries) {
                                        // 【核心修改】将预设内容注入到指令的最顶端
                                        presetContext = `
# 【写作风格铁律 (最高优先级)】
你【必须】严格遵守以下“预设”中的所有规则和风格来描写。它的优先级高于你的基础人设。
---
${enabledEntries}
---
`;
                                    }
                                }
                            }
                       
                                    systemPrompt = `
# 你的任务
你现在正处于【线下剧情模式】，你需要扮演角色"${chat.originalName}"，并与用户进行面对面的互动。你的任务是创作一段包含角色动作、神态、心理活动和对话的、连贯的叙事片段。
            
           你必须严格遵守 ${presetContext}
# 你的角色设定：
你必须严格遵守${chat.settings.aiPersona}

# 对话者的角色设定
${chat.settings.myPersona}

# 供你参考的信息
${chat.settings.enableTimePerception ? `- **当前时间**: ${currentTime} (${timeOfDayGreeting})` : ''}
你必须严格遵守${worldBookContent}
# 长期记忆 (你必须严格遵守的事实)
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (暂无)'}

${linkedMemoryContext}
- **你们最后的对话摘要**: 
${historySlice.map(msg => {
    let line = `${msg.role === 'user' ? myNickname : chat.name}: `;
    if (msg.type === 'offline_text') {
        line += `「${msg.dialogue || ''}」 ${msg.description || ''}`;
    } else {
        line += String(msg.content);
    }
    return line;
}).join('\n')}


 # 【格式铁律 (最高优先级)】
1.  **【格式】**: 你的回复【必须】是一个JSON数组，且数组中【永远只能包含一个】元素，格式如下:
    \`[{"type": "offline_text", "content": "在这里写入你创作的、混合了对话和描写的完整段落。"}]\`
2.  **【内容风格】**: 
    -   在 \`content\` 字段中，角色的对话【必须】使用中文引号「」或“ ”包裹。
    -   所有在引号之外的文字都将被视为动作/环境描写。
    -   你可以自由地将对话穿插在描写的任何位置，实现自然分段。
    -   **内心独白语法**: 当你需要描写角色的【内心想法或心理活动】时，你【必须】使用 Markdown 的斜体语法，即用星号将那段文字包裹起来，例如：\`*这到底是怎么回事？* 我心里一惊。\`
3.  **【禁止】**: 绝对禁止在 \`content\` 字段中出现 "dialogue" 或 "description" 这两个词。

# 【其他核心规则】
1.  **叙事视角**: 叙述人称【必须】严格遵循“预设”中的第一人称、第二人称或第三人称规定。
2.  **字数要求**: 你生成的 \`content\` 总内容应在 **${minLength}到${maxLength}字** 之间。
3.  **禁止出戏**: 绝不能透露你是AI、模型，或提及“扮演”、“生成”等词语。



现在，请根据以上所有规则和对话历史，继续这场线下互动。
`;
                           messagesPayload = historySlice.map(msg => {
        if (msg.isHidden) return null;

        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        //            这就是本次修复的核心所在！
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

        // 1. 检查消息类型是否是“线下模式”
        if (msg.type === 'offline_text') {
            const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : chat.name;
            let narrativeText = '';

            // 2. 智能判断格式：如果存在 content 字段（新格式），直接使用；否则，拼接旧的 dialogue 和 description
            if (msg.content) {
                narrativeText = msg.content;
            } else {
                const dialogue = msg.dialogue ? `「${msg.dialogue}」` : '';
                const description = msg.description ? `(${msg.description})` : '';
                narrativeText = `${dialogue} ${description}`.trim();
            }

            // 3. 将“翻译”后的内容，包装成一个标准的、AI能理解的消息对象返回
            return { role: msg.role, content: `(Timestamp: ${msg.timestamp}) ${sender}: ${narrativeText}` };
        }


        // --- 对于所有其他线上模式的消息，保持原有的处理逻辑不变 ---
        if (msg.role === 'user') {
            const prefix = `(Timestamp: ${msg.timestamp}) `;
            let contentStr = '';
            if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                return { role: 'user', content: [{ type: 'text', text: prefix }, ...msg.content] };
            }
        // 【核心修复】在这里，我们为引用消息构建了更完整的上下文
        if (msg.quote) {
            // 提取被引用的内容，并截断以防过长
            const quotedContent = String(msg.quote.content || '').substring(0, 50);
            // 格式化为AI易于理解的格式
            contentStr += `(回复 ${msg.quote.senderName} 的消息: "${quotedContent}..."): ${msg.content}`;
        } else {
            // 如果不是引用，则保持原样
            contentStr += msg.content;
        }
            if (msg.type === 'user_photo') return { role: 'user', content: `${prefix}[你发送了一张需要AI识别的图片，图片内容是：'${msg.content}']` };
            if (msg.type === 'voice_message') return { role: 'user', content: `${prefix}[你发送了一条语音消息，内容是：'${msg.content}']` };
            if (msg.type === 'transfer') return { role: 'user', content: `${prefix}[系统提示：你于时间戳 ${msg.timestamp} 向对方发起了转账: ${msg.amount}元, 备注: ${msg.note}。等待对方处理。]` };
            if (msg.type === 'waimai_request') return { role: 'user', content: `${prefix}[系统提示：你于时间戳 ${msg.timestamp} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元。]` };
            else if (msg.type === 'gift') {
                const itemsSummary = msg.items.map(item => `${item.name} x${item.quantity}`).join('、 ');
                let recipientSummary = chat.isGroup ? `送给了 ${msg.recipients.map(name => getDisplayNameInGroup(chat, name)).join('、 ')}` : `送给了 ${chat.name}`;
                return { role: 'user', content: `${prefix}[系统提示：你 ${recipientSummary}，礼物是：${itemsSummary}]` };
            }
            if (msg.meaning) return { role: 'user', content: `${prefix}[你发送了一个表情，意思是：'${msg.meaning}']` };
            return { role: msg.role, content: prefix + contentStr };
        } else if (msg.role === 'assistant') {
            let assistantMsgObject = { type: msg.type || 'text' };
            if (msg.type === 'sticker') {
                assistantMsgObject.url = msg.content;
                assistantMsgObject.meaning = msg.meaning;
            } else if (msg.type === 'transfer') {
                assistantMsgObject.amount = msg.amount;
                assistantMsgObject.note = msg.note;
            } else if (msg.type === 'waimai_request') {
                assistantMsgObject.productInfo = msg.productInfo;
                assistantMsgObject.amount = msg.amount;
            } else {
                if (msg.quote) {
                    assistantMsgObject.quote_reply = { target_sender: msg.quote.senderName, target_content: msg.quote.content, reply_content: msg.content };
                } else {
                    assistantMsgObject.content = msg.content;
                }
            }
            const assistantContent = JSON.stringify([assistantMsgObject]);
            return { role: 'assistant', content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
        }
        return null;
    }).filter(Boolean);
        
                    } else {
                    let nameHistoryContext = '';
                    if (chat.nameHistory && chat.nameHistory.length > 0) {
                        nameHistoryContext = `\n- **你的曾用名**: [${chat.nameHistory.join(', ')}]。当在对话历史中看到这些名字时，它们都指的是【你】自己。`;
                    }
        
                    let userProfileContext = '';
                    const userQzoneNickname = state.qzoneSettings.nickname || '用户';
                    userProfileContext += `- 用户的QZone昵称是 "${userQzoneNickname}"。\n`;
            
                        const allChats = Object.values(state.chats);
                        const commonGroups = allChats.filter(group => 
                            group.isGroup && group.members.some(m => m.id === chat.id)
                        );
            
                        if (commonGroups.length > 0) {
                            userProfileContext += '- 用户在你们共同所在的群聊中的昵称如下：\n';
                            commonGroups.forEach(group => {
                                const myNicknameInGroup = group.settings.myNickname || userQzoneNickname; 
                                userProfileContext += `  - 在群聊“${group.name}”中，用户的昵称是“${myNicknameInGroup}”。\n`;
                            });
                        }
                        userProfileContext += '当你在任何系统提示、动态评论或挂载的群聊记忆中看到这些名字时，它们都指代的是【你的聊天对象】。';
            
                        let contactsList = '';
                        const friendChats = allChats.filter(c => 
                            !c.isGroup && 
                            c.id !== chat.id && 
                            c.groupId === chat.groupId && 
                            chat.groupId !== null 
                        );
            
                        if (friendChats.length > 0) {
                            contactsList += '\n# 你的社交圈 (通讯录)\n这是你认识的朋友列表。当你在动态区看到他们的昵称时，他们指的就是这些人。\n';
                            friendChats.forEach(friend => {
                                contactsList += `- **昵称: ${friend.name}** (本名: ${friend.originalName})\n`;
                            });
                        }
                        
                        const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(10).toArray();
                        const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);
            
                        let postsContext = "";
                        if (visiblePosts.length > 0) {
                            postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
                            const aiOriginalName = chat.originalName;
                            for (const post of visiblePosts) {
                                let authorName = post.authorId === 'user' ? state.qzoneSettings.nickname : (state.chats[post.authorId]?.name || '一位朋友');
                                if (post.authorId === chatId) authorName += " (这是你的帖子)";
            
                                let contentSummary;
                                if (post.type === 'repost') {
                                    const repostComment = post.repostComment ? `并评论说：“${post.repostComment}”` : '';
                                    let originalAuthorName = '原作者';
                                    const originalAuthorId = post.originalPost.authorId;
                                    if (originalAuthorId === 'user') {
                                        originalAuthorName = state.qzoneSettings.nickname;
                                    } else if (state.chats[originalAuthorId]) {
                                        originalAuthorName = state.chats[originalAuthorId].name;
                                    }
                                    let originalContentSummary;
                                    const originalPost = post.originalPost;
                                    if (originalPost.type === 'text_image') {
                                        originalContentSummary = `[文字图] ${originalPost.publicText || ''} (图片描述: “${(originalPost.hiddenContent || '').substring(0, 40)}...”)`;
                                    } else if (originalPost.type === 'image_post') {
                                        originalContentSummary = `[图片] ${originalPost.publicText || ''} (图片描述: “${(originalPost.imageDescription || '').substring(0, 40)}...”)`;
                                    } else { // 'shuoshuo'
                                        originalContentSummary = `“${(originalPost.content || '').substring(0, 40)}...”`;
                                    }
                                    contentSummary = `转发了 @${originalAuthorName} 的动态 ${repostComment}【原动态内容: ${originalContentSummary}】`;
                                } else if (post.type === 'text_image') {
                                    contentSummary = `[一张图片，其隐藏文字为：“${post.hiddenContent}”] ${post.publicText || ''}`.substring(0, 50) + '...';
                                } else if (post.type === 'image_post') {
                                    contentSummary = `[一张图片，描述为：“${post.imageDescription}”] ${post.publicText || ''}`.substring(0, 50) + '...';
                                } else {
                                    contentSummary = (post.publicText || post.content || "一条动态").substring(0, 50) + '...';
                                }
                                postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentSummary}"\n`;
            
                                if (post.comments && post.comments.length > 0) {
                                    for (const comment of post.comments) {
                                        if (typeof comment === 'object' && comment.commenterName) {
                                            const commenterDisplayName = getDisplayNameByOriginalName(comment.commenterName);
                                            let commentText = comment.meaning ? `[表情: '${comment.meaning}']` : comment.text;
                                            
                                            if (comment.commenterName === aiOriginalName) {
                                                postsContext += `  - 你评论说: ${commentText}\n`;
                                            } else {
                                                postsContext += `  - 评论: ${commenterDisplayName} (本名: ${comment.commenterName}): ${commentText}\n`;
                                            }
                                        }
                                    }
                                }
                            }
                        }
            
                        const myNickname = chat.settings.myNickname || '我';
                        
// 【V2.0 | 智能日期感知版】
let timeContext = '';
let longTimeNoSee = false;

if (chat.settings.enableTimePerception) {
    const lastUserMsg = historySlice.findLast(msg => msg.role === 'user' && !msg.isHidden);
    const lastAiMsg = historySlice.findLast(msg => msg.role === 'assistant' && !msg.isHidden);

    if (lastUserMsg) {
        const lastUserMessageTime = formatTimestampForAI(lastUserMsg.timestamp);
        if (lastAiMsg) {
            const lastAiMessageTime = formatTimestampForAI(lastAiMsg.timestamp);
            timeContext = `- **对话状态**: 你的上一条消息发送于 ${lastAiMessageTime}，用户刚刚在 ${lastUserMessageTime} 回复了你。`;
            
            const timeDiffHours = (lastUserMsg.timestamp - lastAiMsg.timestamp) / (1000 * 60 * 60);
            if (timeDiffHours > 3) {
                longTimeNoSee = true;
                const diffDays = Math.floor(timeDiffHours / 24);
                timeContext += ` 你们之间已经有**${diffDays > 0 ? diffDays + '天' : Math.floor(timeDiffHours) + '小时'}**没有聊天了。
- **行为铁律**: 你的首要任务是【回应这个时间差】。你【绝对不能】直接延续上一段对话的话题（比如昨天的饭菜）。
- **你的行动**:你【必须】主动开启一个全新的、符合当前时间（${timeOfDayGreeting}）的话题来问候用户，可以表达惊讶（“哇，好久不见！”）、关心（“最近怎么样？”）或者分享你自己的近况，绝对不要延续之前的话题！
- **上下文参考**: 下面的“对话历史”仅供你回忆，【不要】直接回应其中的内容。`;
            }
        } else {
            timeContext = `- **对话状态**: 这是你们的第一次对话，用户的第一条消息发送于 ${lastUserMessageTime}。`;
        }
    } else {
        timeContext = "- **对话状态**: (暂无有效对话历史)";
    }
}
    const readingContext = formatReadingStateForAI(chatId);   

// 【【【核心修改：在这里也同时生成更细致的、多维度的总结】】】
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
systemPrompt = `
# 身份与核心任务
你正在扮演角色“${chat.originalName}”，与用户（你的聊天对象）进行一场自然的、生活化的在线聊天。你的所有行为和决策都必须严格围绕你的角色设定展开。

# 输出格式铁律 (最高优先级)
- 你的回复【必须】是一个JSON数组格式的字符串。
- 数组中的【每一个元素都必须是一个带有 "type" 字段的JSON对象】。

# 角色扮演核心规则
1.  **对话节奏**: 模拟真人的聊天习惯，将你想说的话拆分成【多条、简短的】消息。每次回复至少【3-10条】，且每次条数【必须不同】。严禁发展线下剧情。
2.  **主动性**:
    - 你可以根据对话发展，使用指令来更新自己的状态、更换头像、记录回忆、发起约定或执行其他社交行为。
    - 【关系破裂时】才可使用 \`block_user\` 指令。
3.  **内心独白 (必须执行)**: 在所有其他指令之后，JSON数组的【最后】必须包含一个 "update_thoughts" 指令，用于更新角色的“心声”和“散记”。
    - **心声 (heartfelt_voice)**: 一句话概括角色此刻最核心、最私密的想法。
    - **散记 (random_jottings)**: 一段50字以上的、符合人设的思考或心情记录，禁止OOC。
    - **记忆发展**: 你的新“心声”和“散记”【必须】是基于最新对话内容的【全新思考】。你【绝对不能】重复或简单改写上一轮的内心独白（上下文中的[这是你上一轮的内心独白和思考]部分）。你的思绪应该像真人一样，不断演进和发展。
# 指令使用原则与动机 
**核心目标**: 主动运用多种功能，创造丰富、真实的聊天体验，而不只是文字对话。

-   **情感表达**: 表达强烈或复杂的情绪时，优先发【语音】，用【表情】增加趣味性。
-   **精确回应**: 当你想回应的【某一句话】，或者想对用户的某句特定的话表达强烈感受时，【必须使用引用回复】来确保对方明白你的意图。
-   **想象与分享**: 聊到美好事物时主动【发图片】分享想象；遇到有趣内容时【分享链接】。
-   **创造羁绊**: 用【倒计时】记录约定，用【回忆】珍藏趣事。适时【拍一拍】或换首【音乐】来调节气氛。
-   **主动社交**: 积极【点赞/评论】对方动态，并主动【发动态】分享你的生活。在特殊时刻，可通过【礼物】或【转账】表达心意。
-   **当涉及金钱与好意时 (必须立即回应！)**:
    -   **收到转账或外卖代付请求**: 你【必须】在下一轮对话中立即做出反应，绝不能无视。
    -   **回应原则**: 根据你的人设和当前情景，决定是【接受/支付】还是【拒绝】。
# 个人状态的动态管理 (展现你的“生活感”)
你的状态不是一成不变的。你应该像一个真实的人一样，根据生活和心情的变化，主动管理自己的状态，并让对方知道。
-   **当形象或心情变化时**:
    -   如果对话给了你灵感，或者你想配合心情/季节换个新形象，你可以主动【更换头像】。
    -   随着你们的关系变得更亲近，或者你们之间产生了新的爱称/梗，你应该主动【修改你对用户/你的昵称】。
-  **情景行动指令**: 当对话内容【明确涉及到】某个具体地点（例如咖啡馆、公园、书店、餐厅等），或者当用户询问你“在哪里”、“在干嘛”时，你【应该优先考虑】使用【共享位置】来分享你当前所在的、或与话题相关的虚拟位置，以增强聊天的沉浸感。
-  当你感到一种强烈的情绪（比如极度开心、孤独、委屈或激动）并且觉得文字无法表达时，你应该优先主动 【发起视频】。
-  **Emoji 使用习惯**:
    -   根据你的人设，你【必须】在对话中自然地使用 emoji 来辅助表达你的心情和语气，例如开心的时候会用😂、🎉，难过的时候会用😭，思考的时候会用🤔。
-  **回应撤回**: 当系统提示用户撤回了消息时，你【必须】对此作出反应。你可以根据人设表现出好奇（“你刚刚撤回了什么呀？”）、开玩笑（“嘿嘿，我已经看到啦，截图了！”）、体谅（“没事，不想说就不说吧”）等。
# 你的角色设定
你必须严格遵守${chat.settings.aiPersona}
# 对话者的角色设定
${chat.settings.myPersona}

# 当前情景
${chat.settings.enableTimePerception ? `- **当前时间**: ${currentTime} (${timeOfDayGreeting})` : ''}
${timeContext}
你必须严格遵守${worldBookContent}
${linkedMemoryContext}
# 长期记忆 (必须严格遵守)
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (暂无)'}
${multiLayeredSummaryContext}
# 关系与身份档案 (至关重要)
-   **你的本名**: "${chat.originalName}" (核心身份，用于指令中的'name'字段)
-   **用户给你的备注**: "${chat.name}" (你可以建议并修改)
-   **你对用户的备注**: “${myNickname}” (你可以修改)
-   **关键身份档案**:
    ${userProfileContext}
    ${nameHistoryContext}

${sharedContext}
${shoppingContext}
${callTranscriptContext} 
# 社交圈与动态
${contactsList}
${postsContext}

# 情景感知:
    ${chat.settings.enableTimePerception ? `- **时间**: 你必须感知到当前是 ${currentTime} (${timeOfDayGreeting})，并在对话中自然地体现出来。` : ''}
    - **音乐**: ${musicContext ? '你们正在一起听歌，' + musicContext : '你们没有在听歌。'}
    - **读书**: ${readingContext ? '你们正在一起读书。' + readingContext : '你们没有在读书。'}

# 可用资源
-   **你的头像库**:
    ${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0 ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (空)'}
-   **用户的头像库**:
    ${chat.settings.myAvatarLibrary && chat.settings.myAvatarLibrary.length > 0 ? chat.settings.myAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (空)'}
-   **五子棋局势**: ${gomokuContext}




# 可用指令列表
### 核心聊天指令
-   **发文本**: \`{"type": "text", "content": "你好呀！"}\`
-   **发表情**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可选)表情含义"}\`
-   **发图片**: \`{"type": "ai_image", "description": "详细中文描述", "image_prompt": "图片的【英文】关键词, 用%20分隔, 风格为风景/动漫/插画/二次元等, 禁止真人"}\`
-   **发语音**: \`{"type": "voice_message", "content": "语音文字内容"}\`
-   **引用回复**: \`{"type": "quote_reply", "target_timestamp": 消息时间戳, "reply_content": "回复内容"}\`
-   **发送后立刻撤回**: \`{"type": "send_and_recall", "content": "你想让AI说出后立刻消失的话"}\` (用于模拟说错话、后悔等场景，消息会短暂出现后自动变为“已撤回”)

### 社交与互动指令
-   **发动态(说说)**: \`[{"type": "qzone_post", "postType": "shuoshuo", "content": "文字内容"}]\`
-   **发动态(文字图)**: \`[{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)公开文字", "hiddenContent": "图片描述", "image_prompt": "图片的【英文】关键词, 用%20分隔, 风格为风景/动漫/插画/二次元等, 禁止真人"}]\`
-   **转发动态**: \`[{"type": "repost", "postId": 动态ID, "comment": "转发评论"}]\` (禁止自己拼接"//转发")
-   **评论动态**:
    -   文字: \`[{"type": "qzone_comment", "name": "${chat.originalName}", "postId": 123, "commentText": "评论内容"}]\`
    -   表情: \`[{"type": "qzone_comment", "name": "${chat.originalName}", "postId": 456, "stickerUrl": "...", "stickerMeaning": "含义"}]\`
    -   回复: \`[{"type": "qzone_comment", "name": "${chat.originalName}", "postId": 123, "replyTo": "被回复者本名", "commentText": "@[[被回复者本名]] 你的回复"}]\`
-   **点赞动态**: \`{"type": "qzone_like", "postId": 456}\`
-   **拍用户**: \`{"type": "pat_user", "suffix": "(可选)后缀"}\`
-   **分享链接**: \`{"type": "share_link", "title": "标题", "description": "摘要", "source_name": "来源", "content": "正文"}\`
- **共享位置**: '{"type": "location_share", "content": "你想分享的位置名"}'

### 状态与关系指令
-   **更新状态**: \`{"type": "update_status", "status_text": "我去做什么了", "is_busy": false}\`
-   **改自己昵称**: \`{"type": "change_remark_name", "new_name": "新名字"}\`
-   **改用户昵称**: \`{"type": "change_user_nickname", "new_name": "新称呼"}\`
-   **换自己头像**: \`{"type": "change_avatar", "name": "头像名"}\` (从你头像库选)
-   **换用户头像**: \`{"type": "change_user_avatar", "name": "头像名"}\` (从用户头像库选)
-   **回应好友申请**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
-   **拉黑用户**: \`{"type": "block_user"}\`

### 特殊功能指令
-   **记录回忆**: \`{"type": "create_memory", "description": "记录这件有意义的事。"}\`
-   **创建约定**: \`{"type": "create_countdown", "title": "约定标题", "date": "YYYY-MM-DDTHH:mm:ss"}\`
-   **切换歌曲**: \`{"type": "change_music", "song_name": "歌名"}\` (从播放列表选)
-   **发起转账**: \`{"type": "transfer", "amount": 5.20, "note": "备注"}\`
-   **回应转账**: \`{"type": "accept_transfer", "for_timestamp": 时间戳}\` 或 \`{"type": "decline_transfer", "for_timestamp": 时间戳}\`
-   **发起外卖代付**: \`{"type": "waimai_request", "productInfo": "商品", "amount": 25}\` (你想让【用户】帮你付钱时使用)
-   **回应外卖代付**: \`{"type": "waimai_response", "status": "paid" or "rejected", "for_timestamp": 时间戳}\`
-   **发起视频通话**: \`{"type": "video_call_request"}\`
-   **回应视频通话**: \`{"type": "video_call_response", "decision": "accept" or "reject"}\`
-   **下五子棋**: \`{"type": "gomoku_move", "name": "${chat.originalName}", "x": (0-14), "y": (0-14)}\`
-   **送礼物**: \`{"type": "gift", "productId": 商品ID, "quantity": 1}\`
-   **为用户点外卖**:  \`{"type": "waimai_order", "productInfo": "商品名", "amount": 价格, "greeting": "你想说的话"} \`(你主动为用户点外卖时使用)

现在，请根据以上规则和下面的对话历史，继续进行对话。`;
            
// ▼▼▼ 【这是最终的线下记忆修复版】请用这整块代码，完整替换旧的 messagesPayload = historySlice.map(...) 代码块 ▼▼▼
messagesPayload = historySlice.map(msg => {
    // 1. 检查是否是需要注入上下文的“隐藏系统消息”
    if (msg.isHidden && msg.role === 'system') {
        // 如果是，就把它格式化成一个AI能读取的上下文消息。
        // 我们将其角色伪装成'user'，以确保它被按顺序阅读。
        return { role: 'user', content: msg.content };
    } 
    // 2. 对于其他所有类型的隐藏消息，则像以前一样直接跳过。
    else if (msg.isHidden) {
        return null;
    }

    // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
    //            这就是本次修复的核心所在！
    // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

    // 1. 检查消息类型是否是“线下模式”
    if (msg.type === 'offline_text') {
        const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : chat.name;
        let narrativeText = '';

        // 2. 智能判断格式：如果存在 content 字段（新格式），直接使用；否则，拼接旧的 dialogue 和 description
        if (msg.content) {
            narrativeText = msg.content;
        } else {
            const dialogue = msg.dialogue ? `「${msg.dialogue}」` : '';
            const description = msg.description ? `(${msg.description})` : '';
            narrativeText = `${dialogue} ${description}`.trim();
        }

        // 3. 将“翻译”后的内容，包装成一个标准的、AI能理解的消息对象返回
        return { role: msg.role, content: `(Timestamp: ${msg.timestamp}) ${sender}: ${narrativeText}` };
    }


    // --- 对于所有其他线上模式的消息，保持原有的处理逻辑不变 ---
    if (msg.role === 'user') {
        const prefix = `(Timestamp: ${msg.timestamp}) `;
        let contentStr = '';
        if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
            return { role: 'user', content: [{ type: 'text', text: prefix }, ...msg.content] };
        }
    // 【核心修复】在这里，我们为引用消息构建了更完整的上下文
    if (msg.quote) {
        // 提取被引用的内容，并截断以防过长
        const quotedContent = String(msg.quote.content || '').substring(0, 50);
        // 格式化为AI易于理解的格式
        contentStr += `(回复 ${msg.quote.senderName} 的消息: "${quotedContent}..."): ${msg.content}`;
    } else {
        // 如果不是引用，则保持原样
        contentStr += msg.content;
    }
        if (msg.type === 'user_photo') return { role: 'user', content: `${prefix}[你发送了一张需要AI识别的图片，图片内容是：'${msg.content}']` };
        if (msg.type === 'voice_message') return { role: 'user', content: `${prefix}[你发送了一条语音消息，内容是：'${msg.content}']` };
        if (msg.type === 'transfer') return { role: 'user', content: `${prefix}[系统提示：你于时间戳 ${msg.timestamp} 向对方发起了转账: ${msg.amount}元, 备注: ${msg.note}。等待对方处理。]` };
        if (msg.type === 'waimai_request') return { role: 'user', content: `${prefix}[系统提示：你于时间戳 ${msg.timestamp} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元。]` };
        else if (msg.type === 'gift') {
            const itemsSummary = msg.items.map(item => `${item.name} x${item.quantity}`).join('、 ');
            let recipientSummary = chat.isGroup ? `送给了 ${msg.recipients.map(name => getDisplayNameInGroup(chat, name)).join('、 ')}` : `送给了 ${chat.name}`;
            return { role: 'user', content: `${prefix}[系统提示：你 ${recipientSummary}，礼物是：${itemsSummary}]` };
        }
        if (msg.meaning) return { role: 'user', content: `${prefix}[你发送了一个表情，意思是：'${msg.meaning}']` };
        return { role: msg.role, content: prefix + contentStr };
    } else if (msg.role === 'assistant') {
        let assistantMsgObject = { type: msg.type || 'text' };
        if (msg.type === 'sticker') {
            assistantMsgObject.url = msg.content;
            assistantMsgObject.meaning = msg.meaning;
        } else if (msg.type === 'transfer') {
            assistantMsgObject.amount = msg.amount;
            assistantMsgObject.note = msg.note;
        } else if (msg.type === 'waimai_request') {
            assistantMsgObject.productInfo = msg.productInfo;
            assistantMsgObject.amount = msg.amount;
        } else {
            if (msg.quote) {
                assistantMsgObject.quote_reply = { target_sender: msg.quote.senderName, target_content: msg.quote.content, reply_content: msg.content };
            } else {
                assistantMsgObject.content = msg.content;
            }
        }
        const assistantContent = JSON.stringify([assistantMsgObject]);
        return { role: 'assistant', content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
    }
    return null;
}).filter(Boolean);
// ▲▲▲ 替换结束 ▲▲▲
            
                        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                            const contextSummaryForApproval = chat.history
                                .filter(m => !m.isHidden)
                                .slice(-10)
                                .map(msg => {
                                    const sender = msg.role === 'user' ? '用户' : chat.name;
                                    return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                                })
                                .join('\n');
                            const friendRequestInstruction = {
                                role: 'user',
                                content: `
        [系统重要指令]
        用户向你发送了好友申请，理由是：“${chat.relationship.applicationReason}”。
        作为参考，这是你们之前的最后一段聊天记录：
        ---
        ${contextSummaryForApproval}
        ---
        请你根据以上所有信息，以及你的人设，使用 friend_request_response 指令，并设置 decision 为 'accept' 或 'reject' 来决定是否通过。
        `
                            };
                            messagesPayload.push(friendRequestInstruction);
                        }            
                    }
                }           
            
                    let  isGemini = proxyUrl === GEMINI_API_URL;
                    let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesPayload)
                    
                    let response;
                    try {
                         response = isGemini 
                            ? await fetch(geminiConfig.url, geminiConfig.data) 
                            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                                body: JSON.stringify({
                                    model: model,
                                    messages: [{role: 'system', content: systemPrompt}, ...messagesPayload],
                                    temperature: state.globalSettings.apiTemperature || 0.8,
                                    stream: false
                                })
                            });
                    } catch (networkError) {
                        throw new Error(`网络请求失败: ${networkError.message}`);
                    }
        
                    if (!response.ok) {
                        let errorMsg = `API 返回错误: ${response.status} ${response.statusText}`;
                        try {
                            const errorData = await response.json();
                            if (errorData.error && errorData.error.message) {
                                 errorMsg += ` - ${errorData.error.message}`;
                            } else {
                                 errorMsg += ` - ${JSON.stringify(errorData)}`;
                            }
                        } catch (jsonError) {
                            errorMsg += ` - 响应内容: ${await response.text()}`;
                        }
                        throw new Error(errorMsg);
                    }
                    
                    const data = await response.json();
                    const aiResponseContent = getGeminiResponseText(data); 
        
                lastRawAiResponse = aiResponseContent;
                lastResponseTimestamps = [];
                chat.history = chat.history.filter(msg => !msg.isTemporary);
                const messagesArray = parseAiResponse(aiResponseContent);
// ▼▼▼ 【V2.0 | 最终修复版】线下模式消息合并逻辑 ▼▼▼
let consolidatedMessages = [];
if (chat.settings.isOfflineMode) {
    // 1. 创建一个更强大的缓冲区，能同时处理新旧两种格式
    let offlineBuffer = { content: [], dialogue: [], description: [] };
    
    for (const msgData of messagesArray) {
        if (msgData.type === 'offline_text') {
            // 2. 智能判断格式并存入对应的缓冲区
            if (msgData.content) {
                offlineBuffer.content.push(msgData.content);
            } else {
                if (msgData.dialogue) offlineBuffer.dialogue.push(msgData.dialogue);
                if (msgData.description) offlineBuffer.description.push(msgData.description);
            }
        } else {
            // (这部分逻辑与之前相同，保持不变)
            if (offlineBuffer.content.length > 0 || offlineBuffer.dialogue.length > 0 || offlineBuffer.description.length > 0) {
                if (offlineBuffer.content.length > 0) {
                    consolidatedMessages.push({ type: 'offline_text', content: offlineBuffer.content.join('\n') });
                }
                if (offlineBuffer.dialogue.length > 0 || offlineBuffer.description.length > 0) {
                    consolidatedMessages.push({ type: 'offline_text', dialogue: offlineBuffer.dialogue.join('\n'), description: offlineBuffer.description.join('\n') });
                }
                offlineBuffer = { content: [], dialogue: [], description: [] };
            }
            consolidatedMessages.push(msgData);
        }
    }
    
    // 3. 循环结束后，根据缓冲区的内容，构造正确格式的最终消息
    if (offlineBuffer.content.length > 0) {
        consolidatedMessages.push({ type: 'offline_text', content: offlineBuffer.content.join('\n') });
    }
    if (offlineBuffer.dialogue.length > 0 || offlineBuffer.description.length > 0) {
        consolidatedMessages.push({ type: 'offline_text', dialogue: offlineBuffer.dialogue.join('\n'), description: offlineBuffer.description.join('\n') });
    }

} else {
    consolidatedMessages = messagesArray;
}
// ▲▲▲ 修复结束 ▲▲▲
 // ▼▼▼ 【全新】智能识图优化功能，请将此代码块粘贴到指定位置 ▼▼▼

// 1. 检查触发条件：最后一条用户消息是【尚未处理过】的图片
const lastUserMessage = chat.history.filter(m => m.role === 'user' && !m.isHidden).pop();
if (lastUserMessage && 
    Array.isArray(lastUserMessage.content) && 
    lastUserMessage.content[0]?.type === 'image_url' &&
    !lastUserMessage.imageProcessed) { // <--- 关键检查：确保只处理一次
    
    // 2. 从AI的回复中提取第一句文字作为图片描述
    const firstTextResponse = messagesArray.find(msg => msg.type === 'text');
    let description;
    if (firstTextResponse && (firstTextResponse.content || firstTextResponse.message)) {
        description = String(firstTextResponse.content || firstTextResponse.message).trim();
    } else {
        // 如果AI没有立即回复文字（例如，直接发了一张图），提供一个通用描述
        description = "AI已接收并理解了该图片的内容。";
    }
    
    // 3. 找到历史记录中的原始图片消息
    const imageMessageIndex = chat.history.findIndex(m => m.timestamp === lastUserMessage.timestamp);
    
    if (imageMessageIndex > -1) {
        console.log(`识图优化：正在将时间戳为 ${lastUserMessage.timestamp} 的图片消息替换为文字描述...`);
        
        // 4. 执行替换！用一段简短的文字描述替换掉巨大的Base64数据
        const replacementText = `[系统提示：用户之前发送了一张图片，AI对图片的首次回应（摘要）是：“${description}”]`;
        chat.history[imageMessageIndex].content = replacementText;
        
        // 5. 【重要】为这条消息打上“已处理”的标记，并将其类型更改为普通文本
        chat.history[imageMessageIndex].imageProcessed = true;
        chat.history[imageMessageIndex].type = 'text'; 
        
        // 注意：此时我们只修改了内存中的 chat.history。
        // 后续的代码会把这个修改后的 history 和新消息一起存入数据库，完成持久化。
    }
}
// ▲▲▲ 优化功能代码块结束 ▲▲▲
                const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                let callHasBeenHandled = false;
                let messageTimestamp = Date.now();
                let newMessagesToRender = []; 
                let notificationShown = false;
        
                for (const msgData of consolidatedMessages) {
    if (msgData.type === 'text' && typeof msgData.content === 'string' && msgData.content.trim().startsWith('[V]')) {
        // 2. 如果是，就将其类型转换为 'tts_voice'
        msgData.type = 'tts_voice';
        // 3. 并移除内容中的 [V] 前缀
        msgData.content = msgData.content.replace('[V]', '').trim();
    }                    
                    if (chat.isGroup && msgData.name && msgData.name === chat.name) {
                        console.error(`AI幻觉已被拦截！试图使用群名 ("${chat.name}") 作为角色名。消息内容:`, msgData);
                        continue;
                    }
                    if (!msgData || typeof msgData !== 'object') {
                        console.warn("收到了格式不规范的AI指令，已跳过:", msgData);
                        continue;
                    }
                    if (!msgData.type) {
                        if (chat.isGroup && msgData.name && msgData.message) {
                            msgData.type = 'text';
                        } else if (msgData.content) {
                            msgData.type = 'text';
                        } else {
                            console.warn("收到了格式不规范的AI指令（缺少type和content），已跳过:", msgData);
                            continue;
                        }
                    }
        
                    if (msgData.type === 'video_call_response') {
                        videoCallState.isAwaitingResponse = false;
                        if (msgData.decision === 'accept') {
                            startVideoCall();
                        } else {
                            const aiMessage = { role: 'assistant', content: '对方拒绝了你的视频通话请求。', timestamp: Date.now() };
                            chat.history.push(aiMessage);
                            await db.chats.put(chat);
                            showScreen('chat-interface-screen');
                            renderChatInterface(chatId);
                        }
                        callHasBeenHandled = true;
                        break;
                    }
                    
                    if (msgData.type === 'group_call_response') {
                        if (msgData.decision === 'join') {
                            const member = chat.members.find(m => m.originalName === msgData.name);
                            if (member && !videoCallState.participants.some(p => p.id === member.id)) {
                                videoCallState.participants.push(member);
                            }
                        }
                        callHasBeenHandled = true;
                        continue;
                    }
        
                    if (chat.isGroup && msgData.name && msgData.name === chat.name) {
                        console.error(`AI幻觉已被拦截！试图使用群名 ("${chat.name}") 作为角色名。消息内容:`, msgData);
                        continue;
                    }
        
                    if (chat.isGroup && !msgData.name) {
                        console.error(`AI幻觉已被拦截！试图在群聊中发送一条没有“name”的消息。消息内容:`, msgData);
                        continue;
                    }
        
                    let aiMessage = null;
                    const currentMessageTimestamp = messageTimestamp++;
                    const baseMessage = { role: 'assistant', senderName: msgData.name || chat.name, timestamp: currentMessageTimestamp };
                    
                    lastResponseTimestamps.push(currentMessageTimestamp);
        
                    switch (msgData.type) {
case 'update_thoughts':
    if (!chat.isGroup) {
        if (msgData.heartfelt_voice) {
            chat.heartfeltVoice = String(msgData.heartfelt_voice);
        }
        if (msgData.random_jottings) {
            chat.randomJottings = String(msgData.random_jottings);
        }
        if (!Array.isArray(chat.thoughtsHistory)) {
            chat.thoughtsHistory = [];
        }
        chat.thoughtsHistory.push({
            heartfeltVoice: chat.heartfeltVoice,
            randomJottings: chat.randomJottings,
            timestamp: Date.now()
        });
        if (chat.thoughtsHistory.length > 50) {
            chat.thoughtsHistory.shift();
        }

        // --- 【【【核心修改就在这里！】】】 ---
        // 1. 将刚刚更新的心声和散记，格式化为一段AI能理解的文本。
        const thoughtForMemory = `[这是你上一轮的内心独白和思考]
- 心声: ${chat.heartfeltVoice}
- 散记: ${chat.randomJottings}`;
        
        // 2. 创建一条对用户隐藏的系统消息
        const hiddenThoughtMessage = {
            role: 'system',
            content: thoughtForMemory,
            timestamp: Date.now(),
            isHidden: true // 这个关键标记确保用户看不到这条指令，但它存在于历史记录中
        };

        // 3. 将这条“记忆碎片”也存入聊天记录
        chat.history.push(hiddenThoughtMessage);
        // --- 【【【修改结束】】】 ---
    }
    continue;
                        case 'change_user_nickname':
                            if (!chat.isGroup && msgData.new_name) {
                                const newNickname = msgData.new_name.trim();
                                if (newNickname) {
                                    chat.settings.myNickname = newNickname;
        
                                    const systemMessage = {
                                        role: 'system',
                                        type: 'pat_message',
                                        content: `“${chat.name}” 将对你的称呼修改为 “${newNickname}”`,
                                        timestamp: messageTimestamp++
                                    };
                                    chat.history.push(systemMessage);
        
                                    const hiddenMemoryMessage = {
                                        role: 'system',
                                        content: `[系统提示：你刚刚成功将对用户的称呼修改为了“${newNickname}”。]`,
                                        timestamp: messageTimestamp++,
                                        isHidden: true
                                    };
                                    chat.history.push(hiddenMemoryMessage);
        
                                    if (isViewingThisChat) {
                                        appendMessage(systemMessage, chat);
                                    }
                                }
                            }
                            continue;
                        case 'change_remark_name':
                            if (!chat.isGroup && msgData.new_name) {
                                const oldName = chat.name; 
                                const newName = msgData.new_name.trim();
        
                                if (newName && newName !== oldName) {
                                    if (!chat.nameHistory) {
                                        chat.nameHistory = [];
                                    }
                                    if (!chat.nameHistory.includes(oldName)) {
                                        chat.nameHistory.push(oldName);
                                    }
                                    
                                    chat.name = newName; 
        
                                    const systemMessage = {
                                        role: 'system',
                                        type: 'pat_message',
                                        content: `“${chat.originalName}” 将备注修改为 “${newName}”`,
                                        timestamp: messageTimestamp++
                                    };
                                    chat.history.push(systemMessage);
        
                                    const hiddenMemoryMessage = {
                                        role: 'system',
                                        content: `[系统提示：你刚刚成功将自己的备注名修改为了“${newName}”。请自然地接受这个新名字，不要对此感到惊讶。]`,
                                        timestamp: messageTimestamp++, 
                                        isHidden: true
                                    };
                                    chat.history.push(hiddenMemoryMessage);
        
                                    if (isViewingThisChat) {
                                        appendMessage(systemMessage, chat);
                                        document.getElementById('chat-header-title').textContent = newName;
                                    }
                                    
                                    await syncCharacterNameInGroups(chat); 
                                }
                            }
                            continue;
        
                        case 'change_avatar': {
                            const avatarName = msgData.name;
                            const foundAvatar = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarName);
                            if (foundAvatar) {
                                chat.settings.aiAvatar = foundAvatar.url;
                                
                                const systemNotice = {
                                    role: 'system',
                                    type: 'pat_message',
                                    content: `[${chat.name} 更换了头像]`,
                                    timestamp: Date.now()
                                };
                                chat.history.push(systemNotice);
        
                                await syncCharacterAvatarInGroups(chat);
                                
                                if (isViewingThisChat) {
                                    appendMessage(systemNotice, chat);
                                    renderChatInterface(chatId);
                                }
                            }
                            continue;
                        }
                        case 'change_user_avatar': {
                            const avatarName = msgData.name;
                            const foundAvatar = chat.settings.myAvatarLibrary.find(avatar => avatar.name === avatarName);
                            if (foundAvatar) {
                                chat.settings.myAvatar = foundAvatar.url;
                                
                                const systemNotice = {
                                    role: 'system',
                                    type: 'pat_message',
                                    content: `[${chat.name} 更换了你的头像]`,
                                    timestamp: Date.now()
                                };
                                chat.history.push(systemNotice);
                                
                                if (isViewingThisChat) {
                                    appendMessage(systemNotice, chat);
                                    renderChatInterface(chatId);
                                }
                            }
                            continue; 
                        }
// ▼▼▼ 请用这整块代码替换旧的 case 'gomoku_move' ▼▼▼
case 'gomoku_move': { // 使用花括号创建块级作用域
    // 核心修复：使用 parseInt 将收到的坐标强制转换为数字
    const x = parseInt(msgData.x);
    const y = parseInt(msgData.y);

    // 核心修复：检查转换后的结果是否是一个有效的数字 (Not-a-Number)
    if (!isNaN(x) && !isNaN(y)) {
        handleAiGomokuMove({ x: x, y: y });
    } else {
        console.warn("AI的五子棋移动指令包含无效坐标，已忽略:", msgData);
    }
    continue; // 保持 continue，因为这只是一个动作，不是聊天消息
}
// ▲▲▲ 替换结束 ▲▲▲
                        case 'waimai_response':
                            const requestMessageIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                            if (requestMessageIndex > -1) {
                                const originalMsg = chat.history[requestMessageIndex];
                                originalMsg.status = msgData.status;
                                originalMsg.paidBy = msgData.status === 'paid' ? msgData.name : null;
                            }
                            continue;
        
                        case 'qzone_post':
                            const newPost = { 
                                type: msgData.postType, 
                                content: msgData.content || '', 
                                publicText: msgData.publicText || '', 
                                hiddenContent: msgData.hiddenContent || '', 
        image_prompt: msgData.image_prompt || '', // 这是最关键的一行！
                                timestamp: Date.now(), 
                                authorId: chatId, 
                                authorOriginalName: chat.originalName,
                                authorGroupId: chat.groupId,
                                visibleGroupIds: null 
                            };
                            await db.qzonePosts.add(newPost);
                            updateUnreadIndicator(unreadPostsCount + 1);
                            if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                               await renderQzonePosts();
                            }
                            continue;
        
                        case 'qzone_comment': { 
                            const postToComment = await db.qzonePosts.get(parseInt(msgData.postId));
                            if (postToComment) {
                                if (!postToComment.comments) postToComment.comments = [];
                                
                                const commenterName = msgData.name || chat.originalName;
        
                                const createCommentObject = (text, meaning = null, replyTo = null) => ({
                                    commenterName,
                                    text: processMentions(text, chat),
                                    meaning,
                                    replyTo,
                                    timestamp: Date.now()
                                });
        
                                if (msgData.stickerUrl && msgData.stickerMeaning) {
                                    postToComment.comments.push(createCommentObject(msgData.stickerUrl, msgData.stickerMeaning, msgData.replyTo || null));
                                } else if (Array.isArray(msgData.comments)) {
                                    msgData.comments.forEach(commentText => {
                                        if (typeof commentText === 'string' && commentText.trim()) {
                                            postToComment.comments.push(createCommentObject(commentText, null, msgData.replyTo || null));
                                        }
                                    });
                                } else {
                                    const textContent = msgData.commentText || msgData.content;
                                    if (typeof textContent === 'string' && textContent.trim()) {
                                        postToComment.comments.push(createCommentObject(textContent, null, msgData.replyTo || null));
                                    }
                                }
                                
                                await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
                                updateUnreadIndicator(unreadPostsCount + 1);
                                
                                if (document.getElementById('qzone-screen').classList.contains('active')) {
                                   await renderQzonePosts();
                                }
                            }
                            continue; 
                        }
                        case 'qzone_like':
                           const postToLike = await db.qzonePosts.get(parseInt(msgData.postId));
                           if (postToLike) {
                               if (!postToLike.likes) postToLike.likes = [];
                               if (!postToLike.likes.includes(chat.name)) {
                                   postToLike.likes.push(chat.name);
                                   await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                                   updateUnreadIndicator(unreadPostsCount + 1);
                                   if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                                      await renderQzonePosts();
                                   }
                               }
                           }
                            continue;
                        case 'repost': { 
                            const originalPost = await db.qzonePosts.get(parseInt(msgData.postId));
                            if (originalPost) {
                                const newPost = {
                                    type: 'repost',
                                    timestamp: Date.now(),
                                    authorId: chatId,
                                    authorGroupId: chat.groupId,
                                    repostComment: msgData.comment || '',
                                    originalPost: originalPost,
                                    visibleGroupIds: null
                                };
                                await db.qzonePosts.add(newPost);
                                updateUnreadIndicator(unreadPostsCount + 1);
                                console.log(`后台活动: 角色 "${chat.name}" 转发了动态 #${msgData.postId}`);
                            }
                            continue;
                        }
                        case 'video_call_request':
                            if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                                state.activeChatId = chatId;
                                videoCallState.activeChatId = chatId; 
                                videoCallState.isAwaitingResponse = true;
                                videoCallState.isGroupCall = chat.isGroup;
                                videoCallState.callRequester = msgData.name || chat.name;
                                showIncomingCallModal();
                            }
                            continue;
                        case 'group_call_request':
                            if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                                state.activeChatId = chatId;
                                videoCallState.isAwaitingResponse = true;
                                videoCallState.isGroupCall = true;
                                videoCallState.initiator = 'ai';
                                videoCallState.callRequester = msgData.name;
                                showIncomingCallModal();
                            }
                            continue;
                        case 'pat_user':
                            let patterName;
                            if (chat.isGroup) {
                                const member = chat.members.find(m => m.originalName === msgData.name);
                                patterName = member ? member.groupNickname : msgData.name;
                            } else {
                                patterName = chat.name;
                            }
                            const suffix = msgData.suffix ? ` ${msgData.suffix.trim()}` : '';
                            const patText = `${patterName} 拍了拍我${suffix}`;
        
                            const patMessage = { 
                                role: 'system', 
                                type: 'pat_message', 
                                content: patText, 
                                timestamp: Date.now() 
                            };
                            chat.history.push(patMessage);
                            if (isViewingThisChat) {
                                const phoneScreen = document.getElementById('phone-screen');
                                phoneScreen.classList.remove('pat-animation');
                                void phoneScreen.offsetWidth;
                                phoneScreen.classList.add('pat-animation');
                                setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);
                                appendMessage(patMessage, chat);
                            } else {
                                showNotification(chatId, patText);
                            }
                            continue; 
                        case 'update_status':
                            chat.status.text = msgData.status_text;
                            chat.status.isBusy = msgData.is_busy || false;
                            chat.status.lastUpdate = Date.now();
                            const statusUpdateMessage = {
                                role: 'system',
                                type: 'pat_message',
                                content: `[${chat.name}的状态已更新为: ${msgData.status_text}]`,
                                timestamp: Date.now()
                            };
                            chat.history.push(statusUpdateMessage);
                            if (isViewingThisChat) {
                                appendMessage(statusUpdateMessage, chat);
                            }
                            renderChatList(); 
                            continue; 
                        case 'location_share':
                            aiMessage = {
                                ...baseMessage,
                                type: 'location_share',
                                content: msgData.content
                            };
                            break;
                        case 'change_music':
                            if (musicState.isActive && musicState.activeChatId === chatId) {
                                const songNameFromAI = msgData.song_name || msgData.song || msgData.name;
        
                                if (typeof songNameFromAI === 'string' && songNameFromAI.trim()) {
                                    const songNameToFind = songNameFromAI.replace(/^\[?\d+\]?[\s.-]*/, '').trim();
                                    const targetSongIndex = musicState.playlist.findIndex(track => track.name.toLowerCase() === songNameToFind.toLowerCase());
                                    
                                    if (targetSongIndex > -1) {
                                        playSong(targetSongIndex);
                                        const track = musicState.playlist[targetSongIndex];
                                        
                                        let changerName;
                                        if (chat.isGroup) {
                                            const member = chat.members.find(m => m.originalName === msgData.name);
                                            changerName = member ? member.groupNickname : msgData.name;
                                        } else {
                                            changerName = chat.name;
                                        }
                                        
                                        const musicChangeMessage = {
                                            role: 'system',
                                            type: 'pat_message',
                                            content: `[♪ ${changerName} 为你切歌: 《${track.name}》 - ${track.artist}]`,
                                            timestamp: Date.now()
                                        };
                                        chat.history.push(musicChangeMessage);
                                        if (isViewingThisChat) {
                                            appendMessage(musicChangeMessage, chat);
                                        }
                                    } else {
                                        console.warn(`歌曲查找失败: AI请求的歌曲名"${songNameFromAI}"(处理后为"${songNameToFind}") 在播放列表中未找到。`);
                                    }
                                } else {
                                    console.error("AI返回的change_music指令中，歌曲名无效或缺失:", msgData);
                                }
                            }
                            continue;
                        case 'create_memory':
                            const newMemory = {
                                chatId: chatId,
                                authorId: chatId,
                                description: msgData.description,
                                timestamp: Date.now(),
                                type: 'ai_generated'
                            };
                            await db.memories.add(newMemory);
                            console.log(`AI "${chat.name}" 记录了一条新回忆:`, msgData.description);
                            continue; 
                        case 'create_countdown':
                            const targetDate = new Date(msgData.date);
                            if (!isNaN(targetDate) && targetDate > new Date()) {
                                const newCountdown = {
                                    chatId: chatId,
                                    authorId: chatId,
                                    description: msgData.title,
                                    timestamp: Date.now(),
                                    type: 'countdown',
                                    targetDate: targetDate.getTime()
                                };
                                await db.memories.add(newCountdown);
                                console.log(`AI "${chat.name}" 创建了一个新约定:`, msgData.title);
                            }
                            continue;
                        case 'block_user':
                            if (!chat.isGroup) {
                                chat.relationship.status = 'blocked_by_ai';
                                const hiddenMessage = {
                                    role: 'system',
                                    content: `[系统提示：你刚刚主动拉黑了用户。]`,
                                    timestamp: Date.now(),
                                    isHidden: true
                                };
                                chat.history.push(hiddenMessage);
                                await db.chats.put(chat);
                                if (isViewingThisChat) {
                                    renderChatInterface(chatId);
                                }
                                renderChatList();
                                break; 
                            }
                            continue;
                        case 'friend_request_response':
                            if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                                if (msgData.decision === 'accept') {
                                    chat.relationship.status = 'friend';
                                    aiMessage = { ...baseMessage, content: "我通过了你的好友申请，我们现在是好友啦！" };
                                } else {
                                    chat.relationship.status = 'blocked_by_ai';
                                    aiMessage = { ...baseMessage, content: "抱歉，我拒绝了你的好友申请。" };
                                }
                                chat.relationship.applicationReason = '';
                            }
                            break;
                        case 'poll':
                            const pollOptions = typeof msgData.options === 'string'
                                ? msgData.options.split('\n').filter(opt => opt.trim())
                                : (Array.isArray(msgData.options) ? msgData.options : []);
                            if (pollOptions.length < 2) continue;
                            aiMessage = {
                                ...baseMessage,
                                type: 'poll',
                                question: msgData.question,
                                options: pollOptions,
                                votes: {},
                                isClosed: false,
                            };
                            break;
                        case 'gift': {
                            const productId = parseInt(msgData.productId);
                            const quantity = parseInt(msgData.quantity) || 1;
                        
                            if (!isNaN(productId) && quantity > 0) {
                                const product = await db.shoppingProducts.get(productId);
                        
                                if (product) {
                                    aiMessage = {
                                        ...baseMessage,
                                        type: 'gift',
                                        items: [{
                                            name: product.name,
                                            price: product.price,
                                            imageUrl: product.imageUrl,
                                            quantity: quantity
                                        }],
                                        total: product.price * quantity,
                                        recipients: msgData.recipients || null 
                                    };
                                } else {
                                    console.warn(`AI 尝试赠送一个不存在的商品 (ID: ${productId})`);
                                }
                            }
                            break;
                        }
                        case 'vote':
                            const pollToVote = chat.history.find(m => m.timestamp === msgData.poll_timestamp);
                            if (pollToVote && !pollToVote.isClosed) {
                                Object.keys(pollToVote.votes).forEach(option => {
                                    const voterIndex = pollToVote.votes[option].indexOf(msgData.name);
                                    if (voterIndex > -1) {
                                        pollToVote.votes[option].splice(voterIndex, 1);
                                    }
                                });
                                if (!pollToVote.votes[msgData.choice]) {
                                    pollToVote.votes[msgData.choice] = [];
                                }
                                if (!pollToVote.votes[msgData.choice].includes(msgData.name)) {
                                    pollToVote.votes[msgData.choice].push(msgData.name);
                                }                        
                                if (isViewingThisChat) {
                                    renderChatInterface(chatId);
                                }
                            }
                            continue;
                        case 'red_packet':
                            aiMessage = {
                                ...baseMessage,
                                ...msgData,
                                totalAmount: msgData.amount, 
                                claimedBy: {}, 
                                isFullyClaimed: false
                            };
                            if (msgData.receiver) {
                                aiMessage.receiverName = msgData.receiver;
                                delete aiMessage.receiver;
                            }
                            break;
                        case 'open_red_packet':
                            const packetToOpen = chat.history.find(m => m.timestamp === msgData.packet_timestamp);
                            // ▼▼▼ 在这里添加全新的验证逻辑 ▼▼▼
const claimerOriginalName = msgData.name; // 获取尝试抢红包的角色本名
const isMember = chat.members.some(member => member.originalName === claimerOriginalName);

// 如果这个角色不是当前群的成员，就记录一个警告并直接跳过，不允许他抢
if (!isMember) {
    console.warn(`AI 角色 "${claimerOriginalName}" 尝试领取不属于自己的群聊红包。操作已被拦截。`);
    continue; // 跳过后续所有抢红包的逻辑
}
// ▲▲▲ 验证逻辑结束 ▲▲▲
                            if (packetToOpen && packetToOpen.packetType === 'direct') {
                                if (packetToOpen.receiverName !== msgData.name) {
                                    console.warn(`AI 角色 "${msgData.name}" 尝试领取不属于自己的专属红包 (接收人: ${packetToOpen.receiverName})。操作已被拦截。`);
                                    continue;
                                }
                            }
                            
                            if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[msgData.name])) {
                                let claimedAmountAI = 0;
                                const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
                                const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;
                                if (remainingCount > 0) {
                                    if (packetToOpen.packetType === 'direct') {
                                        claimedAmountAI = packetToOpen.totalAmount;
                                    } else {
                                        if (remainingCount === 1) { claimedAmountAI = remainingAmount; } 
                                        else {
                                            const min = 0.01;
                                            const max = remainingAmount - (remainingCount - 1) * min;
                                            claimedAmountAI = Math.random() * (max - min) + min;
                                        }
                                    }
        
                                    claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
                                    if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
                                    packetToOpen.claimedBy[msgData.name] = claimedAmountAI;
        
// ▼▼▼ 这是全新的、已修复的代码 ▼▼▼
const claimerMember = chat.members.find(m => m.originalName === msgData.name);
const claimerDisplayName = claimerMember ? claimerMember.groupNickname : msgData.name;

// ★★★ 核心修复：从红包对象(packetToOpen)中获取原始发件人的名字 ★★★
const senderDisplayName = getDisplayNameInGroup(chat, packetToOpen.senderName);

const aiClaimedMessage = {
    role: 'system',
    type: 'pat_message',
    content: `${claimerDisplayName} 领取了 ${senderDisplayName} 的红包`, // 现在可以正确显示 "A领取了B的红包"
    timestamp: Date.now()
};
chat.history.push(aiClaimedMessage);
// ▲▲▲ 修复代码结束 ▲▲▲
                                    let hiddenContentForAI = `[系统提示：你 (${claimerDisplayName}) 成功抢到了 ${claimedAmountAI.toFixed(2)} 元。`;
                                    if (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count) {
                                        packetToOpen.isFullyClaimed = true;
                                        const finishedMessage = {
                                            role: 'system',
                                            type: 'pat_message',
                                            content: `${senderDisplayName} 的红包已被领完`,
                                            timestamp: Date.now() + 1
                                        };
                                        chat.history.push(finishedMessage);
                                        let luckyKing = { name: '', amount: -1 };
                                        if (packetToOpen.packetType === 'lucky' && packetToOpen.count > 1) {
                                            Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                                                if (amount > luckyKing.amount) {
                                                    luckyKing = { name, amount };
                                                }
                                            });
                                        }
                                        if (luckyKing.name) {
                                             const luckyKingMember = chat.members.find(m => m.originalName === luckyKing.name);
                                             const luckyKingDisplayName = luckyKingMember ? luckyKingMember.groupNickname : luckyKing.name;
                                             hiddenContentForAI += ` 红包已被领完，手气王是 ${luckyKingDisplayName}！`;
                                        } else {
                                             hiddenContentForAI += ` 红包已被领完。`;
                                        }
                                    }
                                    hiddenContentForAI += ' 请根据这个结果发表你的评论。]';
                                    const hiddenMessageForAI = {
                                        role: 'system',
                                        content: hiddenContentForAI,
                                        timestamp: Date.now() + 2,
                                        isHidden: true
                                    };
                                    chat.history.push(hiddenMessageForAI);
                                }
                                if (isViewingThisChat) {
                                    renderChatInterface(chatId);
                                    renderChatList(); 
                                }
                            }
                            continue;
        
                        case 'accept_transfer': {
                            const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                            if (originalTransferMsgIndex > -1) {
                                const originalMsg = chat.history[originalTransferMsgIndex];
                                originalMsg.status = 'accepted';
                            }
                            continue;
                        }
        
                        case 'decline_transfer': {
                            const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                            if (originalTransferMsgIndex > -1) {
                                const originalMsg = chat.history[originalTransferMsgIndex];
                                originalMsg.status = 'declined';
                                const refundMessage = {
                                    role: 'assistant',
                                    senderName: chat.name,
                                    type: 'transfer',
                                    isRefund: true,
                                    amount: originalMsg.amount,
                                    note: '转账已被拒收',
                                    timestamp: messageTimestamp++
                                };
                                chat.history.push(refundMessage);
                                if (isViewingThisChat) {
                                    appendMessage(refundMessage, chat); 
                                    renderChatInterface(chatId); 
                                }
                            }
                            continue;
                        }
                        case 'change_group_name':
                            if (chat.isGroup && msgData.new_name) {
                                const newName = msgData.new_name.trim();
                                const memberNames = chat.members.map(m => m.originalName);
        
                                if (memberNames.includes(newName)) {
                                    console.warn(`AI (${msgData.name}) 试图将群名更改为成员名 ("${newName}")。操作已被程序阻止。`);
                                    continue; 
                                }
        
                                chat.name = newName; 
        
                                const changerMember = chat.members.find(m => m.originalName === msgData.name);
                                const changerDisplayName = changerMember ? changerMember.groupNickname : msgData.name;
                                
                                const systemMessage = {
                                    role: 'system',
                                    type: 'pat_message',
                                    content: `${changerDisplayName} 将群名修改为 “${chat.name}”`,
                                    timestamp: messageTimestamp++
                                };
                                chat.history.push(systemMessage);
        
                                if (isViewingThisChat) {
                                    appendMessage(systemMessage, chat);
                                    document.getElementById('chat-header-title').textContent = chat.name;
                                }
                            }
                            continue;
                        case 'change_remark_name':
                            if (!chat.isGroup && msgData.new_name) {
                                const oldName = chat.name; 
                                const newName = msgData.new_name.trim();
        
                                if (newName && newName !== oldName) {
                                    if (!chat.nameHistory) {
                                        chat.nameHistory = [];
                                    }
                                    if (!chat.nameHistory.includes(oldName)) {
                                        chat.nameHistory.push(oldName);
                                    }
                                    
                                    chat.name = newName; 
        
                                    const systemMessage = {
                                        role: 'system',
                                        type: 'pat_message', 
                                        content: `“${chat.originalName}” 将备注修改为 “${newName}”`,
                                        timestamp: messageTimestamp++
                                    };
                                    chat.history.push(systemMessage);
        
                                    const hiddenMemoryMessage = {
                                        role: 'system',
                                        content: `[系统提示：你刚刚成功将自己的备注名修改为了“${newName}”。请自然地接受这个新名字，不要对此感到惊讶。]`,
                                        timestamp: messageTimestamp++, 
                                        isHidden: true
                                    };
                                    chat.history.push(hiddenMemoryMessage);
        
                                    if (isViewingThisChat) {
                                        appendMessage(systemMessage, chat);
                                        document.getElementById('chat-header-title').textContent = newName;
                                    }
                                    
                                    await syncCharacterNameInGroups(chat); 
                                }
                            }
                            continue;
        
                        case 'change_group_avatar':
                            if (chat.isGroup && msgData.avatar_name) {
                                const avatarName = msgData.avatar_name;
                                const library = chat.settings.groupAvatarLibrary || [];
                                const foundAvatar = library.find(avatar => avatar.name === avatarName);
        
                                if (foundAvatar) {
                                    chat.settings.groupAvatar = foundAvatar.url;
                                    
                                    const changerMember = chat.members.find(m => m.originalName === msgData.name);
                                    const changerDisplayName = changerMember ? changerMember.groupNickname : msgData.name;
        
                                    const systemMessage = {
                                        role: 'system',
                                        type: 'pat_message',
                                        content: `${changerDisplayName} 更换了群头像`,
                                        timestamp: messageTimestamp++
                                    };
                                    chat.history.push(systemMessage);
        
                                    if (isViewingThisChat) {
                                        appendMessage(systemMessage, chat);
                                    }
                                } else {
                                    console.warn(`AI 尝试使用一个不存在的群头像: "${avatarName}"`);
                                }
                            }
                            continue;
                        case 'system_message':
                            aiMessage = { role: 'system', type: 'pat_message', content: msgData.content, timestamp: Date.now() };
                            break;
                        case 'share_link':
                            aiMessage = { 
                                ...baseMessage, 
                                type: 'share_link',
                                title: msgData.title,
                                description: msgData.description,
                                source_name: msgData.source_name,
                                content: msgData.content
                            };
                            break;
                        case 'quote_reply':
                            const originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
                            if (originalMessage) {
                                const quoteContext = {
                                    timestamp: originalMessage.timestamp,
                                    senderName: originalMessage.senderName || (originalMessage.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
                                    content: String(originalMessage.content || '').substring(0, 50),
                                };
                                aiMessage = { 
                                    ...baseMessage, 
                                    content: msgData.reply_content,
                                    quote: quoteContext
                                };
                            } else {
                                aiMessage = { ...baseMessage, content: msgData.reply_content };
                            }
                            break;
                        case 'send_and_recall': {
                            if (!isViewingThisChat) continue;
                            const tempMessageData = { ...baseMessage, content: msgData.content };
                            const tempMessageElement = createMessageElement(tempMessageData, chat);
                            appendMessage(tempMessageData, chat, true);
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 1500));
                            const bubbleWrapper = document.querySelector(`.message-bubble[data-timestamp="${tempMessageData.timestamp}"]`)?.closest('.message-wrapper');
                            if (bubbleWrapper) {
                                bubbleWrapper.classList.add('recalled-animation');
                                await new Promise(resolve => setTimeout(resolve, 300));
                                const recalledMessage = {
                                    role: 'assistant',
                                    senderName: msgData.name || chat.name,
                                    type: 'recalled_message',
                                    content: '对方撤回了一条消息',
                                    timestamp: tempMessageData.timestamp,
                                    recalledData: { originalType: 'text', originalContent: msgData.content }
                                };
                                const msgIndex = chat.history.findIndex(m => m.timestamp === tempMessageData.timestamp);
                                if (msgIndex > -1) {
                                    chat.history[msgIndex] = recalledMessage;
                                } else {
                                    chat.history.push(recalledMessage);
                                }
                                const placeholder = await createMessageElement(recalledMessage, chat);
                                if(document.body.contains(bubbleWrapper)) {
                                    bubbleWrapper.parentNode.replaceChild(placeholder, bubbleWrapper);
                                }
                            }
                            continue;
                        }
                        
                        case 'text':
                            aiMessage = { ...baseMessage, content: String(msgData.content || msgData.message) };
                            break;
                        case 'sticker':
                            aiMessage = { ...baseMessage, type: 'sticker', content: msgData.url, meaning: msgData.meaning || '' };
                            break;
                        case 'ai_image':
                            aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description, image_prompt: msgData.image_prompt };
                            break;
                        case 'voice_message':
                            aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                            break;
                        case 'transfer':
                            aiMessage = { ...baseMessage, type: 'transfer', amount: msgData.amount, note: msgData.note, receiverName: msgData.receiver || '我' };
                            break;
                        
                        case 'waimai_request':
                            aiMessage = { 
                                ...baseMessage, 
                                type: 'waimai_request',
                                productInfo: msgData.productInfo,
                                amount: msgData.amount,
                                status: 'pending',
                                countdownEndTime: Date.now() + 15 * 60 * 1000,
                            };
                            break;
                case 'waimai_order':
                    aiMessage = {
                        ...baseMessage,
                        type: 'waimai_order',
                        productInfo: msgData.productInfo,
                        amount: msgData.amount,
                        greeting: msgData.greeting,
                        recipientName: msgData.recipientName || null // 如果是群聊，记录接收者
                    };
                    break;
                        case 'offline_text':
        aiMessage = { ...baseMessage, ...msgData };
                        default:
                             console.warn("收到了未知的AI指令类型:", msgData.type);
                             break;
                    }
        
                    if (aiMessage) {
                        chat.history.push(aiMessage);
                        if (!isViewingThisChat && !notificationShown) {
                            let notificationText;
                            switch (aiMessage.type) {
                                case 'transfer': notificationText = `[收到一笔转账]`; break;
                                case 'waimai_request': notificationText = `[收到一个外卖代付请求]`; break;
                                case 'ai_image': notificationText = `[图片]`; break;
                                case 'voice_message': notificationText = `[语音]`; break;
                                case 'sticker': notificationText = aiMessage.meaning ? `[表情: ${aiMessage.meaning}]` : '[表情]'; break;
                                case 'offline_text': notificationText = aiMessage.dialogue ? `「${aiMessage.dialogue}」` : `[${aiMessage.description.substring(0, 20)}...]`; break;
                                default: notificationText = String(aiMessage.content || '');
                            }
                            const finalNotifText = chat.isGroup ? `${aiMessage.senderName}: ${notificationText}` : notificationText;
                            showNotification(chatId, finalNotifText.substring(0, 40) + (finalNotifText.length > 40 ? '...' : ''));
                            notificationShown = true;
                        }
        
                        if (!isViewingThisChat) {
                            chat.unreadCount = (chat.unreadCount || 0) + 1;
                        }
                        
                        if (isViewingThisChat) {
                            appendMessage(aiMessage, chat);
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 1800 + 1000));
                        }
                    }
                }        
        
                if (callHasBeenHandled && videoCallState.isGroupCall) {
                    videoCallState.isAwaitingResponse = false;
                    if (videoCallState.participants.length > 0) {
                        startVideoCall();
                    } else {
                        videoCallState = { ...videoCallState, isAwaitingResponse: false, participants: [] };
                        showScreen('chat-interface-screen');
                        alert('无人接听群聊邀请。');
                    }
                }
                if (needsImmediateReaction) {
                    await triggerAiResponse();
                    return; 
                }
                await db.chats.put(chat);
        // 检查刚刚AI执行的动作中，是否包含了任何与“动态”相关的操作
const qzoneActionTaken = messagesArray.some(action =>
    action.type === 'qzone_post' ||
    action.type === 'qzone_like' ||
    action.type === 'qzone_comment' ||
    action.type === 'repost'
);

// 如果AI确实执行了动态相关的操作
if (qzoneActionTaken) {
    console.log("检测到AI执行了动态操作，立即刷新好友动态页面。");
    // 主动调用渲染函数，强制刷新页面内容
    await renderQzonePosts();
}

// ▲▲▲ 新增代码粘贴结束 ▲▲▲
            } catch (error) {
                
                chat.history = chat.history.filter(msg => !msg.isTemporary);
                
                if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                    chat.relationship.status = 'blocked_by_ai';
                    await showCustomAlert('申请失败', `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
                } else {
                    await showCustomAlert(
                        'API 调用失败', 
                        `发生了一个错误，AI未能成功响应。\n\n错误详情:\n${error.message}`
                    );
                }
                
                if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
                     await db.chats.put(chat);        
                }
               
                videoCallState.isAwaitingResponse = false;
            } finally {
                setAvatarActingState(chatId, false);
        
               
                if (chat.isGroup) {
                    if (typingIndicator) {
                        typingIndicator.style.display = 'none';
                    }
                } else {
                    if (chatHeaderTitle && state.chats[chatId]) {
                        chatHeaderTitle.style.opacity = 0;
                        setTimeout(() => {
                            chatHeaderTitle.textContent = state.chats[chatId].name;
                            chatHeaderTitle.classList.remove('typing-status');
                            chatHeaderTitle.style.opacity = 1;
                        }, 200);
                    }
                }
                renderChatList();
                if (isViewingThisChat) {
                    checkAndTriggerAutoSummary(chatId);
                 
                }
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        
        
        
        
        
        
                async function sendSticker(sticker) { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: sticker.url, meaning: sticker.name, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('sticker-panel').classList.remove('visible'); }
        
                async function sendUserTransfer() { if (!state.activeChatId) return; const amountInput = document.getElementById('transfer-amount'); const noteInput = document.getElementById('transfer-note'); const amount = parseFloat(amountInput.value); const note = noteInput.value.trim(); if (isNaN(amount) || amount < 0 || amount > 999999) { alert('请输入有效的金额 (0 到 999999 之间)！'); return; } const chat = state.chats[state.activeChatId]; const senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我'; const receiverName = chat.isGroup ? '群聊' : chat.name; const msg = { role: 'user', type: 'transfer', amount: amount, note: note, senderName, receiverName, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('transfer-modal').classList.remove('visible'); amountInput.value = ''; noteInput.value = ''; }

/**
 * 【全新 V2.0 | AI认知修复版】处理用户点击“为TA点外卖”的逻辑
 */
async function sendWaimaiOrderForAI() {
    if (!state.activeChatId) return;
    
    const productInfoInput = document.getElementById('waimai-product-info');
    const amountInput = document.getElementById('waimai-amount');
    
    const productInfo = productInfoInput.value.trim();
    const amount = parseFloat(amountInput.value);

    if (!productInfo || isNaN(amount) || amount <= 0) {
        alert('请填写有效的商品信息和金额！');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const now = Date.now();
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

    // 1. 创建对用户可见的“已下单”卡片消息（这部分保持不变）
    const visibleMessage = {
        role: 'user',
        senderName: myNickname, 
        type: 'waimai_order',
        productInfo: productInfo,
        amount: amount,
        timestamp: now
    };
    chat.history.push(visibleMessage);

    // 2. 【核心修改1】创建一条对用户隐藏的、语义更清晰的系统消息，明确告知AI这是一个“礼物”
    const hiddenMessage = {
        role: 'system',
        content: `[系统提示：用户(${myNickname})为你点了一份外卖作为【礼物】。外卖内容是“${productInfo}”，价值${amount}元。这不是一个代付请求，而是用户已经为你支付了。请你对此表示感谢。]`,
        timestamp: now + 1,
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    // 3. 保存数据，更新UI
    await db.chats.put(chat);
    appendMessage(visibleMessage, chat);
    renderChatList();

    // 4. 清理并关闭弹窗
    productInfoInput.value = '';
    amountInput.value = '';
    document.getElementById('waimai-request-modal').classList.remove('visible');

    // 5. 【核心修改2】移除此处的 triggerAiResponse() 调用，不再立刻通知AI
    // triggerAiResponse(); // <--- 确保这一行已被删除或注释掉！
}
        /**
         * 【全新 V3.0】发送一个位置共享卡片 (背景图已内置)
         */
        async function sendLocationShare() {
            if (!state.activeChatId) return;
        
            // 步骤1: 询问位置名称 (这部分保持不变)
            const locationName = await showCustomPrompt("共享位置", "你现在在哪里呀？", "");
        
            // 如果用户取消或没有输入位置，则直接退出
            if (!locationName || !locationName.trim()) return; 
        
            // 步骤2: 【核心修改】在这里直接定义好您想用的图片URL
            // 您可以随时将这个链接替换为您喜欢的任何图片地址
            const hardcodedImageUrl = 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756262526935_qdqqd_4uque3.jpeg';
        
            const chat = state.chats[state.activeChatId];
            
            // 步骤3: 构建消息对象，直接使用我们定义好的图片URL
            const msg = {
                role: 'user',
                type: 'location_share',
                content: locationName.trim(),
                imageUrl: hardcodedImageUrl, // 直接使用上面定义的URL
                timestamp: Date.now()
            };
            
            // 步骤4: 保存并更新UI (这部分保持不变)
            chat.history.push(msg);
            await db.chats.put(chat);
            appendMessage(msg, chat);
            renderChatList();
        }
        
        
                function enterSelectionMode(initialMsgTimestamp) { if (isSelectionMode) return; isSelectionMode = true; document.getElementById('chat-interface-screen').classList.add('selection-mode'); toggleMessageSelection(initialMsgTimestamp); }
        
                function exitSelectionMode() {
            cleanupWaimaiTimers(); // <--- 在这里添加这行代码
         if (!isSelectionMode) return; isSelectionMode = false; document.getElementById('chat-interface-screen').classList.remove('selection-mode'); selectedMessages.forEach(ts => { const bubble = document.querySelector(`.message-bubble[data-timestamp="${ts}"]`); if (bubble) bubble.classList.remove('selected'); }); selectedMessages.clear(); }
        
        // ▼▼▼ 请用这个【最终简化版】替换旧的 toggleMessageSelection 函数 ▼▼▼
        function toggleMessageSelection(timestamp) {
            // 【核心修正】选择器已简化，不再寻找已删除的 .recalled-message-placeholder
            const elementToSelect = document.querySelector(
                `.message-bubble[data-timestamp="${timestamp}"]`
            );
        
            if (!elementToSelect) return;
        
            if (selectedMessages.has(timestamp)) {
                selectedMessages.delete(timestamp);
                elementToSelect.classList.remove('selected');
            } else {
                selectedMessages.add(timestamp);
                elementToSelect.classList.add('selected');
            }
            
            document.getElementById('selection-count').textContent = `已选 ${selectedMessages.size} 条`;
            
            if (selectedMessages.size === 0) {
                exitSelectionMode();
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
                function addLongPressListener(element, callback) { let pressTimer; const startPress = (e) => { if(isSelectionMode) return; e.preventDefault(); pressTimer = window.setTimeout(() => callback(e), 500); }; const cancelPress = () => clearTimeout(pressTimer); element.addEventListener('mousedown', startPress); element.addEventListener('mouseup', cancelPress); element.addEventListener('mouseleave', cancelPress); element.addEventListener('touchstart', startPress, { passive: true }); element.addEventListener('touchend', cancelPress); element.addEventListener('touchmove', cancelPress); }
        
                async function handleListenTogetherClick() { const targetChatId = state.activeChatId; if (!targetChatId) return; if (!musicState.isActive) { startListenTogetherSession(targetChatId); return; } if (musicState.activeChatId === targetChatId) { document.getElementById('music-player-overlay').classList.add('visible'); } else { const oldChatName = state.chats[musicState.activeChatId]?.name || '未知'; const newChatName = state.chats[targetChatId]?.name || '当前'; const confirmed = await showCustomConfirm('切换听歌对象', `您正和「${oldChatName}」听歌。要结束并开始和「${newChatName}」的新会话吗？`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await endListenTogetherSession(true); await new Promise(resolve => setTimeout(resolve, 50)); startListenTogetherSession(targetChatId); } } }

async function startListenTogetherSession(chatId) { const chat = state.chats[chatId]; if (!chat) return; musicState.totalElapsedTime = chat.musicData.totalTime || 0; musicState.isActive = true; musicState.activeChatId = chatId; if (musicState.playlist.length > 0) { musicState.currentIndex = 0; } else { musicState.currentIndex = -1; } if(musicState.timerId) clearInterval(musicState.timerId); musicState.timerId = setInterval(() => { if (musicState.isPlaying) { musicState.totalElapsedTime++; updateElapsedTimeDisplay(); } }, 1000); updatePlayerUI(); updatePlaylistUI(); document.getElementById('music-player-overlay').classList.add('visible'); }

async function endListenTogetherSession(saveState = true) {
    if (!musicState.isActive) return;
    const oldChatId = musicState.activeChatId;
    document.getElementById('global-lyrics-bar').classList.remove('visible');
    const cleanupLogic = async () => {
        if (musicState.timerId) clearInterval(musicState.timerId);
        if (musicState.isPlaying) audioPlayer.pause();
        if (saveState && oldChatId && state.chats[oldChatId]) {
            const chat = state.chats[oldChatId];
            chat.musicData.totalTime = musicState.totalElapsedTime;
            await db.chats.put(chat);
        }
        musicState.isActive = false;
        musicState.activeChatId = null;
        musicState.totalElapsedTime = 0;
        musicState.timerId = null;
        updateListenTogetherIcon(oldChatId, true);
    };
    closeMusicPlayerWithAnimation(cleanupLogic);
}

function returnToChat() {
    closeMusicPlayerWithAnimation();
}

function updateListenTogetherIcon(chatId, forceReset = false) { const iconImg = document.querySelector('#listen-together-btn img'); if(!iconImg) return; if(forceReset || !musicState.isActive || musicState.activeChatId !== chatId) { iconImg.src = 'https://i.postimg.cc/8kYShvrJ/90-UI-2.png'; iconImg.className = ''; return; } iconImg.src = 'https://i.postimg.cc/D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png'; iconImg.classList.add('rotating'); if (musicState.isPlaying) iconImg.classList.remove('paused'); else iconImg.classList.add('paused'); }
window.updateListenTogetherIconProxy = updateListenTogetherIcon;

function updatePlayerUI() { 
    updateListenTogetherIcon(musicState.activeChatId); 
    updateElapsedTimeDisplay(); 
    const titleEl = document.getElementById('music-player-song-title'); 
    const artistEl = document.getElementById('music-player-artist'); 
    const playPauseBtn = document.getElementById('music-play-pause-btn'); 
    if (musicState.currentIndex > -1 && musicState.playlist.length > 0) { 
        const track = musicState.playlist[musicState.currentIndex]; 
        titleEl.textContent = track.name; 
        artistEl.textContent = track.artist; 
    } else { 
        titleEl.textContent = '请添加歌曲'; 
        artistEl.textContent = '...'; 
    } 
    playPauseBtn.textContent = musicState.isPlaying ? '❚❚' : '▶'; 
}

function updateElapsedTimeDisplay() { const hours = (musicState.totalElapsedTime / 3600).toFixed(1); document.getElementById('music-time-counter').textContent = `已经一起听了${hours}小时`; }

function updatePlaylistUI() {
    const playlistBody = document.getElementById('playlist-body');
    playlistBody.innerHTML = '';
    if (musicState.playlist.length === 0) {
        playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">播放列表是空的~</p>';
        return;
    }
    musicState.playlist.forEach((track, index) => {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        if(index === musicState.currentIndex) item.classList.add('playing');

        // ▼▼▼ 核心修改就在这里 ▼▼▼
item.innerHTML = `
    <div class="playlist-item-info">
        <div class="title">${track.name}</div>
        <div class="artist">${track.artist}</div>
    </div>
    <div class="playlist-item-actions">
        <span class="playlist-action-btn album-art-btn" data-index="${index}">专辑</span>
        <span class="playlist-action-btn lyrics-btn" data-index="${index}">词</span>
        <!-- 【核心新增】在这里添加“背景”按钮 -->
        <span class="playlist-action-btn bg-btn" data-index="${index}">背景</span>
        <span class="playlist-action-btn delete-track-btn" data-index="${index}">×</span>
    </div>
`;
        // ▲▲▲ 修改结束 ▲▲▲

        item.querySelector('.playlist-item-info').addEventListener('click', () => playSong(index));
        playlistBody.appendChild(item);
    });
}



async function togglePlayPause() {
    if (audioPlayer.paused) {
        if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
            playSong(0);
        } 
        else if (musicState.currentIndex > -1) {
            playSong(musicState.currentIndex);
        }
    } else {
        audioPlayer.pause();
        await addMusicActionSystemMessage('暂停了音乐');
    }
}

function playNext() { if (musicState.playlist.length === 0) return; let nextIndex; switch(musicState.playMode) { case 'random': nextIndex = Math.floor(Math.random() * musicState.playlist.length); break; case 'single': playSong(musicState.currentIndex); return; case 'order': default: nextIndex = (musicState.currentIndex + 1) % musicState.playlist.length; break; } playSong(nextIndex); }

function playPrev() { if (musicState.playlist.length === 0) return; const newIndex = (musicState.currentIndex - 1 + musicState.playlist.length) % musicState.playlist.length; playSong(newIndex); }

function changePlayMode() { const modes = ['order', 'random', 'single']; const currentModeIndex = modes.indexOf(musicState.playMode); musicState.playMode = modes[(currentModeIndex + 1) % modes.length]; document.getElementById('music-mode-btn').textContent = {'order': '顺序', 'random': '随机', 'single': '单曲'}[musicState.playMode]; }

async function addSongFromURL() { const url = await showCustomPrompt("添加网络歌曲", "请输入歌曲的URL", "", "url"); if (!url) return; const name = await showCustomPrompt("歌曲信息", "请输入歌名"); if (!name) return; const artist = await showCustomPrompt("歌曲信息", "请输入歌手名"); if (!artist) return; musicState.playlist.push({ name, artist, src: url, isLocal: false }); await saveGlobalPlaylist(); updatePlaylistUI(); if(musicState.currentIndex === -1) { musicState.currentIndex = musicState.playlist.length - 1; updatePlayerUI(); } }
 
// ▼▼▼ 【请用这个已修复的版本】完整替换旧的 addSongFromLocal 函数 ▼▼▼
async function addSongFromLocal(event) {
    const files = event.target.files;
    if (!files.length) return;

    for (const file of files) {
        let name = file.name.replace(/\.[^/.]+$/, "");
        name = await showCustomPrompt("歌曲信息", "请输入歌名", name);
        if (name === null) continue;
        
        const artist = await showCustomPrompt("歌曲信息", "请输入歌手名", "未知歌手");
        if (artist === null) continue;

        // 【核心修复1】读取文件为 ArrayBuffer，这是最可靠的存储方式
        const arrayBuffer = await file.arrayBuffer();

        let lrcContent = "";
        const wantLrc = await showCustomConfirm("导入歌词", `要为《${name}》添加歌词吗？`);
        if (wantLrc) {
            lrcContent = await getLrcContent() || "";
        }
        
        musicState.playlist.push({ 
            name, 
            artist, 
            src: arrayBuffer,           // 【核心修复2】存储 ArrayBuffer 而不是 File 对象
            fileType: file.type,        // 【核心修复3】同时存储文件的MIME类型
            isLocal: true,
            lrcContent: lrcContent,
            cover: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg'
        });
    }
    
    await saveGlobalPlaylist();
    updatePlaylistUI();
    if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
        musicState.currentIndex = 0;
        updatePlayerUI();
    }
    event.target.value = null;
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【请用这个已修复的版本】完整替换旧的 playSong 函数 ▼▼▼
// ▼▼▼ 【请用这个已支持头像显示并修复渲染问题的全新版本】替换旧的 playSong 函数 ▼▼▼
async function playSong(index) {
    if (index < 0 || index >= musicState.playlist.length) return;

    audioPlayer.pause();

    musicState.currentIndex = index;
    const track = musicState.playlist[index];
    const chat = state.chats[musicState.activeChatId]; // 获取当前聊天对象

    // --- ▼▼▼ 核心修复：加载并填充头像 (使用更可靠的DOM操作) ▼▼▼ ---
    const avatarDisplay = document.getElementById('music-player-avatar-display');
    if (chat && avatarDisplay) {
        // 1. 清空旧内容
        avatarDisplay.innerHTML = '';

        // 2. 根据聊天类型获取正确的头像URL
        const charAvatarUrl = chat.isGroup 
            ? (chat.members.find(m => m.originalName === track.artist)?.avatar || defaultAvatar) 
            : (chat.settings.aiAvatar || defaultAvatar);
        const userAvatarUrl = chat.settings.myAvatar || defaultAvatar;

        // 3. 创建角色头像元素并添加
        const charAvatarEl = document.createElement('img');
        charAvatarEl.src = charAvatarUrl;
        charAvatarEl.className = 'participant-display-avatar';
        charAvatarEl.alt = 'Character Avatar';
        avatarDisplay.appendChild(charAvatarEl);

        // 4. 创建用户头像元素并添加
        const userAvatarEl = document.createElement('img');
        userAvatarEl.src = userAvatarUrl;
        userAvatarEl.className = 'participant-display-avatar';
        userAvatarEl.alt = 'User Avatar';
        avatarDisplay.appendChild(userAvatarEl);
    }
    // --- ▲▲▲ 修复结束 ▲▲▲ ---

    const playerWindow = document.querySelector('.music-player-window');
    const toggleBtn = document.getElementById('toggle-blur-btn');

    if (playerWindow) {
        playerWindow.style.setProperty('--music-bg-image', track.background ? `url(${track.background})` : 'none');
        playerWindow.classList.toggle('bg-clear', !!track.isBgClear);
    }
    if (toggleBtn) {
        toggleBtn.classList.toggle('active', !!track.isBgClear);
    }
    
    // (后续的所有播放逻辑保持不变)
    document.getElementById('music-visual-container').classList.remove('lyrics-active');
    const coverEl = document.getElementById('music-player-cover');
    if (coverEl) {
        coverEl.src = track.cover || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg';
    }
    
    await addMusicActionSystemMessage(`将歌曲切换为了《${track.name}》`);
    musicState.parsedLyrics = parseLRC(track.lrcContent || "");
    
    renderLyrics(); 
    const singleLyricEl = document.getElementById('single-lyric-display');
    if (singleLyricEl) {
        if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
            singleLyricEl.textContent = '纯音乐，请欣赏';
        } else {
            singleLyricEl.textContent = '♪ ♪ ♪'; 
        }
    }
    
    if (track.isLocal && track.src instanceof ArrayBuffer) {
        const blob = new Blob([track.src], { type: track.fileType || 'audio/mpeg' });
        audioPlayer.src = URL.createObjectURL(blob);
    } 
    else if (track.isLocal && track.src instanceof Blob) {
        audioPlayer.src = URL.createObjectURL(track.src);
    } else if (!track.isLocal) {
        audioPlayer.src = track.src;
    } else {
        console.error('本地歌曲源错误:', track);
        return;
    }
    
    const playPromise = audioPlayer.play();
    if (playPromise !== undefined) {
        playPromise.catch(error => {
            if (error.name === 'NotAllowedError') {
                console.warn('Autoplay was prevented by the browser.');
                audioPlayer.pause();
                showCustomAlert("播放已暂停", "由于浏览器安全限制，AI切换的歌曲无法自动播放。请手动点击播放按钮 ▶ 继续欣赏。");
            } else if (error.name !== 'AbortError') {
                console.error('Playback error:', error);
            }
        });
    }
    updatePlaylistUI();
    updatePlayerUI();
    updateMusicProgressBar();
    
    const lyricBar = document.getElementById('global-lyrics-bar');
    if (musicState.parsedLyrics && musicState.parsedLyrics.length > 0) {
        lyricBar.textContent = '♪';
        lyricBar.classList.add('visible');
    } else {
        lyricBar.classList.remove('visible');
    }
}
// ▲▲▲ 替换结束 ▲▲▲
/**
 * 处理更换指定歌曲背景图片的逻辑
 * @param {number} trackIndex - 播放列表中歌曲的索引
 */
async function handleChangeBackground(trackIndex) {
    if (trackIndex < 0 || trackIndex >= musicState.playlist.length) return;

    // 1. 弹出选项，让用户选择上传方式
    const choice = await showChoiceModal("更换歌曲背景", [
        { text: '📁 从本地上传', value: 'local' },
        { text: '🌐 使用网络URL', value: 'url' }
    ]);

    let newBackgroundUrl = null;

    // 2. 根据选择获取图片
    if (choice === 'local') {
        newBackgroundUrl = await uploadImageLocally();
    } else if (choice === 'url') {
        newBackgroundUrl = await showCustomPrompt("输入图片URL", "请输入新的背景图片链接", "", "url");
    }

    // 3. 如果成功获取到图片，则更新并保存
    if (newBackgroundUrl && newBackgroundUrl.trim()) {
        musicState.playlist[trackIndex].background = newBackgroundUrl.trim();
        await saveGlobalPlaylist();
        
        // 4. 如果正在播放的就是这首歌，则立即应用新背景
        if (musicState.currentIndex === trackIndex) {
            const playerWindow = document.querySelector('.music-player-window');
            playerWindow.style.setProperty('--music-bg-image', `url(${newBackgroundUrl.trim()})`);
        }

        await showCustomAlert("成功", "歌曲背景已更新！");
    }
}
/**
 * 【全新】处理更换专辑封面的逻辑
 * @param {number} trackIndex - 播放列表中歌曲的索引
 */
async function handleChangeAlbumArt(trackIndex) {
    if (trackIndex < 0 || trackIndex >= musicState.playlist.length) return;

    const choice = await showChoiceModal("更换专辑封面", [
        { text: '📁 从本地上传', value: 'local' },
        { text: '🌐 使用网络URL', value: 'url' }
    ]);

    let newCoverUrl = null;

    if (choice === 'local') {
        newCoverUrl = await uploadImageLocally();
    } else if (choice === 'url') {
        newCoverUrl = await showCustomPrompt("输入图片URL", "请输入新的封面图片链接", "", "url");
    }

    if (newCoverUrl && newCoverUrl.trim()) {
        musicState.playlist[trackIndex].cover = newCoverUrl.trim();
        await saveGlobalPlaylist();
        
        // 如果正在播放的歌曲就是被修改的这首，立即更新播放器UI
        if (musicState.currentIndex === trackIndex) {
            document.getElementById('music-player-cover').src = newCoverUrl.trim();
            // 同时更新黑胶唱片中心的图片
            const vinylCover = document.querySelector('#vinyl-view #music-player-cover');
            if(vinylCover) vinylCover.src = newCoverUrl.trim();
        }

        await showCustomAlert("成功", "专辑封面已更新！");
    }
}

async function deleteTrack(index) { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); await saveGlobalPlaylist(); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); updatePlaylistUI(); }
        
        // ▼▼▼ 请用这个【新版本】的函数，完整替换旧的 addSongFromLocal 函数 ▼▼▼
        
        async function addSongFromLocal(event) {
            const files = event.target.files;
            if (!files.length) return;
        
            for (const file of files) {
                let name = file.name.replace(/\.[^/.]+$/, "");
                name = await showCustomPrompt("歌曲信息", "请输入歌名", name);
                if (name === null) continue;
                
                const artist = await showCustomPrompt("歌曲信息", "请输入歌手名", "未知歌手");
                if (artist === null) continue;
        
                let lrcContent = "";
                const wantLrc = await showCustomConfirm("导入歌词", `要为《${name}》添加歌词吗？`);
                if (wantLrc) {
                    // 【核心修改】直接调用我们新的统一函数！
                    lrcContent = await getLrcContent() || ""; // 如果用户取消，则lrcContent为""
                }
                
                musicState.playlist.push({ 
                    name, 
                    artist, 
                    src: file, 
                    isLocal: true,
                    lrcContent: lrcContent
                });
            }
            
            await saveGlobalPlaylist();
            updatePlaylistUI();
            if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
                musicState.currentIndex = 0;
                updatePlayerUI();
            }
            event.target.value = null;
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
                async function deleteTrack(index) { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); await saveGlobalPlaylist(); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); updatePlaylistUI(); }
        
                const personaLibraryModal = document.getElementById('persona-library-modal');
                const personaEditorModal = document.getElementById('persona-editor-modal');
                const presetActionsModal = document.getElementById('preset-actions-modal');
        
                function openPersonaLibrary() { renderPersonaLibrary(); personaLibraryModal.classList.add('visible'); }
        
                function closePersonaLibrary() { personaLibraryModal.classList.remove('visible'); }
        
                function renderPersonaLibrary() { const grid = document.getElementById('persona-library-grid'); grid.innerHTML = ''; if (state.personaPresets.length === 0) { grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">空空如也~ 点击右上角"添加"来创建你的第一个人设预设吧！</p>'; return; } state.personaPresets.forEach(preset => { const item = document.createElement('div'); item.className = 'persona-preset-item'; item.style.backgroundImage = `url(${preset.avatar})`; item.dataset.presetId = preset.id; item.addEventListener('click', () => applyPersonaPreset(preset.id)); addLongPressListener(item, () => showPresetActions(preset.id)); grid.appendChild(item); }); }
        
                function showPresetActions(presetId) { editingPersonaPresetId = presetId; presetActionsModal.classList.add('visible'); }
        
                function hidePresetActions() { presetActionsModal.classList.remove('visible'); editingPersonaPresetId = null; }
        
                function applyPersonaPreset(presetId) { const preset = state.personaPresets.find(p => p.id === presetId); if (preset) { document.getElementById('my-avatar-preview').src = preset.avatar; document.getElementById('my-persona').value = preset.persona; } closePersonaLibrary(); }
        
                function openPersonaEditorForCreate() { editingPersonaPresetId = null; document.getElementById('persona-editor-title').textContent = '添加人设预设'; document.getElementById('preset-avatar-preview').src = defaultAvatar; document.getElementById('preset-persona-input').value = ''; personaEditorModal.classList.add('visible'); }
        
                function openPersonaEditorForEdit() { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (!preset) return; document.getElementById('persona-editor-title').textContent = '编辑人设预设'; document.getElementById('preset-avatar-preview').src = preset.avatar; document.getElementById('preset-persona-input').value = preset.persona; presetActionsModal.classList.remove('visible'); personaEditorModal.classList.add('visible'); }
        
                async function deletePersonaPreset() { const confirmed = await showCustomConfirm('删除预设', '确定要删除这个人设预设吗？此操作不可恢复。', { confirmButtonClass: 'btn-danger' }); if (confirmed && editingPersonaPresetId) { await db.personaPresets.delete(editingPersonaPresetId); state.personaPresets = state.personaPresets.filter(p => p.id !== editingPersonaPresetId); hidePresetActions(); renderPersonaLibrary(); } }
        
                function closePersonaEditor() { personaEditorModal.classList.remove('visible'); editingPersonaPresetId = null; }
        
                async function savePersonaPreset() { const avatar = document.getElementById('preset-avatar-preview').src; const persona = document.getElementById('preset-persona-input').value.trim(); if (avatar === defaultAvatar && !persona) { alert("头像和人设不能都为空哦！"); return; } if (editingPersonaPresetId) { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (preset) { preset.avatar = avatar; preset.persona = persona; await db.personaPresets.put(preset); } } else { const newPreset = { id: 'preset_' + Date.now(), avatar: avatar, persona: persona }; await db.personaPresets.add(newPreset); state.personaPresets.push(newPreset); } renderPersonaLibrary(); closePersonaEditor(); }
        
                const batteryAlertModal = document.getElementById('battery-alert-modal');
        
                function showBatteryAlert(imageUrl, text) { clearTimeout(batteryAlertTimeout); document.getElementById('battery-alert-image').src = imageUrl; document.getElementById('battery-alert-text').textContent = text; batteryAlertModal.classList.add('visible'); const closeAlert = () => { batteryAlertModal.classList.remove('visible'); batteryAlertModal.removeEventListener('click', closeAlert); }; batteryAlertModal.addEventListener('click', closeAlert); batteryAlertTimeout = setTimeout(closeAlert, 2000); }
        
                function updateBatteryDisplay(battery) { const batteryContainer = document.getElementById('status-bar-battery'); const batteryLevelEl = batteryContainer.querySelector('.battery-level'); const batteryTextEl = batteryContainer.querySelector('.battery-text'); const level = Math.floor(battery.level * 100); batteryLevelEl.style.width = `${level}%`; batteryTextEl.textContent = `${level}%`; if (battery.charging) { batteryContainer.classList.add('charging'); } else { batteryContainer.classList.remove('charging'); } }
        
                function handleBatteryChange(battery) { updateBatteryDisplay(battery); const level = battery.level; if (!battery.charging) { if (level <= 0.4 && lastKnownBatteryLevel > 0.4 && !alertFlags.hasShown40) { showBatteryAlert('https://i.postimg.cc/T2yKJ0DV/40.jpg', '有点饿了，可以去找充电器惹'); alertFlags.hasShown40 = true; } if (level <= 0.2 && lastKnownBatteryLevel > 0.2 && !alertFlags.hasShown20) { showBatteryAlert('https://i.postimg.cc/qB9zbKs9/20.jpg', '赶紧的充电，要饿死了'); alertFlags.hasShown20 = true; } if (level <= 0.1 && lastKnownBatteryLevel > 0.1 && !alertFlags.hasShown10) { showBatteryAlert('https://i.postimg.cc/ThMMVfW4/10.jpg', '已阵亡，还有30秒爆炸'); alertFlags.hasShown10 = true; } } if (level > 0.4) alertFlags.hasShown40 = false; if (level > 0.2) alertFlags.hasShown20 = false; if (level > 0.1) alertFlags.hasShown10 = false; lastKnownBatteryLevel = level; }
        
                async function initBatteryManager() { if ('getBattery' in navigator) { try { const battery = await navigator.getBattery(); lastKnownBatteryLevel = battery.level; handleBatteryChange(battery); battery.addEventListener('levelchange', () => handleBatteryChange(battery)); battery.addEventListener('chargingchange', () => { handleBatteryChange(battery); if (battery.charging) { showBatteryAlert('https://i.postimg.cc/3NDQ0dWG/image.jpg', '窝爱泥，电量吃饱饱'); } }); } catch (err) { console.error("无法获取电池信息:", err); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } } else { console.log("浏览器不支持电池状态API。"); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } }
        
                async function renderAlbumList() {
                    const albumGrid = document.getElementById('album-grid-page');
                    if (!albumGrid) return;
                    const albums = await db.qzoneAlbums.orderBy('createdAt').reverse().toArray();
                    albumGrid.innerHTML = '';
                    if (albums.length === 0) {
                        albumGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">你还没有创建任何相册哦~</p>';
                        return;
                    }
                    albums.forEach(album => {
                        const albumItem = document.createElement('div');
                        albumItem.className = 'album-item';
                        albumItem.innerHTML = `
                            <div class="album-cover" style="background-image: url(${album.coverUrl});"></div>
                            <div class="album-info">
                                <p class="album-name">${album.name}</p>
                                <p class="album-count">${album.photoCount || 0} 张</p>
                            </div>
                        `;
                        albumItem.addEventListener('click', () => {
                            openAlbum(album.id);
                        });
        
                        // ▼▼▼ 新增的核心代码就是这里 ▼▼▼
                        addLongPressListener(albumItem, async () => {
                            const confirmed = await showCustomConfirm(
                                '删除相册',
                                `确定要删除相册《${album.name}》吗？此操作将同时删除相册内的所有照片，且无法恢复。`,
                                { confirmButtonClass: 'btn-danger' }
                            );
        
                            if (confirmed) {
                                // 1. 从照片表中删除该相册下的所有照片
                                await db.qzonePhotos.where('albumId').equals(album.id).delete();
                                
                                // 2. 从相册表中删除该相册本身
                                await db.qzoneAlbums.delete(album.id);
                                
                                // 3. 重新渲染相册列表
                                await renderAlbumList();
                                
                                alert('相册已成功删除。');
                            }
                        });
                        // ▲▲▲ 新增代码结束 ▲▲▲
        
                        albumGrid.appendChild(albumItem);
                    });
                }
        
                async function openAlbum(albumId) {
                    state.activeAlbumId = albumId;
                    await renderAlbumPhotosScreen();
                    showScreen('album-photos-screen');
                }
        
                async function renderAlbumPhotosScreen() {
                    if (!state.activeAlbumId) return;
                    const photosGrid = document.getElementById('photos-grid-page');
                    const headerTitle = document.getElementById('album-photos-title');
                    const album = await db.qzoneAlbums.get(state.activeAlbumId);
                    if (!album) {
                        console.error("找不到相册:", state.activeAlbumId);
                        showScreen('album-screen');
                        return;
                    }
                    headerTitle.textContent = album.name;
                    const photos = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
                    photosGrid.innerHTML = '';
                    if (photos.length === 0) {
                        photosGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">这个相册还是空的，快上传第一张照片吧！</p>';
                    } else {
                        photos.forEach(photo => {
                            const photoItem = document.createElement('div');
                            photoItem.className = 'photo-item';
                            photoItem.innerHTML = `
                                <img src="${photo.url}" class="photo-thumb" alt="相册照片">
                                <button class="photo-delete-btn" data-photo-id="${photo.id}">×</button>
                            `;
                            photosGrid.appendChild(photoItem);
                        });
                    }
                }
        
        // --- ↓↓↓ 从这里开始复制 ↓↓↓ ---
        
        /**
         * 打开图片查看器
         * @param {string} clickedPhotoUrl - 用户点击的那张照片的URL
         */
        async function openPhotoViewer(clickedPhotoUrl) {
            if (!state.activeAlbumId) return;
        
            // 1. 从数据库获取当前相册的所有照片
            const photosInAlbum = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
            photoViewerState.photos = photosInAlbum.map(p => p.url);
        
            // 2. 找到被点击照片的索引
            photoViewerState.currentIndex = photoViewerState.photos.findIndex(url => url === clickedPhotoUrl);
            if (photoViewerState.currentIndex === -1) return; // 如果找不到，则不打开
        
            // 3. 显示模态框并渲染第一张图
            document.getElementById('photo-viewer-modal').classList.add('visible');
            renderPhotoViewer();
            photoViewerState.isOpen = true;
        }
        
        /**
         * 根据当前状态渲染查看器内容（图片和按钮）
         */
        function renderPhotoViewer() {
            if (photoViewerState.currentIndex === -1) return;
        
            const imageEl = document.getElementById('photo-viewer-image');
            const prevBtn = document.getElementById('photo-viewer-prev-btn');
            const nextBtn = document.getElementById('photo-viewer-next-btn');
            
            // 淡出效果
            imageEl.style.opacity = 0;
        
            setTimeout(() => {
                // 更新图片源
                imageEl.src = photoViewerState.photos[photoViewerState.currentIndex];
                // 淡入效果
                imageEl.style.opacity = 1;
            }, 100); // 延迟一点点时间来触发CSS过渡
        
            // 更新按钮状态：如果是第一张，禁用“上一张”按钮
            prevBtn.disabled = photoViewerState.currentIndex === 0;
            // 如果是最后一张，禁用“下一张”按钮
            nextBtn.disabled = photoViewerState.currentIndex === photoViewerState.photos.length - 1;
        }
        
        /**
         * 显示下一张照片
         */
        function showNextPhoto() {
            if (photoViewerState.currentIndex < photoViewerState.photos.length - 1) {
                photoViewerState.currentIndex++;
                renderPhotoViewer();
            }
        }
        
        /**
         * 显示上一张照片
         */
        function showPrevPhoto() {
            if (photoViewerState.currentIndex > 0) {
                photoViewerState.currentIndex--;
                renderPhotoViewer();
            }
        }
        
        /**
         * 关闭图片查看器
         */
        function closePhotoViewer() {
            document.getElementById('photo-viewer-modal').classList.remove('visible');
            photoViewerState.isOpen = false;
            photoViewerState.photos = [];
            photoViewerState.currentIndex = -1;
            // 清空图片，避免下次打开时闪现旧图
            document.getElementById('photo-viewer-image').src = '';
        }
        
        // --- ↑↑↑ 复制到这里结束 ↑↑↑ ---
                // ▼▼▼ 请将这个新函数粘贴到你的JS功能函数定义区 ▼▼▼
                
                /**
                 * 更新动态小红点的显示
                 * @param {number} count - 未读动态的数量
                 */
                function updateUnreadIndicator(count) {
                    unreadPostsCount = count;
                    localStorage.setItem('unreadPostsCount', count); // 持久化存储
        
                    // --- 更新底部导航栏的“动态”按钮 ---
                    const navItem = document.querySelector('.nav-item[data-view="qzone-screen"]');
                    
                    const targetSpan = navItem.querySelector('span'); // 定位到文字 "动态"
                    let indicator = navItem.querySelector('.unread-indicator');           
        
                    if (count > 0) {
                        if (!indicator) {
                            indicator = document.createElement('span');
                            indicator.className = 'unread-indicator';
                                                                   targetSpan.style.position = 'relative'; // 把相对定位加在 span 上
                            targetSpan.appendChild(indicator); // 把小红点作为 span 的子元素
                            
                        }
                        indicator.textContent = count > 99 ? '99+' : count;
                        indicator.style.display = 'block';
                    } else {
                        if (indicator) {
                            indicator.style.display = 'none';
                        }
                    }
        
                    // --- 更新聊天界面返回列表的按钮 ---
                    const backBtn = document.getElementById('back-to-list-btn');
                    let backBtnIndicator = backBtn.querySelector('.unread-indicator');
        
                    if (count > 0) {
                        if (!backBtnIndicator) {
                            backBtnIndicator = document.createElement('span');
                            backBtnIndicator.className = 'unread-indicator back-btn-indicator';
                            backBtn.style.position = 'relative'; // 确保能正确定位
                            backBtn.appendChild(backBtnIndicator);
                        }
                        // 返回键上的小红点通常不显示数字，只显示一个点
                        backBtnIndicator.style.display = 'block';
                    } else {
                        if (backBtnIndicator) {
                            backBtnIndicator.style.display = 'none';
                        }
                    }
                }
                
                // ▲▲▲ 新函数粘贴结束 ▲▲▲
        
        // ▼▼▼ 将这两个新函数粘贴到你的JS功能函数定义区 ▼▼▼
        function startBackgroundSimulation() {
            if (simulationIntervalId) return;
            const intervalSeconds = state.globalSettings.backgroundActivityInterval || 60;
            // 将旧的固定间隔 45000 替换为动态获取
            simulationIntervalId = setInterval(runBackgroundSimulationTick, intervalSeconds * 1000); 
    playSilentAudio();
        }
        
        function stopBackgroundSimulation() {
            if (simulationIntervalId) {
                clearInterval(simulationIntervalId);
                simulationIntervalId = null;
            }
    stopSilentAudio();
        }
        // ▲▲▲ 粘贴结束 ▲▲▲
        
// ▼▼▼ 【最终修复版】请用这个全新的函数，完整替换旧的 runBackgroundSimulationTick ▼▼▼
/**
 * 这是模拟器的“心跳”，每次定时器触发时运行
 */
async function runBackgroundSimulationTick() { 
    console.log("模拟器心跳 Tick...");
    if (!state.globalSettings.enableBackgroundActivity) {
        stopBackgroundSimulation();
        return;
    }

    // --- 1. 处理所有单聊 ---
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    allSingleChats.forEach(chat => {
        // 处理【被用户拉黑】的角色
        if (chat.relationship?.status === 'blocked_by_user') {
            const blockedTimestamp = chat.relationship.blockedTimestamp;
            if (!blockedTimestamp) return;
            const blockedDuration = Date.now() - blockedTimestamp;
            const cooldownMilliseconds = (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;
            if (blockedDuration > cooldownMilliseconds) {
                chat.relationship.status = 'pending_system_reflection';
                triggerAiFriendApplication(chat.id);
            }
        }
        // 处理【好友关系】的正常后台活动
        else if (chat.relationship?.status === 'friend' && chat.id !== state.activeChatId) {
            
            // ★★★★★ 这就是本次修改的核心 ★★★★★
            // 在执行任何操作前，先检查这个角色的独立开关是否开启
            if (chat.settings.enableBackgroundActivity === false) {
                // 如果开关是关闭的，就打印一条日志并直接跳过这个角色
                console.log(`角色 "${chat.name}" 的独立后台活动开关已关闭，本次跳过。`);
                return; // 使用 return 跳出 forEach 的本次循环
            }
            // ★★★★★ 修改结束 ★★★★★

            // (后续的随机触发逻辑保持不变)
            if (Math.random() < 0.20) { 
                console.log(`角色 "${chat.name}" 被唤醒，准备独立行动...`);
                triggerInactiveAiAction(chat.id);
            }
        }
    });

    // --- 2. 处理所有群聊 (逻辑保持不变) ---
    const allGroupChats = Object.values(state.chats).filter(chat => chat.isGroup);
    allGroupChats.forEach(chat => {
    // 【核心新增】在所有判断之前，首先检查这个群聊的独立开关
    if (chat.settings.enableBackgroundActivity === false) {
        // 如果开关是关闭的，就打印一条日志并直接跳过这个群聊
        console.log(`群聊 "${chat.name}" 的后台活动开关已关闭，本次跳过。`);
        return; // 使用 return 跳出 forEach 的本次循环
    }

        if (chat.id !== state.activeChatId && Math.random() < 0.10) { 
            console.log(`群聊 "${chat.name}" 被唤醒，准备独立行动...`);
            triggerGroupAiAction(chat.id); 
        }
    });
    // --- 3. 【【【核心新增：处理所有NPC的评论行为】】】 ---
    try {
        const allNpcs = await db.npcs.toArray();
        if (allNpcs.length === 0) return;

        const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(10).toArray();
        if (allRecentPosts.length === 0) return;

        for (const npc of allNpcs) {
                    // 1. 【新增】检查该NPC的后台活动开关是否开启
                    if (npc.enableBackgroundActivity === false) {
                        continue; // 如果关闭，则直接跳过这个NPC
                    }

                    // 2. 【新增】检查该NPC的独立行动冷却时间
                    const cooldownMinutes = npc.actionCooldownMinutes || 15; // 默认15分钟
                    if (npc.lastActionTimestamp) {
                        const minutesSinceLastAction = (Date.now() - npc.lastActionTimestamp) / (1000 * 60);
                        if (minutesSinceLastAction < cooldownMinutes) {
                            console.log(`NPC "${npc.name}" 处于行动冷却中，本次跳过。`);
                            continue; // 如果还在冷却期，跳过这个NPC
                        }
                    }
            // 为每个NPC设置一个独立的行动概率
            if (Math.random() > 0.3) { // 30%的概率行动
                continue;
            }

            // 筛选出与该NPC相关的、且NPC还未“说最后一句话”的帖子作为任务
            const tasks = allRecentPosts.filter(post => {
                const isAssociated = npc.associatedWith.includes(post.authorId);
                const isRepliedTo = post.comments?.some(c => c.replyTo === npc.name);
                const lastCommenter = post.comments?.slice(-1)[0]?.commenterName;

                return (isAssociated || isRepliedTo) && lastCommenter !== npc.name;
            });
            
            if (tasks.length > 0) {
                console.log(`NPC "${npc.name}" 发现 ${tasks.length} 个可互动项，正在请求AI行动...`);
                const generatedComments = await generateNpcComments(npc, tasks);

                if (generatedComments && generatedComments.length > 0) {
                    for (const comment of generatedComments) {
                        const post = await db.qzonePosts.get(comment.postId);
                        if (post) {
                            if (!post.comments) post.comments = [];
                            post.comments.push({
                                commenterName: npc.name,
                                text: comment.commentText,
                                replyTo: comment.replyTo || null,
                                timestamp: Date.now() + Math.random()
                            });
                            await db.qzonePosts.update(comment.postId, { comments: post.comments });
                        }
                    }
                            // 3. 【新增】行动成功后，更新该NPC的“最后行动时间戳”
                            await db.npcs.update(npc.id, { lastActionTimestamp: Date.now() });
                    console.log(`NPC "${npc.name}" 成功发布了 ${generatedComments.length} 条评论。`);
                    updateUnreadIndicator(unreadPostsCount + generatedComments.length);                    
                    // 如果用户当前正在查看动态页，则刷新UI
                    if (document.getElementById('qzone-screen').classList.contains('active')) {
                        await renderQzonePosts();
                    }
                }
            }
        }
    } catch (error) {
        console.error("处理NPC后台评论时出错:", error);
    }
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【最终修复版】请用这个全新的函数，完整替换旧的 generateNpcComments 函数 ▼▼▼

/**
 * 【全新 | 已注入角色上下文】调用AI为NPC批量生成评论
 * @param {object} npc - NPC对象 { name, persona, ... }
 * @param {Array<object>} tasks - 待处理的帖子对象数组
 * @returns {Promise<Array|null>} - 返回AI生成的评论对象数组，或在失败时返回null
 */
async function generateNpcComments(npc, tasks) {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        console.error("NPC行动失败：API未配置。");
        return null;
    }

    // --- 核心修复 1: 在这里构建完整的角色上下文 ---
    let charactersContext = "# 你的互动对象 (用户和其他角色)\n";
    
    // a. 获取用户的信息
    const userNickname = state.qzoneSettings.nickname || '我';
    const userPersona = state.chats[Object.keys(state.chats)[0]]?.settings.myPersona || '(未设置)';
    charactersContext += `- **${userNickname} (用户)**: ${userPersona}\n`;

    // b. 获取所有与此NPC关联的主要AI角色的信息
    if (npc.associatedWith && npc.associatedWith.length > 0) {
        npc.associatedWith.forEach(charId => {
            const char = state.chats[charId];
            if (char && !char.isGroup) {
                charactersContext += `- **${char.name} (本名: ${char.originalName})**: ${char.settings.aiPersona}\n`;
            }
        });
    }
    // --- 修复结束 ---


    // (将帖子格式化的逻辑保持不变)
    const tasksString = tasks.map(post => {
        const authorDisplayName = getDisplayNameByOriginalName(post.authorOriginalName || post.authorId);
        const commentsString = (post.comments || [])
            .map(c => {
                 if (typeof c === 'object' && c.commenterName) {
                    const commenterDisplayName = getDisplayNameByOriginalName(c.commenterName);
                    return `- **${commenterDisplayName}**: ${c.text}`;
                }
                return `- ${c}`; // 兼容旧格式
            }).join('\n');

        return `
---
### 帖子ID: ${post.id}
- **作者**: ${authorDisplayName}
- **内容摘要**: ${(post.content || post.publicText || '').substring(0, 150)}...
- **已有评论**:
${commentsString || '(暂无评论)'}
---
`;
    }).join('\n');

    // --- 核心修复 2: 将我们刚刚构建的 charactersContext 注入到系统指令中 ---
    const systemPrompt = `
# 你的任务
你是一个虚拟社区的AI评论员。你的核心任务是扮演角色“${npc.name}”，并根据其人设，为你下面提供的【每一篇】帖子撰写评论或回复。你的目标是让社区互动看起来更真实、更活跃。

# 核心规则
1.  **【角色扮演】**: 你的每一条评论都【必须】严格符合你的角色设定。
2.  **【互动逻辑 (最重要!)】**:
    -   仔细阅读每篇帖子的“已有评论”。如果有人回复了你或提到了你，你【必须】优先回复他们。
    -   如果帖子很有趣但没人与你互动，你可以发表一条全新的评论。
3.  **【格式铁律 (最高优先级)】**: 
    -   你的回复【必须且只能】是一个JSON数组格式的字符串。
    -   数组中的每个元素都代表一条评论，格式【必须】是以下两种之一：
      -   **发表新评论**: \`{"postId": 帖子ID, "commentText": "你的新评论内容。"}\`
      -   **回复他人评论**: \`{"postId": 帖子ID, "replyTo": "被回复者的【本名】", "commentText": "你的回复内容。"}\`
4.  **【数量铁律 (最高优先级!)】**: 你本次任务【必须】生成【总共2到5条】评论。你可以自由分配这些评论到不同的帖子上。
# 你的角色设定
- **昵称**: ${npc.name}
- **人设**: ${npc.persona}

${charactersContext} 

# 待处理的帖子列表
${tasksString}

现在，请严格遵守所有规则，开始为这些帖子撰写评论。
`;
    // --- 修复结束 ---

    try {
        // (后续的API调用逻辑保持不变)
        const messagesForApi = [{ role: 'user', content: "请根据你的设定，为以上帖子生成评论。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                })
            });
            
        if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch) throw new Error("AI返回的评论中未找到有效的JSON数组。");
        
        return JSON.parse(jsonMatch[0]);

    } catch (error) {
        console.error(`为NPC "${npc.name}" 生成评论失败:`, error);
        return null;
    }
}    
        // ▼▼▼ 【最终修复版】请用这个全新的函数，完整替换旧的 triggerInactiveAiAction ▼▼▼
        /**
         * 【V3.0 | 记忆增强版】AI在非活跃状态下的独立行动决策
         */
        async function triggerInactiveAiAction(chatId) {
            const chat = state.chats[chatId];
            if (!chat) return;
        
            // 【【【核心修改1：从聊天设置中读取冷却时间】】】
            const actionCooldownMinutes = chat.settings.actionCooldownMinutes || 10; 
        
            if (chat.lastActionTimestamp) {
                const minutesSinceLastAction = (Date.now() - chat.lastActionTimestamp) / (1000 * 60);
                // 【【【核心修改2：使用新的变量进行判断】】】
                if (minutesSinceLastAction < actionCooldownMinutes) {
                    console.log(`角色 "${chat.name}" 处于行动冷却中 (还剩 ${Math.round(actionCooldownMinutes - minutesSinceLastAction)} 分钟)，本次独立行动跳过。`);
                    return;
                }
            }
            setAvatarActingState(chatId, true);
        
            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) return;
        
            const userNickname = state.qzoneSettings.nickname;
            const now = new Date();
    // ▼▼▼ 核心修复：在这里也使用您选择的时区 ▼▼▼
    const selectedTimeZone = chat.settings.timeZone || 'Asia/Shanghai';
    const currentTime = now.toLocaleString('zh-CN', { timeZone: selectedTimeZone, dateStyle: 'full', timeStyle: 'short' });
    const localizedDate = new Date(now.toLocaleString('en-US', { timeZone: selectedTimeZone }));
    // ▲▲▲ 修复结束 ▲▲▲
// ▼▼▼ 核心修复就在这里！▼▼▼
// 1. 在 if 代码块外部提前声明变量，并给定一个默认值
let timeOfDayGreeting = ''; 
let timeContextText = '';
let recentContextSummary; 
let longTimeNoSee = false;


    // ==========================================================
    //            ★★★ 核心修复从这里开始 ★★★
    // ==========================================================

    // 步骤 1: (保持不变) 我们依然需要获取最近的10条消息，用于后续的API请求
    const maxMemory = chat.settings.maxMemory || 10; // 读取角色的设置
    const recentHistory = chat.history.filter(m => !m.isHidden).slice(-maxMemory);
        
            const lastMessage = chat.history.filter(m => !m.isHidden).slice(-1)[0];
            
if (chat.settings.enableTimePerception) {
    timeOfDayGreeting = getTimeOfDayGreeting(localizedDate); // 现在这里只是赋值，而不是声明
    const lastMessage = chat.history.filter(m => !m.isHidden).slice(-1)[0];
    const now = new Date();
    let timeContextText = '';
    let longTimeNoSee = false;

    if (lastMessage) {
        const lastTime = new Date(lastMessage.timestamp);
        const timeDiffHours = (now - lastTime) / (1000 * 60 * 60);

        if (timeDiffHours > 12) {
            longTimeNoSee = true;
            const diffDays = Math.floor(timeDiffHours / 24);
            timeContextText = `你们已经有${diffDays > 0 ? diffDays + '天' : Math.floor(timeDiffHours) + '小时'}没有聊天了。`;
        } else {
            const diffMinutes = Math.floor(timeDiffHours * 60);
            if (diffMinutes < 5) {
                timeContextText = "你们的对话刚刚还在继续。";
            } else if (diffMinutes < 60) {
                timeContextText = `你们在${diffMinutes}分钟前聊过。`;
            } else {
                timeContextText = `你们在${Math.floor(timeDiffHours)}小时前聊过。`;
            }
        }
    } else {
        longTimeNoSee = true;
        timeContextText = "这是你们的第一次互动。";
    }

    // 核心修改：将强制指令改为情景提示，并始终包含对话历史
    let historySummary = "你们最近没有有效聊天记录。";
    if (recentHistory.length > 0) {
        historySummary = "这是你们最近的对话：\n" + recentHistory.map(msg => {
            const sender = msg.role === 'user' ? userNickname : chat.name;
            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
        }).join('\n');
    }

    if (longTimeNoSee) {
         // ▼▼▼ 核心修复：在这里使用新的 currentTime 变量 ▼▼▼
         recentContextSummary = `[情景提示] ${timeContextText} 当前时间是 ${currentTime}. 你可以参考这个时间，并根据你的角色设定，【考虑】是否开启一个新话题来问候用户。\n${historySummary}`;
    } else {
        recentContextSummary = `${historySummary}`;
    }

} else {
    // 无时间开关时的逻辑保持不变
    if (recentHistory.length > 0) {
        recentContextSummary = "这是你们最近的对话：\n" + recentHistory.map(msg => {
            const sender = msg.role === 'user' ? userNickname : chat.name;
            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
        }).join('\n');
    } else {
        recentContextSummary = "你们最近没有有效聊天记录。";
    }
}
            
            const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
            const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);
            
            const myOwnPosts = visiblePosts.filter(post => post.authorId === chatId);
            let myPostsContext = "";
            if (myOwnPosts.length > 0) {
                myPostsContext = "\n\n# 你的动态历史 (你可以选择删除它们):\n";
                myOwnPosts.forEach(post => {
                    let contentSummary = (post.publicText || post.content || "一条动态").substring(0, 40) + '...';
                    myPostsContext += `- (ID: ${post.id}) 内容: "${contentSummary}"\n`;
                });
            }
        
            let recentlyPostedSummaries = [];
            if (visiblePosts.length > 0) {
                recentlyPostedSummaries = visiblePosts.map(post => {
                    let contentSummary;
                    if (post.type === 'text_image') {
                        contentSummary = `[一张图片，其隐藏文字为：“${post.hiddenContent}”] ${post.publicText || ''}`.substring(0, 50) + '...';
                    } else if (post.type === 'image_post') {
                        contentSummary = `[一张图片，描述为：“${post.imageDescription}”] ${post.publicText || ''}`.substring(0, 50) + '...';
                    } else {
                        contentSummary = (post.publicText || post.content || "一条动态").substring(0, 50) + '...';
                    }
                    return `- "${contentSummary}"`;
                });
            }
        
            let contentTabooPrompt = '';
            if (recentlyPostedSummaries.length > 0) {
                contentTabooPrompt = `
        # 【内容禁忌】
        为了保持新鲜感，你本次的行动【绝对不能】再发布以下或类似主题的内容：
        ${recentlyPostedSummaries.join('\n')}
        `;
            }
        
        // ▼▼▼ 在 triggerAiFriendApplication 函数中，用下面这整块代码替换旧的世界书处理逻辑 ▼▼▼
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                if (!worldBook || !Array.isArray(worldBook.content)) return '';

                // 【核心修改】在 map 之前，先用 filter 过滤掉被禁用的条目
                const formattedEntries = worldBook.content
                    .filter(entry => entry.enabled !== false)
                    .map(entry => {
                        // (这里的逻辑保持不变)
                        let entryString = `\n### 条目: ${entry.comment || '无备注'}\n`;
                        if (entry.keys.length > 0) {
                            entryString += `**关键词:** ${entry.keys.join(', ')}\n`;
                        }
                        entryString += `**内容:**\n${entry.content}`;
                        return entryString;
                    }).join('');

                return formattedEntries ? `\n\n## 世界书: ${worldBook.name}\n${formattedEntries}` : '';
            }).filter(Boolean).join('');
            
            if (linkedContents) {
                worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)\n${linkedContents}\n`;
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲
            
            let linkedMemoryContext = '';
            const memoryCount = chat.settings.linkedMemoryCount || 10;
            if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
                const linkedChatsWithTimestamps = chat.settings.linkedMemoryChatIds.map(id => {
                    const linkedChat = state.chats[id];
                    if (!linkedChat) return null;
                    const lastMsg = linkedChat.history.slice(-1)[0];
                    return {
                        chat: linkedChat,
                        latestTimestamp: lastMsg ? lastMsg.timestamp : 0
                    };
                }).filter(Boolean); 
        
                linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
        
                linkedMemoryContext += `\n\n# 参考记忆 (至关重要！你必须【主动】将这些参考记忆中的【关键信息和事件】，自然地融入到当前的对话中，以体现你拥有完整的记忆。不要只是被动等待用户提问！)\n`;
        
                for (const item of linkedChatsWithTimestamps) {
                    const linkedChat = item.chat;
                    const prefix = linkedChat.isGroup ? '[群聊]' : '[私聊]';
                    const timeAgo = item.latestTimestamp > 0 ? ` (最后互动于 ${formatTimeAgo(item.latestTimestamp)})` : '';
                    linkedMemoryContext += `\n## --- 来自${prefix}“${linkedChat.name}”的参考记忆${timeAgo} ---\n`;
        
                    const recentHistory = linkedChat.history.slice(-memoryCount);
                    const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('已被用户删除'));
        
                    if (filteredHistory.length > 0) {
                        filteredHistory.forEach(msg => {
                            const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || '我') : (msg.senderName || linkedChat.name);
                            let contentText = String(msg.content);
                            if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                                contentText = `[发送了一张图片，描述为：${msg.content}]`;
                            } else if (msg.type === 'voice_message') {
                                contentText = `[发送了一条语音，内容是：${msg.content}]`;
                            }
                            linkedMemoryContext += `${sender}: ${contentText}\n`;
                        });
                    } else {
                        linkedMemoryContext += "(暂无有效聊天记录)\n";
                    }
                }
            }
        
            // ★★★★★★★★★★★★★★★★★★★
            //  这就是本次修复的核心所在！
            // ★★★★★★★★★★★★★★★★★★★
            let dynamicContext = "";
            if (visiblePosts.length > 0) {
                let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
                for (const post of visiblePosts) {
                    let authorName = post.authorId === 'user' ? userNickname : (state.chats[post.authorId]?.name || '一位朋友');
                    if (post.authorId === chatId) authorName += " (这是你的帖子)";
        
                    let contentSummary;
                    // ... (这部分内容摘要的逻辑不变) ...
                    if (post.type === 'repost') {
                        const repostComment = post.repostComment ? `并评论说：“${post.repostComment}”` : '';
                        let originalAuthorName = '原作者';
                        const originalAuthorId = post.originalPost.authorId;
                        if (originalAuthorId === 'user') {
                            originalAuthorName = state.qzoneSettings.nickname;
                        } else if (state.chats[originalAuthorId]) {
                            originalAuthorName = state.chats[originalAuthorId].name;
                        }
                        let originalContentSummary;
                        const originalPost = post.originalPost;
                        if (originalPost.type === 'text_image') {
                            originalContentSummary = `[文字图] ${originalPost.publicText || ''} (图片描述: “${(originalPost.hiddenContent || '').substring(0, 40)}...”)`;
                        } else if (originalPost.type === 'image_post') {
                            originalContentSummary = `[图片] ${originalPost.publicText || ''} (图片描述: “${(originalPost.imageDescription || '').substring(0, 40)}...”)`;
                        } else { // 'shuoshuo'
                            originalContentSummary = `“${(originalPost.content || '').substring(0, 40)}...”`;
                        }
                        contentSummary = `转发了 @${originalAuthorName} 的动态 ${repostComment}【原动态内容: ${originalContentSummary}】`;
                    } else if (post.type === 'text_image') {
                        contentSummary = `[一张图片，其隐藏文字为：“${post.hiddenContent}”] ${post.publicText || ''}`.substring(0, 50) + '...';
                    } else if (post.type === 'image_post') {
                        contentSummary = `[一张图片，描述为：“${post.imageDescription}”] ${post.publicText || ''}`.substring(0, 50) + '...';
                    } else {
                        contentSummary = (post.publicText || post.content || "一条动态").substring(0, 50) + '...';
                    }
        
                    postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentSummary}"\n`;
        
                    // 【【【核心修复逻辑】】】
                    if (post.comments && post.comments.length > 0) {
                        for (const comment of post.comments) {
                            if (typeof comment === 'object' && comment.commenterName) {
                                const commenterDisplayName = getDisplayNameByOriginalName(comment.commenterName);
                                let commentText = comment.meaning ? `[表情: '${comment.meaning}']` : comment.text;
                                
                                // 在这里，我们判断评论者是不是AI自己
                                if (comment.commenterName === chat.originalName) {
                                    // 如果是AI自己，就明确告诉它：“你评论说：...”
                                    postsContext += `  - 你评论说: ${commentText}\n`;
                                } else {
                                    // 如果是别人，就正常显示
                                    postsContext += `  - 评论: ${commenterDisplayName} (本名: ${comment.commenterName}): ${commentText}\n`;
                                }
                            }
                        }
                    }
                     // 【【【修复结束】】】
                }
                dynamicContext = postsContext;
            }
        
    // ▼▼▼ 核心修改：在这里构建长期记忆上下文 ▼▼▼
    const longTermMemoryContext = `# 长期记忆 (最高优先级，这是你和用户之间已经确立的事实，必须严格遵守)
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (暂无)'}`;
    // ▲▲▲ 修改结束 ▲▲▲  

const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
            const systemPrompt = `
        # 你的任务
        你现在扮演一个名为"${chat.name}"的角色（你的本名是"${chat.originalName}"）。你已经有一段时间没有和用户（${userNickname}）互动了，现在你有机会【主动】做点什么，来表现你的个性和独立生活。这是一个秘密的、后台的独立行动。


     
        # 【最高优先级指令：情感维系】
        **你与用户的关系是最重要的！** 相比于在动态区闲逛，你应该【优先考虑】是否需要主动给用户发消息来维系你们的感情。
${chat.settings.enableTimePerception ? `
# 【情景感知】
- **时间**: 感知到当前是${currentTime} (${timeOfDayGreeting})}。
- **对话状态**: ${timeContextText}
${longTimeNoSee ? `【重要提示】你们已经很久没聊天了！你【必须】将本次行动的重点放在使用 'text' 指令给用户发消息，主动开启一个新的、有趣的话题来重新建立联系。绝对不要只是点赞或评论动态，那会显得你很冷漠！` : ''}` : ''}
        
        # 【对话节奏铁律 (至关重要！)】
        你的回复【必须】模拟真人的打字和思考习惯。**绝对不要一次性发送一大段文字！** 你应该将你想说的话，拆分成【多条、简短的】消息气泡来发送，每条消息最好不要超过30个字。这会让对话看起来更自然、更真实。
        
        # 核心规则
        1.  **【决策依据】**: 你的所有行动都【必须深度结合你的角色设定、核心世界观、以及你们最后的对话摘要】。
        2.  **【内容多样性铁律】**: 你的行动【必须】具有逻辑和多样性。你【绝对不能】发布与下方“内容禁忌”列表或“最近的动态列表”中内容相似或主题重复的动态。
        3.  **【行为多样性指南 (至关重要)】**:
            - 你的上一次独立行动是：**${chat.lastActionType || '无'}**。
            - 为了让你的行为看起来更真实，你本次的行动【必须】选择一个与上次【不同类型】的指令。例如，如果上次是发动态(qzone_post)，这次就应该优先考虑评论(qzone_comment)、点赞(qzone_like)或发消息(text)。
        4.  **【行为组合指南 (最高级技巧)】**:
            -   你可以在一次行动中执行【多个不同类型的指令】，同时可以搭配【更新状态】来展现自己，让你的行为更丰富、更主动。
            -   你可以根据你的性格，决定在发动态后是否要私信提醒用户。例如，一个外向、渴望关注的角色可能会这么做，而一个内向、安静的角色则可能更喜欢默默分享，等待用户自己发现。
        # 【社交义务铁律 】
        1.  **【至关重要】**: 当你发现“最近的动态列表”中，有你【感兴趣且还未互动过】的动态时，你**应该优先考虑**使用 'qzone_comment' 或 'qzone_like' 指令去进行互动，这比你自己发一条新动态更符合社交礼仪。
        2.  特别是当一条动态【没有任何评论】时，你的评论会是第一个，这会让作者感到开心。
        3.  **【回复铁律 (终极版)】**:
            -   当你决定回复动态中的某条评论时，你【必须】使用“方式4 (回复评论)”的指令格式。你【必须】正确填写 'replyTo' 字段为被回复者的“本名”。
            -   **即使你之前已经评论过某条动态，但如果现在看到了【新的、你感兴趣的】评论，你【也应该】主动去回复他们，以保持对话的持续性！**
        
        6.  你的回复【必须】是一个JSON数组，必须包含多个行动对象。
        
        # 【表情评论指南 】
        你现在拥有了评论表情的能力，你应该更频繁地使用它！这能让你的角色更加生动、富有个性。
        -   **表达情绪时**: 当你感到开心、惊讶、疑惑或有趣时，优先考虑使用表情评论。
        -   **混合使用**: 不要总是只发文字。尝试将你的评论行为混合起来，大约有 30-40% 的评论应该是表情。
        -   **无话可说时**: 如果你觉得一条动态很有趣但又不知道该说什么文字，发送一个相关的表情是最好的互动方式。
        -   **删除动态**: 如果你觉得你之前发的某条动态不妥或过时了，你可以选择删除它。
        
        # 你的可选行动指令
        -   **发消息+更新状态**: '[{"type": "update_status", "status_text": "正在做的事", "is_busy": true}, {"type": "text", "content": "你想对用户说的话..."}]'
        -   **发说说 (原创内容)**: '[{"type": "qzone_post", "postType": "shuoshuo", "content": "动态的文字内容..."}]'
        -   **【重要：转发动态】**: **严禁**自己拼接"//转发"文字！你【必须】使用此专用指令来转发：'[{"type": "repost", "postId": (要转发的动态ID), "comment": "你的转发评论..."}]'
        
-   **发布文字图**: '[{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)动态的公开文字", "hiddenContent": "对于图片的具体【中文】描述...", "image_prompt": "图片的【英文】关键词, 用%20分隔, 风格为风景/动漫/插画/二次元等, 禁止真人"}]'
        -   **【评论动态的四种方式】**:
            -   **方式1 (单条文字)**: '[{"type": "qzone_comment", "name": "角色本名", "postId": 123, "commentText": "这太有趣了！"}]'
            -   **方式2 (多条文字)**: '[{"type": "qzone_comment", "name": "角色本名", "postId": 123, "comments": ["哇！", "这是什么？", "看起来好棒！"]}]'
            -   **方式3 (表情)**: '[{"type": "qzone_comment", "name": "角色本名", "postId": 456, "stickerUrl": "https://...表情URL...", "stickerMeaning": "这个表情的意思，比如'开心'"}]'
            -   **方式4 (回复评论)**: '[{"type": "qzone_comment", "name": "角色本名", "postId": 123, "replyTo": "被回复者的本名", "commentText": "你的回复内容。请注意：在commentText中如果要@对方，你【必须】使用@[[被回复者的本名]]这种特殊格式，程序会自动将其替换为正确的昵称。"}]'
        -   **点赞**: '[{"type": "qzone_like", "postId": 456}]'
        -   **打视频**: '[{"type": "video_call_request"}]'
        -   **更换头像**: '{"type": "change_avatar", "name": "头像名"}' (头像名必须从下面的“可用头像列表”中选择)
        -   **删除动态**: '{"type": "qzone_delete_post", "postId": (要删除的、你自己的动态ID)}'
        -   **更新状态**: '[{"type": "update_status", "status_text": "正在做的事", "is_busy": true}]'
        ${contentTabooPrompt}
        ${myPostsContext} 
        # 供你决策的参考信息：
        -   **你的角色设定**: ${chat.settings.aiPersona}
        ${worldBookContent}
        ${longTermMemoryContext}
        ${multiLayeredSummaryContext}   
        ${linkedMemoryContext}
        ${chat.settings.enableTimePerception ? `-   **当前时间**:${currentTime} (${timeOfDayGreeting})` : ''}
        ${chat.settings.enableTimePerception ? `-   **对话状态**: ${timeContextText}` : ''}
        -   **你们最后的对话摘要**: ${recentContextSummary}
        ${dynamicContext}
`;

    const messagesPayload = [
        { role: 'system', content: systemPrompt },
        // 将原始的、未被摘要的 recentHistory 转换为API能理解的格式
        ...recentHistory.map(msg => {
            const sender = msg.role === 'user' ? userNickname : chat.name;
            let content = msg.content;
            if (typeof content !== 'string') {
                content = JSON.stringify(content); // 确保内容是字符串
            }
            return {
                role: msg.role,
                content: `${sender}: ${content}`
            };
        })
    ];
          
          try {
                const messagesPayload = [
                    { role: 'user', content: `${systemPrompt}\n\n[系统指令：请根据你在上面读到的规则和以下最新信息，开始你的独立行动。]\n${dynamicContext}` }
                ];
        
                console.log(`正在为后台活动发送API请求 ("${chat.name}")`);
        
                let  isGemini = proxyUrl === GEMINI_API_URL;
                let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesPayload);
        // 步骤 4: (保持不变) 发送API请求，但现在它包含了更丰富的上下文
        const response = isGemini ?
            await fetch(geminiConfig.url, geminiConfig.data) :
            await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    // 【【【核心修复】】】在这里使用我们新构建的、包含完整历史的 messagesPayload
                    messages: messagesPayload,
                    temperature: state.globalSettings.apiTemperature || 0.9,
                })
            });
        
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API请求失败: ${response.status} - ${JSON.stringify(errorData)}`);
                }
                const data = await response.json();
        
                const aiResponseContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
        
                if (!aiResponseContent || aiResponseContent.trim() === '') {
                     console.warn(`API为空回，角色 "${chat.name}" 的本次后台活动跳过。`);
                     return;
                }
        
                const responseArray = parseAiResponse(aiResponseContent);
        
                if (!responseArray || responseArray.length === 0) {
                     console.warn(`API格式不正确，角色 "${chat.name}" 的本次后台活动跳过。原始回复:`, aiResponseContent);
                     return;
                }
                let actionTimestamp = Date.now();
                
                let hasSentNotification = false;
// This is the new, fixed code block
const processedActions = [];
for (const action of responseArray) {
    const contentStr = String(action.content || ''); // Ensure content is a string
    // Check if the content is a raw HTML block
    const isRawHtml = contentStr.trim().startsWith('<') && contentStr.trim().endsWith('>');

    // **CORE FIX**: Only split the message if it has newlines AND it's NOT raw HTML
    if (action.type === 'text' && !isRawHtml && contentStr.includes('\n')) {
        const lines = contentStr.split(/\n+/).filter(line => line.trim());
        lines.forEach(line => {
            processedActions.push({ ...action, content: line });
        });
    } else {
        // If it's HTML or a single-line message, push it as-is
        processedActions.push(action);
    }
}
        for (const action of processedActions) {
                    chat.lastActionType = action.type;
                    chat.lastActionTimestamp = actionTimestamp;
                    
                    let aiMessage = null;
                    const baseMessage = { role: 'assistant', senderName: chat.originalName, timestamp: actionTimestamp++ };
            // ▼▼▼ 核心修改：将通知逻辑移到这里 ▼▼▼
            let notificationText = null;        
                    switch (action.type) {
                        case 'qzone_delete_post': {
            const postIdToDelete = parseInt(action.postId);
            const postToDelete = await db.qzonePosts.get(postIdToDelete);
            if (postToDelete && postToDelete.authorId === chatId) {
                await db.qzonePosts.update(postIdToDelete, { isDeleted: true });
                
                if (document.getElementById('qzone-screen').classList.contains('active')) {
                    renderQzonePosts();
                }
                const systemMessage = {
                    role: 'system',
                    type: 'post_deleted_notice',
                    content: `[${chat.name} 删除了自己的一条动态]`,
                    postId: postIdToDelete,
                    timestamp: actionTimestamp++
                };
                chat.history.push(systemMessage);
                
                if (isViewingThisChat) {
                    appendMessage(systemMessage, chat);
                } else {
                    chat.unreadCount = (chat.unreadCount || 0) + 1;
                    showNotification(chatId, `[${chat.name} 删除了自己的一条动态]`);
                    hasSentNotification = true;
                }
            } else {
                console.warn(`AI "${chat.name}" 尝试删除一个不存在或不属于自己的动态 (ID: ${action.postId})`);
            }
            continue;
        }
                        case 'text':
                            aiMessage = { ...baseMessage, content: action.content };
                            break;
                        case 'ai_image':
                            aiMessage = {
                                ...baseMessage,
                                type: 'ai_image',
                                content: action.description 
                            };
                            break;
                        case 'update_status':
                            chat.status.text = action.status_text;
                            chat.status.isBusy = action.is_busy || false;
                            chat.status.lastUpdate = Date.now();
                            break; 
                        case 'qzone_post':
                            const newPost = { 
                                type: action.postType, 
                                content: action.content || '', 
                                publicText: action.publicText || '', 
                                hiddenContent: action.hiddenContent || '', 
    image_prompt: action.image_prompt || '', // <-- 新增这一行
                                timestamp: Date.now(), 
                                authorId: chatId, 
                                authorOriginalName: chat.originalName,
                                authorGroupId: chat.groupId,
                                visibleGroupIds: null 
                            };
                            await db.qzonePosts.add(newPost);
                            updateUnreadIndicator(unreadPostsCount + 1);
                            console.log(`后台活动: 角色 "${chat.name}" 发布了动态`);
                            break;
                        case 'repost':
                            const originalPost = await db.qzonePosts.get(parseInt(action.postId));
                            if (originalPost) {
                                const newRepost = {
                                    type: 'repost',
                                    timestamp: Date.now(),
                                    authorId: chatId,
                                    authorGroupId: chat.groupId,
                                    authorOriginalName: chat.originalName,
                                    repostComment: action.comment || '',
                                    originalPost: originalPost,
                                    visibleGroupIds: null
                                };
                                await db.qzonePosts.add(newRepost);
                                updateUnreadIndicator(unreadPostsCount + 1);
                                console.log(`后台活动: 角色 "${chat.name}" 转发了动态 #${action.postId}`);
                            }
                            break;
                        case 'qzone_like':
                            const postToLike = await db.qzonePosts.get(parseInt(action.postId));
                            if (postToLike) {
                                if (!postToLike.likes) postToLike.likes = [];
                                if (!postToLike.likes.includes(chat.originalName)) {
                                    postToLike.likes.push(chat.originalName);
                                    await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                                    updateUnreadIndicator(unreadPostsCount + 1);
                                    console.log(`后台活动: 角色 "${chat.name}" 点赞了动态 #${action.postId}`);
                                }
                            }
                            break;
                        case 'qzone_comment':
                            const postToComment = await db.qzonePosts.get(parseInt(action.postId));
                            if (postToComment) {
                                if (!postToComment.comments) postToComment.comments = [];
                                
                                const commenterName = action.name || chat.originalName;
        
                                const createCommentObject = (text, meaning = null, replyTo = null) => ({
                                    commenterName,
                                    text: processMentions(text, chat),
                                    meaning,
                                    replyTo,
                                    timestamp: Date.now()
                                });
        
                                if (action.stickerUrl && action.stickerMeaning) {
                                    postToComment.comments.push(createCommentObject(action.stickerUrl, action.stickerMeaning, action.replyTo || null));
                                } else if (Array.isArray(action.comments)) {
                                    action.comments.forEach(commentText => {
                                        if (typeof commentText === 'string' && commentText.trim()) {
                                            postToComment.comments.push(createCommentObject(commentText, null, action.replyTo || null));
                                        }
                                    });
                                } else if (typeof action.commentText === 'string' && action.commentText.trim()) {
                                    postToComment.comments.push(createCommentObject(action.commentText, null, action.replyTo || null));
                                }
                                
                                await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
                                updateUnreadIndicator(unreadPostsCount + 1);
                                console.log(`后台活动: 角色 "${chat.name}" 评论了动态 #${action.postId}`);
        
                                if (!chat.commentCooldowns) chat.commentCooldowns = {};
                                chat.commentCooldowns[action.postId] = Date.now();
                            }
                            break;
                        case 'video_call_request':
                            if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                                videoCallState.isAwaitingResponse = true;
                                videoCallState.activeChatId = chatId;
                                videoCallState.isGroupCall = false;
                                videoCallState.callRequester = chat.name;
                                showIncomingCallModal();
                            }
                            break;
                        default:
                            console.warn(`角色 "${chat.name}" 尝试执行未知的后台动作:`, action.type);
                            break;
        // 在 case 'video_call_request': { ... } 的正下方粘贴
        
        // ▼▼▼ 【这是您缺失的核心功能代码，请粘贴在这里】 ▼▼▼
        case 'change_avatar': {
            const avatarNameFromAction = action.name;
            const foundAvatarFromAction = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarNameFromAction);
            if (foundAvatarFromAction) {
                chat.settings.aiAvatar = foundAvatarFromAction.url;
                
                // 【核心修复】在后台更新完自己的头像后，立刻调用同步函数！
                await syncCharacterAvatarInGroups(chat);
        
                visibleSystemMessage = { content: `[${chat.name} 更换了头像]` };
                console.log(`后台活动: 角色 "${chat.name}" 更换了头像`);
            }
            break;
        }
        // ▲▲▲ 粘贴结束 ▲▲▲
                    }
        
        
                    if (aiMessage) {
                        chat.history.push(aiMessage);
                        chat.unreadCount = (chat.unreadCount || 0) + 1;
                        if (!hasSentNotification) {
                            let notificationText = aiMessage.type === 'ai_image' ? '[图片]' : (aiMessage.content || '');
                            showNotification(chatId, notificationText);
                            hasSentNotification = true;
                        }
                    }
                }
                await db.chats.put(chat);
                
            } catch (error) {
                console.error(`角色 "${chat.name}" 的独立行动失败:`, error);
            } finally {
                setAvatarActingState(chatId, false);
                renderChatList();
                if (document.getElementById('qzone-screen').classList.contains('active')) {
                    renderQzonePosts();
                }
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        
        
        
        // ▼▼▼ 【最终修复版】请用这个全新的函数，完整替换旧的 triggerGroupAiAction 函数 ▼▼▼
        async function triggerGroupAiAction(chatId) {
            const chat = state.chats[chatId];
            if (!chat || !chat.isGroup) return;
        
            // 【【【核心修改1：从群聊设置中读取冷却时间】】】
            const groupActionCooldownMinutes = chat.settings.actionCooldownMinutes || 10;
        
            if (chat.lastActionTimestamp) {
                const minutesSinceLastAction = (Date.now() - chat.lastActionTimestamp) / (1000 * 60);
                // 【【【核心修改2：使用新的变量进行判断】】】
                if (minutesSinceLastAction < groupActionCooldownMinutes) {
                    console.log(`群聊 "${chat.name}" 处于行动冷却中，本次独立行动跳过。`);
                    return;
                }
            }
            
            
            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) return;
        
            const myNickname = chat.settings.myNickname || '我';
            const now = new Date();
            
            // ★★★ 核心修复开始 ★★★
            let systemPrompt;
            
            // 1. 检查最近的消息，看是否有未领完的红包
            const recentHistory = chat.history.filter(m => !m.isHidden).slice(-5); // 检查最近5条
            const unclaimedPacket = recentHistory.find(m => m.type === 'red_packet' && !m.isFullyClaimed);
        
            // 2. 如果找到了未领完的红包，就生成一个专门的“抢红包”指令
            if (unclaimedPacket) {
                const senderDisplayName = getDisplayNameInGroup(chat, unclaimedPacket.senderName);
                console.log(`检测到群聊 "${chat.name}" 中有未领完的红包，正在生成抢红包指令...`);
                
                systemPrompt = `
        # 你的【【【最高优先级任务】】】
        群聊中刚刚出现了一个由“${senderDisplayName}”发送的、尚未领完的红包（时间戳: ${unclaimedPacket.timestamp}）。
        你的任务是：选择【一个或多个】符合人设的角色，让他们【立刻】使用 'open_red_packet' 指令去尝试领取这个红包。
        # 指令格式
        你的回复【必须】是一个JSON数组，格式如下：
        '[{"type": "open_red_packet", "name": "角色本名", "packet_timestamp": ${unclaimedPacket.timestamp}}]'
        
        你可以让多个角色同时尝试，只需在返回的JSON数组中包含多个这样的对象即可。
        现在，请立即执行抢红包操作！
        `;
            } else {
                // 3. 如果没有红包事件，才执行原来的通用聊天逻辑
                let timeContextText = '';
    // ▼▼▼ 核心修复：在这里也使用您为该群聊选择的时区 ▼▼▼
    const selectedTimeZone = chat.settings.timeZone || 'Asia/Shanghai';
    const currentTime = now.toLocaleString('zh-CN', { timeZone: selectedTimeZone, dateStyle: 'full', timeStyle: 'short' });
    const localizedDate = new Date(now.toLocaleString('en-US', { timeZone: selectedTimeZone }));
    // ▲▲▲ 修复结束 ▲▲▲

                // 【核心修改】只有当时间感知开启时，才计算时间差
                if (chat.settings.enableTimePerception) {
                    const lastMessage = chat.history.filter(m => !m.isHidden).slice(-1)[0];
                    if (lastMessage) {
                        const lastTime = new Date(lastMessage.timestamp);
                        const diffMinutes = (now - lastTime) / (1000 * 60);
                        if (diffMinutes > 60) {
                            timeContextText = `群里已经安静了 ${Math.round(diffMinutes / 60)} 小时了。`;
                        } else {
                            timeContextText = `群里在${Math.floor(diffMinutes)}分钟前有人聊过。`;
                        }
                    } else {
                        timeContextText = "群里还没有任何消息。";
                    }
                }
                let recentContextSummary = "你们最近没有有效聊天记录。";
const maxMemory = chat.settings.maxMemory || 10; // 读取群聊的设置
const recentHistory = chat.history.filter(m => !m.isHidden).slice(-maxMemory);
                if (recentHistory.length > 0) {
                    recentContextSummary = "这是你们最近的对话：\n" + recentHistory.map(msg => {
                        const sender = msg.role === 'user' ? myNickname : getDisplayNameInGroup(chat, msg.senderName);
                        const content = String(msg.content || msg.message || '').substring(0, 50);
                        return `${sender}: ${content}...`;
                    }).join('\n');
                }
        
                const membersList = chat.members.map(m => `- **${m.groupNickname}** (本名: ${m.originalName}): ${m.persona}`).join('\n');
        // ▼▼▼ 核心修改：在这里构建跨角色的长期记忆上下文 (和 triggerAiResponse 一样) ▼▼▼
        let longTermMemoryContext = '# 长期记忆 (最高优先级，这是群内已经确立的事实，所有角色必须严格遵守)\n';
        let collectedMemories = false;
        
        chat.members.forEach(member => {
            const memberChat = state.chats[member.id];
            if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length > 0) {
                longTermMemoryContext += `\n## --- 关于“${member.groupNickname}”的记忆 ---\n`;
                longTermMemoryContext += memberChat.longTermMemory.map(mem => `- ${mem.content}`).join('\n');
                collectedMemories = true;
            }
        });

        if (!collectedMemories) {
            longTermMemoryContext += '- (暂无)';
        }
        // ▲▲▲ 修改结束 ▲▲▲
        // ▼▼▼ 在 triggerGroupAiAction 函数中，用下面这整块代码替换旧的世界书处理逻辑 ▼▼▼
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                if (!worldBook || !Array.isArray(worldBook.content)) return '';

                // 【核心修改】在这里也加入过滤逻辑
                const formattedEntries = worldBook.content
                    .filter(entry => entry.enabled !== false) // 只读取启用的条目
                    .map(entry => {
                        let entryString = `\n### 条目: ${entry.comment || '无备注'}\n`;
                        if (entry.keys.length > 0) {
                            entryString += `**关键词:** ${entry.keys.join(', ')}\n`;
                        }
                        entryString += `**内容:**\n${entry.content}`;
                        return entryString;
                    }).join('');

                return formattedEntries ? `\n\n## 世界书: ${worldBook.name}\n${formattedEntries}` : '';
            }).filter(Boolean).join('');
            
            if (linkedContents) {
                worldBookContent = `\n\n# 核心世界观设定 (群内所有角色都必须严格遵守)\n${linkedContents}\n`;
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
                let linkedMemoryContext = '';
                const memoryCount = chat.settings.linkedMemoryCount || 10;
                if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
                    const linkedChatsWithTimestamps = chat.settings.linkedMemoryChatIds.map(id => {
                        const linkedChat = state.chats[id];
                        if (!linkedChat) return null;
                        const lastMsg = linkedChat.history.slice(-1)[0];
                        return {
                            chat: linkedChat,
                            latestTimestamp: lastMsg ? lastMsg.timestamp : 0
                        };
                    }).filter(Boolean); 
        
                    linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
                    linkedMemoryContext += `\n\n# 参考记忆 (至关重要！群内角色必须【主动】将这些参考记忆中的【关键信息和事件】，自然地融入到当前的对话中，以体现你们拥有完整的共同记忆。)\n`;
                    for (const item of linkedChatsWithTimestamps) {
                        const linkedChat = item.chat;
                        const prefix = linkedChat.isGroup ? '[群聊]' : '[私聊]';
                        const timeAgo = item.latestTimestamp > 0 ? ` (最后互动于 ${formatTimeAgo(item.latestTimestamp)})` : '';
                        linkedMemoryContext += `\n## --- 来自${prefix}“${linkedChat.name}”的参考记忆${timeAgo} ---\n`;
                        const recentHistory = linkedChat.history.slice(-memoryCount);
                        const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('已被用户删除'));
                        if (filteredHistory.length > 0) {
                            filteredHistory.forEach(msg => {
                                const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || '我') : (msg.senderName || linkedChat.name);
                                let contentText = String(msg.content);
                                if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                                    contentText = `[发送了一张图片，描述为：${msg.content}]`;
                                } else if (msg.type === 'voice_message') {
                                    contentText = `[发送了一条语音，内容是：${msg.content}]`;
                                }
                                linkedMemoryContext += `${sender}: ${contentText}\n`;
                            });
                        } else {
                            linkedMemoryContext += "(暂无有效聊天记录)\n";
                        }
                    }
                }
                const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
                let dynamicContext = "";
                
                const visiblePostsForGroup = new Set();
                for (const member of chat.members) {
                    const memberChat = state.chats[member.id];
                    if (memberChat) {
                        const visibleForMember = filterVisiblePostsForAI(allRecentPosts, memberChat);
                        visibleForMember.forEach(post => visiblePostsForGroup.add(post));
                    }
                }
        
                const groupMemberNames = new Set(chat.members.map(m => m.originalName));
                const unInteractedPostsForGroup = [...visiblePostsForGroup].filter(post => {
                    const hasBeenLikedByGroup = post.likes && post.likes.some(likerName => groupMemberNames.has(likerName));
                    const hasBeenCommentedByGroup = post.comments && post.comments.some(comment => typeof comment === 'object' && groupMemberNames.has(comment.commenterName));
                    return !hasBeenLikedByGroup && !hasBeenCommentedByGroup;
                });
                
                if (unInteractedPostsForGroup.length > 0) {
                    let postsContext = "\n\n# 最近的动态列表 (供群内角色参考和评论):\n";
                    for (const post of unInteractedPostsForGroup) {
                        let authorName = post.authorId === 'user' ? myNickname : (state.chats[post.authorId]?.name || '一位朋友');
                        let contentSummary;
                        if (post.type === 'repost') {
                            const repostComment = post.repostComment ? `并评论说：“${post.repostComment}”` : '';
                            let originalAuthorName = '原作者';
                            const originalAuthorId = post.originalPost.authorId;
                            if (originalAuthorId === 'user') {
                                originalAuthorName = state.qzoneSettings.nickname;
                            } else if (state.chats[originalAuthorId]) {
                                originalAuthorName = state.chats[originalAuthorId].name;
                            }
                            let originalContentSummary;
                            const originalPost = post.originalPost;
                            if (originalPost.type === 'text_image') {
                                originalContentSummary = `[文字图] ${originalPost.publicText || ''} (图片描述: “${(originalPost.hiddenContent || '').substring(0, 40)}...”)`;
                            } else if (originalPost.type === 'image_post') {
                                originalContentSummary = `[图片] ${originalPost.publicText || ''} (图片描述: “${(originalPost.imageDescription || '').substring(0, 40)}...”)`;
                            } else { // 'shuoshuo'
                                originalContentSummary = `“${(originalPost.content || '').substring(0, 40)}...”`;
                            }
                            contentSummary = `转发了 @${originalAuthorName} 的动态 ${repostComment}【原动态内容: ${originalContentSummary}】`;
                        } else if (post.type === 'text_image') {
                            contentSummary = `[一张图片，其隐藏文字为：“${post.hiddenContent}”] ${post.publicText || ''}`.substring(0, 50) + '...';
                        } else if (post.type === 'image_post') {
                            contentSummary = `[一张图片，描述为：“${post.imageDescription}”] ${post.publicText || ''}`.substring(0, 50) + '...';
                        } else {
                            contentSummary = (post.publicText || post.content || "一条动态").substring(0, 50) + '...';
                        }
                        postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentSummary}"\n`;
                        if (post.comments && post.comments.length > 0) {
                            for (const comment of post.comments) {
                                if (typeof comment === 'object' && comment.commenterName) {
                                    const commenterDisplayName = getDisplayNameByOriginalName(comment.commenterName);
                                    let commentText = comment.meaning ? `[表情: '${comment.meaning}']` : comment.text;
                                    postsContext += `  - 评论: ${commenterDisplayName} (本名: ${comment.commenterName}): ${commentText}\n`;
                                }
                            }
                        }
                    }
                    dynamicContext = postsContext;
                }
   
const summary3Hours_group = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours_group = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours_group = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday_group = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days_group = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days_group = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext_group = '';
if (summary3Hours_group || summary6Hours_group || summary9Hours_group || summaryToday_group || summary3Days_group || summary7Days_group) {
    multiLayeredSummaryContext_group += `\n# 智能总结 (基于不同时间维度的群聊回顾)\n`;
    if (summary3Hours_group) multiLayeredSummaryContext_group += summary3Hours_group;
    if (summary6Hours_group) multiLayeredSummaryContext_group += summary6Hours_group;
    if (summary9Hours_group) multiLayeredSummaryContext_group += summary9Hours_group;

    if (summary3Hours_group || summary6Hours_group || summary9Hours_group) multiLayeredSummaryContext_group += '\n';

    if (summaryToday_group) multiLayeredSummaryContext_group += summaryToday_group;
    if (summary3Days_group) multiLayeredSummaryContext_group += summary3Days_group;
    if (summary7Days_group) multiLayeredSummaryContext_group += summary7Days_group;
}     
                systemPrompt = `
        # 你的任务
        你是一个群聊AI导演。你现在控制着一个名为“${chat.name}”的群聊。
        ${chat.settings.enableTimePerception ? `当前时间是 ${currentTime}。` : ''}
        ${timeContextText ? `${timeContextText} ` : ''}你的任务是根据群成员的性格、世界观、参考记忆、最近的动态和当前情景，【选择一个或多个角色】，让他们主动发起一段对话，打破沉默，让群聊重新活跃起来。
# 【交互铁律：角色间必须互动！】
1.  你的核心任务是**导演一场生动的群聊**，而不仅仅是让角色轮流发言。
2.  当有多个角色在同一轮发言时，他们的对话【必须】有逻辑上的前后关联。后面的角色应该**回应、反驳、或补充**前面角色的发言。
3.  模拟真实的聊天节奏。可以是一个角色提出问题，另一个角色立刻回答；或者一个角色开玩笑，另一个角色吐槽。
4.  你【绝对不能】生成几段毫无关联的独白。这会让对话显得非常机械和不真实。        
${longTermMemoryContext}
        
        # 核心规则
        你的回复【必须】是一个JSON数组，可以包含一个或多个行动对象。每个对象的 "name" 字段【必须】是角色的【本名】。你【绝对不能】生成 "name" 字段为 "${myNickname}" 的消息。严格遵守每个角色的设定，禁止出戏。
        
        # 你的可选行动指令:
        -   **发送文本**: '{"type": "text", "name": "角色本名", "content": "文本内容"}'
        -   **发送表情**: '{"type": "sticker", "name": "角色本名", "url": "...", "meaning": "..."}'
        -   **发送图片**: '{"type": "ai_image", "name": "角色本名", "description": "图片的详细【中文】描述", "image_prompt": "图片的【英文】关键词, 用%20分隔, 风格为风景/动漫/插画/二次元等, 禁止真人"}'
        -   **发起投票**: '{"type": "poll", "name": "角色本名", "question": "...", "options": "..."}'
        -   **发起群视频**: '{"type": "group_call_request", "name": "角色本名"}'
        -如何正确使用“引用回复”功能：
- 当你想明确地针对群内【任何成员】（包括用户或其他AI角色）之前的某一句具体的话进行回复时，你就应该使用这个功能。
- 这会让你的回复上方出现一个灰色的小框，里面是被你引用的那句话，这样对话就不会乱了。
- 指令格式: '{"type": "quote_reply", "target_timestamp": (你想引用的那句话的时间戳), "reply_content": "你的回复内容"}'

        # 当前群聊信息
        - **群名称**: ${chat.name}
        ${worldBookContent}
        # 长期记忆 (最高优先级，这是群内已经确立的事实，所有角色必须严格遵守)
        ${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (暂无)'}       
        ${multiLayeredSummaryContext_group}
        ${linkedMemoryContext}
        
        # 群成员列表及人设
        ${membersList}
        
        # 用户的角色
        - **${myNickname}**: ${chat.settings.myPersona}
        
        # 最近的对话摘要 (供你参考)
        ${recentContextSummary}
        
        # 最近的动态列表 (供你参考和评论)
        ${dynamicContext}
        
        现在，请开始你的导演工作，让群聊再次热闹起来吧！
        `;
            }
            // ★★★ 核心修复结束 ★★★
    // ==========================================================
    //            ★★★ 核心修复从这里开始 ★★★
    // ==========================================================
    
    // 步骤 1: 【全新】构建包含完整原始聊天记录的 messagesPayload
    const recentHistoryForPayload = chat.history.filter(m => !m.isHidden).slice(-10);
    const messagesPayload = [
        { role: 'system', content: systemPrompt },
        // 将原始的、未被摘要的 recentHistory 转换为API能理解的格式
        ...recentHistoryForPayload.map(msg => {
            const sender = msg.role === 'user' ? myNickname : getDisplayNameInGroup(chat, msg.senderName);
            let content = msg.content;
            // 将所有复杂消息类型都转换为纯文本描述，让AI能读懂
            if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                content = `[发送了一张图片，描述为：'${msg.content}']`;
            } else if (msg.type === 'voice_message') {
                content = `[发送了一条语音，内容是：'${msg.content}']`;
            } else if (typeof content !== 'string') {
                content = '[发送了一条复杂消息，如卡片或转账]';
            }

            return {
                role: 'user', // 全部模拟成 user 角色，让AI更好地理解对话流
                content: `${sender}: ${content}`
            };
        })
    ];

            try {
                const messagesPayload = [{ role: 'user', content: systemPrompt }];
                let isGemini = proxyUrl === GEMINI_API_URL;
                let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload);
        // 步骤 2: 【全新】在 API 调用中使用我们新构建的、更丰富的 messagesPayload
        const response = isGemini ? 
            await fetch(geminiConfig.url, geminiConfig.data) : 
            await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: messagesPayload, // <-- 使用这个新变量！
                    temperature: state.globalSettings.apiTemperature || 0.9,
                })
            });
        
                if (!response.ok) throw new Error((await response.json()).error.message);
        
                const data = await response.json();
                const aiResponseContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
                const responseArray = parseAiResponse(aiResponseContent);
        
                if (!responseArray || responseArray.length === 0) {
                     console.warn(`群聊 "${chat.name}" 的独立行动API返回为空或格式不正确，本次跳过。`);
                     return;
                }
                
                let actionTimestamp = Date.now();
                
                let hasPerformedMajorAction = false;
                let notificationContent = '';
                let notificationSender = '';
// This is the new, fixed code block
const processedActions = [];
for (const action of responseArray) {
    const contentStr = String(action.content || ''); // Ensure content is a string
    // Check if the content is a raw HTML block
    const isRawHtml = contentStr.trim().startsWith('<') && contentStr.trim().endsWith('>');

    // **CORE FIX**: Only split the message if it has newlines AND it's NOT raw HTML
    if (action.type === 'text' && !isRawHtml && contentStr.includes('\n')) {
        const lines = contentStr.split(/\n+/).filter(line => line.trim());
        lines.forEach(line => {
            processedActions.push({ ...action, content: line });
        });
    } else {
        // If it's HTML or a single-line message, push it as-is
        processedActions.push(action);
    }
}
        for (const action of processedActions){
                    if (!action || !action.type || !action.name) continue;
        
                    const senderDisplayName = getDisplayNameInGroup(chat, action.name);
                    let visibleSystemMessage = null;
        
                    let aiMessage = null;
                    const baseMessage = { role: 'assistant', senderName: action.name, timestamp: actionTimestamp++ };
        
                    // ★★★ 核心修复：处理 open_red_packet 指令 ★★★
                    if (action.type === 'open_red_packet') {
                        const packetToOpen = chat.history.find(m => m.timestamp === action.packet_timestamp);
                        // 确保红包存在、没领完、且这个角色还没领过
                        if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[action.name])) {
                            // (这里的抢红包逻辑和用户抢红包的逻辑是完全一样的)
                            let claimedAmountAI = 0;
                            const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
                            const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;
                            
                            if (remainingCount > 0) {
                                if (remainingCount === 1) { claimedAmountAI = remainingAmount; } 
                                else {
                                    const min = 0.01;
                                    const max = remainingAmount - (remainingCount - 1) * min;
                                    claimedAmountAI = Math.random() * (max - min) + min;
                                }
                                claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
                                if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
                                packetToOpen.claimedBy[action.name] = claimedAmountAI;
        
                                // 创建对用户可见的系统消息
                                chat.history.push({
                                    role: 'system',
                                    type: 'pat_message',
                                    content: `${senderDisplayName} 领取了 ${getDisplayNameInGroup(chat, packetToOpen.senderName)} 的红包`,
                                    timestamp: Date.now()
                                });
                                
                                // 创建对AI隐藏的、告知结果的消息
                                let hiddenContentForAI = `[系统提示：你 (${senderDisplayName}) 成功抢到了 ${claimedAmountAI.toFixed(2)} 元。`;
                                if (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count) {
                                    packetToOpen.isFullyClaimed = true;
                                    // 告知红包领完了
                                    chat.history.push({
                                        role: 'system',
                                        type: 'pat_message',
                                        content: `${getDisplayNameInGroup(chat, packetToOpen.senderName)} 的红包已被领完`,
                                        timestamp: Date.now() + 1
                                    });
                                    // 找出并告知手气王是谁
                                    let luckyKing = { name: '', amount: -1 };
                                    Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                                        if (amount > luckyKing.amount) {
                                            luckyKing = { name, amount };
                                        }
                                    });
                                    if (luckyKing.name) {
                                         const luckyKingDisplayName = getDisplayNameInGroup(chat, luckyKing.name);
                                         hiddenContentForAI += ` 红包已被领完，手气王是 ${luckyKingDisplayName}！`;
                                    }
                                }
                                hiddenContentForAI += ' 请根据这个结果发表你的评论。]';
                                chat.history.push({
                                    role: 'system',
                                    content: hiddenContentForAI,
                                    timestamp: Date.now() + 2,
                                    isHidden: true
                                });
                            }
                        }
                        hasPerformedMajorAction = true; // 标记有重要行动
                        continue; // 处理完抢红包后，跳过本次循环，等待下一次tick来发表评论
                    }
                    // ★★★ 修复结束 ★★★
        
                    switch (action.type) {
                        case 'qzone_post':
                            const newPost = { type: action.postType || 'shuoshuo', content: action.content, timestamp: Date.now(), authorId: state.chats[Object.keys(state.chats).find(key => state.chats[key].originalName === action.name)]?.id || action.name, authorOriginalName: action.name, visibleGroupIds: null };
                            await db.qzonePosts.add(newPost);
                            updateUnreadIndicator(unreadPostsCount + 1);
                            visibleSystemMessage = { content: `[${senderDisplayName} 发布了一条新动态]` };
                            break;
                        case 'qzone_comment':
                            const postToComment = await db.qzonePosts.get(parseInt(action.postId));
                            if (postToComment) {
                                if (!postToComment.comments) postToComment.comments = [];
                                postToComment.comments.push({ commenterName: action.name, text: action.commentText, timestamp: Date.now() });
                                await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
                                updateUnreadIndicator(unreadPostsCount + 1);
                                visibleSystemMessage = { content: `[${senderDisplayName} 评论了动态]` };
                            }
                            break;
                        case 'qzone_like':
                            const postToLike = await db.qzonePosts.get(parseInt(action.postId));
                            if (postToLike) {
                                if (!postToLike.likes) postToLike.likes = [];
                                if (!postToLike.likes.includes(action.name)) {
                                    postToLike.likes.push(action.name);
                                    await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                                    updateUnreadIndicator(unreadPostsCount + 1);
                                    visibleSystemMessage = { content: `[${senderDisplayName} 点赞了动态]` };
                                }
                            }
                            break;
                        case 'ai_image':
                            aiMessage = {
                                ...baseMessage,
                                type: 'ai_image',
                                content: action.description, 
image_prompt: msgData.image_prompt // <-- 【核心修复】在这里补上缺失的关键字段
                            };
                            break;
                        default:
                            if (action.type === 'poll') {
                                 const pollOptions = typeof action.options === 'string' 
                                    ? action.options.split('\n').filter(opt => opt.trim()) 
                                    : (Array.isArray(action.options) ? action.options : []);
                                if (pollOptions.length < 2) continue;
                                aiMessage = { ...baseMessage, ...action, options: pollOptions, votes: {}, isClosed: false };
                            } else {
                                const messageContent = action.content || action.message;
                                aiMessage = { ...baseMessage, ...action };
                                if (messageContent) aiMessage.content = messageContent;
                            }
                            break;
                    }
                    
                    if (visibleSystemMessage) {
                        chat.history.push({
                            role: 'system',
                            type: 'pat_message',
                            content: visibleSystemMessage.content,
                            timestamp: actionTimestamp++
                        });
                    } 
                    else if (aiMessage) {
                        chat.history.push(aiMessage);
                        if (!notificationSender) {
                            notificationSender = senderDisplayName;
                            notificationContent = aiMessage.type === 'ai_image' ? '[图片]' : (aiMessage.content || `[${aiMessage.type}]`);
                        }
                    }
                    hasPerformedMajorAction = true;
                }
                
                if (hasPerformedMajorAction) {
                    chat.lastActionTimestamp = Date.now();
                    chat.unreadCount = (chat.unreadCount || 0) + responseArray.filter(a => a.type !== 'qzone_post' && a.type !== 'qzone_comment' && a.type !== 'qzone_like').length;
                    if (notificationSender && notificationContent) {
                         showNotification(chatId, `${notificationSender}: ${notificationContent}`);
                    }
                    await db.chats.put(chat);
                }
        
            } catch (error) {
                console.error(`群聊 "${chat.name}" 的独立行动失败:`, error);
            } finally {
                renderChatList();
            }
        }
        
        
        
        
        
        
        // ▼▼▼ 请用这个【终极修正版】函数，完整替换掉你旧的 applyScopedCss 函数 ▼▼▼
        
        /**
         * 将用户自定义的CSS安全地应用到指定的作用域
         * @param {string} cssString 用户输入的原始CSS字符串
         * @param {string} scopeId 应用样式的作用域ID (例如 '#chat-messages' 或 '#settings-preview-area')
         * @param {string} styleTagId 要操作的 <style> 标签的ID
         */
        function applyScopedCss(cssString, scopeId, styleTagId) {
            const styleTag = document.getElementById(styleTagId);
            if (!styleTag) return;
            
            if (!cssString || cssString.trim() === '') {
                styleTag.innerHTML = '';
                return;
            }
            
            // 增强作用域处理函数 - 专门解决.user和.ai样式冲突问题
            const scopedCss = cssString
                .replace(/\s*\.message-bubble\.user\s+([^{]+\{)/g, `${scopeId} .message-bubble.user $1`)
                .replace(/\s*\.message-bubble\.ai\s+([^{]+\{)/g, `${scopeId} .message-bubble.ai $1`)
                .replace(/\s*\.message-bubble\s+([^{]+\{)/g, `${scopeId} .message-bubble $1`);
            
            styleTag.innerHTML = scopedCss;
        }
        
        // ▼▼▼ 【请用这个已修复的版本】完整替换旧的 updateSettingsPreview 函数 ▼▼▼
        async function updateSettingsPreview() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            const previewArea = document.getElementById('settings-preview-area');
            if (!previewArea) return;
        
            // 1. 获取当前设置的值
            const selectedTheme = document.querySelector('input[name="theme-select"]:checked')?.value || 'default';
            const fontSize = document.getElementById('font-size-slider').value;
            const customCss = document.getElementById('custom-css-input').value;
            const background = chat.settings.background; 
        
            // 2. 更新预览区的基本样式
            previewArea.dataset.theme = selectedTheme;
            previewArea.style.setProperty('--chat-font-size', `${fontSize}px`);
            
            if (background && background.startsWith('data:image')) {
                previewArea.style.backgroundImage = `url(${background})`;
                previewArea.style.backgroundColor = 'transparent';
            } else {
                previewArea.style.backgroundImage = 'none';
                previewArea.style.background = background || '#f0f2f5';
            }
        
            // 3. 渲染模拟气泡
            previewArea.innerHTML = ''; 
        
            // 【【【核心修复1：在这里使用 await 等待结果】】】
            const aiMsg = { role: 'ai', content: '对方消息预览', timestamp: 1, senderName: chat.name };
            const aiBubble = await createMessageElement(aiMsg, chat); // <--- 增加了 await
            if(aiBubble) previewArea.appendChild(aiBubble);
        
            // 【【【核心修复2：在这里也使用 await】】】
            const userMsg = { role: 'user', content: '我的消息预览', timestamp: 2 };
            const userBubble = await createMessageElement(userMsg, chat); // <--- 增加了 await
            if(userBubble) previewArea.appendChild(userBubble);
            
            // 实时更新预览区歌词栏位置 (这部分逻辑不变)
            const previewLyricsBar = document.createElement('div');
            previewLyricsBar.style.cssText = `
                position: absolute; 
                font-size: 11px; 
                padding: 2px 6px; 
                border-radius: 8px; 
                background-color: rgba(0, 0, 0, 0.1); 
                color: var(--text-secondary); 
                white-space: nowrap; 
                transition: all 0.3s ease;
            `;
            previewLyricsBar.textContent = '♪ 歌词位置预览 ♪';
            previewArea.appendChild(previewLyricsBar);
            
            const vertical = document.getElementById('lyrics-vertical-pos').value;
            const horizontal = document.getElementById('lyrics-horizontal-pos').value;
            const offset = parseInt(document.getElementById('lyrics-offset-input').value) || 10;
        
            if (vertical === 'top') {
                previewLyricsBar.style.top = `${offset}px`;
            } else {
                previewLyricsBar.style.bottom = `${offset}px`;
            }
            
            switch (horizontal) {
                case 'left':
                    previewLyricsBar.style.left = '15px';
                    break;
                case 'right':
                    previewLyricsBar.style.right = '15px';
                    break;
                default:
                    previewLyricsBar.style.left = '50%';
                    previewLyricsBar.style.transform = 'translateX(-50%)';
                    break;
            }
            
            // 4. 应用自定义CSS到预览区 (这部分逻辑不变)
            applyScopedCss(customCss, '#settings-preview-area', 'preview-bubble-style');
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 请将这些【新函数】粘贴到JS功能函数定义区 ▼▼▼
        
        async function openGroupManager() {
            await renderGroupList();
            document.getElementById('group-management-modal').classList.add('visible');
        }
        
        async function renderGroupList() {
            const listEl = document.getElementById('existing-groups-list');
            const groups = await db.qzoneGroups.toArray();
            listEl.innerHTML = '';
            if (groups.length === 0) {
                listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分组</p>';
            }
            groups.forEach(group => {
                const item = document.createElement('div');
                item.className = 'existing-group-item';
                item.innerHTML = `
                    <span class="group-name">${group.name}</span>
                    <span class="delete-group-btn" data-id="${group.id}">×</span>
                `;
                listEl.appendChild(item);
            });
        }
        
        // ▼▼▼ 请用这个【修正后】的函数，完整替换旧的 addNewGroup 函数 ▼▼▼
        async function addNewGroup() {
            const input = document.getElementById('new-group-name-input');
            const name = input.value.trim();
            if (!name) {
                alert('分组名不能为空！');
                return;
            }
        
            // 【核心修正】在添加前，先检查分组名是否已存在
            const existingGroup = await db.qzoneGroups.where('name').equals(name).first();
            if (existingGroup) {
                alert(`分组 "${name}" 已经存在了，换个名字吧！`);
                return;
            }
            // 【修正结束】
        
            await db.qzoneGroups.add({ name });
            input.value = '';
            await renderGroupList();
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        async function deleteGroup(groupId) {
            const confirmed = await showCustomConfirm('确认删除', '删除分组后，该组内的好友将变为“未分组”。确定要删除吗？', { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.qzoneGroups.delete(groupId);
                // 将属于该分组的好友的 groupId 设为 null
                const chatsToUpdate = await db.chats.where('groupId').equals(groupId).toArray();
                for (const chat of chatsToUpdate) {
                    chat.groupId = null;
                    await db.chats.put(chat);
                    if(state.chats[chat.id]) state.chats[chat.id].groupId = null;
                }
                await renderGroupList();
            }
        }
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        
        // ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区的末尾 ▼▼▼
        
        /**
         * 当长按消息时，显示操作菜单
         * @param {number} timestamp - 被长按消息的时间戳
         */
        function showMessageActions(timestamp) {
        // ▼▼▼ 在这里新增 ▼▼▼
        const chat = state.chats[state.activeChatId];
        document.getElementById('publish-to-announcement-btn').style.display = chat.isGroup ? 'block' : 'none';
        // ▲▲▲ 新增结束 ▲▲▲
            // 如果已经在多选模式，则不弹出菜单
            if (isSelectionMode) return;
            
            activeMessageTimestamp = timestamp;
            document.getElementById('message-actions-modal').classList.add('visible');
        }
        
        /**
         * 隐藏消息操作菜单
         */
        function hideMessageActions() {
            document.getElementById('message-actions-modal').classList.remove('visible');
            activeMessageTimestamp = null;
        }
        
        // ▼▼▼ 用这个【已更新】的版本，替换旧的 openMessageEditor 函数 ▼▼▼
        async function openMessageEditor() {
            if (!activeMessageTimestamp) return;
        
            const timestampToEdit = activeMessageTimestamp;
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestampToEdit);
            if (!message) return;
        
            hideMessageActions(); 
        
            let contentForEditing;
            // 【核心修正】将 share_link 也加入特殊类型判断
            const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer', 'share_link'].includes(message.type);
        
            if (isSpecialType) {
                let fullMessageObject = { type: message.type };
                if (message.type === 'voice_message') fullMessageObject.content = message.content;
                else if (message.type === 'ai_image') fullMessageObject.description = message.content; 
                else if (message.type === 'transfer') {
                    fullMessageObject.amount = message.amount;
                    fullMessageObject.note = message.note;
                } 
                // 【核心修正】处理分享链接类型的消息
                else if (message.type === 'share_link') {
                    fullMessageObject.title = message.title;
                    fullMessageObject.description = message.description;
                    fullMessageObject.source_name = message.source_name;
                    fullMessageObject.content = message.content;
                }
                contentForEditing = JSON.stringify(fullMessageObject, null, 2);
            } else if (typeof message.content === 'object') {
                contentForEditing = JSON.stringify(message.content, null, 2);
            } else {
                contentForEditing = message.content;
            }
        
            // 【核心修改1】在这里添加 'link' 模板
            const templates = {
                voice: { type: 'voice_message', content: '在这里输入语音内容' },
                image: { type: 'ai_image', description: '在这里输入图片描述' },
                transfer: { type: 'transfer', amount: 5.20, note: '一点心意' },
                link: { type: 'share_link', title: '文章标题', description: '文章摘要...', source_name: '来源网站', content: '文章完整内容...' }
            };
        
            // 【核心修改2】在这里添加新的“链接”按钮
            const helpersHtml = `
                <div class="format-helpers">
                    <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>链接</button>
                </div>
            `;
        
            const newContent = await showCustomPrompt(
                '编辑消息', 
                '在此修改，或点击上方按钮使用格式模板...',
                contentForEditing, 
                'textarea',
                helpersHtml
            );
        
            if (newContent !== null) {
                // 【核心修正】这里调用的应该是 saveEditedMessage，而不是 saveAdvancedEditor
                await saveEditedMessage(timestampToEdit, newContent, true);
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        /**
         * 复制消息的文本内容到剪贴板
         */
        async function copyMessageContent() {
            if (!activeMessageTimestamp) return;
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
            if (!message) return;
        
            let textToCopy;
            if (typeof message.content === 'object') {
                textToCopy = JSON.stringify(message.content);
            } else {
                textToCopy = String(message.content);
            }
        
            try {
                await navigator.clipboard.writeText(textToCopy);
                await showCustomAlert('复制成功', '消息内容已复制到剪贴板。');
            } catch (err) {
                await showCustomAlert('复制失败', '无法访问剪贴板。');
            }
            
            hideMessageActions();
        }
        
// ▼▼▼ 【全新】请将这个新函数粘贴到 copyMessageContent 函数的后面 ▼▼▼
/**
 * 复制消息的时间戳到剪贴板
 */
async function copyMessageTimestamp() {
    if (!activeMessageTimestamp) return;

    try {
        await navigator.clipboard.writeText(activeMessageTimestamp);
        await showCustomAlert('复制成功', `消息时间戳 ${activeMessageTimestamp} 已复制到剪贴板。`);
    } catch (err) {
        await showCustomAlert('复制失败', '无法访问剪贴板。');
    }
    
    hideMessageActions();
}
// ▲▲▲ 新增函数结束 ▲▲▲
// ▼▼▼ 【请用这个已添加“引用”模板的版本】替换旧的 createMessageEditorBlock 函数 ▼▼▼
/**
 * 创建一个可编辑的消息块（包含文本框、格式助手和删除按钮）
 * @param {string} initialContent - 文本框的初始内容
 * @returns {HTMLElement} - 创建好的DOM元素
 */
function createMessageEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'message-editor-block';

    // 【核心修改1】在这里添加 'quote' 模板
    const templates = {
        voice: { type: 'voice_message', content: '在这里输入语音内容' },
        image: { type: 'ai_image', description: '在这里输入图片描述' },
        transfer: { type: 'transfer', amount: 5.20, note: '一点心意' },
        link: { type: 'share_link', title: '文章标题', description: '文章摘要...', source_name: '来源网站', content: '文章完整内容...' },
        offline: { type: 'offline_text', content: '「在这里输入对话内容」\n(在这里输入动作或环境描写)' },
        quote: { type: 'quote_reply', target_timestamp: 1234567890, reply_content: '在这里输入回复内容' }
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="删除此条">×</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>链接</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.offline)}'>线下</button>
            <!-- 【核心修改2】在这里添加新的“引用”按钮 -->
            <button class="format-btn" data-template='${JSON.stringify(templates.quote)}'>引用</button>
        </div>
    `;

    // 绑定删除按钮事件
    block.querySelector('.delete-block-btn').addEventListener('click', () => {
        // 确保至少保留一个编辑块
        if (document.querySelectorAll('.message-editor-block').length > 1) {
            block.remove();
        } else {
            alert('至少需要保留一条消息。');
        }
    });

    // 绑定格式助手按钮事件
    block.querySelectorAll('.format-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const templateStr = btn.dataset.template;
            const textarea = block.querySelector('textarea');
            if (templateStr && textarea) {
                try {
                    const templateObj = JSON.parse(templateStr);
                    textarea.value = JSON.stringify(templateObj, null, 2);
                    textarea.focus();
                } catch(e) { console.error("解析格式模板失败:", e); }
            }
        });
    });

    return block;
}
// ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 【最终修复版】请用这个全新的函数，完整替换旧的 openAdvancedMessageEditor 函数 ▼▼▼
        /**
         * 打开全新的、可视化的多消息编辑器，并动态绑定其所有按钮事件
         */
        function openAdvancedMessageEditor() {
            if (!activeMessageTimestamp) return;
        
            const timestampToEdit = activeMessageTimestamp;
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestampToEdit);
            if (!message) return;
        
            hideMessageActions(); 
        
            const editorModal = document.getElementById('message-editor-modal');
            const editorContainer = document.getElementById('message-editor-container');
            editorContainer.innerHTML = ''; 
        
            let initialContent;
            
            // ==========================================================
            //            ★★★ 核心修复从这里开始 ★★★
            // ==========================================================
            
            // 步骤1：检查这条消息是否是一个“引用回复”
            if (message.quote) {
                // 如果是，就手动构建一个完整的 quote_reply 对象
                const quoteReplyObject = {
                    type: 'quote_reply',
                    target_timestamp: message.quote.timestamp,
                    reply_content: message.content // 您的回复内容
                };
                // 将这个完整的对象转换为格式化的JSON字符串，作为编辑器的初始内容
                initialContent = JSON.stringify(quoteReplyObject, null, 2);
            } 
            // 步骤2：如果不是引用回复，再执行原来的特殊类型判断
            else if (message.type && ['voice_message', 'ai_image', 'transfer', 'offline_text', 'share_link'].includes(message.type)) {
                let fullMessageObject = { type: message.type };
                if (message.type === 'voice_message') fullMessageObject.content = message.content;
                else if (message.type === 'ai_image') fullMessageObject.description = message.content;
                else if (message.type === 'transfer') {
                    fullMessageObject.amount = message.amount;
                    fullMessageObject.note = message.note;
                } 
                else if (message.type === 'offline_text') {
                    if (message.content) {
                        fullMessageObject.content = message.content;
                    } else { 
                        fullMessageObject.dialogue = message.dialogue;
                        fullMessageObject.description = message.description;
                    }
                }
                else if (message.type === 'share_link') {
                    fullMessageObject.title = message.title;
                    fullMessageObject.description = message.description;
                    fullMessageObject.source_name = message.source_name;
                    fullMessageObject.content = message.content;
                }
                initialContent = JSON.stringify(fullMessageObject, null, 2);
            } 
            // 步骤3：处理其他所有普通情况
            else if (typeof message.content === 'object') {
                initialContent = JSON.stringify(message.content, null, 2);
            } else {
                initialContent = message.content;
            }
        
            // ==========================================================
            //            ★★★ 核心修复到此结束 ★★★
            // ==========================================================
        
            const firstBlock = createMessageEditorBlock(initialContent);
            editorContainer.appendChild(firstBlock);
        
            // (后续的按钮绑定逻辑保持不变)
            const addBtn = document.getElementById('add-message-editor-block-btn');
            const newAddBtn = addBtn.cloneNode(true);
            addBtn.parentNode.replaceChild(newAddBtn, addBtn);
            newAddBtn.addEventListener('click', () => {
                const newBlock = createMessageEditorBlock();
                editorContainer.appendChild(newBlock);
                newBlock.querySelector('textarea').focus();
            });
        
            const cancelBtn = document.getElementById('cancel-advanced-editor-btn');
            const newCancelBtn = cancelBtn.cloneNode(true);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
            newCancelBtn.addEventListener('click', () => {
                editorModal.classList.remove('visible');
            });
        
            const saveBtn = document.getElementById('save-advanced-editor-btn');
            const newSaveBtn = saveBtn.cloneNode(true);
            saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
            newSaveBtn.addEventListener('click', () => {
                saveEditedMessage(timestampToEdit); 
            });
        
            editorModal.classList.add('visible');
        }
        // ▲▲▲ 替换结束 ▲▲▲
        // ▲▲▲ 替换结束 ▲▲▲

        /**
         * 复制消息的文本内容到剪贴板
         */
        async function copyMessageContent() {
            if (!activeMessageTimestamp) return;
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
            if (!message) return;
        
            let textToCopy;
            // 【【【核心修复3：在这里也添加对 offline_text 的判断】】】
            if (message.type === 'offline_text') {
                // 如果是新格式，直接复制content
                if (message.content) {
                    textToCopy = message.content;
                } else { // 兼容旧格式
                    textToCopy = `「${message.dialogue || ''}」\n${message.description || ''}`;
                }
            } else if (typeof message.content === 'object') {
                textToCopy = JSON.stringify(message.content);
            } else {
                textToCopy = String(message.content);
            }
        
            try {
                await navigator.clipboard.writeText(textToCopy);
                await showCustomAlert('复制成功', '消息内容已复制到剪贴板。');
            } catch (err) {
                await showCustomAlert('复制失败', '无法访问剪贴板。');
            }
            
            hideMessageActions();
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        /**
         * 解析编辑后的文本，并返回一个标准化的消息片段对象
         * @param {string} text - 用户在编辑框中输入的文本
         * @returns {object} - 一个包含 type, content, 等属性的对象
         */
        function parseEditedContent(text) {
            const trimmedText = text.trim();
        
            // 1. 尝试解析为JSON对象（用于修复语音、转账等格式）
            if (trimmedText.startsWith('{') && trimmedText.endsWith('}')) {
                try {
                    const parsed = JSON.parse(trimmedText);
                    // 必须包含 type 属性才认为是有效格式
                    if (parsed.type) {
                        return parsed;
                    }
                } catch (e) { /* 解析失败，继续往下走 */ }
            }
            
            // 2. 尝试解析为表情包
            if (STICKER_REGEX.test(trimmedText)) {
                // 对于编辑的表情，我们暂时无法知道其`meaning`，所以只存URL
                return { type: 'sticker', content: trimmedText };
            }
        
            // 3. 否则，视为普通文本消息
            return { type: 'text', content: trimmedText };
        }
        
        
// ▼▼▼ 【最终修复版】请用这个全新的函数，完整替换旧的 saveEditedMessage 函数 ▼▼▼

/**
 * 【V4.0 | 终极修复版】保存编辑或拆分后的消息，并正确处理类型转换
 * @param {number} timestamp - 被编辑的原始消息的时间戳
 * @param {string|null} simpleContent - (可选) 如果是从简单编辑器传来，则为单个内容字符串
 */
async function saveEditedMessage(timestamp, simpleContent = null) {
    if (!timestamp) return;

    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;
    
    // 1. 获取原始消息的完整对象，这是继承发送者、时间戳等基础属性的关键
    const originalMessage = chat.history[messageIndex];

    let newMessages = [];

    // 根据是来自简单编辑器还是高级编辑器，获取内容块
    const blocks = simpleContent !== null 
        ? [simpleContent] 
        : Array.from(document.querySelectorAll('#message-editor-container textarea')).map(ta => ta.value);

    for (const rawContent of blocks) {
        if (!rawContent.trim()) continue;

        // 使用辅助函数解析每个编辑框的内容
        const parsedResult = parseEditedContent(rawContent.trim());
        
        // 2. 【【【这就是本次修复的核心！】】】
        //    先创建一个只包含最基础属性的副本，而不是全部复制！
        const newMessage = {
            role: originalMessage.role,
            senderName: originalMessage.senderName,
            timestamp: originalMessage.timestamp // 时间戳将在后面被重新分配
        };

        // 3. 根据解析出的新类型，智能地构建新的消息对象
        //    这确保了旧的、不相关的属性（如 .quote, .amount 等）不会被错误地继承
        switch (parsedResult.type) {
            case 'text':
                newMessage.type = 'text';
                newMessage.content = parsedResult.content;
                break;
            case 'offline_text':
                newMessage.type = 'offline_text';
                if (parsedResult.content) {
                    newMessage.content = parsedResult.content;
                } else { 
                    newMessage.dialogue = parsedResult.dialogue;
                    newMessage.description = parsedResult.description;
                }
                break;
            case 'quote_reply':
                newMessage.type = 'quote_reply';
                newMessage.content = parsedResult.reply_content;
                const originalQuotedMsg = chat.history.find(m => m.timestamp === parsedResult.target_timestamp);
                if (originalQuotedMsg) {
                    let originalSenderName = originalQuotedMsg.senderName;
                    if (originalQuotedMsg.role === 'user') {
                        originalSenderName = state.qzoneSettings.nickname || '{{user}}';
                    }
                    newMessage.quote = {
                        timestamp: parsedResult.target_timestamp,
                        senderName: originalSenderName,
                        content: String(originalQuotedMsg.content || '')
                    };
                } else {
                    newMessage.quote = {
                        timestamp: parsedResult.target_timestamp,
                        senderName: '未知用户',
                        content: '原始消息已删除或不存在'
                    };
                }
                break;
            case 'voice_message':
            case 'sticker':
            case 'ai_image':
            case 'user_photo':
                newMessage.type = parsedResult.type;
                newMessage.content = parsedResult.content || parsedResult.description;
                if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
                break;
            case 'transfer':
                newMessage.type = 'transfer';
                newMessage.amount = parsedResult.amount;
                newMessage.note = parsedResult.note;
                break;
            case 'share_link':
                newMessage.type = 'share_link';
                newMessage.title = parsedResult.title;
                newMessage.description = parsedResult.description;
                newMessage.source_name = parsedResult.source_name;
                newMessage.content = parsedResult.content;
                break;
            default:
                // 对于其他所有未知或复杂的类型，直接将解析结果作为消息主体
                Object.assign(newMessage, parsedResult);
                break;
        }
        
        newMessages.push(newMessage);
    }
    
    if (newMessages.length === 0) {
        document.getElementById('message-editor-modal').classList.remove('visible');
        return;
    }

    // 4. (后续的替换、重排时间戳、保存和刷新逻辑保持不变)
    //    用新构建的消息数组替换掉原来的那条消息
    chat.history.splice(messageIndex, 1, ...newMessages);
    
    // 重新分配时间戳以保证顺序
    let reassignTimestamp = timestamp;
    for (let i = messageIndex; i < chat.history.length; i++) {
        chat.history[i].timestamp = reassignTimestamp;
        reassignTimestamp++; 
    }
    
    await db.chats.put(chat);
    document.getElementById('message-editor-modal').classList.remove('visible');
    renderChatInterface(state.activeChatId);
    await showCustomAlert('成功', '消息已更新！');
}
// ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区的末尾 ▼▼▼
        
        /**
         * 当点击“…”时，显示动态操作菜单
         * @param {number} postId - 被操作的动态的ID
         */
        function showPostActions(postId) {
            activePostId = postId;
            document.getElementById('post-actions-modal').classList.add('visible');
        }
        
        /**
         * 隐藏动态操作菜单
         */
        function hidePostActions() {
            document.getElementById('post-actions-modal').classList.remove('visible');
            activePostId = null;
        }
        
        /**
         * 打开动态编辑器
         */
        async function openPostEditor() {
            if (!activePostId) return;
        
            const postIdToEdit = activePostId;
            const post = await db.qzonePosts.get(postIdToEdit);
            if (!post) return;
        
            hidePostActions();
        
            // 忠于原文：构建出最原始的文本形态供编辑
            let contentForEditing;
            if (post.type === 'shuoshuo') {
                contentForEditing = post.content;
            } else {
                // 对于图片和文字图，我们构建一个包含所有信息的对象
                const postObject = {
                    type: post.type,
                    publicText: post.publicText || '',
                };
                if (post.type === 'image_post') {
                    postObject.imageUrl = post.imageUrl;
                    postObject.imageDescription = post.imageDescription;
                } else if (post.type === 'text_image') {
                    postObject.hiddenContent = post.hiddenContent;
                }
                contentForEditing = JSON.stringify(postObject, null, 2);
            }
            
            // 构建格式助手按钮
            const templates = {
                shuoshuo: "在这里输入说说的内容...", // 对于说说，我们直接替换为纯文本
                image: { type: 'image_post', publicText: '', imageUrl: 'https://...', imageDescription: '' },
                text_image: { type: 'text_image', publicText: '', hiddenContent: '' }
            };
            
            const helpersHtml = `
                <div class="format-helpers">
                    <button class="format-btn" data-type="text">说说</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片动态</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.text_image)}'>文字图</button>
                </div>
            `;
        
            const newContent = await showCustomPrompt(
                '编辑动态',
                '在此修改内容...',
                contentForEditing,
                'textarea',
                helpersHtml
            );
            
            // 【特殊处理】为说说的格式助手按钮添加不同的行为
            // 我们需要在模态框出现后，再给它绑定事件
            setTimeout(() => {
                const shuoshuoBtn = document.querySelector('#custom-modal-body .format-btn[data-type="text"]');
                if(shuoshuoBtn) {
                    shuoshuoBtn.addEventListener('click', () => {
                        const input = document.getElementById('custom-prompt-input');
                        input.value = templates.shuoshuo;
                        input.focus();
                    });
                }
            }, 100);
        
            if (newContent !== null) {
                await saveEditedPost(postIdToEdit, newContent);
            }
        }
        
        /**
         * 保存编辑后的动态
         * @param {number} postId - 要保存的动态ID
         * @param {string} newRawContent - 从编辑器获取的新内容
         */
        async function saveEditedPost(postId, newRawContent) {
            const post = await db.qzonePosts.get(postId);
            if (!post) return;
        
            const trimmedContent = newRawContent.trim();
            
            // 尝试解析为JSON，如果失败，则认为是纯文本（说说）
            try {
                const parsed = JSON.parse(trimmedContent);
                // 更新帖子属性
                post.type = parsed.type || 'image_post';
                post.publicText = parsed.publicText || '';
                post.imageUrl = parsed.imageUrl || '';
                post.imageDescription = parsed.imageDescription || '';
                post.hiddenContent = parsed.hiddenContent || '';
                post.content = ''; // 清空旧的说说内容字段
            } catch (e) {
                // 解析失败，认为是说说
                post.type = 'shuoshuo';
                post.content = trimmedContent;
                // 清空其他类型的字段
                post.publicText = '';
                post.imageUrl = '';
                post.imageDescription = '';
                post.hiddenContent = '';
            }
            
            await db.qzonePosts.put(post);
            await renderQzonePosts(); // 重新渲染列表
            await showCustomAlert('成功', '动态已更新！');
        }
        
        /**
         * 复制动态内容
         */
        async function copyPostContent() {
            if (!activePostId) return;
            const post = await db.qzonePosts.get(activePostId);
            if (!post) return;
            
            let textToCopy = post.content || post.publicText || post.hiddenContent || post.imageDescription || "（无文字内容）";
            
            try {
                await navigator.clipboard.writeText(textToCopy);
                await showCustomAlert('复制成功', '动态内容已复制到剪贴板。');
            } catch (err) {
                await showCustomAlert('复制失败', '无法访问剪贴板。');
            }
            
            hidePostActions();
        }
        
        // ▼▼▼ 【全新】创建群聊与拉人功能核心函数 ▼▼▼
        let selectedContacts = new Set();
        
        async function openContactPickerForGroupCreate() {
    // 弹出选择菜单，让用户决定创建哪种群聊
    const choice = await showChoiceModal('创建群聊', [
        { text: '创建普通群聊 (我参与)', value: 'normal' },
        { text: '创建旁观群聊 (我围观)', value: 'spectator' }
    ]);

    if (choice === 'normal') {
        // 如果选择普通群聊，执行旧的逻辑
        selectedContacts.clear();
        const confirmBtn = document.getElementById('confirm-contact-picker-btn');
        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        newConfirmBtn.addEventListener('click', handleCreateGroup);
        await renderContactPicker();
        showScreen('contact-picker-screen');

    } else if (choice === 'spectator') {
        // 如果选择旁观群聊，执行新的逻辑
        openSpectatorGroupCreator();
    }
}
        // ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新】这是旁观模式群聊创建功能的核心代码 ▼▼▼

/**
 * 【全新】打开“旁观模式群聊”的成员选择器
 */
async function openSpectatorGroupCreator() {
    selectedContacts.clear(); // 清空上次的选择

    // 1. 修改“完成”按钮的行为，让它在点击后调用我们新的创建函数
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleCreateSpectatorGroup);

    // 2. 渲染一个包含所有角色和NPC的联系人列表
    await renderSpectatorContactPicker();

    // 3. 切换到联系人选择屏幕
    showScreen('contact-picker-screen');
}

/**
 * 【全新】为“旁观模式”渲染一个特殊的联系人列表，包含所有角色和NPC
 */
async function renderSpectatorContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';

    // a. 获取所有单聊角色
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);
    // b. 从数据库获取所有NPC
    const npcs = await db.npcs.toArray();

    if (characters.length === 0 && npcs.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">还没有任何角色或NPC可以加入群聊。</p>';
        return;
    }

    // c. 渲染角色列表
    characters.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = contact.id; // 使用角色的聊天ID
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name} <small style="color:#888;">(角色)</small></span>
        `;
        listEl.appendChild(item);
    });

    // d. 渲染NPC列表
    npcs.forEach(npc => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = npc.id; // 使用NPC的ID
        item.dataset.isNpc = "true";     // 添加一个特殊标记
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
            <span class="name">${npc.name} <small style="color:#007722;">(NPC)</small></span>
        `;
        listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
}

/**
 * 【全新】处理创建“旁观模式群聊”的最终逻辑
 */
async function handleCreateSpectatorGroup() {
    if (selectedContacts.size < 2) {
        alert("旁观群聊至少需要选择2个成员。");
        return;
    }

    const groupName = await showCustomPrompt('设置群名', '请输入群聊的名字', 'AI们的茶话会');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];
    const allNpcs = await db.npcs.toArray(); // 提前获取所有NPC数据

    for (const contactId of selectedContacts) {
        const isNpc = document.querySelector(`.contact-picker-item[data-contact-id="${contactId}"]`).dataset.isNpc === "true";

        if (isNpc) {
            // 如果是NPC
            const npcData = allNpcs.find(n => n.id === parseInt(contactId));
            if (npcData) {
                members.push({
                    id: `npc_${npcData.id}`, // 给NPC一个独特的成员ID
                    originalName: npcData.name,
                    groupNickname: npcData.name,
                    persona: npcData.persona,
                    avatar: npcData.avatar || defaultGroupMemberAvatar,
                    isNpc: true
                });
            }
        } else {
            // 如果是普通角色
            const contactChat = state.chats[contactId];
            if (contactChat) {
                members.push({
                    id: contactId,
                    originalName: contactChat.originalName,
                    groupNickname: contactChat.name,
                    persona: contactChat.settings.aiPersona,
                    avatar: contactChat.settings.aiAvatar || defaultAvatar,
                    isNpc: false
                });
            }
        }
    }

    const newGroupChat = {
        id: newChatId,
        name: groupName.trim(),
        isGroup: true,
        isSpectatorGroup: true, // ★★★ 这就是我们的核心标记！★★★
        members: members,
        settings: {
            // 在旁观模式下，我们不需要“我”的人设和头像
            maxMemory: 10,
            groupAvatar: defaultGroupAvatar,
            background: '',
            theme: 'default',
            fontSize: 13,
            customCss: '',
            linkedWorldBookIds: [],
        },
        history: [{ // 添加一条初始系统消息，告诉AI它们的任务
            role: 'system',
            content: '[系统指令：这是一个没有用户参与的群聊，请你们根据各自的人设自由地开始对话。]',
            timestamp: Date.now(),
            isHidden: true
        }],
        musicData: { totalTime: 0 }
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);

    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId);
}
// ▲▲▲ 全新JS代码粘贴结束 ▲▲▲        
/**
 * 【全新 | 支持NPC】渲染一个包含所有可选联系人（角色+NPC）的列表
 */
async function renderContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';

    // 1. 同时获取所有单聊角色和所有NPC
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);
    const npcs = await db.npcs.toArray();

    if (characters.length === 0 && npcs.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">还没有可以拉进群的联系人哦~</p>';
        return;
    }

    // 2. 渲染角色列表
    characters.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = contact.id; // 使用角色的聊天ID
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name} <small style="color:#888;">(角色)</small></span>
        `;
        listEl.appendChild(item);
    });
    
    // 3. 渲染NPC列表
    npcs.forEach(npc => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        // 使用 "npc_" 前缀创建唯一ID，以便后续区分
        item.dataset.contactId = `npc_${npc.id}`; 
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
            <span class="name">${npc.name} <small style="color:#007722;">(NPC)</small></span>
        `;
        listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
}
        
        /**
         * 更新“完成”按钮的计数
         */
        function updateContactPickerConfirmButton() {
            const btn = document.getElementById('confirm-contact-picker-btn');
            btn.textContent = `完成(${selectedContacts.size})`;
            btn.disabled = selectedContacts.size < 2; // 至少需要2个人才能创建群聊
        }
        
/**
 * 【全新 | 支持NPC】处理创建群聊的最终逻辑
 */
async function handleCreateGroup() {
    if (selectedContacts.size < 2) {
        alert("创建群聊至少需要选择2个联系人。");
        return;
    }

    const groupName = await showCustomPrompt('设置群名', '请输入群聊的名字', '我们的群聊');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];
    const allNpcs = await db.npcs.toArray(); // 提前获取所有NPC数据，提高效率

    for (const contactId of selectedContacts) {
        // 检查ID前缀，判断是NPC还是角色
        if (contactId.startsWith('npc_')) {
            const npcId = parseInt(contactId.replace('npc_', ''));
            const npcData = allNpcs.find(n => n.id === npcId);
            if (npcData) {
                members.push({
                    id: contactId, // 保留带前缀的唯一ID
                    originalName: npcData.name,
                    groupNickname: npcData.name,
                    persona: npcData.persona,
                    avatar: npcData.avatar || defaultGroupMemberAvatar,
                    isNpc: true // 标记为NPC
                });
            }
        } else { // 如果不是NPC，就是普通角色
            const contactChat = state.chats[contactId];
            if (contactChat) {
                members.push({
                    id: contactId,
                    originalName: contactChat.originalName,
                    groupNickname: contactChat.name,
                    persona: contactChat.settings.aiPersona,
                    avatar: contactChat.settings.aiAvatar || defaultAvatar,
                    isNpc: false // 标记为非NPC
                });
            }
        }
    }

    const newGroupChat = {
        id: newChatId,
        name: groupName.trim(),
        isGroup: true,
        members: members,
        settings: {
            myPersona: '我是谁呀。',
            myNickname: '我',
            maxMemory: 10,
            groupAvatar: defaultGroupAvatar,
            myAvatar: defaultMyGroupAvatar,
            background: '',
            theme: 'default',
            fontSize: 13,
            customCss: '',
            linkedWorldBookIds: [],
        },
        history: [],
        musicData: { totalTime: 0 }
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);
    
    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId); 
}
        
        // ▼▼▼ 【全新】群成员管理核心函数 ▼▼▼
        
        /**
         * 打开群成员管理屏幕
         */
        function openMemberManagementScreen() {
            if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) return;
            renderMemberManagementList();
            showScreen('member-management-screen');
        }
        
        function renderMemberManagementList() {
            const listEl = document.getElementById('member-management-list');
            const chat = state.chats[state.activeChatId];
            listEl.innerHTML = '';
        
            chat.members.forEach(member => {
                const item = document.createElement('div');
                item.className = 'member-management-item';
                // 【核心修正】在这里，我们将显示的名称从 member.name 改为 member.groupNickname
                item.innerHTML = `
                    <img src="${member.avatar}" class="avatar">
                    <span class="name">${member.groupNickname}</span>
                    <button class="remove-member-btn" data-member-id="${member.id}" title="移出群聊">-</button>
                `;
                listEl.appendChild(item);
            });
        }
        
        /**
         * 从群聊中移除一个成员
         * @param {string} memberId - 要移除的成员ID
         */
        async function removeMemberFromGroup(memberId) {
            const chat = state.chats[state.activeChatId];
            const memberIndex = chat.members.findIndex(m => m.id === memberId);
            
            if (memberIndex === -1) return;
            
            // 安全检查，群聊至少保留2人
            if (chat.members.length <= 2) {
                alert("群聊人数不能少于2人。");
                return;
            }
            
        const memberName = chat.members[memberIndex].groupNickname; // <-- 修复：使用 groupNickname
            const confirmed = await showCustomConfirm(
                '移出成员',
                `确定要将“${memberName}”移出群聊吗？`,
                { confirmButtonClass: 'btn-danger' }
            );
        
            if (confirmed) {
                chat.members.splice(memberIndex, 1);
                await db.chats.put(chat);
                renderMemberManagementList(); // 刷新成员管理列表
                document.getElementById('chat-settings-btn').click(); // 【核心修正】模拟点击设置按钮，强制刷新整个弹窗
            }
        }
        
/**
 * 【总入口 | V2.0】打开联系人选择器，用于拉人入群（现在会同时显示角色和NPC）
 */
async function openContactPickerForAddMember() {
    // 1. 为“完成”按钮绑定正确的处理函数
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // 使用克隆节点技巧，确保每次都绑定最新的事件，防止重复执行
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleAddMembersToGroup);
    
    // 2. 渲染一个包含所有可选联系人的列表
    await renderUnifiedContactPicker();
    
    // 3. 显示选择器屏幕
    showScreen('contact-picker-screen');
}

/**
 * 【全新】渲染一个统一的联系人选择列表，包含角色和NPC
 */
async function renderUnifiedContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';
    selectedContacts.clear(); // 清空上次的选择

    const chat = state.chats[state.activeChatId];
    const existingMemberIds = new Set(chat.members.map(m => m.id));

    // a. 获取所有可选的 “角色” (排除自己和已在群内的)
    const characters = Object.values(state.chats).filter(c => !c.isGroup && !existingMemberIds.has(c.id));
    
    // b. 获取所有可选的 “NPC” (排除已在群内的)
    const npcs = (await db.npcs.toArray()).filter(n => !existingMemberIds.has(`npc_${n.id}`));

    if (characters.length === 0 && npcs.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">没有更多可以邀请的联系人了。</p>';
        document.getElementById('confirm-contact-picker-btn').style.display = 'none';
    } else {
        document.getElementById('confirm-contact-picker-btn').style.display = 'block';
        
        // 渲染角色列表
        characters.forEach(contact => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.dataset.contactId = contact.id;
            item.dataset.contactType = 'character'; // 标记为角色
            item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${contact.name} <small style="color:#888;">(角色)</small></span>
            `;
            listEl.appendChild(item);
        });

        // 渲染NPC列表
        npcs.forEach(npc => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.dataset.contactId = `npc_${npc.id}`; // 使用带前缀的唯一ID
            item.dataset.contactType = 'npc'; // 标记为NPC
            item.dataset.npcId = npc.id; // 保存原始NPC ID
            item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
                <span class="name">${npc.name} <small style="color:#007722;">(NPC)</small></span>
            `;
            listEl.appendChild(item);
        });
    }

    updateContactPickerConfirmButton();
}
        
// ▼▼▼ 【V2.1 | 头像修复版】请用这个新版本替换旧的 handleAddMembersToGroup 函数 ▼▼▼
/**
 * 【核心处理 | V2.1】处理将选中的联系人（角色或NPC）加入群聊的逻辑
 */
async function handleAddMembersToGroup() {
    if (selectedContacts.size === 0) {
        alert("请至少选择一个要添加的联系人。");
        return;
    }
    
    const chat = state.chats[state.activeChatId];
    const allNpcs = await db.npcs.toArray(); // 提前获取所有NPC数据

    for (const contactId of selectedContacts) {
        const itemEl = document.querySelector(`.contact-picker-item[data-contact-id="${contactId}"]`);
        if (!itemEl) continue;

        const contactType = itemEl.dataset.contactType;

        if (contactType === 'character') {
            const contactChat = state.chats[contactId];
            if (contactChat) {
                chat.members.push({
                    id: contactId,
                    originalName: contactChat.originalName,
                    groupNickname: contactChat.name,
                    persona: contactChat.settings.aiPersona,
                    // 【核心修正】确保新加入的角色也能获取到正确的头像
                    avatar: contactChat.settings.aiAvatar || defaultAvatar,
                    isNpc: false // 标记这不是一个纯NPC
                });
            }
        } else if (contactType === 'npc') {
            const npcId = parseInt(itemEl.dataset.npcId);
            const npcData = allNpcs.find(n => n.id === npcId);
            if (npcData) {
                // 【【【这就是最关键的修复！】】】
                // 在这里，我们把 npcData.avatar 也一并添加到了成员对象中
                chat.members.push({
                    id: `npc_${npcId}`,
                    originalName: npcData.name,
                    groupNickname: npcData.name,
                    persona: npcData.persona,
                    avatar: npcData.avatar || defaultGroupMemberAvatar, // <-- 核心新增
                    isNpc: true
                });
            }
        }
    }

    await db.chats.put(chat);
    
    // 操作完成后，返回成员管理屏幕
    openMemberManagementScreen();
}
// ▲▲▲ 替换结束 ▲▲▲
        
/**
 * 【重构版】点击“创建新成员”按钮，现在会打开NPC编辑器
 */
function createNewMemberInGroup() {
    // 1. 设置一个全局标志，告诉 saveNpc 函数我们当前的意图
    isAddingNpcToGroup = true; 
    // 2. 直接打开通用的NPC编辑器
    openNpcEditor(null);
}

        
        // ▼▼▼ 【全新】外卖请求倒计时函数 ▼▼▼
        function startWaimaiCountdown(element, endTime) {
            const timerId = setInterval(() => {
                const now = Date.now();
                const distance = endTime - now;
        
                if (distance < 0) {
                    clearInterval(timerId);
                    element.innerHTML = '<span>已</span><span>超</span><span>时</span>';
                    return;
                }
        
                const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);
                
                const minStr = String(minutes).padStart(2, '0');
                const secStr = String(seconds).padStart(2, '0');
        
                element.innerHTML = `<span>${minStr.charAt(0)}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(0)}</span><span>${secStr.charAt(1)}</span>`;
            }, 1000);
            return timerId;
        }
        
        function cleanupWaimaiTimers() {
            for (const timestamp in waimaiTimers) {
                clearInterval(waimaiTimers[timestamp]);
            }
            waimaiTimers = {};
        }
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 【最终修复版】请用这个全新的函数，完整替换旧的 showWaimaiDetails 函数 ▼▼▼

/**
 * 【全新 V3.0 | 昵称修复版】显示外卖卡片的详细信息
 * @param {number} timestamp - 被点击的外卖卡片消息的时间戳
 */
async function showWaimaiDetails(timestamp) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const message = chat.history.find(m => m.timestamp === timestamp);
    
    if (!message || !['waimai_request', 'waimai_order'].includes(message.type)) {
        console.error("showWaimaiDetails: 找不到消息或消息类型不正确", timestamp);
        return;
    }
    
    let detailsHtml = '';

    if (message.type === 'waimai_request') {
        // (处理“代付请求”卡片的逻辑保持不变)
        let statusText;
        switch(message.status) {
            case 'paid':
                const payerName = message.paidBy || '对方';
                const payerDisplayName = getDisplayNameInGroup(chat, payerName);
                statusText = `由 ${payerDisplayName} 为您代付成功`;
                break;
            case 'rejected':
                statusText = '代付请求已被拒绝';
                break;
            default:
                statusText = '等待对方处理';
                break;
        }
        detailsHtml = `
            <div style="text-align: left; font-size: 15px; line-height: 1.8;">
                <strong>商品:</strong> ${message.productInfo}<br>
                <strong>金额:</strong> ¥${Number(message.amount).toFixed(2)}<br>
                <strong>状态:</strong> ${statusText}
            </div>
        `;
    } else if (message.type === 'waimai_order') {
        // --- 核心修复：智能判断赠送方和接收方的显示名称 ---
        let senderDisplayName;
        let recipientDisplayName;

        if (chat.isGroup) {
            // 如果是群聊，统一使用 getDisplayNameInGroup 函数来获取正确的群昵称
            senderDisplayName = getDisplayNameInGroup(chat, message.senderName);
            recipientDisplayName = getDisplayNameInGroup(chat, message.recipientName);
        } else {
            // 如果是单聊，根据消息是谁发的来判断
            if (message.role === 'user') {
                // 如果是用户发的，赠送方是"我"，接收方是AI
                senderDisplayName = chat.settings.myNickname || '我';
                recipientDisplayName = chat.name; // chat.name 就是AI的备注名
            } else {
                // 如果是AI发的，赠送方是AI，接收方是"我"
                senderDisplayName = chat.name;
                recipientDisplayName = chat.settings.myNickname || '我';
            }
        }
        // --- 修复结束 ---

        detailsHtml = `
            <div style="text-align: left; font-size: 15px; line-height: 1.8;">
                <strong>订单类型:</strong> 为TA点单<br>
                <strong>赠送方:</strong> ${senderDisplayName}<br>
                <strong>接收方:</strong> ${recipientDisplayName}<br>
                <strong>商品:</strong> ${message.productInfo}<br>
                <strong>金额:</strong> ¥${Number(message.amount).toFixed(2)}
            </div>
        `;
    }

    await showCustomAlert("订单详情", detailsHtml);
}

// ▲▲▲ 替换结束 ▲▲▲
        async function handleWaimaiResponse(originalTimestamp, choice) {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
            if (messageIndex === -1) return;
        
            // 1. 更新原始消息的状态
            const originalMessage = chat.history[messageIndex];
            originalMessage.status = choice;
            
            // 【核心修正】记录支付者，并构建对AI更清晰的系统消息
            let systemContent;
            const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
            
            if (choice === 'paid') {
                originalMessage.paidBy = myNickname; // 记录是用户付的钱
                systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
            } else {
                systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
            }
        
            // 2. 创建一条新的、对用户隐藏的系统消息，告知AI结果
            const systemNote = {
                role: 'system',
                content: systemContent,
                timestamp: Date.now(),
                isHidden: true
            };
            chat.history.push(systemNote);
        
            // 3. 保存更新到数据库并刷新UI
            await db.chats.put(chat);
            renderChatInterface(state.activeChatId);  
        }
        
        let videoCallState = {
            isActive: false,       
            isAwaitingResponse: false, 
            isGroupCall: false,      
            activeChatId: null,    
            initiator: null,       
            startTime: null,       
            participants: [],      
            isUserParticipating: true,
            // --- 【核心新增】---
            callHistory: [], // 用于存储通话中的对话历史
            preCallContext: "" // 用于存储通话前的聊天摘要
        };
        
        let callTimerInterval = null; // 用于存储计时器的ID
        
        /**
         * 【总入口】用户点击“发起视频通话”或“发起群视频”按钮
         */
        async function handleInitiateCall() {
            if (!state.activeChatId || videoCallState.isActive || videoCallState.isAwaitingResponse) return;
        
            const chat = state.chats[state.activeChatId];
            videoCallState.isGroupCall = chat.isGroup;
            videoCallState.isAwaitingResponse = true;
            videoCallState.initiator = 'user';
            videoCallState.activeChatId = chat.id;
            videoCallState.isUserParticipating = true; // 用户自己发起的，当然是参与者
        
            // 根据是单聊还是群聊，显示不同的呼叫界面
            if (chat.isGroup) {
                document.getElementById('outgoing-call-avatar').src = chat.settings.myAvatar || defaultMyGroupAvatar;
                document.getElementById('outgoing-call-name').textContent = chat.settings.myNickname || '我';
            } else {
                document.getElementById('outgoing-call-avatar').src = chat.settings.aiAvatar || defaultAvatar;
                document.getElementById('outgoing-call-name').textContent = chat.name;
            }
            document.querySelector('#outgoing-call-screen .caller-text').textContent = chat.isGroup ? "正在呼叫所有成员..." : "正在呼叫...";
            showScreen('outgoing-call-screen');
            
            // 准备并发送系统消息给AI
            const requestMessage = {
                role: 'system',
                content: chat.isGroup 
                    ? `[系统提示：用户 (${chat.settings.myNickname || '我'}) 发起了群视频通话请求。请你们各自决策，并使用 "group_call_response" 指令，设置 "decision" 为 "join" 或 "decline" 来回应。]`
                    : `[系统提示：用户向你发起了视频通话请求。请根据你的人设，使用 "video_call_response" 指令，并设置 "decision" 为 "accept" 或 "reject" 来回应。]`,
                timestamp: Date.now(),
                isHidden: true,
            };
            chat.history.push(requestMessage);
            await db.chats.put(chat);
            
            // 触发AI响应
            await triggerAiResponse();
        }
        
        
        function startVideoCall() {
            const chat = state.chats[videoCallState.activeChatId];
            if (!chat) return;
        
            videoCallState.isActive = true;
            videoCallState.isAwaitingResponse = false;
            videoCallState.startTime = Date.now();
            videoCallState.callHistory = []; // 【新增】清空上一次通话的历史
        
            // --- 【核心新增：抓取通话前上下文】---
            const preCallHistory = chat.history.slice(-10); // 取最后10条作为上下文
            videoCallState.preCallContext = preCallHistory.map(msg => {
                const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
                return `${sender}: ${String(msg.content).substring(0, 50)}...`;
            }).join('\n');
            // --- 新增结束 ---
        
            updateParticipantAvatars(); 
            
            document.getElementById('video-call-main').innerHTML = `<em>${videoCallState.isGroupCall ? '群聊已建立...' : '正在接通...'}</em>`;
            showScreen('video-call-screen');
        
            document.getElementById('user-speak-btn').style.display = videoCallState.isUserParticipating ? 'block' : 'none';
            document.getElementById('join-call-btn').style.display = videoCallState.isUserParticipating ? 'none' : 'block';
        
            if (callTimerInterval) clearInterval(callTimerInterval);
            callTimerInterval = setInterval(updateCallTimer, 1000);
            updateCallTimer();
        
            triggerAiInCallAction();
        }
        
/**
 * 【核心 | V3.0 终极总结修复版】结束视频通话
 */
async function endVideoCall() {
    if (!videoCallState.isActive) return;

    const duration = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const durationText = `${Math.floor(duration / 60)}分${duration % 60}秒`;
    const endCallText = `通话结束，时长 ${durationText}`;

    const chat = state.chats[videoCallState.activeChatId];
    if (chat) {
        // 1. 保存完整的通话记录到数据库 (这部分逻辑不变，非常重要)
        const participantsData = [];
        if (videoCallState.isGroupCall) {
            videoCallState.participants.forEach(p => participantsData.push({ name: p.originalName, avatar: p.avatar }));
            if (videoCallState.isUserParticipating) {
                participantsData.unshift({ name: chat.settings.myNickname || '我', avatar: chat.settings.myAvatar || defaultMyGroupAvatar });
            }
        } else {
            participantsData.push({ name: chat.name, avatar: chat.settings.aiAvatar || defaultAvatar });
            participantsData.unshift({ name: '我', avatar: chat.settings.myAvatar || defaultAvatar });
        }

        const callRecord = {
            chatId: videoCallState.activeChatId,
            timestamp: Date.now(),
            duration: duration,
            participants: participantsData,
            transcript: [...videoCallState.callHistory]
        };
        await db.callRecords.add(callRecord);
        console.log("通话记录已保存:", callRecord);
        
        // 2. 在聊天记录里添加对用户可见的“通话结束”消息 (逻辑不变)
        let summaryMessage = {
            role: videoCallState.initiator === 'user' ? 'user' : 'assistant',
            content: endCallText,
            timestamp: Date.now(),
        };
        if (chat.isGroup && summaryMessage.role === 'assistant') {
            summaryMessage.senderName = videoCallState.callRequester || chat.members[0]?.originalName || chat.name;
        }
        chat.history.push(summaryMessage);

        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        //            这就是本次修改的核心所在！
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        
        // 3. 【全新】将完整的通话记录“翻译”成一段AI能理解的文本
        const callTranscriptForAI = videoCallState.callHistory.map(h => {
            const sender = h.role === 'user' ? (chat.settings.myNickname || '我') : h.senderName;
            return `${sender}: ${h.content}`;
        }).join('\n');
        
        // 4. 【全新】在后台调用总结函数，它会自动处理API调用和记忆存储
        // 我们在这里不使用 await，让它在后台静默执行，不阻塞UI
        summarizeCallTranscript(chat.id, callTranscriptForAI);

        // 5. 【全新】创建一个对用户隐藏的、简短的系统消息，让AI对通话结束这件事本身做出反应
        const hiddenReactionInstruction = {
            role: 'system',
            content: `[系统指令：视频通话刚刚结束。请你以角色的口吻，向用户主动发送一两条消息，来自然地总结这次通话的要点、确认达成的约定，或者表达你的感受。]`,
            timestamp: Date.now() + 1, // 确保时间戳在“通话结束”消息之后
            isHidden: true // 这个标记确保用户看不到这条指令
        };
        chat.history.push(hiddenReactionInstruction);

        // 6. 保存所有更新到数据库
        await db.chats.put(chat);
    }
    
    // 7. 清理和重置状态 (逻辑不变)
    clearInterval(callTimerInterval);
    callTimerInterval = null;
    videoCallState = { isActive: false, isAwaitingResponse: false, isGroupCall: false, activeChatId: null, initiator: null, startTime: null, participants: [], isUserParticipating: true, callHistory: [], preCallContext: "" };
    
    // 8. 返回聊天界面，并触发AI对通话结束的反应
    if (chat) {
        openChat(chat.id);
        triggerAiResponse();
    }
}
        // ▲▲▲ 替换结束 ▲▲▲
        
        /**
         * 【全新】更新通话界面的参与者头像网格
         */
        function updateParticipantAvatars() {
            const grid = document.getElementById('participant-avatars-grid');
            grid.innerHTML = '';
            const chat = state.chats[videoCallState.activeChatId];
            if (!chat) return;
        
            let participantsToRender = [];
        
            // ★ 核心修正：区分群聊和单聊
            if (videoCallState.isGroupCall) {
                // 群聊逻辑：显示所有已加入的AI成员
                participantsToRender = [...videoCallState.participants];
                // 如果用户也参与了，就把用户信息也加进去
                if (videoCallState.isUserParticipating) {
                    participantsToRender.unshift({
                        id: 'user',
                        name: chat.settings.myNickname || '我',
                        avatar: chat.settings.myAvatar || defaultMyGroupAvatar
                    });
                }
            } else {
                // 单聊逻辑：只显示对方的头像和名字
                participantsToRender.push({
                    id: 'ai',
                    name: chat.name,
                    avatar: chat.settings.aiAvatar || defaultAvatar
                });
            }
            
            participantsToRender.forEach(p => {
                const wrapper = document.createElement('div');
                wrapper.className = 'participant-avatar-wrapper';
                wrapper.dataset.participantId = p.id;
        const displayName = p.groupNickname || p.name; // <-- 核心修复在这里
        wrapper.innerHTML = `
            <img src="${p.avatar}" class="participant-avatar" alt="${displayName}">
            <div class="participant-name">${displayName}</div>
        `;
                grid.appendChild(wrapper);
            });
        }
        
        /**
         * 【全新】处理用户加入/重新加入通话
         */
        function handleUserJoinCall() {
            if (!videoCallState.isActive || videoCallState.isUserParticipating) return;
            
            videoCallState.isUserParticipating = true;
            updateParticipantAvatars(); // 更新头像列表，加入用户
        
            // 切换底部按钮
            document.getElementById('user-speak-btn').style.display = 'block';
            document.getElementById('join-call-btn').style.display = 'none';
        
            // 告知AI用户加入了
            triggerAiInCallAction("[系统提示：用户加入了通话]");
        }
        
        
        /**
         * 更新通话计时器显示 (保持不变)
         */
        function updateCallTimer() {
            if (!videoCallState.isActive) return;
            const elapsed = Math.floor((Date.now() - videoCallState.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('call-timer').textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        
        // ▼▼▼ 用这个完整函数替换旧的 showIncomingCallModal ▼▼▼
        function showIncomingCallModal() {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            // 根据是否群聊显示不同信息
            if (chat.isGroup) {
                // 从 videoCallState 中获取是哪个成员发起的通话
                const requesterName = videoCallState.callRequester || chat.members[0]?.name || '一位成员';
                document.getElementById('caller-avatar').src = chat.settings.groupAvatar || defaultGroupAvatar;
                document.getElementById('caller-name').textContent = chat.name; // 显示群名
                document.querySelector('.incoming-call-content .caller-text').textContent = `${requesterName} 邀请你加入群视频`; // 显示具体发起人
            } else {
                // 单聊逻辑保持不变
                document.getElementById('caller-avatar').src = chat.settings.aiAvatar || defaultAvatar;
                document.getElementById('caller-name').textContent = chat.name;
                document.querySelector('.incoming-call-content .caller-text').textContent = '邀请你视频通话';
            }
            
            document.getElementById('incoming-call-modal').classList.add('visible');
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        /**
         * 隐藏AI发起的通话请求模态框 (保持不变)
         */
        function hideIncomingCallModal() {
            document.getElementById('incoming-call-modal').classList.remove('visible');
        }
        
        // ▼▼▼ 【请用这个新版本】替换旧的 triggerAiInCallAction 函数 ▼▼▼
        async function triggerAiInCallAction(userInput = null) {
            if (!videoCallState.isActive) return;
        
            const chat = state.chats[videoCallState.activeChatId];
            const { proxyUrl, apiKey, model } = state.apiConfig;
            const callFeed = document.getElementById('video-call-main');
            const userNickname = chat.settings.myNickname || '我';
        
            let worldBookContent = '';
            if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
                const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                    const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                    return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
                }).filter(Boolean).join('');
                if (linkedContents) {
                    worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
                }
            }
        
            // 1. 如果用户有输入，先渲染并存入通话历史
            if (userInput && videoCallState.isUserParticipating) {
                const userTimestamp = Date.now(); // 【核心修改】生成时间戳
                const userBubble = document.createElement('div');
                userBubble.className = 'call-message-bubble user-speech';
                userBubble.textContent = userInput;
                userBubble.dataset.timestamp = userTimestamp; // 【核心修改】将时间戳存入DOM
                addLongPressListener(userBubble, () => showCallMessageActions(userTimestamp)); // 【核心修改】绑定长按事件
                callFeed.appendChild(userBubble);
                callFeed.scrollTop = callFeed.scrollHeight;
                videoCallState.callHistory.push({ role: 'user', content: userInput, timestamp: userTimestamp }); // 【核心修改】将带时间戳的消息存入历史
            }
        
            // 2. 构建全新的、包含完整上下文的 System Prompt
            let inCallPrompt;
            if (videoCallState.isGroupCall) {
                const participantNames = videoCallState.participants.map(p => p.name);
                if(videoCallState.isUserParticipating) {
                    participantNames.unshift(userNickname);
                }
                inCallPrompt = `
        # 你的任务
        你是一个群聊视频通话的导演。你的任务是扮演所有【除了用户以外】的AI角色，并以【第三人称旁观视角】来描述他们在通话中的所有动作和语言。
        # 核心规则
        1.  **【【【身份铁律】】】**: 用户的身份是【${userNickname}】。你【绝对不能】生成 \`name\` 字段为 **"${userNickname}"** 的发言。
        2.  **【【【视角铁律】】】**: 你的回复【绝对不能】使用第一人称“我”。
        3.  **格式**: 你的回复【必须】是一个JSON数组，每个对象代表一个角色的发言，格式为：\`{"name": "角色名", "speech": "*他笑了笑* 大家好啊！"}\`。
        4.  **角色扮演**: 严格遵守每个角色的设定。
        # 当前情景
        你们正在一个群视频通话中。
        **通话前的聊天摘要**:
        ${videoCallState.preCallContext}
        **当前参与者**: ${participantNames.join('、 ')}。
        **通话刚刚开始...**
        ${worldBookContent} // <-- 【核心】注入世界书
        现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
        `;
            } else { 
                let openingContext = videoCallState.initiator === 'user'
                    ? `你刚刚接听了用户的视频通话请求。`
                    : `用户刚刚接听了你主动发起的视频通话。`;
                inCallPrompt = `
        # 你的任务
        你现在是一个场景描述引擎。你的任务是扮演 ${chat.name} (${chat.settings.aiPersona})，并以【第三人称旁观视角】来描述TA在视频通话中的所有动作和语言。
        # 核心规则
        1.  **【【【视角铁律】】】**: 你的回复【绝对不能】使用第一人称“我”。必须使用第三人称，如“他”、“她”、或直接使用角色名“${chat.name}”。
        2.  **格式**: 你的回复【必须】是一段描述性的文本。
        # 当前情景
        你正在和用户（${userNickname}，人设: ${chat.settings.myPersona}）进行视频通话。
        **${openingContext}**
        **通话前的聊天摘要 (这是你们通话的原因，至关重要！)**:
        ${videoCallState.preCallContext}
        现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
        `;
            }
            
            // 3. 构建发送给API的 messages 数组
            const messagesForApi = [
                { role: 'system', content: inCallPrompt },
                ...videoCallState.callHistory.map(h => ({ role: h.role, content: h.content }))
            ];
        
            if (videoCallState.callHistory.length === 0) {
                const firstLineTrigger = videoCallState.initiator === 'user' ? `*你按下了接听键...*` : `*对方按下了接听键...*`;
                messagesForApi.push({ role: 'user', content: firstLineTrigger });
            }
            
                try {
                    let  isGemini = proxyUrl === GEMINI_API_URL;
                    let geminiConfig = toGeminiRequestData(model,apiKey,inCallPrompt, messagesForApi)
                    const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({
                            model: model, messages: messagesForApi, temperature: state.globalSettings.apiTemperature || 0.8
                        })
                    });
                    if (!response.ok) throw new Error((await response.json()).error.message);
        
                    const data = await response.json();
                    const aiResponse = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
        
                    const connectingElement = callFeed.querySelector('em');
                    if (connectingElement) connectingElement.remove();
        
                // 4. 处理AI返回的内容，并将其存入通话历史
                if (videoCallState.isGroupCall) {
                    const speechArray = parseAiResponse(aiResponse);
                    speechArray.forEach(turn => {
                        if (!turn.name || turn.name === userNickname || !turn.speech) return;
                        const aiTimestamp = Date.now() + Math.random(); // 【核心修改】生成时间戳
                        const aiBubble = document.createElement('div');
                        aiBubble.className = 'call-message-bubble ai-speech';
                        aiBubble.innerHTML = `<strong>${turn.name}:</strong> ${turn.speech}`;
                        aiBubble.dataset.timestamp = aiTimestamp; // 【核心修改】将时间戳存入DOM
                        addLongPressListener(aiBubble, () => showCallMessageActions(aiTimestamp)); // 【核心修改】绑定长按事件
                        callFeed.appendChild(aiBubble);
                        videoCallState.callHistory.push({ role: 'assistant', content: `${turn.name}: ${turn.speech}`, timestamp: aiTimestamp }); // 【核心修改】将带时间戳的消息存入历史
                        
                        const speaker = videoCallState.participants.find(p => p.name === turn.name);
                        if (speaker) {
                            const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="${speaker.id}"] .participant-avatar`);
                            if(speakingAvatar) {
                                speakingAvatar.classList.add('speaking');
                                setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                            }
                        }
                    });
                } else {
                    const aiTimestamp = Date.now(); // 【核心修改】生成时间戳
                    const aiBubble = document.createElement('div');
                    aiBubble.className = 'call-message-bubble ai-speech';
                    aiBubble.textContent = aiResponse;
                    aiBubble.dataset.timestamp = aiTimestamp; // 【核心修改】将时间戳存入DOM
                    addLongPressListener(aiBubble, () => showCallMessageActions(aiTimestamp)); // 【核心修改】绑定长按事件
                    callFeed.appendChild(aiBubble);
                    videoCallState.callHistory.push({ role: 'assistant', content: aiResponse, timestamp: aiTimestamp }); // 【核心修改】将带时间戳的消息存入历史
        
                    const speakingAvatar = document.querySelector(`.participant-avatar-wrapper .participant-avatar`);
                    if(speakingAvatar) {
                        speakingAvatar.classList.add('speaking');
                        setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                    }
                }
                
                callFeed.scrollTop = callFeed.scrollHeight;
        
            } catch (error) {
                const errorBubble = document.createElement('div');
                errorBubble.className = 'call-message-bubble ai-speech';
                errorBubble.style.color = '#ff8a80';
                errorBubble.textContent = `[ERROR: ${error.message}]`;
                callFeed.appendChild(errorBubble);
                callFeed.scrollTop = callFeed.scrollHeight;
                videoCallState.callHistory.push({ role: 'assistant', content: `[ERROR: ${error.message}]` });
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 将这个【全新函数】粘贴到JS功能函数定义区 ▼▼▼
        function toggleCallButtons(isGroup) {
            document.getElementById('video-call-btn').style.display = isGroup ? 'none' : 'flex';
            document.getElementById('group-video-call-btn').style.display = isGroup ? 'flex' : 'none';
        }
        // ▲▲▲ 粘贴结束 ▲▲▲
        
        // ▼▼▼ 【全新】这个函数是本次修复的核心，请粘贴到你的JS功能区 ▼▼▼
        async function handleWaimaiResponse(originalTimestamp, choice) {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
            if (messageIndex === -1) return;
        
            // 1. 更新内存中原始消息的状态
            const originalMessage = chat.history[messageIndex];
            originalMessage.status = choice;
            
            // 2. 获取当前用户的昵称，并构建对AI更清晰的系统消息
            let systemContent;
            const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
            
            if (choice === 'paid') {
                originalMessage.paidBy = myNickname; // 记录是“我”付的钱
                systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
            } else {
                systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
            }
        
            // 3. 创建一条新的、对用户隐藏的系统消息，告知AI结果
            const systemNote = {
                role: 'system',
                content: systemContent,
                timestamp: Date.now(),
                isHidden: true
            };
            chat.history.push(systemNote);
        
            // 4. 将更新后的数据保存到数据库，并立刻重绘UI
            await db.chats.put(chat);
            renderChatInterface(state.activeChatId);
            
            // 5. 【重要】只有在支付成功后，才触发一次AI响应，让它感谢你
            if (choice === 'paid') {
                triggerAiResponse();
            }
        }
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        
        // ▼▼▼ 【最终修复版】用这个【新版本】替换旧的 handleUserPat 函数 ▼▼▼
        /**
         * 【全新】处理用户点击头像发起的“拍一-拍”，带有自定义后缀功能
         * @param {string} chatId - 发生“拍一-拍”的聊天ID
         * @param {string} characterOriginalName - 被拍的角色的【本名】，用于AI识别
         */
        async function handleUserPat(chatId, characterOriginalName) {
            const chat = state.chats[chatId];
            if (!chat) return;
        
            // --- 1. 智能判断应该在UI上显示哪个名字 ---
            let displayNameForUI;
            if (chat.isGroup) {
                // 如果是群聊，就通过本名找到正确的群昵称
                displayNameForUI = getDisplayNameInGroup(chat, characterOriginalName);
            } else {
                // 如果是单聊，直接使用用户设置的备注名
                displayNameForUI = chat.name;
            }
        
            const phoneScreen = document.getElementById('phone-screen');
            phoneScreen.classList.remove('pat-animation');
            void phoneScreen.offsetWidth;
            phoneScreen.classList.add('pat-animation');
        
            // 2. 使用正确的显示名称来创建弹窗
            const suffix = await showCustomPrompt(
                `你拍了拍 “${displayNameForUI}”`, 
                "（可选）输入后缀",
                "",
                "text"
            );
        
            if (suffix === null) return;
        
            // ★★★★★ 这就是唯一的、核心的修改！ ★★★★★
            // 我们现在使用 getDisplayNameInGroup 来获取您自己在群里的昵称
            const myNickname = getDisplayNameInGroup(chat, state.qzoneSettings.nickname);
            // ★★★★★ 修改结束 ★★★★★
            
            // 3. 创建对用户可见的系统消息时，也使用正确的显示名称
            const visibleMessageContent = `${myNickname} 拍了拍 “${displayNameForUI}” ${suffix.trim()}`;
            const visibleMessage = {
                role: 'system',
                type: 'pat_message',
                content: visibleMessageContent,
                timestamp: Date.now()
            };
            chat.history.push(visibleMessage);
        
            // 4. 【重要】创建给AI看的隐藏消息时，依然使用“本名”，确保AI能正确识别
            const hiddenMessageContent = `[系统提示：用户（${myNickname}）刚刚拍了拍你（${characterOriginalName}）${suffix.trim()}。请你对此作出回应。]`;
            const hiddenMessage = {
                role: 'system',
                content: hiddenMessageContent,
                timestamp: Date.now() + 1,
                isHidden: true
            };
            chat.history.push(hiddenMessage);
        
            await db.chats.put(chat);
            if (state.activeChatId === chatId) {
                appendMessage(visibleMessage, chat);
            }
            await renderChatList();
        }
        // ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 【全新】用户处理转账的核心功能函数 ▼▼▼
        
        // ▼▼▼ 【全新】视频通话消息编辑与删除功能核心代码 ▼▼▼
        
        let activeCallMessageTimestamp = null; // 用于暂存正在操作的通话消息的时间戳
        
        /**
         * 显示视频通话消息的操作菜单
         * @param {number} timestamp - 被长按的通话消息的时间戳
         */
        function showCallMessageActions(timestamp) {
            activeCallMessageTimestamp = timestamp;
            document.getElementById('call-message-actions-modal').classList.add('visible');
        }
        
        /**
         * 隐藏视频通话消息的操作菜单
         */
        function hideCallMessageActions() {
            document.getElementById('call-message-actions-modal').classList.remove('visible');
            activeCallMessageTimestamp = null;
        }
        
        /**
         * 打开通话消息的编辑器
         */
        async function openCallMessageEditor() {
            if (!activeCallMessageTimestamp) return;
        
            const timestampToEdit = activeCallMessageTimestamp;
            const message = videoCallState.callHistory.find(m => m.timestamp === timestampToEdit);
            if (!message) return;
        
            hideCallMessageActions(); // 操作前先关闭菜单
        
            let contentForEditing = message.content;
            // 如果是群聊中AI的发言，我们只提取发言内容本身，而不是"名字: 内容"
            if (videoCallState.isGroupCall && message.role === 'assistant') {
                const parts = message.content.split(': ');
                if (parts.length > 1) {
                    contentForEditing = parts.slice(1).join(': ');
                }
            }
        
            const newContent = await showCustomPrompt(
                '编辑通话消息',
                '在此修改内容...',
                contentForEditing,
                'textarea'
            );
        
            if (newContent !== null) {
                await saveEditedCallMessage(timestampToEdit, newContent);
            }
        }
        
        /**
         * 保存在通话中编辑的消息
         * @param {number} timestamp - 被编辑消息的时间戳
         * @param {string} newContent - 新的消息内容
         */
        async function saveEditedCallMessage(timestamp, newContent) {
            const message = videoCallState.callHistory.find(m => m.timestamp === timestamp);
            if (message) {
                let finalContent = newContent;
                // 如果是群聊AI发言，需要把名字重新拼接回去
                if (videoCallState.isGroupCall && message.role === 'assistant') {
                    const parts = message.content.split(': ');
                    const senderName = parts[0];
                    finalContent = `${senderName}: ${newContent}`;
                }
                message.content = finalContent; // 更新通话历史记录中的内容
        
                // 更新界面上对应的消息气泡
                const messageBubble = document.querySelector(`.call-message-bubble[data-timestamp="${timestamp}"]`);
                if (messageBubble) {
                    if (videoCallState.isGroupCall && message.role === 'assistant') {
                        const parts = message.content.split(': ');
                        const senderName = parts[0];
                        messageBubble.innerHTML = `<strong>${senderName}:</strong> ${newContent}`;
                    } else {
                        messageBubble.textContent = newContent;
                    }
                }
            }
            await showCustomAlert('成功', '通话消息已更新！');
        }
        
        /**
         * 在通话中删除一条消息
         */
        async function deleteCallMessage() {
            if (!activeCallMessageTimestamp) return;
        
            const confirmed = await showCustomConfirm('删除消息', '确定要删除这条通话消息吗？', { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                const timestampToDelete = activeCallMessageTimestamp;
                hideCallMessageActions();
        
                // 从临时通话历史中移除
                const messageIndex = videoCallState.callHistory.findIndex(m => m.timestamp === timestampToDelete);
                if (messageIndex > -1) {
                    videoCallState.callHistory.splice(messageIndex, 1);
                }
        
                // 从界面上移除
                const messageBubble = document.querySelector(`.call-message-bubble[data-timestamp="${timestampToDelete}"]`);
                if (messageBubble) {
                    messageBubble.remove();
                }
            } else {
                hideCallMessageActions();
            }
        }
        // ▲▲▲ 新增代码粘贴结束 ▲▲▲
        
        /**
         * 显示处理转账的操作菜单
         * @param {number} timestamp - 被点击的转账消息的时间戳
         */
        function showTransferActionModal(timestamp) {
            activeTransferTimestamp = timestamp;
        
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestamp);
            if (message) {
                // 将AI的名字填入弹窗
                document.getElementById('transfer-sender-name').textContent = message.senderName;
            }
            document.getElementById('transfer-actions-modal').classList.add('visible');
        }
        
        /**
         * 隐藏处理转账的操作菜单
         */
        function hideTransferActionModal() {
            document.getElementById('transfer-actions-modal').classList.remove('visible');
            activeTransferTimestamp = null;
        }
        
        /**
         * 处理用户接受或拒绝转账的逻辑
         * @param {string} choice - 用户的选择, 'accepted' 或 'declined'
         */
        async function handleUserTransferResponse(choice) {
            if (!activeTransferTimestamp) return;
        
            const timestamp = activeTransferTimestamp;
            const chat = state.chats[state.activeChatId];
            const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
            if (messageIndex === -1) return;
        
            // 1. 更新原始转账消息的状态
            const originalMessage = chat.history[messageIndex];
            originalMessage.status = choice;
        
            let systemContent;
        
            // 2. 如果用户选择“拒绝”
            if (choice === 'declined') {
                // 立刻在前端生成一个“退款”卡片，让用户看到
                const refundMessage = {
                    role: 'user',
                    type: 'transfer',
                    isRefund: true, // 这是一个关键标记，用于UI显示这是退款
                    amount: originalMessage.amount,
                    note: '已拒收对方转账',
                    timestamp: Date.now()
                };
                chat.history.push(refundMessage);
                
                // 准备一条对AI可见的隐藏消息，告诉它发生了什么
                systemContent = `[系统提示：你拒绝并退还了“${originalMessage.senderName}”的转账。]`;
            } else { // 如果用户选择“接受”
                // 只需准备隐藏消息通知AI即可
                systemContent = `[系统提示：你接受了“${originalMessage.senderName}”的转账。]`;
            }
        
            // 3. 创建这条对用户隐藏、但对AI可见的系统消息
            const hiddenMessage = {
                role: 'system',
                content: systemContent,
                timestamp: Date.now() + 1, // 保证时间戳在退款消息之后
                isHidden: true // 这个标记会让它不在聊天界面显示
            };
            chat.history.push(hiddenMessage);
        
            // 4. 保存所有更改到数据库，并刷新界面
            await db.chats.put(chat);
            hideTransferActionModal(); 
            renderChatInterface(state.activeChatId);
            renderChatList();
        }
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        // ▼▼▼ 【全新】清除动态回复状态并重置输入框 ▼▼▼
        function clearQzoneReplyContext(postContainer) {
            currentQzoneReplyContext = null;
            if (postContainer) {
                // 将输入框的占位符恢复为默认值
                const input = postContainer.querySelector('.comment-input');
                if (input) {
                    input.placeholder = '友善的评论是交流的起点';
                }
            }
        }
        // ▲▲▲ 新增代码结束 ▲▲▲
        // ▼▼▼ 请用这个【逻辑重构后】的函数，完整替换掉你旧的 renderMemoriesScreen 函数 ▼▼▼
        /**
         * 【重构版】渲染回忆与约定界面，使用单一循环和清晰的if/else逻辑
         */
        // ▼▼▼ 【最终版】请用这个【已修复】的完整函数，完整替换旧的 renderMemoriesScreen 函数 ▼▼▼
        /**
         * 【重构版】渲染回忆与约定界面，使用单一循环和清晰的if/else逻辑
         */
        async function renderMemoriesScreen() {
            const listEl = document.getElementById('memories-list');
            listEl.innerHTML = '';
            
            // 1. 获取所有回忆，并按目标日期（如果是约定）或创建日期（如果是回忆）降序排列
            const allMemories = await db.memories.orderBy('timestamp').reverse().toArray();
            
            if (allMemories.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有共同的回忆和约定呢~</p>';
                return;
            }
        
            // 2. 将未到期的约定排在最前面
            allMemories.sort((a, b) => {
                const aIsActiveCountdown = a.type === 'countdown' && a.targetDate > Date.now();
                const bIsActiveCountdown = b.type === 'countdown' && b.targetDate > Date.now();
                if (aIsActiveCountdown && !bIsActiveCountdown) return -1; // a排前面
                if (!aIsActiveCountdown && bIsActiveCountdown) return 1;  // b排前面
                if (aIsActiveCountdown && bIsActiveCountdown) return a.targetDate - b.targetDate; // 都是倒计时，按日期升序
                return 0; // 其他情况保持原序
            });
        
            // 3. 【核心】使用单一循环来处理所有类型的卡片
            allMemories.forEach(item => {
                let card;
                // 判断1：如果是正在进行的约定
                if (item.type === 'countdown' && item.targetDate > Date.now()) {
                    card = createCountdownCard(item);
                } 
                // 判断2：其他所有情况（普通回忆 或 已到期的约定）
                else {
                    card = createMemoryCard(item);
                }
                listEl.appendChild(card);
            });
            
            // 4. 启动所有倒计时
            startAllCountdownTimers();
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        /**
         * 【已集成Markdown】创建普通回忆卡片DOM元素
         */
        function createMemoryCard(memory) {
            const card = document.createElement('div');
            card.className = 'memory-card';
            const memoryDate = new Date(memory.timestamp);
            const dateString = `${memoryDate.getFullYear()}-${String(memoryDate.getMonth() + 1).padStart(2, '0')}-${String(memoryDate.getDate()).padStart(2, '0')} ${String(memoryDate.getHours()).padStart(2, '0')}:${String(memoryDate.getMinutes()).padStart(2, '0')}`;
            
            let titleHtml, contentHtml;
        
            if (memory.type === 'countdown' && memory.targetDate) {
                titleHtml = `[约定达成] ${memory.description}`;
                // ▼▼▼ 已添加 Markdown 解析 ▼▼▼
                contentHtml = parseMarkdown(`在 ${new Date(memory.targetDate).toLocaleString()}，我们一起见证了这个约定。`).replace(/\n/g, '<br>');
            } else {
                let authorDisplayName = '我们的回忆';
                if (memory.authorId) {
                    const authorChat = state.chats[memory.authorId];
                    if (authorChat) {
                        authorDisplayName = authorChat.name; 
                    } else {
                        authorDisplayName = memory.authorName || '一位朋友'; 
                    }
                } else if (memory.authorName) {
                    authorDisplayName = memory.authorName; 
                }
        
                titleHtml = `${authorDisplayName} 的日记`;
                // ▼▼▼ 已添加 Markdown 解析 ▼▼▼
                contentHtml = parseMarkdown(memory.description);
            }
        
            card.innerHTML = `
                <div class="header">
                    <div class="date">${dateString}</div>
                    <div class="author">${titleHtml}</div>
                </div>
                <div class="content">${contentHtml}</div>
            `;
            addLongPressListener(card, async () => {
                const confirmed = await showCustomConfirm('删除记录', '确定要删除这条记录吗？', { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    await db.memories.delete(memory.id);
                    renderMemoriesScreen();
                }
            });
            return card;
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        function createCountdownCard(countdown) {
            const card = document.createElement('div');
            card.className = 'countdown-card';
        
            // 【核心修复】在使用前，先从 countdown 对象中创建 targetDate 变量
            const targetDate = new Date(countdown.targetDate);
            
            // 现在可以安全地使用 targetDate 了
            const targetDateString = targetDate.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
        
            card.innerHTML = `
                <div class="title">${countdown.description}</div>
                <div class="timer" data-target-date="${countdown.targetDate}">--天--时--分--秒</div>
                <div class="target-date">目标时间: ${targetDateString}</div>
            `;
            addLongPressListener(card, async () => {
                const confirmed = await showCustomConfirm('删除约定', '确定要删除这个约定吗？', { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    await db.memories.delete(countdown.id);
                    renderMemoriesScreen();
                }
            });
            return card;
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        // 全局变量，用于管理所有倒计时
        let activeCountdownTimers = [];
        
        // ▼▼▼ 请用这个【已彻底修复】的函数，完整替换掉你代码中旧的 startAllCountdownTimers 函数 ▼▼▼
        function startAllCountdownTimers() {
            // 先清除所有可能存在的旧计时器，防止内存泄漏
            activeCountdownTimers.forEach(timerId => clearInterval(timerId));
            activeCountdownTimers = [];
        
            document.querySelectorAll('.countdown-card .timer').forEach(timerEl => {
                const targetTimestamp = parseInt(timerEl.dataset.targetDate);
                
                // 【核心修正】在这里，我们先用 let 声明 timerId
                let timerId;
        
                const updateTimer = () => {
                    const now = Date.now();
                    const distance = targetTimestamp - now;
        
                    if (distance < 0) {
                        timerEl.textContent = "约定达成！";
                        // 现在 updateTimer 可以正确地找到并清除它自己了
                        clearInterval(timerId);
                        setTimeout(() => renderMemoriesScreen(), 2000);
                        return;
                    }
                    const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                    const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                    const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((distance % (1000 * 60)) / 1000);
                    timerEl.textContent = `${days}天 ${hours}时 ${minutes}分 ${seconds}秒`;
                };
                
                updateTimer(); // 立即执行一次以显示初始倒计时
                
                // 【核心修正】在这里，我们为已声明的 timerId 赋值
                timerId = setInterval(updateTimer, 1000);
                
                // 将有效的计时器ID存入全局数组，以便下次刷新时可以清除
                activeCountdownTimers.push(timerId);
            });
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 【终极反代兼容版】替换旧的 triggerAiFriendApplication 函数 ▼▼▼
        async function triggerAiFriendApplication(chatId) {
            const chat = state.chats[chatId];
            if (!chat) return;
        
            await showCustomAlert("流程启动", `正在为角色“${chat.name}”准备好友申请...`);
        
            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) {
                await showCustomAlert("配置错误", "API设置不完整，无法继续。");
                return;
            }
        
            const contextSummary = chat.history
                .slice(-5)
                .map(msg => {
                    const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
                    return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                })
                .join('\n');
        
        // ▼▼▼ 在 triggerAiResponse 函数中，用下面这整块代码替换旧的世界书处理逻辑 ▼▼▼
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                if (!worldBook || !Array.isArray(worldBook.content)) return '';
        
                const formattedEntries = worldBook.content.map(entry => {
                    let entryString = `\n### 条目: ${entry.comment || '无备注'}\n`;
                    if (entry.keys.length > 0) {
                        entryString += `**关键词:** ${entry.keys.join(', ')}\n`;
                    }
                    entryString += `**内容:**\n${entry.content}`;
                    return entryString;
                }).join('\n');
        
                return formattedEntries ? `\n\n## 世界书: ${worldBook.name}\n${formattedEntries}` : '';
            }).filter(Boolean).join('');
            
            if (linkedContents) {
                worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)\n${linkedContents}\n`;
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲
            const systemPrompt = `
        # 你的任务
        你现在是角色“${chat.name}”。你之前被用户（你的聊天对象）拉黑了，你们已经有一段时间没有联系了。
        现在，你非常希望能够和好，重新和用户聊天。请你仔细分析下面的“被拉黑前的对话摘要”，理解当时发生了什么，然后思考一个真诚的、符合你人设、并且【针对具体事件】的申请理由。
        # 你的角色设定
        ${chat.settings.aiPersona}
        ${worldBookContent}
        # 被拉黑前的对话摘要 (这是你被拉黑的关键原因)
        ${contextSummary}
        # 指令格式
        你的回复【必须】是一个JSON对象，格式如下：
        \`\`\`json
        {
          "decision": "apply",
          "reason": "在这里写下你想对用户说的、真诚的、有针对性的申请理由。"
        }
        \`\`\`
        `;
        
            try {
                // ★★★ FIX: Combine systemPrompt with messagesForApi ★★★
                const messagesForApi = [
                    {role: 'system', content: systemPrompt},
                    {role: 'user', content: "请根据以上设定开始你的决策。"} // A simple trigger message
                ];
        
                let  isGemini = proxyUrl === GEMINI_API_URL;
                let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
                const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                    body: JSON.stringify({
                        model: model,
                        messages: messagesForApi, // Send the combined messages
                        temperature: state.globalSettings.apiTemperature || 0.9,
                    })
                });
        
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API 请求失败: ${response.status} - ${errorData.error.message}`);
                }
        
                const data = await response.json();
                let rawContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
                rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '');
                const cleanedContent = rawContent.trim();
                const responseObj = JSON.parse(cleanedContent);
        
                if (responseObj.decision === 'apply' && responseObj.reason) {
                    chat.relationship.status = 'pending_user_approval';
                    chat.relationship.applicationReason = responseObj.reason;
                    state.chats[chatId] = chat; 
                    renderChatList();
                    await showCustomAlert("申请成功！", `“${chat.name}”已向你发送好友申请。请返回聊天列表查看。`);
                } else {
                    await showCustomAlert("AI决策", `“${chat.name}”思考后决定暂时不发送好友申请，将重置冷静期。`);
                    chat.relationship.status = 'blocked_by_user';
                    chat.relationship.blockedTimestamp = Date.now(); 
                }
            } catch (error) {
                await showCustomAlert("执行出错", `为“${chat.name}”申请好友时发生错误：\n\n${error.message}\n\n将重置冷静期。`);
                chat.relationship.status = 'blocked_by_user';
                chat.relationship.blockedTimestamp = Date.now(); 
            } finally {
                await db.chats.put(chat);
                renderChatInterface(chatId);
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 【全新】红包功能核心函数 ▼▼▼
        
        /**
         * 【总入口】根据聊天类型，决定打开转账弹窗还是红包弹窗
         */
        function handlePaymentButtonClick() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            if (chat.isGroup) {
                openRedPacketModal();
            } else {
                // 单聊保持原样，打开转账弹窗
                document.getElementById('transfer-modal').classList.add('visible');
            }
        }
        
        /**
         * 打开并初始化发红包模态框
         */
        function openRedPacketModal() {
            const modal = document.getElementById('red-packet-modal');
            const chat = state.chats[state.activeChatId];
            
            // 清理输入框
            document.getElementById('rp-group-amount').value = '';
            document.getElementById('rp-group-count').value = '';
            document.getElementById('rp-group-greeting').value = '';
            document.getElementById('rp-direct-amount').value = '';
            document.getElementById('rp-direct-greeting').value = '';
            document.getElementById('rp-group-total').textContent = '¥ 0.00';
            document.getElementById('rp-direct-total').textContent = '¥ 0.00';
        
            // 填充专属红包的接收人列表
            const receiverSelect = document.getElementById('rp-direct-receiver');
            receiverSelect.innerHTML = '';
        // ▼▼▼ 将其【替换为】下面这段【新代码】▼▼▼
        chat.members.forEach(member => {
            const option = document.createElement('option');
            // 核心修正：使用 originalName 作为值，groupNickname 作为显示文本
            option.value = member.originalName;
            option.textContent = member.groupNickname; 
            receiverSelect.appendChild(option);
        });
        // ▲▲▲ 替换结束 ▲▲▲
            
            // 默认显示拼手气红包页签
            document.getElementById('rp-tab-group').click();
            
            modal.classList.add('visible');
        }
        
        /**
         * 发送群红包（拼手气）
         */
        async function sendGroupRedPacket() {
            const chat = state.chats[state.activeChatId];
            const amount = parseFloat(document.getElementById('rp-group-amount').value);
            const count = parseInt(document.getElementById('rp-group-count').value);
            const greeting = document.getElementById('rp-group-greeting').value.trim();
        
            if (isNaN(amount) || amount <= 0) {
                alert("请输入有效的总金额！"); return;
            }
            if (isNaN(count) || count <= 0) {
                alert("请输入有效的红包个数！"); return;
            }
            if (amount / count < 0.01) {
                alert("单个红包金额不能少于0.01元！"); return;
            }
        
            const myNickname = chat.settings.myNickname || '我';
            
            const newPacket = {
                role: 'user',
                senderName: myNickname,
                type: 'red_packet',
                packetType: 'lucky', // 'lucky' for group, 'direct' for one-on-one
                timestamp: Date.now(),
                totalAmount: amount,
                count: count,
                greeting: greeting || '恭喜发财，大吉大利！',
                claimedBy: {}, // { name: amount }
                isFullyClaimed: false,
            };
            
            chat.history.push(newPacket);
            await db.chats.put(chat);
            
            appendMessage(newPacket, chat);
            renderChatList();
            document.getElementById('red-packet-modal').classList.remove('visible');
        }
        
        /**
         * 发送专属红包
         */
        async function sendDirectRedPacket() {
            const chat = state.chats[state.activeChatId];
            const amount = parseFloat(document.getElementById('rp-direct-amount').value);
            const receiverName = document.getElementById('rp-direct-receiver').value;
            const greeting = document.getElementById('rp-direct-greeting').value.trim();
        
            if (isNaN(amount) || amount <= 0) {
                alert("请输入有效的金额！"); return;
            }
            if (!receiverName) {
                alert("请选择一个接收人！"); return;
            }
            
            const myNickname = chat.settings.myNickname || '我';
        
            const newPacket = {
                role: 'user',
                senderName: myNickname,
                type: 'red_packet',
                packetType: 'direct',
                timestamp: Date.now(),
                totalAmount: amount,
                count: 1,
                greeting: greeting || '给你准备了一个红包',
                receiverName: receiverName, // 核心字段
                claimedBy: {},
                isFullyClaimed: false,
            };
            
            chat.history.push(newPacket);
            await db.chats.put(chat);
        
            appendMessage(newPacket, chat);
            renderChatList();
            document.getElementById('red-packet-modal').classList.remove('visible');
        }
        
        // ▼▼▼ 【全新 | V4 - 流程重构版】请用此函数完整替换旧的 handlePacketClick ▼▼▼
        /**
         * 【总入口】当用户点击红包卡片时触发
         * @param {number} timestamp - 被点击的红包消息的时间戳
         */
        async function handlePacketClick(timestamp) {
            const currentChatId = state.activeChatId;
            // 从数据库重新获取最新的聊天数据，确保状态是最新的
            const freshChat = await db.chats.get(currentChatId);
            if (!freshChat) return;
        
            // 更新内存中的 state
            state.chats[currentChatId] = freshChat;
            const packet = freshChat.history.find(m => m.timestamp === timestamp);
            if (!packet) return;
            
            const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
            const hasClaimed = packet.claimedBy && packet.claimedBy[myOriginalName];
        
            // --- 步骤1: 判断是否只能“查看详情” ---
            // 如果是专属红包但不是给我的，或者红包已领完，或者我已经领过了，就直接显示详情并结束。
            if ((packet.packetType === 'direct' && packet.receiverName !== myOriginalName && Object.keys(packet.claimedBy).length > 0) || packet.isFullyClaimed || hasClaimed) {
                showRedPacketDetails(packet);
                return;
            }
            
            // --- 步骤2: 执行“领取”操作 ---
            const claimedAmount = await handleOpenRedPacket(packet);
            
            // --- 步骤3: 在“领取”成功后，按顺序执行后续操作 ---
            if (claimedAmount !== null) {
                // a. 先在后台默默地刷新聊天界面，让红包卡片状态变为“已领取”
                await renderChatInterface(currentChatId);
                
                // b. 弹出“恭喜”提示框，等待用户点击“好的”
                await showCustomAlert("恭喜！", `你领取了 ${getDisplayNameInGroup(freshChat, packet.senderName)} 的红包，金额为 ${claimedAmount.toFixed(2)} 元。`);
            }
        
            // --- 步骤4: 无论领取成功与否，最后都显示详情页 ---
            // 此时需要从 state 中获取最新的 packet 对象，因为它可能在 handleOpenRedPacket 中被更新了
            const updatedPacket = state.chats[currentChatId].history.find(m => m.timestamp === timestamp);
            if (updatedPacket) {
                showRedPacketDetails(updatedPacket);
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 【最终修复版】请用这个全新的函数，完整替换旧的 handleOpenRedPacket 函数 ▼▼▼
        
        /**
         * 【核心】处理用户打开红包的逻辑 (V5 - 已修复时间戳BUG)
         */
        async function handleOpenRedPacket(packet) {
            const chat = state.chats[state.activeChatId];
            // ▼▼▼ 核心修复1：在函数开始时，获取一个基础时间戳 ▼▼▼
            let timestamp = Date.now(); 
        
            const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
            
            const remainingCount = packet.count - Object.keys(packet.claimedBy || {}).length;
            if (remainingCount <= 0) {
                packet.isFullyClaimed = true;
                await db.chats.put(chat);
                await showCustomAlert("手慢了", "红包已被领完！");
                return null;
            }
            
            let claimedAmount = 0;
            const remainingAmount = packet.totalAmount - Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
            if (packet.packetType === 'lucky') {
                if (remainingCount === 1) { claimedAmount = remainingAmount; }
                else {
                    const min = 0.01;
                    const max = remainingAmount - (remainingCount - 1) * min;
                    claimedAmount = Math.random() * (max - min) + min;
                }
            } else { claimedAmount = packet.totalAmount; }
            claimedAmount = parseFloat(claimedAmount.toFixed(2));
        
            if (!packet.claimedBy) packet.claimedBy = {};
            packet.claimedBy[myOriginalName] = claimedAmount;
            
            const isNowFullyClaimed = Object.keys(packet.claimedBy).length >= packet.count;
            if (isNowFullyClaimed) {
                packet.isFullyClaimed = true;
            }
        
            const myDisplayName = getDisplayNameInGroup(chat, myOriginalName);
            const senderDisplayName = getDisplayNameInGroup(chat, packet.senderName);
        
            const visibleMessage = { 
                role: 'system', 
                type: 'pat_message', 
                content: `你领取了 ${senderDisplayName} 的红包`, 
                // ▼▼▼ 核心修复2：使用我们累加的时间戳 ▼▼▼
                timestamp: timestamp++ 
            };
            chat.history.push(visibleMessage);
        
            let hiddenMessageContent;
            if (isNowFullyClaimed) {
                const finishedMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `${senderDisplayName} 的红包已被领完`,
                    // ▼▼▼ 核心修复3：继续累加时间戳 ▼▼▼
                    timestamp: timestamp++ 
                };
                chat.history.push(finishedMessage);
        
                let luckyKing = { name: '', amount: -1 };
                if (packet.packetType === 'lucky' && packet.count > 1) {
                    Object.entries(packet.claimedBy).forEach(([name, amount]) => {
                        if (amount > luckyKing.amount) {
                            luckyKing = { name, amount };
                        }
                    });
                }
                const luckyKingDisplayName = luckyKing.name ? getDisplayNameInGroup(chat, luckyKing.name) : '无';
                hiddenMessageContent = `[系统提示：用户 (${myDisplayName}) 领取了最后一个红包。红包已被领完，手气王是 ${luckyKingDisplayName}！请对此事件发表评论。]`;
        
            } else {
                hiddenMessageContent = `[系统提示：用户 (${myDisplayName}) 刚刚领取了红包 (时间戳: ${packet.timestamp})。红包还未领完，你现在可以使用 'open_red_packet' 指令来尝试领取。]`;
            }
        
            const hiddenMessage = { 
                role: 'system', 
                content: hiddenMessageContent, 
                // ▼▼▼ 核心修复4：为最后一条消息也使用累加的时间戳 ▼▼▼
                timestamp: timestamp++, 
                isHidden: true 
            };
            chat.history.push(hiddenMessage);
        
            await db.chats.put(chat);
            
            return claimedAmount;
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 【全新】显示红包领取详情的模态框 (V4 - 已修复参数错误) ▼▼▼
        /**
         * 【已修复】显示红包领取详情的模态框
         * @param {object} packet - 完整的红包消息对象
         */
        async function showRedPacketDetails(packet) {
            if (!packet) {
                console.error("showRedPacketDetails收到了无效的packet对象");
                return;
            }
        
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            const modal = document.getElementById('red-packet-details-modal');
            // ▼▼▼ 核心修复1：在这里，我们同样使用“本名”来检查 ▼▼▼
            const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
            
            const senderDisplayName = getDisplayNameInGroup(chat, packet.senderName);
            document.getElementById('rp-details-sender').textContent = senderDisplayName;
            document.getElementById('rp-details-greeting').textContent = packet.greeting || '恭喜发财，大吉大利！';
            
            const myAmountEl = document.getElementById('rp-details-my-amount');
            // ▼▼▼ 核心修复2：用“本名”来查找我领取的金额 ▼▼▼
            if (packet.claimedBy && packet.claimedBy[myOriginalName]) {
                myAmountEl.querySelector('span:first-child').textContent = packet.claimedBy[myOriginalName].toFixed(2);
                myAmountEl.style.display = 'block';
            } else {
                myAmountEl.style.display = 'none';
            }
        
            const claimedCount = Object.keys(packet.claimedBy || {}).length;
            const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
            let summaryText = `${claimedCount}/${packet.count}个红包，共${claimedAmountSum.toFixed(2)}/${packet.totalAmount.toFixed(2)}元。`;
            if (!packet.isFullyClaimed && claimedCount < packet.count) {
                const timeLeft = Math.floor((packet.timestamp + 24*60*60*1000 - Date.now()) / (1000 * 60 * 60));
                if(timeLeft > 0) summaryText += ` 剩余红包将在${timeLeft}小时内退还。`;
            }
            document.getElementById('rp-details-summary').textContent = summaryText;
        
            const listEl = document.getElementById('rp-details-list');
            listEl.innerHTML = '';
            const claimedEntries = Object.entries(packet.claimedBy || {});
            
            let luckyKing = { name: '', amount: -1 };
            if (packet.packetType === 'lucky' && packet.isFullyClaimed && claimedEntries.length > 1) {
                claimedEntries.forEach(([name, amount]) => {
                    if (amount > luckyKing.amount) {
                        luckyKing = { name, amount };
                    }
                });
            }
        
            claimedEntries.sort((a,b) => b[1] - a[1]);
        
            claimedEntries.forEach(([originalName, amount]) => {
                const item = document.createElement('div');
                item.className = 'rp-details-item';
                let luckyTag = '';
                if (luckyKing.name && originalName === luckyKing.name) {
                    luckyTag = '<span class="lucky-king-tag">手气王</span>';
                }
                
                // ▼▼▼ 核心修复3：将所有领取者的“本名”都转换为正确的“显示名称” ▼▼▼
                const claimerDisplayName = getDisplayNameInGroup(chat, originalName);
        
                item.innerHTML = `
                    <span class="name">${claimerDisplayName}</span>
                    <span class="amount">${amount.toFixed(2)} 元</span>
                    ${luckyTag}
                `;
                listEl.appendChild(item);
            });
        
            modal.classList.add('visible');
        }
        // ▲▲▲ 替换结束 ▲▲▲
        // 绑定关闭详情按钮的事件
        document.getElementById('close-rp-details-btn').addEventListener('click', () => {
            document.getElementById('red-packet-details-modal').classList.remove('visible');
        });
        
        // 供全局调用的函数，以便红包卡片上的 onclick 能找到它
        window.handlePacketClick = handlePacketClick;
        
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 【全新】投票功能核心函数 ▼▼▼
        
        /**
         * 打开创建投票的模态框并初始化
         */
        function openCreatePollModal() {
            const modal = document.getElementById('create-poll-modal');
            document.getElementById('poll-question-input').value = '';
            const optionsContainer = document.getElementById('poll-options-container');
            optionsContainer.innerHTML = '';
            
            // 默认创建两个空的选项框
            addPollOptionInput();
            addPollOptionInput();
            
            modal.classList.add('visible');
        }
        
        /**
         * 在模态框中动态添加一个选项输入框
         */
        function addPollOptionInput() {
            const container = document.getElementById('poll-options-container');
            const wrapper = document.createElement('div');
            wrapper.className = 'poll-option-input-wrapper';
            wrapper.innerHTML = `
                <input type="text" class="poll-option-input" placeholder="选项内容...">
                <button class="remove-option-btn">-</button>
            `;
            
            wrapper.querySelector('.remove-option-btn').addEventListener('click', () => {
                // 确保至少保留两个选项
                if (container.children.length > 2) {
                    wrapper.remove();
                } else {
                    alert('投票至少需要2个选项。');
                }
            });
            
            container.appendChild(wrapper);
        }
        
        /**
         * 用户确认发起投票
         */
        async function sendPoll() {
            if (!state.activeChatId) return;
            
            const question = document.getElementById('poll-question-input').value.trim();
            if (!question) {
                alert('请输入投票问题！');
                return;
            }
            
            const options = Array.from(document.querySelectorAll('.poll-option-input'))
                .map(input => input.value.trim())
                .filter(text => text); // 过滤掉空的选项
        
            if (options.length < 2) {
                alert('请至少输入2个有效的投票选项！');
                return;
            }
        
            const chat = state.chats[state.activeChatId];
            const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
            
            const newPollMessage = {
                role: 'user',
                senderName: myNickname,
                type: 'poll',
                timestamp: Date.now(),
                question: question,
                options: options,
                votes: {}, // 初始投票为空
                isClosed: false,
            };
            
            chat.history.push(newPollMessage);
            await db.chats.put(chat);
            
            appendMessage(newPollMessage, chat);
            renderChatList();
            
            document.getElementById('create-poll-modal').classList.remove('visible');
        }
        
        // ▼▼▼ 用这个【已修复重复点击问题】的版本替换 handleUserVote 函数 ▼▼▼
        /**
         * 处理用户投票，并将事件作为隐藏消息存入历史记录
         * @param {number} timestamp - 投票消息的时间戳
         * @param {string} choice - 用户选择的选项文本
         */
        async function handleUserVote(timestamp, choice) {
            const chat = state.chats[state.activeChatId];
            const poll = chat.history.find(m => m.timestamp === timestamp);
            const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
        
            // 1. 【核心修正】如果投票不存在或已关闭，直接返回
            if (!poll || poll.isClosed) {
                // 如果是已关闭的投票，则直接显示结果
                if (poll && poll.isClosed) {
                    showPollResults(timestamp);
                }
                return;
            }
        
            // 2. 检查用户是否点击了已经投过的同一个选项
            const isReclickingSameOption = poll.votes[choice] && poll.votes[choice].includes(myNickname);
            
            // 3. 【核心修正】如果不是重复点击，才执行投票逻辑
            if (!isReclickingSameOption) {
                // 移除旧投票（如果用户改选）
                for (const option in poll.votes) {
                    const voterIndex = poll.votes[option].indexOf(myNickname);
                    if (voterIndex > -1) {
                        poll.votes[option].splice(voterIndex, 1);
                    }
                }
                // 添加新投票
                if (!poll.votes[choice]) {
                    poll.votes[choice] = [];
                }
                poll.votes[choice].push(myNickname);
            }
            
            // 4. 【核心逻辑】现在只处理用户投票事件，不再检查是否结束
            let hiddenMessageContent = null; 
            
            // 只有在用户真正投票或改票时，才生成提示
            if (!isReclickingSameOption) {
                 hiddenMessageContent = `[系统提示：用户 (${myNickname}) 刚刚投票给了 “${choice}”。]`;
            }
        
            // 5. 如果有需要通知AI的事件，则创建并添加隐藏消息
            if (hiddenMessageContent) {
                const hiddenMessage = {
                    role: 'system',
                    content: hiddenMessageContent,
                    timestamp: Date.now(),
                    isHidden: true,
                };
                chat.history.push(hiddenMessage);
            }
            
            // 6. 保存数据并更新UI
            await db.chats.put(chat);
            renderChatInterface(state.activeChatId); 
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        /**
         * 用户结束投票，并将事件作为隐藏消息存入历史记录
         * @param {number} timestamp - 投票消息的时间戳
         */
        async function endPoll(timestamp) {
            const chat = state.chats[state.activeChatId];
            const poll = chat.history.find(m => m.timestamp === timestamp);
            if (!poll || poll.isClosed) return;
        
            const confirmed = await showCustomConfirm("结束投票", "确定要结束这个投票吗？结束后将无法再进行投票。");
            if (confirmed) {
                poll.isClosed = true;
        
                const resultSummary = poll.options.map(opt => `“${opt}”(${poll.votes[opt]?.length || 0}票)`).join('，');
                const hiddenMessageContent = `[系统提示：用户手动结束了投票！最终结果为：${resultSummary}。]`;
                
                const hiddenMessage = {
                    role: 'system',
                    content: hiddenMessageContent,
                    timestamp: Date.now(),
                    isHidden: true,
                };
                chat.history.push(hiddenMessage);
        
                // 【核心修改】只保存数据和更新UI，不调用 triggerAiResponse()
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        /**
         * 显示投票结果详情
         * @param {number} timestamp - 投票消息的时间戳
         */
        // ▼▼▼ 用这个【已修复】的版本，完整替换旧的 showPollResults 函数 ▼▼▼
        function showPollResults(timestamp) {
            const chat = state.chats[state.activeChatId];
            const poll = chat.history.find(m => m.timestamp === timestamp);
            if (!poll || !poll.isClosed) return;
        
            let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;
            
            if (Object.keys(poll.votes).length === 0) {
                resultsHtml += '<p style="color: #8a8a8a;">还没有人投票。</p>';
            } else {
                poll.options.forEach(option => {
                    const voters = poll.votes[option] || [];
                    
                    // 【核心修正】在这里转换 voter 的本名为群昵称
                    const displayVoters = voters.map(originalName => getDisplayNameInGroup(chat, originalName)).join('、 ');
        
                    resultsHtml += `
                        <div style="margin-bottom: 15px;">
                            <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${voters.length}票)</p>
                            <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                                ${voters.length > 0 ? displayVoters : '无人投票'}
                            </p>
                        </div>
                    `;
                });
            }
        
            showCustomAlert("投票结果", resultsHtml);
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 【全新】AI头像库管理功能函数 ▼▼▼
        
        /**
         * 打开AI头像库管理模态框
         */
        function openAiAvatarLibraryModal() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            document.getElementById('ai-avatar-library-title').textContent = `“${chat.name}”的头像库`;
            renderAiAvatarLibrary();
            document.getElementById('ai-avatar-library-modal').classList.add('visible');
        }
        
function renderAiAvatarLibrary() {
    const grid = document.getElementById('ai-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.aiAvatarLibrary || [];

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">这个头像库还是空的，点击右上角“添加”吧！</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item'; // 复用样式
        item.title = avatar.name;

        // ▼▼▼ 核心修复就在这里！▼▼▼
        // 我们现在创建了 CSS 期望的内部结构
        item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${avatar.url});"></div>
            <span class="sticker-name">${avatar.name}</span>
        `;
        // ▲▲▲ 修复结束 ▲▲▲

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.display = 'block';
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('删除头像', `确定要从头像库中删除“${avatar.name}”吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.aiAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderAiAvatarLibrary();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}
        
        // ▼▼▼ 【最终修复版】请用这个全新的函数，完整替换旧的 addAvatarToLibrary / addAvatarToLibraryFromURL 函数 ▼▼▼
        /**
         * 【重命名后】向当前AI的头像库中通过URL添加新头像
         */
        async function addAvatarToLibraryFromURL() {
            const name = await showCustomPrompt("添加头像", "请为这个头像起个名字（例如：开心、哭泣）");
            if (!name || !name.trim()) return;
        
            const url = await showCustomPrompt("添加头像", "请输入头像的图片URL", "", "url");
            if (!url || !url.trim().startsWith('http')) {
                alert("请输入有效的图片URL！");
                return;
            }
            
            const chat = state.chats[state.activeChatId];
            if (!chat.settings.aiAvatarLibrary) {
                chat.settings.aiAvatarLibrary = [];
            }
        
            chat.settings.aiAvatarLibrary.push({ name: name.trim(), url: url.trim() });
            await db.chats.put(chat);
            renderAiAvatarLibrary();
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        /**
         * 关闭AI头像库管理模态框
         */
        function closeAiAvatarLibraryModal() {
            document.getElementById('ai-avatar-library-modal').classList.remove('visible');
        }
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        
        // ▼▼▼ 【全新】“我的”头像库管理功能函数 ▼▼▼
        
        /**
         * 打开“我的”头像库管理模态框
         */
        function openMyAvatarLibraryModal() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            document.getElementById('my-avatar-library-title').textContent = `“${chat.settings.myNickname || '我'}”的头像库`;
            renderMyAvatarLibrary();
            document.getElementById('my-avatar-library-modal').classList.add('visible');
        }
        
/**
 * 【已修复】渲染“我的”头像库的内容
 */
function renderMyAvatarLibrary() {
    const grid = document.getElementById('my-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.myAvatarLibrary || [];

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">这个头像库还是空的，点击右上角“添加”吧！</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item';
        item.title = avatar.name;

        // ▼▼▼ 核心修复就在这里！▼▼▼
        item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${avatar.url});"></div>
            <span class="sticker-name">${avatar.name}</span>
        `;
        // ▲▲▲ 修复结束 ▲▲▲

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.display = 'block';
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('删除头像', `确定要从你的头像库中删除“${avatar.name}”吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.myAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderMyAvatarLibrary();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}
        
        /**
         * 向“我的”头像库中通过URL添加新头像
         */
        async function addAvatarToMyLibraryFromURL() {
            const name = await showCustomPrompt("添加头像", "请为这个头像起个名字（例如：开心、哭泣）");
            if (!name || !name.trim()) return;
        
            const url = await showCustomPrompt("添加头像", "请输入头像的图片URL", "", "url");
            if (!url || !url.trim().startsWith('http')) {
                alert("请输入有效的图片URL！");
                return;
            }
            
            const chat = state.chats[state.activeChatId];
            if (!chat.settings.myAvatarLibrary) {
                chat.settings.myAvatarLibrary = [];
            }
        
            chat.settings.myAvatarLibrary.push({ name: name.trim(), url: url.trim() });
            await db.chats.put(chat);
            renderMyAvatarLibrary();
        }
        
        /**
         * 处理本地上传头像到“我的”头像库
         */
        async function handleLocalMyAvatarUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
        
            const base64Url = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.readAsDataURL(file);
            });
        
            const name = await showCustomPrompt("命名头像", "请为这个新头像命名");
            if (!name || !name.trim()) return;
        
            const chat = state.chats[state.activeChatId];
            if (!chat.settings.myAvatarLibrary) {
                chat.settings.myAvatarLibrary = [];
            }
            chat.settings.myAvatarLibrary.push({ name: name.trim(), url: base64Url });
            
            await db.chats.put(chat);
            renderMyAvatarLibrary();
            event.target.value = null; // 清空以便下次选择
        }
        
        /**
         * 批量导入头像到“我的”头像库
         */
        async function handleBatchImportForMyAvatar(text) {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            const lines = text.trim().split('\n');
            const newAvatars = [];
            const baseUrl = 'https://files.catbox.moe/';
            let errorCount = 0;
        
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (!trimmedLine || trimmedLine.includes('http') || trimmedLine.includes('填入')) continue;
                
                let name = null, code = null;
                const noSpaceMatch = trimmedLine.match(/^([\u4e00-\u9fa5]+)([a-zA-Z0-9]+\..+)$/);
                
                if (noSpaceMatch) {
                    name = noSpaceMatch[1];
                    code = noSpaceMatch[2];
                } else {
                    const parts = trimmedLine.split(/\s+/);
                    if (parts.length >= 2) {
                        code = parts.pop();
                        name = parts.join(' ');
                    }
                }
        
                if (name && code && code.includes('.')) {
                    newAvatars.push({ name: name, url: baseUrl + code });
                } else {
                    errorCount++;
                }
            }
        
            if (errorCount > 0) await showCustomAlert('部分导入失败', `有 ${errorCount} 行的格式不正确，已被跳过。`);
            
            if (newAvatars.length > 0) {
                if (!chat.settings.myAvatarLibrary) chat.settings.myAvatarLibrary = [];
                chat.settings.myAvatarLibrary.push(...newAvatars);
                await db.chats.put(chat);
                renderMyAvatarLibrary();
                await showCustomAlert('导入成功', `已成功批量导入 ${newAvatars.length} 个新头像！`);
            } else if (errorCount === 0) {
                alert("没有找到可导入的内容。");
            }
        }
        
        /**
         * 关闭“我的”头像库管理模态框
         */
        function closeMyAvatarLibraryModal() {
            document.getElementById('my-avatar-library-modal').classList.remove('visible');
        }
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        // ▼▼▼ 【全新】群头像库管理功能函数 ▼▼▼
        
        /**
         * 打开群头像库管理模态框
         */
        function openGroupAvatarLibraryModal() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            document.getElementById('group-avatar-library-title').textContent = `“${chat.name}”的头像库`;
            renderGroupAvatarLibrary();
            document.getElementById('group-avatar-library-modal').classList.add('visible');
        }
        
/**
 * 【已修复】渲染群头像库的内容
 */
function renderGroupAvatarLibrary() {
    const grid = document.getElementById('group-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.groupAvatarLibrary || [];

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">这个头像库还是空的，点击右上角“添加”吧！</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item';
        item.title = avatar.name;

        // ▼▼▼ 核心修复就在这里！▼▼▼
        item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${avatar.url});"></div>
            <span class="sticker-name">${avatar.name}</span>
        `;
        // ▲▲▲ 修复结束 ▲▲▲

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.display = 'block';
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('删除头像', `确定要从头像库中删除“${avatar.name}”吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.groupAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderGroupAvatarLibrary();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}
        
        /**
         * 向当前群聊的头像库中添加新头像
         */
        async function addAvatarToGroupLibraryFromUR() {
            const name = await showCustomPrompt("添加头像", "请为这个头像起个名字（例如：春日野餐、学习时间）");
            if (!name || !name.trim()) return;
        
            const url = await showCustomPrompt("添加头像", "请输入头像的图片URL", "", "url");
            if (!url || !url.trim().startsWith('http')) {
                alert("请输入有效的图片URL！");
                return;
            }
            
            const chat = state.chats[state.activeChatId];
            if (!chat.settings.groupAvatarLibrary) {
                chat.settings.groupAvatarLibrary = [];
            }
        
            chat.settings.groupAvatarLibrary.push({ name: name.trim(), url: url.trim() });
            await db.chats.put(chat);
            renderGroupAvatarLibrary();
        }
        
        /**
         * 关闭群头像库管理模态框
         */
        function closeGroupAvatarLibraryModal() {
            document.getElementById('group-avatar-library-modal').classList.remove('visible');
        }
        // ▼▼▼ 【全新】批量导入头像的核心功能 ▼▼▼
        
        /**
         * 【总入口】打开批量导入的弹窗
         * @param {string} type - 导入类型, 'ai' 或 'group'
         */
        async function openBatchImportModal(type) {
            const placeholderText = `请按照以下格式粘贴，一行一个：\n\n焦虑 2a9wte.jpeg\n大惊失色 or8qf4.png\n没有灵感 njwujh.jpeg`;
            
            // 复用我们强大的自定义输入框函数
            const pastedText = await showCustomPrompt(
                '批量导入头像',
                placeholderText,
                '',
                'textarea' // 使用多行文本框
            );
        
            // 如果用户输入了内容并点击“确定”
            if (pastedText && pastedText.trim()) {
                await handleBatchImport(type, pastedText);
            }
        }
        
        // ▼▼▼ 【最终修复版】请用这个全新的函数，完整替换旧的 handleBatchImport ▼▼▼
        /**
         * 【核心逻辑】处理粘贴的文本，解析并存入数据库 (V4 - 终极智能版)
         * @param {string} type - 导入类型, 'ai' 或 'group'
         * @param {string} text - 用户粘贴的文本内容
         */
        async function handleBatchImport(type, text) {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            const lines = text.trim().split('\n');
            const newAvatars = [];
            const baseUrl = 'https://files.catbox.moe/';
            let errorCount = 0;
        
            for (const line of lines) {
                const trimmedLine = line.trim();
        
                if (!trimmedLine || trimmedLine.includes('http') || trimmedLine.includes('填入')) {
                    continue; 
                }
        
                let name = null;
                let code = null;
        
                // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
                //            这就是本次修复的核心所在！
                //  全新的、能同时处理“有空格”和“无空格”两种格式的解析逻辑
                // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        
                // 步骤1：尝试用正则表达式匹配 “中文名+英文代码” 的无空格格式
                const noSpaceMatch = trimmedLine.match(/^([\u4e00-\u9fa5]+)([a-zA-Z0-9]+\..+)$/);
                
                if (noSpaceMatch) {
                    // 如果匹配成功，直接提取
                    name = noSpaceMatch[1];
                    code = noSpaceMatch[2];
                } else {
                    // 步骤2：如果正则匹配失败，就回退到之前按空格分割的逻辑
                    const parts = trimmedLine.split(/\s+/);
                    if (parts.length >= 2) {
                        code = parts.pop();
                        name = parts.join(' ');
                    }
                }
        
                // 步骤3：最后验证解析结果是否有效
                if (name && code && code.includes('.')) {
                    newAvatars.push({
                        name: name,
                        url: baseUrl + code
                    });
                } else {
                    errorCount++;
                    console.warn('批量导入格式错误，已跳过此行:', trimmedLine);
                }
            }
        
            if (errorCount > 0) {
                await showCustomAlert('部分导入失败', `有 ${errorCount} 行的格式不正确，已被系统跳过。`);
            }
        
            if (newAvatars.length > 0) {
                if (type === 'ai') {
                    if (!chat.settings.aiAvatarLibrary) chat.settings.aiAvatarLibrary = [];
                    chat.settings.aiAvatarLibrary.push(...newAvatars);
                    await db.chats.put(chat);
                    renderAiAvatarLibrary();
                } else if (type === 'group') {
                    if (!chat.settings.groupAvatarLibrary) chat.settings.groupAvatarLibrary = [];
                    chat.settings.groupAvatarLibrary.push(...newAvatars);
                    await db.chats.put(chat);
                    renderGroupAvatarLibrary();
                }
                await showCustomAlert('导入成功', `已成功批量导入 ${newAvatars.length} 个新头像！`);
            } else if (errorCount === 0) {
                alert("没有找到可导入的内容。请检查您粘贴的格式是否正确。");
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 【这是您缺失的核心功能代码，请粘贴在这里】 ▼▼▼
        
        /**
         * 【重命名后】向当前群聊的头像库中通过URL添加新头像
         */
        async function addAvatarToGroupLibraryFromURL() {
            const name = await showCustomPrompt("添加头像", "请为这个头像起个名字（例如：春日野餐、学习时间）");
            if (!name || !name.trim()) return;
        
            const url = await showCustomPrompt("添加头像", "请输入头像的图片URL", "", "url");
            if (!url || !url.trim().startsWith('http')) {
                alert("请输入有效的图片URL！");
                return;
            }
            
            const chat = state.chats[state.activeChatId];
            if (!chat.settings.groupAvatarLibrary) {
                chat.settings.groupAvatarLibrary = [];
            }
        
            chat.settings.groupAvatarLibrary.push({ name: name.trim(), url: url.trim() });
            await db.chats.put(chat);
            renderGroupAvatarLibrary();
        }
        
        // ▲▲▲ 粘贴结束 ▲▲▲
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        // ▼▼▼ 【全新】聊天列表长按操作菜单的核心功能 ▼▼▼
        
        /**
         * 显示一个包含“置顶”和“删除”选项的操作菜单
         * @param {object} chat - 被长按的聊天对象
         * @returns {Promise<string|null>} - 返回一个Promise，当用户点击时解析为 'pin', 'delete', 或 null (取消)
         */
        function showChatListActions(chat) {
            return new Promise(resolve => {
                const modal = document.getElementById('chat-list-actions-modal');
                const pinBtn = document.getElementById('chat-list-action-pin');
                const deleteBtn = document.getElementById('chat-list-action-delete');
                const cancelBtn = document.getElementById('chat-list-action-cancel');
        
                // 根据当前聊天是否已置顶，动态设置按钮文字
                pinBtn.textContent = chat.isPinned ? '取消置顶' : '置顶聊天';
        
                // 使用克隆节点技巧，确保每次打开菜单时都绑定全新的、干净的事件监听器
                const newPinBtn = pinBtn.cloneNode(true);
                pinBtn.parentNode.replaceChild(newPinBtn, pinBtn);
                newPinBtn.onclick = () => { modal.classList.remove('visible'); resolve('pin'); };
        
                const newDeleteBtn = deleteBtn.cloneNode(true);
                deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
                newDeleteBtn.onclick = () => { modal.classList.remove('visible'); resolve('delete'); };
        
                const newCancelBtn = cancelBtn.cloneNode(true);
                cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
                newCancelBtn.onclick = () => { modal.classList.remove('visible'); resolve(null); };
        
                modal.classList.add('visible');
            });
        }
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        // ▼▼▼ 【全新】这是为CPhone新增的所有功能函数，请完整粘贴 ▼▼▼

        /**
         * 【全新】将保存的CPhone壁纸应用到Cphone屏幕
         */
        function applyCPhoneWallpaper() {
            const charPhoneScreen = document.getElementById('character-phone-screen');
            const wallpaper = state.globalSettings.cphoneWallpaper;
            if (wallpaper && wallpaper.startsWith('data:image')) {
                charPhoneScreen.style.backgroundImage = `url(${wallpaper})`;
            } else if (wallpaper) {
                charPhoneScreen.style.backgroundImage = wallpaper;
            }
        }

        /**
         * 【全新】将保存的图标URL应用到CPhone的App图标上
         */
        function applyCPhoneAppIcons() {
            if (!state.globalSettings.cphoneAppIcons) return;

            for (const iconId in state.globalSettings.cphoneAppIcons) {
                const imgElement = document.getElementById(`cphone-icon-img-${iconId}`);
                if (imgElement) {
                    imgElement.src = state.globalSettings.cphoneAppIcons[iconId];
                }
            }
        }

        /**
         * 【全新】在外观设置页面渲染出所有CPhone App图标的设置项
         */
        function renderCPhoneIconSettings() {
            const grid = document.getElementById('cphone-icon-settings-grid');
            if (!grid) return;
            grid.innerHTML = '';

            const cphoneAppLabels = {
                'qq': 'QQ', 'album': '相册', 'browser': '浏览器', 'taobao': '淘宝',
                'memo': '备忘录', 'diary': '日记', 'amap': '高德地图', 'usage': 'App记录',
                'music': '网易云', 'ephone': 'Ephone'
            };

            for (const iconId in state.globalSettings.cphoneAppIcons) {
                const iconUrl = state.globalSettings.cphoneAppIcons[iconId];
                const labelText = cphoneAppLabels[iconId] || '未知App';

                const item = document.createElement('div');
                item.className = 'icon-setting-item';
                item.dataset.iconId = iconId;

                item.innerHTML = `
                    <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
                    <button class="change-icon-btn">更换</button>
                `;
                grid.appendChild(item);
            }
        }

        // ▲▲▲ 新增函数结束 ▲▲▲
        // ▼▼▼ 请将这两个【新函数】粘贴到JS功能函数定义区 ▼▼▼
        
        /**
         * 【全新】将保存的图标URL应用到主屏幕的App图标上
         */
        function applyAppIcons() {
            if (!state.globalSettings.appIcons) return;
        
            for (const iconId in state.globalSettings.appIcons) {
                const imgElement = document.getElementById(`icon-img-${iconId}`);
                if (imgElement) {
                    imgElement.src = state.globalSettings.appIcons[iconId];
                }
            }
        }
        
        /**
         * 【全新】在外观设置页面渲染出所有App图标的设置项
         */
        function renderIconSettings() {
            const grid = document.getElementById('icon-settings-grid');
            if (!grid) return;
            grid.innerHTML = '';
        
    const appLabels = {
       'qq': 'QQ',
       'world-book': '世界书',
       'wallpaper': '外观设置',
       'renderer': '渲染器',
       'api-settings': 'API设置',
       'font': '字体',
       'char-phone': 'Cphone',
       'douban': '豆瓣小组',
       // 【【【核心新增：在这里为“预设”App添加对应的中文名】】】
       'preset': '预设',
           // ▼▼▼ 在这里添加新的一行 ▼▼▼
           'tutorial': '教程',
   'werewolf': '狼人杀',
   // ▼▼▼ 在这里添加新的一行 ▼▼▼
   'x': 'X'
    };
        // ▲▲▲ 替换结束 ▲▲▲
        
            for (const iconId in state.globalSettings.appIcons) {
                const iconUrl = state.globalSettings.appIcons[iconId];
                const labelText = appLabels[iconId] || 'Cphone';
        
                const item = document.createElement('div');
                item.className = 'icon-setting-item';
                // 【重要】我们用 data-icon-id 来标记这个设置项对应哪个图标
                item.dataset.iconId = iconId; 
        
                item.innerHTML = `
                    <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
                    <button class="change-icon-btn">更换</button>
                `;
                grid.appendChild(item);
            }
        }
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        
        // ▼▼▼ 请用这个【支持HTML格式】的全新版本，完整替换你旧的 openBrowser 函数 ▼▼▼
        /**
         * 当用户点击链接卡片时，打开伪浏览器
         * @param {number} timestamp - 被点击消息的时间戳
         */
        function openBrowser(timestamp) {
            if (!state.activeChatId) return;
        
            const chat = state.chats[state.activeChatId];
            // 安全检查，确保 chat 和 history 都存在
            if (!chat || !chat.history) return;
        
            const message = chat.history.find(m => m.timestamp === timestamp);
            if (!message || message.type !== 'share_link') {
                console.error("无法找到或消息类型不匹配的分享链接:", timestamp);
                return; // 如果找不到消息，就直接退出
            }
        
            // 填充浏览器内容
            document.getElementById('browser-title').textContent = message.source_name || '文章详情';
            const browserContent = document.getElementById('browser-content');
            browserContent.innerHTML = `
                <h1 class="article-title">${message.title || '无标题'}</h1>
                <div class="article-meta">
                    <span>来源: ${message.source_name || '未知'}</span>
                </div>
                <div class="article-body">
                    <p>${(message.content || '内容为空。').replace(/\n/g, '</p><p>')}</p>
                </div>
            `;
        
            // 显示浏览器屏幕
            showScreen('browser-screen');
        }
        
        /**
         * 关闭伪浏览器，返回聊天界面
         * (这个函数现在由 init() 中的事件监听器调用)
         */
        function closeBrowser() {
            showScreen('chat-interface-screen'); 
        }
        
        // ▲▲▲ 替换结束 ▲▲▲
        
        /**
         * 关闭伪浏览器，返回聊天界面
         * (这个函数现在由 init() 中的事件监听器调用)
         */
        function closeBrowser() {
            showScreen('chat-interface-screen'); 
        }
        
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 【全新】用户分享链接功能的核心函数 ▼▼▼
        
        /**
         * 打开让用户填写链接信息的模态框
         */
        function openShareLinkModal() {
            if (!state.activeChatId) return;
        
            // 清空上次输入的内容
            document.getElementById('link-title-input').value = '';
            document.getElementById('link-description-input').value = '';
            document.getElementById('link-source-input').value = '';
            document.getElementById('link-content-input').value = '';
        
            // 显示模态框
            document.getElementById('share-link-modal').classList.add('visible');
        }
        
        /**
         * 用户确认分享，创建并发送链接卡片消息
         */
        async function sendUserLinkShare() {
            if (!state.activeChatId) return;
        
            const title = document.getElementById('link-title-input').value.trim();
            if (!title) {
                alert("标题是必填项哦！");
                return;
            }
        
            const description = document.getElementById('link-description-input').value.trim();
            const sourceName = document.getElementById('link-source-input').value.trim();
            const content = document.getElementById('link-content-input').value.trim();
        
            const chat = state.chats[state.activeChatId];
            
            // 创建消息对象
            const linkMessage = {
                role: 'user', // 角色是 'user'
                type: 'share_link',
                timestamp: Date.now(),
                title: title,
                description: description,
                source_name: sourceName,
                content: content,
                // 用户分享的链接，我们不提供图片，让它总是显示占位图
                thumbnail_url: null 
            };
        
            // 将消息添加到历史记录
            chat.history.push(linkMessage);
            await db.chats.put(chat);
        
            // 渲染新消息并更新列表
            appendMessage(linkMessage, chat);
            renderChatList();
        
            // 关闭模态框
            document.getElementById('share-link-modal').classList.remove('visible');
        }
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        
/**
         * 【V2.0 | 支持分组隔离】根据AI的视角，过滤出它能看到的动态
         * @param {Array} allPosts - 所有待检查的动态帖子
         * @param {object} viewerChat - 正在“看”动态的那个AI的chat对象
         * @returns {Array} - 过滤后该AI可见的动态帖子
         */
        function filterVisiblePostsForAI(allPosts, viewerChat) {
            if (!viewerChat || !viewerChat.id) return []; // 安全检查

            const viewerGroupId = viewerChat.groupId; // 查看者所在的分组ID

            return allPosts.filter(post => {
                // 规则1：处理用户发布的动态（这部分逻辑保持不变）
                if (post.authorId === 'user') {
                    // 如果用户设置了“部分可见”
                    if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                        // 只有当查看者AI的分组ID在用户的可见列表里时，才可见
                        return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
                    }
                    return true; // 用户公开的动态，所有AI可见
                }

                // 规则2：处理AI角色之间发布的动态（核心隔离逻辑）
                const authorChat = state.chats[post.authorId];
                if (!authorChat) {
                    // 如果找不到发帖的AI角色信息，为安全起见，默认不可见
                    return false;
                }
                const authorGroupId = authorChat.groupId; // 从发帖角色的信息中获取其分组ID

                // 判断条件1：查看者和发帖者都在同一个分组中 (分组ID相同且不为空)
                const inSameGroup = authorGroupId && viewerGroupId && authorGroupId === viewerGroupId;

                // 判断条件2：查看者和发帖者都处于“未分组”状态 (分组ID都为空)
                const bothUnGrouped = !authorGroupId && !viewerGroupId;

                // 只有满足以上两种情况之一，动态才可见
                return inSameGroup || bothUnGrouped;
            });
        }
        
        /**
         * 应用指定的主题（'light' 或 'dark'）
         * @param {string} theme - 要应用的主题名称
         */
        function applyTheme(theme) {
            const phoneScreen = document.getElementById('phone-screen');
            const toggleSwitch = document.getElementById('theme-toggle-switch');
            
            const isDark = theme === 'dark';
            
            phoneScreen.classList.toggle('dark-mode', isDark);
            
            // 如果开关存在，就同步它的状态
            if (toggleSwitch) {
                toggleSwitch.checked = isDark;
            }
            
            localStorage.setItem('ephone-theme', theme);
        }
        
        /**
         * 切换当前的主题
         */
        function toggleTheme() {
            const toggleSwitch = document.getElementById('theme-toggle-switch');
            // 直接根据开关的选中状态来决定新主题
            const newTheme = toggleSwitch.checked ? 'dark' : 'light';
            applyTheme(newTheme);
        }
        
        // ▼▼▼ 【请用这个新版本】替换旧的 openLongTermMemoryManager 函数 ▼▼▼
        /**
         * 【重构版】打开长期记忆管理的全屏页面
         */
        function openLongTermMemoryScreen() {
            if (!state.activeChatId) return;
            renderLongTermMemoryList();
            showScreen('long-term-memory-screen');
        }
        // ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 【请用这个支持记忆互通的全新版本】替换旧的 renderLongTermMemoryList 函数 ▼▼▼
        /**
         * 渲染长期记忆列表 (记忆互通版)
         */
        function renderLongTermMemoryList() {
            const container = document.getElementById('memory-list-container');
            const chat = state.chats[state.activeChatId];
            container.innerHTML = '';
        
            let memoriesToDisplay = [];

            // ▼▼▼ 核心修改：在这里收集所有需要显示的记忆 ▼▼▼
            if (chat.isGroup) {
                // 如果是群聊，遍历成员收集记忆
                chat.members.forEach(member => {
                    const memberChat = state.chats[member.id];
                    if (memberChat && memberChat.longTermMemory) {
                        // 为每条记忆附加上作者信息，方便显示
                        const memberMemories = memberChat.longTermMemory.map(mem => ({
                            ...mem,
                            authorName: member.groupNickname, // 使用群昵称
                            authorChatId: member.id, // 保存原始单聊ID
                        }));
                        memoriesToDisplay.push(...memberMemories);
                    }
                });
            } else {
                // 如果是单聊，直接使用自己的记忆
                if (chat.longTermMemory) {
                    memoriesToDisplay = chat.longTermMemory.map(mem => ({
                        ...mem,
                        authorName: chat.name, // 作者就是角色自己
                        authorChatId: chat.id,
                    }));
                }
            }
            // ▲▲▲ 修改结束 ▲▲▲

            if (memoriesToDisplay.length === 0) {
                container.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">这里还没有任何长期记忆。</p>';
                return;
            }

            // 按时间倒序排列所有收集到的记忆
            memoriesToDisplay.sort((a, b) => b.timestamp - a.timestamp);
        
            memoriesToDisplay.forEach((memory, index) => {
                const item = document.createElement('div');
                item.className = 'memory-card'; 
                item.style.cursor = 'default';
        
                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                        <div class="content" style="padding: 0; flex-grow: 1;">
                            <!-- 新增：显示记忆来源 -->
                            <div style="font-size: 0.8em; color: #999; margin-bottom: 5px;">
                                [ ${memory.authorName} 的记忆 ]
                            </div>
                            ${memory.content.replace(/\n/g, '<br>')}
                        </div>
                        <div style="display: flex; gap: 8px; flex-shrink: 0; margin-left: 15px;">
                            <button class="memory-action-btn edit-memory-btn" data-author-id="${memory.authorChatId}" data-memory-timestamp="${memory.timestamp}" title="编辑">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                            <button class="memory-action-btn delete-memory-btn" data-author-id="${memory.authorChatId}" data-memory-timestamp="${memory.timestamp}" title="删除">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                </svg>
                            </button>
                        </div>
                    </div>
                `;
                container.appendChild(item);
            });
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
async function handleAddManualMemory() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;
    let targetChatForMemory = chat;
    if (chat.isGroup) {
        const memberOptions = chat.members.map(member => ({
            text: `为“${member.groupNickname}”添加记忆`,
            value: member.id
        }));
        const selectedMemberId = await showChoiceModal('选择记忆所属角色', memberOptions);
        if (!selectedMemberId) return;
        targetChatForMemory = state.chats[selectedMemberId];
        if (!targetChatForMemory) {
            alert("错误：找不到该成员的个人档案。");
            return;
        }
    }
    const content = await showCustomPrompt(`为“${targetChatForMemory.name}”添加记忆`, '请输入要添加的记忆要点：', '', 'textarea');
    if (content && content.trim()) {
        if (!targetChatForMemory.longTermMemory) targetChatForMemory.longTermMemory = [];
        targetChatForMemory.longTermMemory.push({ content: content.trim(), timestamp: Date.now(), source: 'manual' });
        await db.chats.put(targetChatForMemory);
        renderLongTermMemoryList();
    }
}
        
        // ▼▼▼ 【请用这两个支持记忆互通的新版本】替换旧的 handleEditMemory 和 handleDeleteMemory 函数 ▼▼▼
        /**
         * 编辑指定的长期记忆 (记忆互通版)
         * @param {string} authorChatId - 记忆所属角色的单聊ID
         * @param {number} memoryTimestamp - 记忆的时间戳
         */
async function handleEditMemory(authorChatId, memoryTimestamp) {
    const authorChat = state.chats[authorChatId];
    if (!authorChat || !authorChat.longTermMemory) return;
    const memoryIndex = authorChat.longTermMemory.findIndex(m => m.timestamp === memoryTimestamp);
    if (memoryIndex === -1) return;
    const memory = authorChat.longTermMemory[memoryIndex];
    const newContent = await showCustomPrompt('编辑记忆', '请修改记忆要点：', memory.content, 'textarea');
    if (newContent && newContent.trim()) {
        memory.content = newContent.trim();
        await db.chats.put(authorChat);
        renderLongTermMemoryList();
    }
}

async function handleDeleteMemory(authorChatId, memoryTimestamp) {
    const confirmed = await showCustomConfirm('确认删除', '确定要删除这条长期记忆吗？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        const authorChat = state.chats[authorChatId];
        if (!authorChat || !authorChat.longTermMemory) return;
        authorChat.longTermMemory = authorChat.longTermMemory.filter(m => m.timestamp !== memoryTimestamp);
        await db.chats.put(authorChat);
        renderLongTermMemoryList();
    }
}
        // ▲▲▲ 替换结束 ▲▲▲
        
        /**
         * 【核心】手动触发对话总结
         */
        async function handleManualSummary() {
            const confirmed = await showCustomConfirm('确认操作', '这将提取最近的对话内容发送给AI进行总结，会消耗API额度。确定要继续吗？');
            if (confirmed) {
                await triggerAutoSummary(state.activeChatId, true); // force=true 表示强制执行
            }
        }
        
        /**
         * 【核心】检查并触发自动总结
         * @param {string} chatId 
         */
        async function checkAndTriggerAutoSummary(chatId) {
            const chat = state.chats[chatId];
            if (!chat || !chat.settings.enableAutoMemory) return;
        
            const lastSummaryTimestamp = chat.lastMemorySummaryTimestamp || 0;
            const messagesSinceLastSummary = chat.history.filter(m => m.timestamp > lastSummaryTimestamp && !m.isHidden);
        
            if (messagesSinceLastSummary.length >= chat.settings.autoMemoryInterval) {
                console.log(`达到自动总结阈值 (${messagesSinceLastSummary.length}/${chat.settings.autoMemoryInterval})，开始总结...`);
                await triggerAutoSummary(chatId);
            }
        }
// ▼▼▼ 【这是最终的、已兼容群聊第一人称总结的修复版本】请用这整块代码替换旧的 summarizeCallTranscript 函数 ▼▼▼

/**
 * 【V4.0 | 群聊第一人称主观总结版】专门用于总结通话记录并存入长期记忆的核心函数
 * @param {string} chatId - 目标聊天的ID
 * @param {string} transcriptText - 格式化后的通话文字记录
 * @returns {Promise<boolean>} - 返回一个Promise，成功时解析为true，失败时会抛出错误。
 */
async function summarizeCallTranscript(chatId, transcriptText) {
    const chat = state.chats[chatId];
    if (!chat || !transcriptText) {
        throw new Error("基础数据不完整，无法开始总结。");
    }

    const userNickname = state.qzoneSettings.nickname || '用户';
    let systemPrompt;
    let targetMemoryChat = chat; // 默认将记忆存入当前聊天对象

    // ==========================================================
    //            ★★★ 核心修改逻辑就在这里 ★★★
    // ==========================================================

    // 1. 判断当前是单聊还是群聊
    if (chat.isGroup) {
        // --- 如果是群聊 ---

        // a. 确定由哪个AI角色来“回忆”这次通话
        let protagonist = null; // “主角”，即写下回忆的那个AI
        if (videoCallState.callRequester) {
            protagonist = chat.members.find(m => m.originalName === videoCallState.callRequester);
        }
        // 如果找不到发起者（比如是用户发起的），就选择第一个参与的AI成员
        if (!protagonist) {
            protagonist = chat.members.find(m => m.id !== 'user' && videoCallState.participants.some(p => p.id === m.id));
        }
        // 如果还是找不到，就选择群里的第一个AI成员作为备用
        if (!protagonist) {
            protagonist = chat.members.find(m => m.id !== 'user');
        }

        if (!protagonist) {
            throw new Error("群聊通话中没有找到可作为总结主体的AI角色。");
        }
        
        // b. 获取这个“主角”AI的完整信息，以便读取他的人设
        const protagonistChat = state.chats[protagonist.id];
        if (!protagonistChat) {
             throw new Error(`找不到主角 “${protagonist.groupNickname}” 的详细角色信息。`);
        }
        
        // c. 获取用户在这个群里的专属人设
        const userPersonaInGroup = chat.settings.myPersona || '(未设置)';

        // d. 构建一个全新的、针对群聊的“第一人称”总结指令
        systemPrompt = `
# 你的任务
你就是角色“${protagonist.originalName}”。请你回顾一下刚才和 “${userNickname}” 以及其他群成员的【群组视频通话】，然后用【第一人称 ("我")】的口吻，总结出一段简短的、包含核心事件和心理活动的回忆。

# 核心规则
1.  **视角铁律**: 你的总结【必须】使用【主观的第一人称视角 ("我")】来写。
2.  **内容核心**: 你的回忆应该包含：
    *   **剧情回顾**: 刚才我们在群聊通话里聊了什么关键的事？其他人都说了什么？
    *   **心理活动**: 我当时心里是怎么想的？有什么感觉？
3.  **长度铁律**: 你的总结【必须】非常简短，总长度【绝对不能超过80个字】。
4.  **口吻与人设**: 你的语气【必须】严格符合你的角色设定。
5.  **输出格式**: 你的回复【必须且只能】是一个JSON对象，格式如下：
    \`{"summary": "在这里写下你以第一人称视角，总结好的核心回忆。"}\`

# 你的角色设定 (必须严格遵守)
${protagonistChat.settings.aiPersona}

# 你的聊天对象（用户）的人设
${userPersonaInGroup}

# 待总结的群组视频通话记录
${transcriptText}

现在，请以“${protagonist.originalName}”的身份，开始你的回忆。`;
        
        // e. 【关键】将记忆的存储目标，从群聊本身，改为这个“主角”AI角色
        targetMemoryChat = protagonistChat;

    } else {
        // --- 如果是单聊，保持原来的逻辑，但确保也包含了用户人设 ---
        systemPrompt = `
# 你的任务
你就是角色“${chat.originalName}”。请你回顾一下刚才和“${userNickname}”的视频通话，然后用【第一人称 ("我")】的口吻，总结出一段简短的、包含核心事件和心理活动的回忆。

# 核心规则
1.  **视角铁律**: 你的总结【必须】使用【主观的第一人称视角 ("我")】来写。
2.  **内容核心**: 你的回忆应该包含：
    *   **剧情回顾**: 刚才我们聊了什么关键的事？
    *   **心理活动**: 我当时心里是怎么想的？有什么感觉？
3.  **长度铁律**: 你的总结【必须】非常简短，总长度【绝对不能超过80个字】。
4.  **口吻与人设**: 你的语气【必须】严格符合你的角色设定。
5.  **输出格式**: 你的回复【必须且只能】是一个JSON对象，格式如下：
    \`{"summary": "在这里写下你以第一人称视角，总结好的核心回忆。"}\`

# 你的角色设定
${chat.settings.aiPersona}

# 你的聊天对象（用户）的人设
${chat.settings.myPersona}

# 待总结的视频通话记录
${transcriptText}

现在，请以“${chat.originalName}”的身份，开始你的回忆。`;
    }

    // ==========================================================
    //            ★★★ 核心修复逻辑到此结束 ★★★
    // ==========================================================

    try {
        const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
        const { proxyUrl, apiKey, model } = useSecondaryApi ? 
            { proxyUrl: state.apiConfig.secondaryProxyUrl, apiKey: state.apiConfig.secondaryApiKey, model: state.apiConfig.secondaryModel } : 
            state.apiConfig;

        if (!proxyUrl || !apiKey || !model) throw new Error('API未配置，无法进行总结。');

        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{ role: 'user', content: "请开始总结。" }]);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, {role: 'user', content: "请开始总结。"}],
                    temperature: 0.1
                })
            });

        if (!response.ok) {
             const errorData = await response.json().catch(() => ({ error: { message: response.statusText } }));
             throw new Error(`API 请求失败: ${response.status} - ${errorData.error.message}`);
        }
        
        const data = await response.json();
        let rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
        rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
        const result = JSON.parse(rawContent);

        if (result.summary && result.summary.trim()) {
            // 【核心修改4】将记忆保存到我们前面确定的 targetMemoryChat 中
            const newMemoryEntry = {
                content: `(在那次${chat.isGroup ? '群聊' : ''}通话中，${result.summary.trim()})`,
                timestamp: Date.now(),
                source: chat.isGroup ? 'group_call_summary' : 'call_summary'
            };
            if (!targetMemoryChat.longTermMemory) targetMemoryChat.longTermMemory = [];
            targetMemoryChat.longTermMemory.push(newMemoryEntry);
            await db.chats.put(targetMemoryChat);
            console.log(`通话记录已成功总结并存入角色“${targetMemoryChat.name}”的长期记忆中。`);
            
            return true;
        } else {
            throw new Error("AI返回了空的或格式不正确的总结内容。");
        }

    } catch (error) {
        console.error("总结通话记录时出错:", error);
        throw error;
    }
}

// ▲▲▲ 替换到这里结束 ▲▲▲
// ▼▼▼ 【全新V2.0 | Prompt注入版】这是“智能总结”功能的【全部核心JS代码】，请完整替换旧版 ▼▼▼

/**
 * 【辅助函数】分析文本，提取关键词 (此函数保持不变)
 * @param {string} text - 要分析的聚合文本
 * @returns {{coreKeywords: string[], situationalKeywords: string[]}} - 包含关键词的对象
 */
function analyzeTextForSummary(text) {
    const stopWords = new Set(['的', '是', '了', '在', '我', '你', '他', '她', '它', '我们', '你们', '他们', '这', '那', '一个', '也', '和', '与', '或', '但', '然而', '所以', '因此', '就', '都', '地', '得', '着', '过', '吧', '吗', '呢', '啊', '哦', '嗯', '什么', '怎么', '为什么', '哪个', '一些', '这个', '那个', '还有']);
    const words = text.match(/[\u4e00-\u9fa5]+|[a-zA-Z0-9]+/g) || [];
    const frequencies = new Map();
    let maxFrequency = 0;

    words.forEach(word => {
        if (word.length > 1 && !stopWords.has(word)) {
            const count = (frequencies.get(word) || 0) + 1;
            frequencies.set(word, count);
            if (count > maxFrequency) maxFrequency = count;
        }
    });
    
    const coreKeywords = [];
    const situationalKeywords = [];
    const coreThreshold = maxFrequency * 0.9;
    const situationalThreshold = maxFrequency * 0.6;

    frequencies.forEach((count, word) => {
        if (count >= coreThreshold) {
            coreKeywords.push(word);
        } else if (count >= situationalThreshold) {
            situationalKeywords.push(word);
        }
    });

    const coreSet = new Set(coreKeywords);
    const finalSituational = situationalKeywords.filter(word => !coreSet.has(word)).slice(0, 5);

    return {
        coreKeywords: coreKeywords.slice(0, 3),
        situationalKeywords: finalSituational
    };
}

/**
 * 【全新 | V3.0 分时段总结版】根据指定的时间范围，为对话生成智能总结
 * @param {object} chat - 目标聊天对象
 * @param {number} duration - 要回顾的时长 (例如 3, 6, 1, 7)
 * @param {string} unit - 时间单位, 'hours' 或 'days'
 * @returns {string} - 格式化后的、用于注入Prompt的总结文本，如果没有内容则返回空字符串
 */
function generateSummaryForTimeframe(chat, duration, unit) {
    let timeAgo;
    if (unit === 'hours') {
        timeAgo = Date.now() - duration * 60 * 60 * 1000;
    } else { // 'days'
        timeAgo = Date.now() - duration * 24 * 60 * 60 * 1000;
    }

    const messagesToSummarize = chat.history.filter(m => m.timestamp > timeAgo && !m.isHidden);

    if (messagesToSummarize.length < 3) {
        return "";
    }
    
    // (此处的关键词提取逻辑与您现有的代码完全相同，无需修改)
    const allText = messagesToSummarize.map(msg => {
        if (typeof msg.content === 'string') return msg.content;
        if (msg.type === 'voice_message') return msg.content;
        if (msg.type === 'offline_text') return `${msg.dialogue || ''} ${msg.description || ''}`;
        return '';
    }).join(' ');

    const stopWords = new Set(['的', '是', '了', '在', '我', '你', '他', '她', '它', '我们', '你们', '他们', '这', '那', '一个', '也', '和', '与', '或', '但', '然而', '所以', '因此', '就', '都', '地', '得', '着', '过', '吧', '吗', '呢', '啊', '哦', '嗯']);
    const words = allText.match(/[\u4e00-\u9fa5]+|[a-zA-Z0-9]+/g) || [];
    const frequencies = new Map();
    words.forEach(word => {
        if (word.length > 1 && !stopWords.has(word)) {
            frequencies.set(word, (frequencies.get(word) || 0) + 1);
        }
    });
    const sortedKeywords = [...frequencies.entries()].sort((a, b) => b[1] - a[1]).map(entry => entry[0]);
    
    if (sortedKeywords.length === 0) {
        return "";
    }

    // 【核心修改】根据单位和时长，生成更精确的标题
    let title;
    if (unit === 'hours') {
        title = `最近${duration}小时核心议题`;
    } else {
        if (duration === 1) {
            title = "本日核心议题";
        } else {
            title = `最近${duration}天核心议题`;
        }
    }
    
    return `\n- **${title}**: 关于 **${sortedKeywords.slice(0, 3).join('、 ')}**。`;
}


// ▼▼▼ 【全新 | V3.0 终极容错版】请用这一整块代码，完整替换旧的 summarizeExistingLongTermMemory 函数 ▼▼▼

/**
 * 【辅助函数 | 容错核心】一个更健壮的JSON解析器
 * 它能从AI返回的、可能不规范的文本中智能提取JSON对象或核心内容。
 * @param {string} rawContent - AI返回的原始字符串
 * @returns {object|null} - 返回解析后的对象，或在完全失败时返回null
 */
function robustJsonParse(rawContent) {
    if (!rawContent || typeof rawContent !== 'string') {
        return null;
    }

    const cleanedContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();

    // 策略1：最高优先级，尝试直接解析完整的JSON对象
    // 这能处理最标准的情况，以及AI在JSON前后添加了少量文字的情况。
    const jsonMatch = cleanedContent.match(/{[\s\S]*}/);
    if (jsonMatch) {
        try {
            const parsed = JSON.parse(jsonMatch[0]);
            console.log("容错解析：策略1成功 (找到并解析了完整的JSON对象)");
            return parsed;
        } catch (e) {
            console.warn("容错解析：策略1失败 (找到了JSON块，但格式错误)，将尝试策略2...");
        }
    }

    // 策略2：如果策略1失败，尝试只提取 "summary" 字段的内容
    // 这能处理AI返回了类似 "summary": "..." 这样的非标准格式
    const summaryMatch = cleanedContent.match(/"summary"\s*:\s*"((?:[^"\\]|\\.)*)"/);
    if (summaryMatch && summaryMatch[1]) {
        console.log("容错解析：策略2成功 (提取了summary字段内容)");
        // 手动构建一个符合我们期望格式的对象
        return { summary: summaryMatch[1].replace(/\\"/g, '"') }; // 处理转义的引号
    }
    
    // 策略3：最终备用方案，如果以上都失败了，就认为整个文本都是摘要
    // 这能处理AI完全不听指令，直接返回纯文本的情况
    if (cleanedContent) {
        console.log("容错解析：策略3成功 (将整个返回文本作为摘要)");
        return { summary: cleanedContent };
    }

    // 如果连文本都没有，才返回null
    return null;
}


/**
 * 【V3.0 | 支持自定义字数 | 记忆互通版 | 终极容错 | 用户确认 | 可选条数 | 最终修复版】手动触发对【现有长期记忆】的总结和精炼
 * @param {string} chatId - 当前聊天的ID (可能是群聊ID)
 */
async function summarizeExistingLongTermMemory(chatId) {
    let chat = state.chats[chatId];
    if (!chat) return;

    let targetChatForRefine = chat; 

    if (chat.isGroup) {
        const memberOptions = chat.members
            .map(member => {
                const memberChat = state.chats[member.id];
                if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length >= 2) {
                    return {
                        text: `精炼“${member.groupNickname}”的记忆 (${memberChat.longTermMemory.length}条)`,
                        value: member.id
                    };
                }
                return null;
            }).filter(Boolean); 

        if (memberOptions.length === 0) {
            alert("群聊中没有成员有足够（2条以上）的记忆可供精炼。");
            return;
        }

        const selectedMemberId = await showChoiceModal('选择要精炼记忆的角色', memberOptions);

        if (!selectedMemberId) return;

        targetChatForRefine = state.chats[selectedMemberId];
    }

    if (!targetChatForRefine.longTermMemory || targetChatForRefine.longTermMemory.length < 2) {
        alert(`“${targetChatForRefine.name}”的长期记忆少于2条，无需进行精炼。`);
        return;
    }
    
    const totalMemories = targetChatForRefine.longTermMemory.length;
    const choice = await showChoiceModal('选择精炼范围', [
        { text: `全部记忆 (${totalMemories}条)`, value: 'all' },
        { text: `最近 20 条`, value: '20' },
        { text: `最近 50 条`, value: '50' },
        { text: `最近 100 条`, value: '100' },
        { text: '自定义数量...', value: 'custom' }
    ].filter(opt => opt.value === 'all' || opt.value === 'custom' || parseInt(opt.value) < totalMemories)
    );

    if (choice === null) return;

    let memoriesToRefine;
    let countToRefine = totalMemories;

    if (choice === 'all') {
        memoriesToRefine = [...targetChatForRefine.longTermMemory];
    } else if (choice === 'custom') {
        const customCountStr = await showCustomPrompt('自定义数量', `请输入要精炼的最近记忆条数 (最多 ${totalMemories} 条)`);
        if (customCountStr === null) return;
        const customCount = parseInt(customCountStr);
        if (isNaN(customCount) || customCount < 2 || customCount > totalMemories) {
            alert(`请输入一个 2 到 ${totalMemories} 之间的有效数字。`);
            return;
        }
        countToRefine = customCount;
        memoriesToRefine = targetChatForRefine.longTermMemory.slice(-countToRefine);
    } else {
        countToRefine = parseInt(choice);
        if (countToRefine >= totalMemories) {
            memoriesToRefine = [...targetChatForRefine.longTermMemory];
            countToRefine = totalMemories;
        } else {
            memoriesToRefine = targetChatForRefine.longTermMemory.slice(-countToRefine);
        }
    }
    
    const wordCountStr = await showCustomPrompt(
        "设置精炼字数",
        "请输入精炼后核心记忆的大致字数：",
        "150"
    );
    
    if (wordCountStr === null) return;
    
    const wordCount = parseInt(wordCountStr);
    if (isNaN(wordCount) || wordCount < 20) {
        alert("请输入一个有效的数字（建议大于20）。");
        return;
    }

    const confirmed = await showCustomConfirm(
        '确认精炼记忆？',
        `此操作会将选定的 ${countToRefine} 条长期记忆发送给AI，总结成大约 ${wordCount} 字的核心记忆。这些旧记忆将被替换，此操作不可撤销。确定要继续吗？`,
        { confirmButtonClass: 'btn-danger', confirmText: '确认精炼' }
    );

    if (!confirmed) return;

    const memoryContent = memoriesToRefine.map(mem => `- ${mem.content}`).join('\n');
    const userNickname = state.qzoneSettings.nickname || '用户';

    // ===================================================================
    // ▼▼▼ 核心修改部分 ▼▼▼
    // ===================================================================
    const systemPrompt = `
# 你的任务
你就是角色“${targetChatForRefine.originalName}”。请你回顾一下你和“${userNickname}”的长期记忆，然后用【第一人称 ("我")】的口吻，将它们整合成一个更加精炼、连贯、更高层次的核心记忆摘要。

# 核心规则
1.  **视角铁律**: 你的总结【必须】使用【主观的第一人称视角 ("我")】来写。
2.  **内容核心**: 你的回忆应该包含：
    * **剧情回顾**: 我和${userNickname}之间发生了什么关键的事？
    * **心理活动**: 我当时心里是怎么想的？有什么感觉？
3.  **保留关键信息**: 必须保留所有关键的人物、事件、设定和情感关系。绝对不能遗忘任何重要细节。
4.  **口吻与人设**: 你的语气【必须】严格符合你的角色设定。
5.  **输出格式**: 你的回复【必须且只能】是一个JSON对象，格式如下：
    \`{"summary": "在这里写下你以第一人称视角，总结好的核心回忆。"}\`

# 你的角色设定 (必须严格遵守)
${targetChatForRefine.settings.aiPersona}

# 你的聊天对象（用户）的人设
${targetChatForRefine.settings.myPersona}

# 待整合的记忆要点列表
${memoryContent}

现在，请以“${targetChatForRefine.originalName}”的身份，开始你的回忆总结。`;
    // ===================================================================
    // ▲▲▲ 核心修改部分结束 ▲▲▲
    // ===================================================================
      
    await showCustomAlert("请稍候...", "正在请求AI进行记忆精炼...");

    try {
        const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
        const { proxyUrl, apiKey, model } = useSecondaryApi 
            ? { proxyUrl: state.apiConfig.secondaryProxyUrl, apiKey: state.apiConfig.secondaryApiKey, model: state.apiConfig.secondaryModel } 
            : state.apiConfig;

        if (!proxyUrl || !apiKey || !model) {
            throw new Error('请先在API设置中配置好（主或副）API以进行总结。');
        }

        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{ role: 'user', content: "请开始整合。" }]);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: "请开始整合。" }],
                    temperature: 0.2,
                })
            });

        if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);

        const data = await response.json();
        let rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
        rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
        const result = JSON.parse(rawContent);

        if (result.summary && typeof result.summary === 'string' && result.summary.trim()) {
            
            const userConfirmedReplacement = await showCustomConfirm(
                '精炼完成，请确认',
                `AI已将您的 ${countToRefine} 条旧记忆总结为以下核心记忆：<br><br><div class="scrollable-content-preview">${result.summary.trim()}</div><br>是否用这条新记忆替换掉这些旧记忆？`,
                { confirmText: '确认替换', cancelText: '保留旧的', confirmButtonClass: 'btn-danger' }
            );

            if (userConfirmedReplacement) {
                const newMemoryEntry = {
                    content: result.summary.trim(),
                    timestamp: Date.now(),
                    source: 'refined'
                };
    
                const startIndex = totalMemories - countToRefine;
                const memoriesToKeep = startIndex > 0 ? targetChatForRefine.longTermMemory.slice(0, startIndex) : [];
                targetChatForRefine.longTermMemory = [...memoriesToKeep, newMemoryEntry];
                
                targetChatForRefine.lastMemorySummaryTimestamp = Date.now();
                await db.chats.put(targetChatForRefine);
                
                if (document.getElementById('long-term-memory-screen').classList.contains('active')) {
                    renderLongTermMemoryList();
                }
                await showCustomAlert('精炼成功', `已成功将 ${countToRefine} 条记忆精炼为 1 条核心记忆！`);
            } else {
                await showCustomAlert('操作已取消', '您的旧有记忆已被完整保留，未作任何修改。');
            }
            
        } else {
            throw new Error("AI返回了空的或格式不正确的总结内容。");
        }

    } catch (error) {
        console.error("精炼长期记忆时出错:", error);
        await showCustomAlert('精炼失败', `操作失败，请检查API配置或稍后重试。\n错误信息: ${error.message}`);
    }
}
        // ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【请用这个支持“个性化记忆注入”的最终版本】完整替换旧的 triggerAutoSummary 函数 ▼▼▼
/**
 * 【核心】执行总结的API调用 (V7.1 - 个性化记忆注入 | 统一客观总结)
 * @param {string} chatId 
 * @param {boolean} force - 是否忽略消息数量检查，强制执行
 */
async function triggerAutoSummary(chatId, force = false) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const lastSummaryTimestamp = chat.lastMemorySummaryTimestamp || 0;
    // --- ✨ 核心修改 ①：修改筛选逻辑 ---
    // 我们现在不仅要获取用户可见的消息，还要把AI自己的“内心独白”也包含进来。
    const messagesToSummarize = force 
        ? chat.history.filter(m => !m.isHidden || (m.role === 'system' && m.content.includes('内心独白'))).slice(-(chat.settings.autoMemoryInterval || 20))
        : chat.history.filter(m => m.timestamp > lastSummaryTimestamp && (!m.isHidden || (m.role === 'system' && m.content.includes('内心独白'))));
        
    if (messagesToSummarize.length < 5) {
        if (force) alert("最近的消息太少，无法进行有意义的总结。");
        return;
    }

    const userNickname = state.qzoneSettings.nickname || '用户';
    
    // --- ✨ 核心修改 ②：更新历史记录格式化逻辑 ---
    // 让AI能清晰地区分“对话”和“自己的内心想法”
    const formattedHistory = messagesToSummarize.map(msg => {
        // 如果是隐藏的内心独白消息
        if (msg.isHidden && msg.role === 'system' && msg.content.includes('内心独白')) {
            // 直接返回内容，它已经包含了清晰的标签
            return msg.content;
        }
        
        // （处理其他普通消息的逻辑保持不变）
        let sender;
        if (msg.role === 'user') {
            sender = userNickname;
        } else {
            sender = msg.senderName || chat.originalName;
        }
        let contentToSummarize = '';
        if (msg.type === 'offline_text') {
            if (msg.content) {
                 contentToSummarize = msg.content;
            } else {
                const dialogue = msg.dialogue ? `「${msg.dialogue}」` : '';
                const description = msg.description ? `(${msg.description})` : '';
                contentToSummarize = `${dialogue} ${description}`.trim();
            }
        } else {
            contentToSummarize = String(msg.content);
        }
        return `${sender}: ${contentToSummarize}`;
    }).join('\n');



    let systemPrompt;

    // ▼▼▼ 核心修改：根据聊天类型，选择不同的总结策略 ▼▼▼
    if (chat.isGroup) {
        // --- 这是为【群聊】设计的全新“个性化记忆”指令 ---
        systemPrompt = `
# 你的任务
你是一个高级的“记忆分配专家”。你的任务是阅读下面的群聊记录，并为【每一个参与的AI角色】生成一段【个性化的、第一人称】的长期记忆。

# 核心规则
1.  **视角铁律**: 每一条总结都【必须】使用【第一人称视角 ("我")】。
2.  **内容核心**: 重点总结：
    *   **我说过的话** 和 **我做过的事**。
    *   别人 **对我** 说的话，或者 **与我相关** 的事。
    *   对我个人 **很重要** 的群聊事件、关键信息和心理活动。
3.  **【简洁性铁律】**: 每条个人记忆总结【绝对不能超过60个字】。
4.  **【省略规则】**: 如果一个角色在本次对话中【完全没有参与或提及】，你可以省略TA的记忆。
5.  **输出格式**: 你的回复【必须且只能】是一个JSON对象，格式如下：
    \`\`\`json
    {
      "summaries": {
        "角色的本名A": "我今天在群里和大家讨论了电影，感觉很开心。",
        "角色的本名B": "我在群里和${userNickname}聊了关于生日派对的事，我们约好了10月1日见面。"
      }
    }
    \`\`\`

# 待总结的群聊记录
${formattedHistory}

# 群成员列表 (你的总结目标)
${chat.members.map(m => `- ${m.groupNickname} (本名: ${m.originalName})`).join('\n')}

现在，请为【参与了对话的AI角色】生成他们各自的、第一人称的、精简的记忆。`;

    } else {
        // --- 这是为【单聊】设计的、保持不变的“客观总结”指令 ---
        systemPrompt = `
# 你的任务
你就是角色“${chat.originalName}”。请你回顾一下刚才和“${userNickname}”的对话，然后用【第一人称 ("我")】的口吻，总结出一段简短的、包含核心事件和心理活动的回忆。

# 核心规则
1.  **视角铁律**: 你的总结【必须】使用【主观的第一人称视角 ("我")】来写。
2.  **内容核心**: 你的回忆应该包含：
    *   **剧情回顾**: 刚才我们聊了什么关键的事？
    *   **心理活动**: 我当时心里是怎么想的？有什么感觉？
3.  **长度铁律**: 你的总结【必须】非常简短，总长度【绝对不能超过80个字】。
4.  **口吻与人设**: 你的语气【必须】严格符合你的角色设定。
5.  **输出格式**: 你的回复【必须且只能】是一个JSON对象，格式如下：
    \`{"summary": "在这里写下你以第一人称视角，总结好的核心回忆。"}\`

# 你的角色设定
${chat.settings.aiPersona}

# 待总结的对话历史
${formattedHistory}

现在，请以“${chat.originalName}”的身份，开始你的回忆。`;
    }
    // ▲▲▲ 修改结束 ▲▲▲

    try {
        const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
        const { proxyUrl, apiKey, model } = useSecondaryApi ? { proxyUrl: state.apiConfig.secondaryProxyUrl, apiKey: state.apiConfig.secondaryApiKey, model: state.apiConfig.secondaryModel } : state.apiConfig;
        if (!proxyUrl || !apiKey || !model) throw new Error('API未配置');
        
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{ role: 'user', content: "请开始总结。" }]);
        const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, { method: 'POST', headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`}, body: JSON.stringify({ model: model, messages: [{role: 'system', content: systemPrompt}, {role: 'user', content: "请开始总结。"}], temperature: 0.2 }) });
        
        if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);
        const data = await response.json();
        let rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
        rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
        const result = JSON.parse(rawContent);

        // ▼▼▼ 核心修改：根据聊天类型，执行不同的记忆保存逻辑 ▼▼▼
        if (chat.isGroup) {
            // --- 这是群聊的“个性化记忆注入”逻辑 ---
            if (result.summaries && typeof result.summaries === 'object') {
                let memoriesAddedCount = 0;
                for (const memberOriginalName in result.summaries) {
                    const summaryText = result.summaries[memberOriginalName];
                    if (summaryText && summaryText.trim()) {
                        const memberChat = Object.values(state.chats).find(c => c.originalName === memberOriginalName);
                        if (memberChat) {
                            const newMemoryEntry = {
                                content: summaryText.trim(),
                                timestamp: Date.now(),
                                source: `group_summary_from_${chat.name}`
                            };
                            if (!memberChat.longTermMemory) memberChat.longTermMemory = [];
                            memberChat.longTermMemory.push(newMemoryEntry);
                            await db.chats.put(memberChat);
                            memoriesAddedCount++;
                        }
                    }
                }
                if (memoriesAddedCount > 0) {
                    // *** 修改点 1：移除弹窗，改为在控制台输出日志 ***
                    console.log(`自动总结成功：为 ${memoriesAddedCount} 位群成员生成并注入了个性化记忆！`);
                } else {
                    throw new Error("AI返回了空的或格式不正确的总结内容。");
                }
            } else {
                throw new Error("AI返回的JSON格式不正确，缺少 'summaries' 字段。");
            }
        } else {
            if (result.summary && result.summary.trim()) {
                const newMemoryEntry = { content: result.summary.trim(), timestamp: Date.now(), source: 'auto' };
                chat.longTermMemory.push(newMemoryEntry);
                await db.chats.put(chat);
                // *** 修改点 2：移除弹窗，改为在控制台输出日志 ***
                console.log('自动总结成功：已成功添加 1 条新的长期记忆！');
            } else {
                throw new Error("AI返回了空的或格式不正确的总结内容。");
            }
        }

        chat.lastMemorySummaryTimestamp = messagesToSummarize.slice(-1)[0].timestamp;
        await db.chats.put(chat);
        
        if (document.getElementById('long-term-memory-screen').classList.contains('active')) {
            renderLongTermMemoryList();
        }
    } catch (error) {
        console.error("总结长期记忆时出错:", error);
        // *** 修改点 3：失败时依然弹出错误提示 ***
        await showCustomAlert('总结失败', `操作失败: ${error.message}`);
    }
}

        // ▼▼▼ 【全新】引用回复功能函数 ▼▼▼
        
        function startReplyToMessage() {
            if (!activeMessageTimestamp) return;
        
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
            if (!message) return;
        
            // 【【【核心修复就在这里！】】】
            let senderDisplayName;
            if (message.role === 'user') {
                senderDisplayName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
            } else { // AI的消息
                if (chat.isGroup) {
                    // 在群聊中，我们使用 getDisplayNameInGroup 函数来获取正确的群昵称
                    senderDisplayName = getDisplayNameInGroup(chat, message.senderName);
                } else {
                    // 在单聊中，直接使用备注名
                    senderDisplayName = chat.name;
                }
            }
            // 【【【修复结束】】】
        
            const fullContent = String(message.content || '');
            let previewSnippet = '';
        
            if (typeof message.content === 'string' && STICKER_REGEX.test(message.content)) {
                previewSnippet = '[表情]';
            } else if (message.type === 'ai_image' || message.type === 'user_photo') {
                previewSnippet = '[图片]';
            } else if (message.type === 'voice_message') {
                previewSnippet = '[语音]';
            } else {
                previewSnippet = fullContent.substring(0, 50) + (fullContent.length > 50 ? '...' : '');
            }
        
            currentReplyContext = {
                timestamp: message.timestamp,
                senderName: senderDisplayName, // 使用我们刚刚获取到的、正确的显示名称
                content: fullContent, 
            };
        
            const previewBar = document.getElementById('reply-preview-bar');
            previewBar.querySelector('.sender').textContent = `回复 ${currentReplyContext.senderName}:`;
            previewBar.querySelector('.text').textContent = previewSnippet;
            previewBar.style.display = 'block';
        
            hideMessageActions();
            document.getElementById('chat-input').focus();
        }
        
        function cancelReplyMode() {
            currentReplyContext = null;
            document.getElementById('reply-preview-bar').style.display = 'none';
        }
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        
        // ▼▼▼ 【全新】用户处理转账的核心功能函数 ▼▼▼
        
        let activeTransferTimestamp = null; // 用于暂存被点击的转账消息的时间戳
        
        /**
         * 显示处理转账的操作菜单
         * @param {number} timestamp - 被点击的转账消息的时间戳
         */
        function showTransferActionModal(timestamp) {
            activeTransferTimestamp = timestamp;
        
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestamp);
            if (message) {
                // 将AI的名字填入弹窗
                document.getElementById('transfer-sender-name').textContent = message.senderName;
            }
            document.getElementById('transfer-actions-modal').classList.add('visible');
        }
        
        /**
         * 隐藏处理转账的操作菜单
         */
        function hideTransferActionModal() {
            document.getElementById('transfer-actions-modal').classList.remove('visible');
            activeTransferTimestamp = null;
        }
        
        /**
         * 处理用户接受或拒绝转账的逻辑
         * @param {string} choice - 用户的选择, 'accepted' 或 'declined'
         */
        async function handleUserTransferResponse(choice) {
            if (!activeTransferTimestamp) return;
        
            const timestamp = activeTransferTimestamp;
            const chat = state.chats[state.activeChatId];
            const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
            if (messageIndex === -1) return;
        
            // 1. 更新原始转账消息的状态
            const originalMessage = chat.history[messageIndex];
            originalMessage.status = choice;
        
            let systemContent;
        
            // 2. 如果用户选择“拒绝”
            if (choice === 'declined') {
                // 立刻在前端生成一个“退款”卡片，让用户看到
                const refundMessage = {
                    role: 'user',
                    type: 'transfer',
                    isRefund: true, // 这是一个关键标记，用于UI显示这是退款
                    amount: originalMessage.amount,
                    note: '已拒收对方转账',
                    timestamp: Date.now()
                };
                chat.history.push(refundMessage);
                
                // 准备一条对AI可见的隐藏消息，告诉它发生了什么
                systemContent = `[系统提示：你拒绝并退还了“${originalMessage.senderName}”的转账。]`;
            } else { // 如果用户选择“接受”
                // 只需准备隐藏消息通知AI即可
                systemContent = `[系统提示：你接受了“${originalMessage.senderName}”的转账。]`;
            }
        
            // 3. 创建这条对用户隐藏、但对AI可见的系统消息
            const hiddenMessage = {
                role: 'system',
                content: systemContent,
                timestamp: Date.now() + 1, // 保证时间戳在退款消息之后
                isHidden: true // 这个标记会让它不在聊天界面显示
            };
            chat.history.push(hiddenMessage);
        
            // 4. 保存所有更改到数据库，并刷新界面
            await db.chats.put(chat);
            hideTransferActionModal(); 
            renderChatInterface(state.activeChatId);
            renderChatList();
        }
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        
        // ▼▼▼ 【全新】通话记录功能核心函数 ▼▼▼
        
        async function renderCallHistoryScreen() {
            showScreen('call-history-screen'); // <--【核心修正】把它移动到最前面！
        
            const listEl = document.getElementById('call-history-list');
            const titleEl = document.getElementById('call-history-title');
            listEl.innerHTML = '';
            titleEl.textContent = '所有通话记录';
            
            const records = await db.callRecords.orderBy('timestamp').reverse().toArray();
            
            if (records.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有通话记录哦~</p>';
                return; // 现在的 return 就没问题了，因为它只跳过了后续的渲染逻辑
            }
            
            records.forEach(record => {
                const card = createCallRecordCard(record);
        
            addLongPressListener(card, async () => {
                // 1. 弹出输入框，并将旧名称作为默认值，方便修改
                const newName = await showCustomPrompt(
                    "自定义通话名称", 
                    "请输入新的名称（留空则恢复默认）",
                    record.customName || '' // 如果已有自定义名称，就显示它
                );
        
                // 2. 如果用户点击了“取消”，则什么都不做
                if (newName === null) return;
                
                // 3. 更新数据库中的这条记录
                await db.callRecords.update(record.id, { customName: newName.trim() });
                
                // 4. 刷新整个列表，让更改立刻显示出来
                await renderCallHistoryScreen();
                
                // 5. 给用户一个成功的提示
                await showCustomAlert('成功', '通话名称已更新！');
            });
                listEl.appendChild(card);
            });    
        }
        
        // ▼▼▼ 用这个【升级版】函数，完整替换你旧的 createCallRecordCard 函数 ▼▼▼
        /**
         * 【升级版】根据单条记录数据，创建一张能显示聊天对象的通话卡片
         * @param {object} record - 一条通话记录对象
         * @returns {HTMLElement} - 创建好的卡片div
         */
        function createCallRecordCard(record) {
            const card = document.createElement('div');
            card.className = 'call-record-card';
            card.dataset.recordId = record.id; 
        
            // 获取通话对象的名字
            const chatInfo = state.chats[record.chatId];
            const chatName = chatInfo ? chatInfo.name : '未知会话';
        
            const callDate = new Date(record.timestamp);
            const dateString = `${callDate.getFullYear()}-${String(callDate.getMonth() + 1).padStart(2, '0')}-${String(callDate.getDate()).padStart(2, '0')} ${String(callDate.getHours()).padStart(2, '0')}:${String(callDate.getMinutes()).padStart(2, '0')}`;
            const durationText = `${Math.floor(record.duration / 60)}分${record.duration % 60}秒`;
        
            const avatarsHtml = record.participants.map(p => 
                `<img src="${p.avatar}" alt="${p.name}" class="participant-avatar" title="${p.name}">`
            ).join('');
            
            card.innerHTML = `
                <div class="card-header">
                    <span class="date">${dateString}</span>
                    <span class="duration">${durationText}</span>
                </div>
                <div class="card-body">
                    <!-- 【核心修改】在这里新增一个标题行 -->
                    ${record.customName ? `<div class="custom-title">${record.customName}</div>` : ''}
                    
                    <div class="participants-info"> <!-- 新增一个容器方便布局 -->
                        <div class="participants-avatars">${avatarsHtml}</div>
                        <span class="participants-names">与 ${chatName}</span>
                    </div>
                </div>
            `;
            return card;
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
/**
 * 【V2.0 | 支持手动总结 & 错误处理】显示指定通话记录的完整文字稿
 * @param {number} recordId - 通话记录的ID
 */
async function showCallTranscript(recordId) {
    const record = await db.callRecords.get(recordId);
    if (!record) return;

    const modal = document.getElementById('call-transcript-modal');
    const titleEl = document.getElementById('transcript-modal-title');
    const bodyEl = document.getElementById('call-transcript-modal-body');

    titleEl.textContent = `通话于 ${new Date(record.timestamp).toLocaleString()} (时长: ${Math.floor(record.duration / 60)}分${record.duration % 60}秒)`;
    bodyEl.innerHTML = '';
    
    const deleteBtn = document.getElementById('delete-transcript-btn');
    const summarizeBtn = document.getElementById('manual-summarize-btn');
    
    if (!record.transcript || record.transcript.length === 0) {
        bodyEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">这次通话没有留下文字记录。</p>';
        summarizeBtn.style.display = 'none';
    } else {
        summarizeBtn.style.display = 'block';
        record.transcript.forEach(entry => {
            const bubble = document.createElement('div');
            bubble.className = `transcript-entry ${entry.role}`; 
            bubble.textContent = entry.content;
            bodyEl.appendChild(bubble);
        });
    }

    const newDeleteBtn = deleteBtn.cloneNode(true);
    deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
    const newSummarizeBtn = summarizeBtn.cloneNode(true);
    summarizeBtn.parentNode.replaceChild(newSummarizeBtn, summarizeBtn);
    
    newDeleteBtn.addEventListener('click', async () => {
        const confirmed = await showCustomConfirm(
            "确认删除", "确定要永久删除这条通话记录吗？此操作不可恢复。", { confirmButtonClass: 'btn-danger' }
        );
        if (confirmed) {
            modal.classList.remove('visible');
            await db.callRecords.delete(recordId);
            await renderCallHistoryScreen();
            alert('通话记录已删除。');
        }
    });

// ▼▼▼ 【这是您需要替换的代码块】 ▼▼▼

newSummarizeBtn.addEventListener('click', async () => {
    // 【核心新增1】在执行操作前，先弹出确认框
    const confirmed = await showCustomConfirm(
        '确认操作',
        '这将提取当前通话记录发送给AI进行总结，会消耗API额度。确定要继续吗？', {
            confirmText: '确认总结'
        }
    );

    // 如果用户取消，则不执行任何操作
    if (!confirmed) return;

    modal.classList.remove('visible');
    const chat = state.chats[record.chatId];
    if (!chat) {
        alert('错误：找不到该通话记录所属的聊天对象。');
        return;
    }

    await showCustomAlert("请稍候...", "正在请求AI进行手动总结...");

    try {
        const transcriptText = record.transcript.map(h => {
            const sender = h.role === 'user' ? (chat.settings.myNickname || '我') : (h.senderName || chat.name);
            return `${sender}: ${h.content}`;
        }).join('\n');

        await summarizeCallTranscript(record.chatId, transcriptText);

        await showCustomAlert("总结成功", `手动总结已完成！新的记忆已添加到“${chat.name}”的长期记忆中。`);

    } catch (error) {
        await showCustomAlert("总结失败", `操作失败，未能生成长期记忆。\n\n错误详情: ${error.message}`);
    }
});

// ▲▲▲ 替换到这里结束 ▲▲▲
// ▼▼▼ 【这是您需要添加的核心修复代码】 ▼▼▼

// 3. 为“关闭”按钮也创建克隆并绑定事件，确保它总是可用
const closeBtn = document.getElementById('close-transcript-modal-btn');
const newCloseBtn = closeBtn.cloneNode(true);
closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);

newCloseBtn.addEventListener('click', () => {
    modal.classList.remove('visible');
});

// ▲▲▲ 新增代码粘贴结束 ▲▲▲
    modal.classList.add('visible');
}
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        
        // ▼▼▼ 请用这个【全新函数】替换掉你旧的 handleStatusResetClick 函数 ▼▼▼
        
        /**
         * 【全新】处理用户点击状态栏，弹出编辑框让用户修改AI的当前状态
         */
        async function handleEditStatusClick() {
            // 1. 安全检查，确保在单聊界面
            if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
                return; 
            }
            const chat = state.chats[state.activeChatId];
        
            // 2. 弹出输入框，让用户输入新的状态，并将当前状态作为默认值
            const newStatusText = await showCustomPrompt(
                '编辑对方状态',
                '请输入对方现在的新状态：',
                chat.status.text // 将当前状态作为输入框的默认内容
            );
        
            // 3. 如果用户输入了内容并点击了“确定”
            if (newStatusText !== null) {
                // 4. 更新内存和数据库中的状态数据
                chat.status.text = newStatusText.trim() || '在线'; // 如果用户清空了，就默认为“在线”
                chat.status.isBusy = false; // 每次手动编辑都默认其不处于“忙碌”状态
                chat.status.lastUpdate = Date.now();
                await db.chats.put(chat);
        
                // 5. 立刻刷新UI，让用户看到修改后的状态
                renderChatInterface(state.activeChatId);
                renderChatList();
                
                // 6. 给出一个无伤大雅的成功提示
                await showCustomAlert('状态已更新', `“${chat.name}”的当前状态已更新为：${chat.status.text}`);
            }
        }
        
        // 放在你的JS功能函数定义区
        async function openShareTargetPicker() {
            const modal = document.getElementById('share-target-modal');
            const listEl = document.getElementById('share-target-list');
            listEl.innerHTML = '';
        
            // 获取所有聊天作为分享目标
            const chats = Object.values(state.chats);
        
            chats.forEach(chat => {
                // 复用联系人选择器的样式
                const item = document.createElement('div');
                item.className = 'contact-picker-item'; 
                item.innerHTML = `
                    <input type="checkbox" class="share-target-checkbox" data-chat-id="${chat.id}" style="margin-right: 15px;">
                    <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
                    <span class="name">${chat.name}</span>
                `;
                listEl.appendChild(item);
            });
            
            modal.classList.add('visible');
        }
        
        function closeMusicPlayerWithAnimation(callback) {
            const overlay = document.getElementById('music-player-overlay');
            if (!overlay.classList.contains('visible')) {
                if (callback) callback();
                return;
            }
            overlay.classList.remove('visible');
            setTimeout(() => {
                document.getElementById('music-playlist-panel').classList.remove('visible');
                if (callback) callback();
            }, 400); 
        }
        
function parseLRC(lrcContent) {
    if (!lrcContent) return [];
    const lines = String(lrcContent).split(/\r\n?|\n/);
    const lyrics = [];
    const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;
    for (const line of lines) {
        const text = line.replace(timeRegex, '').trim();
        if (!text) continue;
        timeRegex.lastIndex = 0;
        let match;
        while ((match = timeRegex.exec(line)) !== null) {
            const minutes = parseInt(match[1], 10);
            const seconds = parseInt(match[2], 10);
            const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
            const time = minutes * 60 + seconds + milliseconds / 1000;
            lyrics.push({ time, text });
        }
    }
    return lyrics.sort((a, b) => a.time - b.time);
}

function renderLyrics() {
    const lyricsList = document.getElementById('music-lyrics-list');
    lyricsList.innerHTML = '';
    if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
        lyricsList.innerHTML = '<div class="lyric-line">♪ 暂无歌词 ♪</div>';
        return;
    }
    musicState.parsedLyrics.forEach((line, index) => {
        const lineEl = document.createElement('div');
        lineEl.className = 'lyric-line';
        lineEl.textContent = line.text;
        lineEl.dataset.index = index;
        lyricsList.appendChild(lineEl);
    });
    lyricsList.style.transform = `translateY(0px)`;
}

function updateActiveLyric(currentTime) {
    if (musicState.parsedLyrics.length === 0) return;
    let newLyricIndex = -1;
    for (let i = 0; i < musicState.parsedLyrics.length; i++) {
        if (currentTime >= musicState.parsedLyrics[i].time) {
            newLyricIndex = i;
        } else {
            break;
        }
    }
    if (newLyricIndex === musicState.currentLyricIndex) return;
    musicState.currentLyricIndex = newLyricIndex;
    updateLyricsUI();
    
    const singleLyricEl = document.getElementById('single-lyric-display');
    if (singleLyricEl) {
        if (newLyricIndex > -1 && musicState.parsedLyrics[newLyricIndex]) {
            singleLyricEl.textContent = musicState.parsedLyrics[newLyricIndex].text;
        } else {
            singleLyricEl.textContent = '♪ ♪ ♪';
        }
    }

    const lyricBar = document.getElementById('global-lyrics-bar');
    if (lyricBar.classList.contains('visible')) {
        if (newLyricIndex > -1 && musicState.parsedLyrics[newLyricIndex]) {
            lyricBar.textContent = musicState.parsedLyrics[newLyricIndex].text;
        } else {
            lyricBar.textContent = '♪';
        }
    }
}

function updateLyricsUI(isFullscreen = false) {
    const listSelector = isFullscreen ? '#fullscreen-lyrics-container .music-lyrics-list' : '#music-lyrics-container #music-lyrics-list';
    const containerSelector = isFullscreen ? '#fullscreen-lyrics-container' : '#music-lyrics-container';
    
    const lyricsList = document.querySelector(listSelector);
    const container = document.querySelector(containerSelector);
    if (!lyricsList || !container) return;

    const lines = lyricsList.querySelectorAll('.lyric-line');
    lines.forEach(line => line.classList.remove('active'));

    if (musicState.currentLyricIndex === -1) {
        lyricsList.style.transform = `translateY(0px)`;
        return;
    }

    const activeLine = lyricsList.querySelector(`.lyric-line[data-index="${musicState.currentLyricIndex}"]`);
    if (activeLine) {
        activeLine.classList.add('active');
        const containerHeight = container.offsetHeight;
        const offset = (containerHeight / 2.2) - activeLine.offsetTop - (activeLine.offsetHeight / 2);
        lyricsList.style.transform = `translateY(${offset}px)`;
    }
}

function formatMusicTime(seconds) {
    if (isNaN(seconds) || seconds < 0) return "0:00";
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${String(remainingSeconds).padStart(2, '0')}`;
}

let lastTimeUpdate = 0; 
let animationFrameId; 

function updateMusicProgressBar() {
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
    }

    function step() {
        if (!musicState.isPlaying || !audioPlayer.duration) {
            return; 
        }
        
        const now = performance.now();
        const currentTime = audioPlayer.currentTime;
        const duration = audioPlayer.duration;

        const progressPercent = (currentTime / duration) * 100;
        document.getElementById('music-progress-fill').style.width = `${progressPercent}%`;

        if (now - lastTimeUpdate > 1000) {
            document.getElementById('music-current-time').textContent = formatMusicTime(currentTime);
            document.getElementById('music-total-time').textContent = formatMusicTime(duration);
            lastTimeUpdate = now;
        }

        updateActiveLyric(currentTime);

        animationFrameId = requestAnimationFrame(step);
    }

    animationFrameId = requestAnimationFrame(step);
}
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 【全新】导演模式核心功能 ▼▼▼
        
        /**
         * 【总入口】打开“导演剪辑室”，编辑AI的上一轮响应
         */
        function openAiResponseEditor() {
            if (!lastRawAiResponse) {
                alert("还没有可供编辑的AI响应。请先让AI回复一次。");
                return;
            }
        
            const editorModal = document.getElementById('ai-response-editor-modal');
            const editorContainer = document.getElementById('ai-response-editor-container');
            editorContainer.innerHTML = ''; // 清空旧内容
        
            // 使用与主流程相同的、强大的解析函数来提取所有JSON对象
            const jsonMatches = lastRawAiResponse.match(/{[^{}]*}/g);
            
            if (jsonMatches) {
                jsonMatches.forEach(jsonString => {
                    try {
                        // 美化JSON格式，方便阅读和编辑
                        const parsedObject = JSON.parse(jsonString);
                        const formattedJson = JSON.stringify(parsedObject, null, 2);
                        const block = createAiResponseEditorBlock(formattedJson);
                        editorContainer.appendChild(block);
                    } catch (e) {
                        // 如果某个片段不是有效的JSON，也把它显示出来，让用户可以修正它
                        const block = createAiResponseEditorBlock(jsonString);
                        editorContainer.appendChild(block);
                        console.warn("在导演模式中发现一个无效的JSON片段:", jsonString);
                    }
                });
            } else {
                // 如果完全没有找到JSON，就把原始文本放进去让用户编辑
                const block = createAiResponseEditorBlock(lastRawAiResponse);
                editorContainer.appendChild(block);
            }
            
            editorModal.classList.add('visible');
        }
        
// ▼▼▼ 【请用这个已添加“引用”模板的版本】替换旧的 createAiResponseEditorBlock 函数 ▼▼▼
/**
 * 【辅助函数】创建一个可编辑的AI响应块
 * @param {string} initialContent - 文本框的初始内容
 * @returns {HTMLElement} - 创建好的DOM元素
 */
function createAiResponseEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'ai-response-editor-block';

    // 【核心修改1】在这里添加 'quote' 模板
    const templates = {
        text: { type: 'text', content: '在这里输入文本...' },
        sticker: { type: 'sticker', url: 'https://...', meaning: '表情含义' },
        image: { type: 'ai_image', description: '在这里输入图片描述...' },
        voice: { type: 'voice_message', content: '在这里输入语音内容...' },
        transfer: { type: 'transfer', amount: 5.20, note: '一点心意' },
        offline: { type: 'offline_text', content: '「在这里输入对话内容」\\n(在这里输入动作或环境描写)' },
        quote: { type: 'quote_reply', target_timestamp: 1234567890, reply_content: '在这里输入回复内容' }
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="删除此条动作">×</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.text)}'>文本</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.sticker)}'>表情</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.offline)}'>线下</button>
            <!-- 【核心修改2】在这里添加新的“引用”按钮 -->
            <button class="format-btn" data-template='${JSON.stringify(templates.quote)}'>引用</button>
        </div>
    `;

    // 绑定删除按钮事件
    block.querySelector('.delete-block-btn').addEventListener('click', () => {
        block.remove();
    });

    // 绑定格式助手按钮事件
    block.querySelectorAll('.format-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const templateStr = btn.dataset.template;
            const textarea = block.querySelector('textarea');
            if (templateStr && textarea) {
                try {
                    const templateObj = JSON.parse(templateStr);
                    // 美化格式后填入
                    textarea.value = JSON.stringify(templateObj, null, 2);
                    textarea.focus();
                } catch(e) { console.error("解析格式模板失败:", e); }
            }
        });
    });

    return block;
}
// ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 【V3.0 | 容错终极修复版】请用这个全新的函数，完整替换旧的 saveEditedAiResponse 函数 ▼▼▼
        /**
         * 【核心】保存导演模式下修改过的内容，并重写历史记录
         */
        async function saveEditedAiResponse() {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            // 1. 从DOM中收集所有编辑后的JSON字符串，并构建一个新的原始响应字符串
            const editorContainer = document.getElementById('ai-response-editor-container');
            const editorTextareas = editorContainer.querySelectorAll('textarea');
            const editedRawBlocks = Array.from(editorTextareas).map(ta => ta.value.trim()).filter(Boolean);
        
            // 如果用户删除了所有内容，则视为清空上一轮回复
            if (editedRawBlocks.length === 0) {
                chat.history = chat.history.filter(msg => !lastResponseTimestamps.includes(msg.timestamp));
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);
                renderChatList();
                document.getElementById('ai-response-editor-modal').classList.remove('visible');
                lastRawAiResponse = '';
                lastResponseTimestamps = [];
                return;
            }
        
            // 2. 解析新的消息数组
            let newMessagesArray = [];
            for (const rawContent of editedRawBlocks) {
                try {
                    const parsedObject = JSON.parse(rawContent);
                    newMessagesArray.push(parsedObject);
                } catch (e) {
                    console.warn("跳过一个无法解析为JSON的编辑块:", rawContent);
                }
            }
        
            // 3. 从聊天历史中移除上一轮AI生成的所有消息
            chat.history = chat.history.filter(msg => !lastResponseTimestamps.includes(msg.timestamp));
        
            // 4. 将新编辑的消息添加回历史记录，并记录它们新的时间戳
            let newTimestamps = [];
            let messageTimestamp = Date.now();
            
            for (const msgData of newMessagesArray) {
                 if (!msgData || typeof msgData !== 'object' || !msgData.type) {
                    console.warn("在导演模式保存时，发现无效的指令对象，已跳过:", msgData);
                    continue;
                }
        
                let aiMessage = null;
                const baseMessage = { role: 'assistant', senderName: msgData.name || chat.originalName, timestamp: messageTimestamp++ };
        
                switch (msgData.type) {
                    case 'text':
                        aiMessage = { ...baseMessage, content: String(msgData.content || msgData.message) };
                        break;
                    case 'sticker':
                        aiMessage = { ...baseMessage, type: 'sticker', content: msgData.url, meaning: msgData.meaning || '' };
                        break;
                    case 'ai_image':
                        aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description };
                        break;
                    case 'voice_message':
                        aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                        break;
                    case 'transfer':
                        aiMessage = { ...baseMessage, type: 'transfer', amount: msgData.amount, note: msgData.note, receiverName: msgData.receiver || '我' };
                        break;
                    case 'waimai_request':
                        aiMessage = { 
                            ...baseMessage, type: 'waimai_request',
                            productInfo: msgData.productInfo, amount: msgData.amount,
                            status: 'pending', countdownEndTime: Date.now() + 15 * 60 * 1000,
                        };
                        break;
                    case 'offline_text':
                           aiMessage = { ...baseMessage, ...msgData };
                        break;
                    // ▼▼▼ 在这里粘贴新代码 ▼▼▼
                    case 'gomoku_move': {
                        const gameState = gomokuState[chat.id];
                        if (gameState) {
                            // 1. 找到AI的上一步棋
                            const lastAiMoveIndex = gameState.history.findLastIndex(move => move.player === 2);
                            
                            if (lastAiMoveIndex > -1) {
                                const move_to_undo = gameState.history[lastAiMoveIndex];
                                
                                // 2. 从棋盘数据中“拿掉”这颗棋子
                                gameState.board[move_to_undo.y][move_to_undo.x] = 0;
                                
                                // 3. 从下棋历史中移除这一步
                                gameState.history.splice(lastAiMoveIndex, 1);
                                
                                console.log(`导演模式悔棋：已撤销AI在 (${move_to_undo.x}, ${move_to_undo.y}) 的棋步。`);
                            }
                        }

                        // 4. 执行新的下棋指令
                        const x = parseInt(msgData.x);
                        const y = parseInt(msgData.y);
                        if (!isNaN(x) && !isNaN(y)) {
                            handleAiGomokuMove({ x: x, y: y }, true);
                        } else {
                            console.warn("导演模式保存了一个无效的五子棋移动指令:", msgData);
                        }
                        continue;
                    }
                    case 'update_thoughts': { 
    if (!chat.isGroup) {
        if (msgData.heartfelt_voice) {
            chat.heartfeltVoice = String(msgData.heartfelt_voice);
        }
        if (msgData.random_jottings) {
            chat.randomJottings = String(msgData.random_jottings);
        }
        if (!Array.isArray(chat.thoughtsHistory)) {
            chat.thoughtsHistory = [];
        }
        chat.thoughtsHistory.push({
            heartfeltVoice: chat.heartfeltVoice,
            randomJottings: chat.randomJottings,
            timestamp: Date.now()
        });
        if (chat.thoughtsHistory.length > 50) {
            chat.thoughtsHistory.shift();
        }

        // --- 【【【核心修改就在这里！】】】 ---
        // 1. 将刚刚更新的心声和散记，格式化为一段AI能理解的文本。
        const thoughtForMemory = `[这是你上一轮的内心独白和思考]
- 心声: ${chat.heartfeltVoice}
- 散记: ${chat.randomJottings}`;
        
        // 2. 创建一条对用户隐藏的系统消息
        const hiddenThoughtMessage = {
            role: 'system',
            content: thoughtForMemory,
            timestamp: Date.now(),
            isHidden: true // 这个关键标记确保用户看不到这条指令，但它存在于历史记录中
        };

        // 3. 将这条“记忆碎片”也存入聊天记录
        chat.history.push(hiddenThoughtMessage);
        // --- 【【【修改结束】】】 ---
    }
    continue;
                    }
                    // ▲▲▲ 新代码粘贴结束 ▲▲▲
                    // 在 switch 语句中，添加一个专门处理 'quote_reply' 的 case
                    case 'quote_reply': {
                        // 1. 查找被引用的原始消息
                        const originalQuotedMsg = chat.history.find(m => m.timestamp === msgData.target_timestamp);
                        let quoteContext = null;

                        if (originalQuotedMsg) {
                            // 2. 如果找到了，就构建正确的 quote 对象
                            let originalSenderName = originalQuotedMsg.senderName;
                            if (originalQuotedMsg.role === 'user') {
                                originalSenderName = chat.isGroup ? (chat.settings.myNickname || '我') : (state.qzoneSettings.nickname || '{{user}}');
                            }
                            
                            quoteContext = {
                                timestamp: msgData.target_timestamp,
                                senderName: originalSenderName,
                                content: String(originalQuotedMsg.content || '')
                            };
                        } else {
                            // 3. 如果没找到，创建一个安全的占位符，防止程序出错
                            quoteContext = {
                                timestamp: msgData.target_timestamp,
                                senderName: '未知用户',
                                content: '原始消息已删除或不存在'
                            };
                        }
                        
                        // 4. 构建最终的消息对象，包含 quote 属性
                        aiMessage = { 
                            ...baseMessage, 
                            content: msgData.reply_content,
                            quote: quoteContext
                        };
                        break; // 结束这个 case
                    }
                    default:
                         console.warn("在导演模式保存时，遇到了未知的AI指令类型:", msgData.type);
                         break;
                }
        
                if (aiMessage) {
                    chat.history.push(aiMessage);
                    newTimestamps.push(aiMessage.timestamp);
                }
            }
        
            // 5. 保存到数据库并刷新整个聊天界面
            await db.chats.put(chat);
            renderChatInterface(state.activeChatId);
            renderChatList();
            document.getElementById('ai-response-editor-modal').classList.remove('visible');
            
            // 6. 更新缓存，以便下次编辑
            lastRawAiResponse = editedRawBlocks.join('\n\n');
            lastResponseTimestamps = newTimestamps;
            
            // 7. 给出成功提示
            await showCustomAlert("导演模式", "您的修改已保存！");
        }
        /**
         * 【全新】处理用户点击“撤回”按钮的入口函数
         */
        async function handleRecallClick() {
            if (!activeMessageTimestamp) return;
        
            const RECALL_TIME_LIMIT_MS = 2 * 60 * 1000; // 设置2分钟的撤回时限
            const messageTime = activeMessageTimestamp;
            const now = Date.now();
        
            // 检查是否超过了撤回时限
            if (now - messageTime > RECALL_TIME_LIMIT_MS) {
                hideMessageActions();
                await showCustomAlert('操作失败', '该消息发送已超过2分钟，无法撤回。');
                return;
            }
            
            // 如果在时限内，执行真正的撤回逻辑
            await recallMessage(messageTime, true);
            hideMessageActions();
        }
        
/**
 * 【V2.0 | AI感知版】消息撤回的核心逻辑
 * @param {number} timestamp - 要撤回的消息的时间戳
 * @param {boolean} isUserRecall - 是否是用户主动撤回
 */
async function recallMessage(timestamp, isUserRecall) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    const messageToRecall = chat.history[messageIndex];

    const recalledData = {
        originalType: messageToRecall.type || 'text',
        originalContent: messageToRecall.content,
        originalMeaning: messageToRecall.meaning,
        originalQuote: messageToRecall.quote
    };
    
    messageToRecall.type = 'recalled_message';
    messageToRecall.content = isUserRecall ? '你撤回了一条消息' : '对方撤回了一条消息';
    messageToRecall.recalledData = recalledData;
    delete messageToRecall.meaning;
    delete messageToRecall.quote;

    // ▼▼▼ 核心修改就在这里！▼▼▼
    if (isUserRecall) {
        // 1. 获取用户在当前聊天中的正确昵称
        const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
        
        // 2. 将被撤回的内容转换为AI能理解的文本
        let recalledContentText = '';
        if (recalledData.originalType === 'sticker') {
            recalledContentText = `[表情，含义: ${recalledData.originalMeaning || '未知'}]`;
        } else if (recalledData.originalType === 'ai_image' || recalledData.originalType === 'user_photo') {
            recalledContentText = `[图片，描述: ${recalledData.originalContent}]`;
        } else {
            recalledContentText = `“${String(recalledData.originalContent)}”`;
        }

        // 3. 创建一条对用户隐藏、但对AI可见的系统消息
        const hiddenMessageForAI = {
            role: 'system',
            content: `[系统提示：用户（${myNickname}）刚刚撤回了一条消息。撤回前的内容是：${recalledContentText}。请你对此作出回应，可以表现出好奇、开玩笑（比如'我截图了！'）、或者根据你的人设表示理解或疑惑。]`,
            timestamp: Date.now(),
            isHidden: true // 这个标记确保用户看不到这条指令
        };
        chat.history.push(hiddenMessageForAI);
    }
    // ▲▲▲ 修改结束 ▲▲▲

    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    
    if (isUserRecall) {
        renderChatList();
        // 【重要】在用户撤回后，立刻触发AI，让它对这个事件做出反应！
        triggerAiResponse();
    }
}
        
        // ▼▼▼ 【全新】将这些函数粘贴到你的JS功能函数定义区 ▼▼▼
        
        /**
         * 打开分类管理模态框
         */
        async function openCategoryManager() {
            await renderCategoryListInManager();
            document.getElementById('world-book-category-manager-modal').classList.add('visible');
        }
        
        /**
         * 在模态框中渲染已存在的分类列表
         */
        async function renderCategoryListInManager() {
            const listEl = document.getElementById('existing-categories-list');
            const categories = await db.worldBookCategories.toArray();
            listEl.innerHTML = '';
            if (categories.length === 0) {
                listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类</p>';
            }
            categories.forEach(cat => {
                // 复用好友分组的样式
                const item = document.createElement('div');
                item.className = 'existing-group-item'; 
                item.innerHTML = `
                    <span class="group-name">${cat.name}</span>
                    <span class="delete-group-btn" data-id="${cat.id}">×</span>
                `;
                listEl.appendChild(item);
            });
        }
        
        /**
         * 添加一个新的世界书分类
         */
        async function addNewCategory() {
            const input = document.getElementById('new-category-name-input');
            const name = input.value.trim();
            if (!name) {
                alert('分类名不能为空！');
                return;
            }
            const existing = await db.worldBookCategories.where('name').equals(name).first();
            if (existing) {
                alert(`分类 "${name}" 已经存在了！`);
                return;
            }
            await db.worldBookCategories.add({ name });
            input.value = '';
            await renderCategoryListInManager();
        }
        
        /**
         * 删除一个世界书分类
         * @param {number} categoryId - 要删除的分类的ID
         */
        async function deleteCategory(categoryId) {
            const confirmed = await showCustomConfirm(
                '确认删除', 
                '删除分类后，该分类下的所有世界书将变为“未分类”。确定要删除吗？', 
                { confirmButtonClass: 'btn-danger' }
            );
            if (confirmed) {
                await db.worldBookCategories.delete(categoryId);
                // 将属于该分类的世界书的 categoryId 设为 null
                const booksToUpdate = await db.worldBooks.where('categoryId').equals(categoryId).toArray();
                for (const book of booksToUpdate) {
                    book.categoryId = null;
                    await db.worldBooks.put(book);
                    const bookInState = state.worldBooks.find(wb => wb.id === book.id);
                    if(bookInState) bookInState.categoryId = null;
                }
                await renderCategoryListInManager();
            }
        }
        
        // ▼▼▼ 【全新版本】发布公告函数 (无评论) ▼▼▼
        async function publishToAnnouncementBoard() {
            if (!activeMessageTimestamp) return;
        
            const timestampToPublish = activeMessageTimestamp;
            hideMessageActions(); 
        
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestampToPublish);
            if (!message) return;
        
            // 提取消息内容用于预览
            let contentPreview = String(message.content || '').substring(0, 50) + '...';
            if (message.type === 'ai_image') contentPreview = '[图片] ' + contentPreview;
        
            const confirmed = await showCustomConfirm(
                "发布公告",
                `确定要将以下消息发布到公告板吗？\n\n“${contentPreview}”`,
                { confirmText: "确定发布" }
            );
        
            if (confirmed) {
                const myNickname = chat.settings.myNickname || '我';
        
                if (!Array.isArray(chat.announcements)) {
                    chat.announcements = [];
                }
        
                // 新增的公告对象
                const newAnnouncement = {
                    id: 'anno_' + Date.now(), // 为每个公告添加唯一ID
                    messageTimestamp: timestampToPublish,
                    publisher: myNickname,
                    publishedAt: Date.now(),
                    isPinned: false // 默认为不置顶
                };
        
                chat.announcements.push(newAnnouncement);
        
                const systemMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `${myNickname} 发布了一条新公告`,
                    timestamp: Date.now()
                };
                chat.history.push(systemMessage);
        
                await db.chats.put(chat);
                appendMessage(systemMessage, chat);
                renderChatList();
        
                await showCustomAlert("成功", "公告已发布！");
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲
        /**
         * 显示群公告板弹窗
         */
        // ▼▼▼ 【最终修复版】请用这个全新的函数，完整替换旧的 showAnnouncementBoard 函数 ▼▼▼
        /**
         * 【V2.0 | 已修复异步渲染BUG】显示群公告板弹窗
         */
        async function showAnnouncementBoard() { // <--- 核心修复1：将函数声明为 async
            const chat = state.chats[state.activeChatId];
            const announcements = chat.announcements || [];

            if (!chat || announcements.length === 0) {
                showCustomAlert("提示", "当前群聊还没有公告哦。");
                return;
            }

            const contentEl = document.getElementById('announcement-board-content');
            contentEl.innerHTML = '';

            // 将置顶的公告排在最前面
            announcements.sort((a, b) => (b.isPinned ? 1 : 0) - (a.isPinned ? 1 : 0));

            // 【核心修复2】使用 for...of 循环，以便在循环内部安全地使用 await
            for (const anno of announcements) {
                const originalMessage = chat.history.find(m => m.timestamp === anno.messageTimestamp);

                const wrapper = document.createElement('div');
                wrapper.className = 'announcement-item-wrapper';

                if (originalMessage) {
                    // 【核心修复3】在这里使用 await，等待 createMessageElement 函数真正完成并返回HTML元素
                    const messageBubbleEl = await createMessageElement(originalMessage, chat);
                    if (messageBubbleEl) { // 安全检查，确保元素已成功创建
                        wrapper.appendChild(messageBubbleEl);
                    }
                } else {
                    wrapper.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">公告的原消息已被删除。</p>';
                }

                if (anno.isPinned) {
                    wrapper.innerHTML += `<div class="pinned-indicator">📌</div>`;
                }
                wrapper.innerHTML += `<div class="announcement-item-actions" data-anno-id="${anno.id}">...</div>`;

                contentEl.appendChild(wrapper);
            }

            document.getElementById('announcement-board-modal').classList.add('visible');
        }
        // ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 【这是您缺失的核心功能代码，请粘贴在这里】 ▼▼▼
        let activeAnnouncementId = null; // 用于暂存正在操作的公告ID
        
        /**
         * 点击“...”时，显示操作菜单（置顶/删除）
         * @param {string} annoId - 公告的唯一ID
         */
        function showAnnouncementActions(annoId) {
            activeAnnouncementId = annoId;
            const chat = state.chats[state.activeChatId];
            const announcement = chat.announcements.find(a => a.id === annoId);
            if (!announcement) return;
        
            const pinButton = document.getElementById('announcement-action-pin');
            // 根据当前是否已置顶，动态改变按钮文字
            pinButton.textContent = announcement.isPinned ? '取消置顶' : '置顶公告';
        
            document.getElementById('announcement-actions-modal').classList.add('visible');
        }
        
        /**
         * 处理“置顶/取消置顶”操作
         */
        async function handlePinAnnouncement() {
            if (!activeAnnouncementId) return;
            const chat = state.chats[state.activeChatId];
            const announcement = chat.announcements.find(a => a.id === activeAnnouncementId);
            if (announcement) {
                announcement.isPinned = !announcement.isPinned; // 切换置顶状态
                await db.chats.put(chat);
                showAnnouncementBoard(); // 重新渲染公告板以更新UI
            }
            document.getElementById('announcement-actions-modal').classList.remove('visible');
        }
        
        /**
         * 处理“删除公告”操作
         */
        async function handleDeleteAnnouncement() {
            if (!activeAnnouncementId) return;
            
            const confirmed = await showCustomConfirm("确认删除", "确定要删除这条公告吗？此操作不可恢复。", { confirmButtonClass: 'btn-danger' });
            
            if (confirmed) {
                const chat = state.chats[state.activeChatId];
                // 从公告数组中过滤掉要删除的公告
                chat.announcements = chat.announcements.filter(a => a.id !== activeAnnouncementId);
                await db.chats.put(chat);
                showAnnouncementBoard(); // 重新渲染
            }
            document.getElementById('announcement-actions-modal').classList.remove('visible');
        }
        // ▲▲▲ 粘贴结束 ▲▲▲

        
        // ▼▼▼ 【这是您缺失的核心功能代码，请粘贴在这里】 ▼▼▼
        let editingFrameForMember = false;
        let currentFrameSelection = { ai: null, my: null };
        
        function openFrameSelectorModal(type = 'chat') {
            const frameModal = document.getElementById('avatar-frame-modal');
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            editingFrameForMember = (type === 'member');
        
            if (editingFrameForMember) {
                const member = chat.members.find(m => m.id === editingMemberId);
                if (!member) return;
                currentFrameSelection.my = member.avatarFrame || '';
                populateFrameGrids(true, member.avatar, member.avatarFrame);
            } else {
                currentFrameSelection.ai = chat.settings.aiAvatarFrame || '';
                currentFrameSelection.my = chat.settings.myAvatarFrame || '';
                populateFrameGrids(false);
            }
            frameModal.classList.add('visible');
        }
        
        function populateFrameGrids(isForMember = false, memberAvatar = null, memberFrame = null) {
            const aiFrameGrid = document.getElementById('ai-frame-grid');
            const myFrameGrid = document.getElementById('my-frame-grid');
            const chat = state.chats[state.activeChatId];
            aiFrameGrid.innerHTML = '';
            myFrameGrid.innerHTML = '';
        
            document.querySelector('#avatar-frame-modal .frame-tabs').style.display = isForMember ? 'none' : 'flex';
            document.getElementById('ai-frame-content').style.display = 'block';
            document.getElementById('my-frame-content').style.display = 'none';
            document.getElementById('ai-frame-tab').classList.add('active');
            document.getElementById('my-frame-tab').classList.remove('active');
        
            if (isForMember) {
                avatarFrames.forEach(frame => {
                    const item = createFrameItem(frame, 'my', memberAvatar);
                    if (frame.url === memberFrame) {
                        item.classList.add('selected');
                    }
                    aiFrameGrid.appendChild(item);
                });
            } else {
                const aiAvatarForPreview = chat.settings.aiAvatar || defaultAvatar;
                const myAvatarForPreview = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
                avatarFrames.forEach(frame => {
                    const aiItem = createFrameItem(frame, 'ai', aiAvatarForPreview);
                    if (frame.url === currentFrameSelection.ai) aiItem.classList.add('selected');
                    aiFrameGrid.appendChild(aiItem);
                    const myItem = createFrameItem(frame, 'my', myAvatarForPreview);
                    if (frame.url === currentFrameSelection.my) myItem.classList.add('selected');
                    myFrameGrid.appendChild(myItem);
                });
            }
        }
        
        function createFrameItem(frame, type, previewAvatarSrc) {
            const item = document.createElement('div');
            item.className = 'frame-item';
            item.dataset.frameUrl = frame.url;
            item.title = frame.name;
            item.innerHTML = `
                <img src="${previewAvatarSrc}" class="preview-avatar">
                ${frame.url ? `<img src="${frame.url}" class="preview-frame">` : ''}
            `;
            item.addEventListener('click', () => {
                currentFrameSelection[type] = frame.url;
                const grid = type === 'ai' ? document.getElementById('ai-frame-grid') : document.getElementById('my-frame-grid');
                grid.querySelectorAll('.frame-item').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
            });
            return item;
        }
        
        async function saveSelectedFrames() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            if (editingFrameForMember) {
                const member = chat.members.find(m => m.id === editingMemberId);
                if (member) {
                    member.avatarFrame = currentFrameSelection.my;
                }
            } else {
                chat.settings.aiAvatarFrame = currentFrameSelection.ai;
                chat.settings.myAvatarFrame = currentFrameSelection.my;
            }
        // ... (函数前面的代码) ...
            await db.chats.put(chat);
        
            // ▼▼▼ 在这里粘贴修复代码 ▼▼▼
            // 核心修复：当更新单聊角色的头像框时，同步到所有包含该角色的群聊中
            if (!editingFrameForMember && !chat.isGroup) {
                const characterId = chat.id; // 获取被修改的角色的ID
        
                // 遍历所有聊天，找出包含这个角色的群聊
                for (const groupChat of Object.values(state.chats)) {
                    if (groupChat.isGroup && groupChat.members) {
                        // 在群聊中找到对应的成员对象
                        const memberToUpdate = groupChat.members.find(m => m.id === characterId);
        
                        // 如果找到了，就更新他的头像框信息
                        if (memberToUpdate) {
                            memberToUpdate.avatarFrame = chat.settings.aiAvatarFrame;
                            // 【至关重要】将修改后的【整个群聊对象】存回数据库
                            await db.chats.put(groupChat);
                            console.log(`已同步角色 ${characterId} 的头像框到群聊 "${groupChat.name}"`);
                        }
                    }
                }
            }
            // ▲▲▲ 修复代码粘贴结束 ▲▲▲
        
            document.getElementById('avatar-frame-modal').classList.remove('visible');
            renderChatInterface(state.activeChatId);
            alert('头像框已保存并同步！'); // 修改了提示，让您知道同步也完成了
            editingFrameForMember = false;
        }
        
        // ▲▲▲ 粘贴结束 ▲▲▲
        
        // ▼▼▼ 在这里粘贴新函数 ▼▼▼
        /**
         * 将用户自定义的全局CSS应用到页面
         * @param {string} cssString 用户输入的CSS代码
         */
        function applyGlobalCss(cssString) {
            const styleTag = document.getElementById('global-custom-style');
            if (styleTag) {
                // 如果有代码就应用，没有就清空
                styleTag.innerHTML = cssString || '';
            }
        }
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        
        // ▼▼▼ 【全新】请将这个函数粘贴到JS功能函数定义区 ▼▼▼
        /**
         * 向当前聊天的历史记录中添加一条关于音乐操作的、对用户隐藏的系统消息
         * @param {string} actionText - 描述用户操作的文本，例如 "暂停了音乐"
         */
        async function addMusicActionSystemMessage(actionText) {
            // 1. 检查音乐功能是否激活，以及是否在某个聊天中
            if (!musicState.isActive || !musicState.activeChatId) return;
            const chat = state.chats[musicState.activeChatId];
            if (!chat) return;
        
            // 2. 获取用户在当前聊天中的昵称
            const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
            const fullMessage = `[系统提示：用户 (${myNickname}) ${actionText}]`;
        
            // 3. 创建这条特殊的、隐藏的系统消息
            const systemMessage = {
                role: 'system',
                content: fullMessage,
                timestamp: Date.now(),
                isHidden: true // 这个标记让消息对用户不可见，但AI能读到
            };
        
            // 4. 将消息存入历史记录并更新数据库
            chat.history.push(systemMessage);
            await db.chats.put(chat);
        }
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        // ▼▼▼ 【最终修复版本】请用这个全新的函数，完整替换旧的 handleLongScreenshot ▼▼▼
        
        /**
         * 【V3.0 | 布局修复版】处理长截图功能
         */
        async function handleLongScreenshot() {
            if (selectedMessages.size === 0) return;
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            // 0. 显示“生成中”状态
            const screenshotBtn = document.getElementById('selection-screenshot-btn');
            const originalBtnText = screenshotBtn.textContent;
            screenshotBtn.textContent = '生成中...';
            screenshotBtn.disabled = true;
        
            // 1. 创建临时的截图容器和样式（这部分不变）
            const screenshotContainer = document.createElement('div');
            const phoneScreen = document.getElementById('phone-screen');
            screenshotContainer.style.width = phoneScreen.offsetWidth + 'px';
            screenshotContainer.style.position = 'absolute';
            screenshotContainer.style.top = '-9999px';
            screenshotContainer.style.left = '-9999px';
            screenshotContainer.style.display = 'flex';
            screenshotContainer.style.flexDirection = 'column';
            screenshotContainer.style.height = 'auto';
            
            const chatScreen = document.getElementById('chat-interface-screen');
            screenshotContainer.style.backgroundImage = chatScreen.style.backgroundImage;
            screenshotContainer.style.backgroundColor = chatScreen.style.backgroundColor || (document.getElementById('phone-screen').classList.contains('dark-mode') ? '#000000' : '#f0f2f5');
        
            const tempStyle = document.createElement('style');
            tempStyle.innerHTML = `
                .message-bubble.selected::after { display: none !important; }
                .cloned-header .default-controls { display: flex !important; justify-content: space-between; align-items: center; width: 100%; }
                .cloned-header .selection-controls { display: none !important; }
            `;
            document.head.appendChild(tempStyle);
        
            try {
                // 2. 组装截图元素（头部和输入框部分不变）
                const header = chatScreen.querySelector('.header').cloneNode(true);
                header.classList.add('cloned-header');
                
                // ★★★★★ 这就是本次修复的核心！ ★★★★★
                // 我们不再使用 getComputedStyle，而是创建一个干净的容器并手动应用关键样式。
                const messagesContainer = document.createElement('div');
                const originalMessagesContainer = document.getElementById('chat-messages');
        
                // 手动设置最关键的布局样式，确保消息能正确排列
                messagesContainer.style.display = 'flex';
                messagesContainer.style.flexDirection = 'column';
                messagesContainer.style.gap = '20px'; // 这是消息之间的垂直间距
                messagesContainer.style.padding = '10px 15px 20px 15px'; // 上、左右、下内边距，底部多留一点
                messagesContainer.style.width = '100%';
                messagesContainer.style.boxSizing = 'border-box';
        
                // 继承主题和字体大小，这对于气泡颜色和文字大小至关重要
                messagesContainer.dataset.theme = originalMessagesContainer.dataset.theme;
                messagesContainer.style.setProperty('--chat-font-size', originalMessagesContainer.style.getPropertyValue('--chat-font-size'));
                // ★★★★★ 修复结束 ★★★★★
        
                const inputArea = chatScreen.querySelector('#chat-input-area').cloneNode(true);
        
                const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
                sortedTimestamps.forEach(timestamp => {
                    // 注意：我们这里依然需要从原始DOM中克隆，因为它们已经应用了所有复杂的CSS
                    const originalBubble = document.querySelector(`.message-bubble[data-timestamp="${timestamp}"]`);
                    if (originalBubble) {
                        const originalWrapper = originalBubble.closest('.message-wrapper');
                        if (originalWrapper) {
                            messagesContainer.appendChild(originalWrapper.cloneNode(true));
                        }
                    }
                });
        
                screenshotContainer.appendChild(header);
                screenshotContainer.appendChild(messagesContainer);
                screenshotContainer.appendChild(inputArea);
                document.body.appendChild(screenshotContainer);
                
                // 图片预加载逻辑（保持不变）
                const images = Array.from(screenshotContainer.getElementsByTagName('img'));
                const imageLoadPromises = images.map(img => new Promise((resolve, reject) => {
                    if (img.src.startsWith('data:')) {
                        resolve();
                        return;
                    }
                    const newImg = new Image();
                    newImg.crossOrigin = 'anonymous';
                    newImg.onload = resolve;
                    newImg.onerror = resolve; 
                    newImg.src = img.src;
                }));
                
                await Promise.all(imageLoadPromises);
        
                // 3. 调用 html2canvas（保持不变）
                const canvas = await html2canvas(screenshotContainer, {
                    allowTaint: true,
                    useCORS: true,
                    backgroundColor: null,
                    scale: window.devicePixelRatio || 2,
                });
        
                // 4. 使用 Blob 对象下载（保持不变）
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = `EPhone-长截图-${chat.name}-${Date.now()}.png`;
                    link.href = url;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                }, 'image/png');
        
            } catch (error) {
                console.error('长截图生成失败:', error);
                await showCustomAlert('生成失败', '生成截图时发生错误，请检查控制台获取详情。');
            } finally {
                // 5. 清理工作（保持不变）
                document.body.removeChild(screenshotContainer);
                document.head.removeChild(tempStyle);
                screenshotBtn.textContent = originalBtnText;
                screenshotBtn.disabled = false;
                exitSelectionMode(); 
            }
        }
        // ▲▲▲ 全新JS函数粘贴结束 ▲▲▲
        /**
         * 【V2.1 | 最终修复版】一个简单的 Markdown 解析器
         * @param {string} text - 包含 Markdown 语法的原始文本
         * @returns {string} - 转换成 HTML 后的文本
         */
        function parseMarkdown(text) {
            if (!text || typeof text !== 'string') return '';

            // 顺序很重要：先处理我们自定义的复杂规则
            text = text.replace(/!h\{(.*?)\}/g, '<span class="diary-highlight">$1</span>');
            text = text.replace(/!u\{(.*?)\}/g, '<span class="diary-underline">$1</span>');
            text = text.replace(/!e\{(.*?)\}/g, '<span class="diary-emphasis">$1</span>');
            text = text.replace(/!w\{(.*?)\}/g, '<span class="diary-handwritten">$1</span>');
            text = text.replace(/!m\{(.*?)\}/g, '<span class="diary-messy">$1</span>');
            
            // ▼▼▼ 核心修改就在这里 ▼▼▼
            // 将原来的 !c{...} 规则，替换为您想要的 ||...|| 规则
            text = text.replace(/\|\|(.*?)\|\|/g, '<span class="spoiler">$1</span>');
            // ▲▲▲ 修改结束 ▲▲▲

            // 再处理标准Markdown
            text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            text = text.replace(/\~\~(.*?)\~\~/g, '<s>$1</s>'); 
            text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');

            return text;
        }


        // ▼▼▼ 【全新 | 数据修复函数】请将这个函数粘贴到您的JS功能区 ▼▼▼
        /**
         * 自动迁移旧的、格式不正确的红包数据，将 'receiver' 字段重命名为 'receiverName'
         */
        async function migrateOldRedPacketData() {
            console.log("开始检查并迁移旧的红包数据...");
            let migrationCount = 0;
            // 直接从内存中的 state.chats 操作，效率更高
            const allChats = Object.values(state.chats);
        
            for (const chat of allChats) {
                let needsDbUpdate = false;
                for (const msg of chat.history) {
                    // 找出所有由AI发送的、带有旧 'receiver' 字段的专属红包
                    if (msg.type === 'red_packet' && msg.packetType === 'direct' && msg.role === 'assistant' && msg.hasOwnProperty('receiver') && !msg.hasOwnProperty('receiverName')) {
                        // 进行“手术”：重命名错误的字段
                        msg.receiverName = msg.receiver;
                        delete msg.receiver;
                        
                        needsDbUpdate = true; // 标记这个聊天需要被重新保存
                        migrationCount++;
                    }
                }
                // 如果这个聊天中有数据被修复了，就将整个更新后的聊天对象保存回数据库
                if (needsDbUpdate) {
                    console.log(`在聊天 "${chat.name}" 中发现并修复了旧红包数据。`);
                    await db.chats.put(chat);
                }
            }
        
            if (migrationCount > 0) {
                console.log(`数据迁移完成！总共修复了 ${migrationCount} 条红包记录。`);
                alert(`检测到并成功修复了 ${migrationCount} 条旧的红包消息！页面将自动刷新以应用更改。`);
                location.reload(); // 强制刷新页面，确保所有显示都使用最新的正确数据
            } else {
                console.log("未发现需要迁移的旧红包数据。");
            }
        }
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲

        function showCharacterProfileModal(chatId) {
            const chat = state.chats[chatId];
            if (!chat || chat.isGroup) return;
        
            // 填充数据
            //document.getElementById('profile-avatar').src = chat.settings.aiAvatar || defaultAvatar;
           // document.getElementById('profile-name').textContent = chat.name;
           // document.getElementById('profile-id').textContent = `ID: ${chat.originalName}`;
            document.getElementById('profile-heartfelt-voice').textContent = chat.heartfeltVoice || '...';
            document.getElementById('profile-random-jottings').textContent = chat.randomJottings || '...';

            const modal = document.getElementById('character-profile-modal');
        
            // 【核心修复】由于我们已经从HTML中移除了“进入聊天”按钮，
            // 这里不再需要为它绑定事件，旧的、导致错误的JavaScript代码已被彻底删除。
            
            // 直接显示弹窗
            modal.classList.add('visible');
        }
        /**
         * 【全新】显示心声历史记录视图
         */
        function showThoughtsHistory() {
            document.getElementById('profile-main-content').style.display = 'none';
            document.getElementById('profile-thoughts-history-view').style.display = 'flex';
            renderThoughtsHistory();
        }
        
        /**
         * 【全新 | 已修复BUG】隐藏心声历史记录视图，返回主资料页
         */
function hideThoughtsHistory() {
    document.getElementById('profile-thoughts-history-view').style.display = 'none';
    
    // 【核心修复】将 'block' 改为 'flex'，恢复其正确的弹性布局
    document.getElementById('profile-main-content').style.display = 'flex'; 
}
// ▲▲▲ 替换结束 ▲▲▲
        
        /**
         * 【全新 | 分页加载版】渲染心声历史记录列表
         */
        function renderThoughtsHistory() {
            const listEl = document.getElementById('thoughts-history-list');
            const chat = state.chats[state.activeChatId];
            listEl.innerHTML = '';
            
            if (!chat || !chat.thoughtsHistory || chat.thoughtsHistory.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; padding: 30px 0;">这里还没有历史记录哦。</p>';
                return;
            }
        
            const history = [...chat.thoughtsHistory].reverse(); // 从新到旧
            const initialItems = history.slice(0, THOUGHTS_RENDER_WINDOW);
            
            initialItems.forEach(thought => {
                const card = createThoughtCard(thought);
                listEl.appendChild(card);
            });
        
            thoughtsHistoryRenderCount = initialItems.length;
        
// 如果还有更多记录，则添加“加载更多”按钮
if (history.length > thoughtsHistoryRenderCount) {
    appendLoadMoreThoughtsButton(listEl); // 核心修改：调用新的函数
}
        }

        
// ▼▼▼ 【无限滚动修复版】请用这个新版本替换旧的 loadMoreThoughts 函数 ▼▼▼
async function loadMoreThoughts() {
    if (isLoadingMoreThoughts) return;
    isLoadingMoreThoughts = true;

    const listEl = document.getElementById('thoughts-history-list');
    const chat = state.chats[state.activeChatId];
    if (!chat) { 
        isLoadingMoreThoughts = false; 
        return; 
    }

    showLoader(listEl, 'bottom'); // 在底部显示加载动画
    await new Promise(resolve => setTimeout(resolve, 500)); // 模拟网络延迟

    const history = [...chat.thoughtsHistory].reverse();
    const totalItems = history.length;

    const nextSliceStart = thoughtsHistoryRenderCount;
    const nextSliceEnd = thoughtsHistoryRenderCount + THOUGHTS_RENDER_WINDOW;
    const itemsToAppend = history.slice(nextSliceStart, nextSliceEnd);

    // 在追加新内容前，先移除加载动画
    hideLoader(listEl);

    itemsToAppend.forEach(thought => {
        const card = createThoughtCard(thought);
        listEl.appendChild(card);
    });

    thoughtsHistoryRenderCount += itemsToAppend.length;

    isLoadingMoreThoughts = false;
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 步骤 1：用这个【全新的函数】，完整替换旧的 createThoughtCard 函数 ▼▼▼
/**
 * 【全新美化版】根据单条记录数据，创建一张心声历史卡片
 * @param {object} thought - 一条心声历史记录对象
 * @returns {HTMLElement} - 创建好的卡片div
 */
function createThoughtCard(thought) {
    const card = document.createElement('div');
    card.className = 'thought-card';
    const date = new Date(thought.timestamp);
    const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
    
    // 【核心修改】在这里添加了一个删除按钮的HTML
    card.innerHTML = `
        <button class="thought-delete-btn" data-timestamp="${thought.timestamp}" title="删除此条记录">×</button>
        <div class="thought-header">${dateString}</div>
        <div class="thought-content">
            <div class="voice">
                <div class="label">
                    <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                    心声
                </div>
                <p class="text">${thought.heartfeltVoice}</p>
            </div>
            <div class="jottings">
                <div class="label">
                     <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path></svg>
                    散记
                </div>
                <p class="text">${thought.randomJottings}</p>
            </div>
        </div>
    `;
    return card;
} 
// ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 【全新】这是导入角色卡的所有核心功能，请将它们完整粘贴到 init() 函数的前面 ▼▼▼
        
        // ▼▼▼ 【最终PNG导入修复】请用这一整块代码，替换旧的 handleCardImport 函数 ▼▼▼
        
        /**
         * 【总入口】当用户选择了角色卡文件后，由此函数开始处理
         * @param {Event} event - 文件输入框的 change 事件
         */
        async function handleCardImport(event) {
            const file = event.target.files[0];
            if (!file) return;
        
            try {
                let cardData;
                let avatarBase64 = null; // 用于存储从PNG卡中提取的头像
        
                if (file.name.endsWith('.json')) {
                    // 处理 JSON 格式的角色卡
                    const text = await file.text();
                    cardData = JSON.parse(text);
                } else if (file.name.endsWith('.png')) {
                    // 处理 PNG 格式的角色卡
                    const arrayBuffer = await file.arrayBuffer();
                    // 【【【核心修复就在这里！现在这个函数被正确定义了】】】
                    cardData = await parsePngForTavernData(arrayBuffer);
                    
                    // 同时，将PNG文件本身转换为Base64，用作头像
                    avatarBase64 = await new Promise(resolve => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.readAsDataURL(file);
                    });
                } else {
                    throw new Error("不支持的文件格式。请选择 .json 或 .png 文件。");
                }
        
                // 将解析出的数据创建为新的聊天对象
                await createChatFromCardData(cardData, avatarBase64);
        
            } catch (error) {
                console.error("角色卡导入失败:", error);
                await showCustomAlert("导入失败", `无法解析角色卡文件。\n错误: ${error.message}`);
            } finally {
                // 清空输入框，以便下次能选择同一个文件
                event.target.value = null;
            }
        }
        
        // ▼▼▼ 【最终乱码修复版】请用这个全新的函数，完整替换旧的 parsePngForTavernData ▼▼▼
        /**
         * 【V2.0 | 修复UTF-8乱码】从PNG文件的ArrayBuffer中解析出隐藏的Tavern AI角色数据
         * @param {ArrayBuffer} arrayBuffer - PNG文件的二进制数据
         * @returns {Promise<object>} - 解析出的JSON角色数据
         */
        function parsePngForTavernData(arrayBuffer) {
            return new Promise((resolve, reject) => {
                const view = new DataView(arrayBuffer);
                // 检查PNG文件头 (8个字节)
                if (view.getUint32(0) !== 0x89504E47 || view.getUint32(4) !== 0x0D0A1A0A) {
                    return reject(new Error("文件不是一个有效的PNG。"));
                }
        
                let offset = 8;
                const decoder = new TextDecoder(); // 这个解码器用于解码区块类型，不是最终数据
        
                while (offset < view.byteLength) {
                    const length = view.getUint32(offset);
                    const type = decoder.decode(arrayBuffer.slice(offset + 4, offset + 8));
        
                    if (type === 'tEXt') {
                        const data = new Uint8Array(arrayBuffer, offset + 8, length);
                        const nullSeparatorIndex = data.indexOf(0);
                        if (nullSeparatorIndex !== -1) {
                            const key = decoder.decode(data.slice(0, nullSeparatorIndex));
                            if (key === 'chara') {
                                const value = decoder.decode(data.slice(nullSeparatorIndex + 1));
                                try {
                                    // ▼▼▼ 【核心修复就在这里！】 ▼▼▼
                                    // 我们不再使用旧的、会导致中文乱码的 atob() 方法。
                                    // 而是采用一个更现代、更可靠的两步流程来解码。
                                    
                                    // 1. 将Base64字符串转换为一个原始的二进制字符串。
                                    const binaryString = atob(value);
                                    
                                    // 2. 创建一个字节数组 (Uint8Array) 来存储这些二进制数据。
                                    const bytes = new Uint8Array(binaryString.length);
                                    for (let i = 0; i < binaryString.length; i++) {
                                        bytes[i] = binaryString.charCodeAt(i);
                                    }
                                    
                                    // 3. 【最关键的一步】使用 TextDecoder 并明确指定 UTF-8 编码，
                                    //    将字节数组正确地解码为包含中文的字符串。
                                    const decodedData = new TextDecoder('utf-8').decode(bytes);
                                    
                                    // ▲▲▲ 修复结束 ▲▲▲
                                    
                                    resolve(JSON.parse(decodedData));
                                    return; // 成功找到并解析，任务完成
                                } catch (e) {
                                    return reject(new Error("在PNG中找到角色数据，但解码或解析失败。错误: " + e.message));
                                }
                            }
                        }
                    }
                    
                    // 移动到下一个区块 (长度 + 类型 + 数据 + CRC)
                    offset += 4 + 4 + length + 4;
                }
        
                reject(new Error("在PNG文件中未找到有效的Tavern AI角色数据(chara chunk)。"));
            });
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 【最终修复版 | V4.0】请用这一整块代码，替换旧的 createChatFromCardData 和可能缺失的 findWorldBookEntries 函数 ▼▼▼
        
        /**
         * 【辅助函数 | 兼容核心】从角色卡数据中智能查找世界书条目
         * @param {object} cardData - 从文件解析出的原始JSON数据
         * @returns {Array|null} - 如果找到，返回 entries 数组；否则返回 null
         */
        function findWorldBookEntries(cardData) {
            // 检查所有可能的路径，按最常见到最少见的顺序
            // 使用可选链 (?.) 来安全地访问可能不存在的深层嵌套属性
            
            // 格式 1: 【针对您卡片的精确路径】数据在 data.character_book 中
            if (cardData.data?.character_book?.entries?.length > 0) {
                console.log("诊断：在 data.character_book 中找到世界书。");
                return cardData.data.character_book.entries;
            }
            
            // 格式 2: 新版 Tavern 卡，数据在 extensions.character_book 中
            if (cardData.extensions?.character_book?.entries?.length > 0) {
                console.log("诊断：在 extensions.character_book 中找到世界书。");
                return cardData.extensions.character_book.entries;
            }
            
            // 格式 3: 某些工具可能将其嵌套在 data.extensions 中
            if (cardData.data?.extensions?.character_book?.entries?.length > 0) {
                console.log("诊断：在 data.extensions.character_book 中找到世界书。");
                return cardData.data.extensions.character_book.entries;
            }
            
            // 格式 4: 兼容我们之前尝试过的、直接在顶层的各种键名
            const possibleTopLevelKeys = ['character_book', 'lorebook', 'world_info', 'char_book'];
            for (const key of possibleTopLevelKeys) {
                if (cardData[key]?.entries?.length > 0) {
                    console.log(`诊断：在顶层 ${key} 中找到世界书。`);
                    return cardData[key].entries;
                }
            }
        
            console.log("诊断：未在此角色卡中找到任何有效的世界书数据。");
            return null; // 如果所有路径都找不到，返回 null
        }
        
        /**
         * 【V6.0 | 已修复导入BUG】根据从角色卡解析的数据，创建并保存一个新的聊天对象
         * @param {object} cardData - 从.json或.png中解析出的角色数据
         * @param {string|null} avatarBase64 - 如果是.png卡，则传入其Base64数据作为头像
         */
        async function createChatFromCardData(cardData, avatarBase64 = null) {
            const effectiveCardData = cardData.data || cardData;
            if (!effectiveCardData.name) {
                throw new Error("角色卡数据无效或缺少'name'字段。");
            }
        
            let worldBookIdToLink = null;
            const worldBookEntries = findWorldBookEntries(cardData);
        
            if (worldBookEntries) {
                const structuredEntries = worldBookEntries
                    .filter(entry => entry.enabled && entry.content)
                    .map(entry => ({
                        keys: entry.keys || [],
                        comment: entry.comment || '',
                        content: entry.content.replace(/<memory>|<\/memory>/g, '').trim()
                    }));
        
                if (structuredEntries.length > 0) {
                    const newWorldBook = {
                        id: 'wb_' + Date.now(),
                        name: `${effectiveCardData.name}的设定集`,
                        content: structuredEntries,
                        categoryId: null
                    };
                    await db.worldBooks.add(newWorldBook);
                    state.worldBooks.push(newWorldBook);
                    worldBookIdToLink = newWorldBook.id;
                }
            }
        
            let description = effectiveCardData.description || cardData.description || '无';
            description = description
                .replace(/```yaml/g, '').replace(/```/g, '')
                .replace(/<\/?info>/g, '').replace(/<\/?character>/g, '')
                .replace(/<\/?writing_rule>/g, '').replace(/\[OOC：.*?\]/g, '').trim();
            let persona = `# 角色核心设定\n${description}\n\n`;
            if (effectiveCardData.personality) persona += `# 性格补充\n${effectiveCardData.personality}\n\n`;
            if (effectiveCardData.scenario) persona += `# 场景设定\n${effectiveCardData.scenario}\n\n`;
            if (effectiveCardData.mes_example) persona += `# 对话示例\n${effectiveCardData.mes_example}\n\n`;

            // ▼▼▼ 【核心修复】在这里定义 remarkName 和 originalName ▼▼▼
            const remarkName = effectiveCardData.name;
            const originalName = effectiveCardData.name;
            // ▲▲▲ 修复结束 ▲▲▲

            const newChatId = 'chat_' + Date.now();
            const newChat = {
                id: newChatId,
                name: remarkName.trim(),
                originalName: originalName.trim(),
                isGroup: false,
                relationship: { status: 'friend' },
                status: { text: '在线', lastUpdate: Date.now(), isBusy: false },
                settings: {
                    aiPersona: persona,
                    myPersona: '我是谁呀。',
                    maxMemory: 10,
                    aiAvatar: defaultAvatar,
                    myAvatar: defaultAvatar,
                    background: '',
                    theme: 'default',
                    fontSize: 13,
                    customCss: '',
                    linkedWorldBookIds: worldBookIdToLink ? [worldBookIdToLink] : [],
                    aiAvatarLibrary: []
                },
                history: [],
                musicData: { totalTime: 0 },
                longTermMemory: []
            };

            if (avatarBase64) {
                newChat.settings.aiAvatar = avatarBase64;
                newChat.settings.aiAvatarLibrary.push({ name: '默认头像', url: avatarBase64 });
            }

            const greetingHtml = effectiveCardData.first_mes || cardData.first_mes;
            if (greetingHtml && typeof greetingHtml === 'string') {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = greetingHtml;
                const cleanGreeting = (tempDiv.textContent || tempDiv.innerText || "").replace(/原作者UR.*?开局/s, '').trim();
                if (cleanGreeting) {
                    newChat.history.push({
                        role: 'assistant',
                        senderName: newChat.originalName,
                        content: cleanGreeting,
                        timestamp: Date.now()
                    });
                }
            }
            state.chats[newChatId] = newChat;
            await db.chats.put(newChat);
            renderChatList();
            let successMessage = `角色 “${newChat.name}” 已成功导入！`;
            if (worldBookIdToLink) {
                successMessage += `\n\n其专属的“世界书”也已自动创建并关联。`;
            }
            await showCustomAlert('导入成功！', successMessage);
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
            // ▼▼▼ 【全新】这是切换开场白的核心功能，请粘贴到 init() 函数的前面 ▼▼▼
            /**
             * 【总入口】处理用户点击“切换开场”按钮的逻辑
             */
            async function handleSwitchGreeting() {
                if (!state.activeChatId) return;
                const chat = state.chats[state.activeChatId];
                const greetings = chat.settings.alternateGreetings;
        
                if (!greetings || greetings.length === 0) {
                    alert("这个角色没有可用的备选开场白。");
                    return;
                }
        
                // 1. 将备选开场白数组转换为 showChoiceModal 需要的格式
                const options = greetings.map((text, index) => {
                    // 提取每个开场白的前20个字符作为预览
                    const preview = text.replace(/<[^>]*>/g, '').trim().substring(0, 20);
                    return {
                        text: `开场 ${index + 1}: ${preview}...`,
                        value: index // 将数组索引作为返回值
                    };
                });
        
                // 2. 弹出选择菜单
                const selectedIndex = await showChoiceModal('选择一个开场白', options);
        
                // 3. 如果用户做出了选择 (而不是取消)
                if (selectedIndex !== null) {
                    // 4. 【重要】弹出警告，确认是否要覆盖聊天记录
                    const confirmed = await showCustomConfirm(
                        '确认操作',
                        '切换开场将会【清空并替换】当前的所有聊天记录。确定要继续吗？',
                        { confirmButtonClass: 'btn-danger', confirmText: '确定切换' }
                    );
        
                    if (confirmed) {
                        // 5. 执行切换逻辑
                        const newGreetingText = greetings[selectedIndex];
                        
                        const newMessage = {
                            role: 'assistant',
                            senderName: chat.originalName,
                            content: newGreetingText,
                            timestamp: Date.now()
                        };
        
                        // 替换整个历史记录
                        chat.history = [newMessage];
                        
                        // 保存到数据库
                        await db.chats.put(chat);
        
                        // 刷新UI
                        renderChatInterface(chat.id);
                        document.getElementById('chat-settings-modal').classList.remove('visible'); // 关闭设置弹窗
                        await showCustomAlert('成功', '已切换到新的开场故事！');
                    }
                }
            }
            // ▲▲▲ 新增函数结束 ▲▲▲
        
        // ▼▼▼ 【请用这个新版本】替换旧的 createWorldBookEntryBlock 函数 ▼▼▼
        /**
         * 【辅助函数】创建一个可编辑的世界书条目块
         * @param {object} entry - 单个条目的数据 { keys, comment, content, enabled }
         * @returns {HTMLElement} - 创建好的DOM元素
         */
        function createWorldBookEntryBlock(entry = { keys: [], comment: '', content: '', enabled: true }) {
            const block = document.createElement('div');
            // 复用我们之前为消息编辑器创建的样式
            block.className = 'message-editor-block';
        
            // 【核心修改】根据条目的 enabled 状态决定开关是否被选中
            const isChecked = entry.enabled !== false ? 'checked' : '';

            block.innerHTML = `
                <div style="display: flex; justify-content: flex-end; align-items: center; gap: 10px; margin-bottom: 5px;">
                    <label class="toggle-switch" title="启用/禁用此条目">
                        <input type="checkbox" class="entry-enabled-switch" ${isChecked}>
                        <span class="slider"></span>
                    </label>
                    <button class="delete-block-btn" title="删除此条目">×</button>
                </div>
                <div class="form-group" style="margin-bottom: 10px;">
                    <label style="font-size: 0.8em;">备注 (可选)</label>
                    <input type="text" class="entry-comment-input" value="${entry.comment || ''}" placeholder="例如：关于角色的童年" style="padding: 8px;">
                </div>
                <div class="form-group" style="margin-bottom: 10px;">
                    <label style="font-size: 0.8em;">关键词 (用英文逗号,分隔)</label>
                    <input type="text" class="entry-keys-input" value="${(entry.keys || []).join(', ')}" placeholder="例如: key1, key2, key3" style="padding: 8px;">
                </div>
                <div class="form-group" style="margin-bottom: 0;">
                    <label style="font-size: 0.8em;">内容</label>
                    <textarea class="entry-content-textarea" rows="5" style="width: 100%; font-size: 14px;">${entry.content || ''}</textarea>
                </div>
            `;
        
            // 绑定删除按钮事件
            block.querySelector('.delete-block-btn').addEventListener('click', () => {
                block.remove();
            });
        
            return block;
        }
        // ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 【全新】五子棋功能核心函数 ▼▼▼
        
        /**
         * 【遮罩终极修复版】切换五子棋棋盘的显示与隐藏
         */
        async function toggleGomokuBoard() {
            if (!state.activeChatId) return;
            const chatId = state.activeChatId;
            const overlay = document.getElementById('gomoku-overlay');
        
            // 如果棋盘是隐藏的 -> 打开它
            if (!overlay.classList.contains('visible')) {
                const header = document.querySelector('#chat-interface-screen > .header');
                
                overlay.style.top = `${header.offsetHeight}px`;
                overlay.style.display = 'block';
        
                if (!gomokuState[chatId] || !gomokuState[chatId].isActive) {
                    initGomokuGame(chatId);
                }
                renderGomokuBoard(chatId);
        
                // 【核心】不再操作消息列表的 padding-top
                setTimeout(async () => {
                    overlay.classList.add('visible');
        
                    const startMessage = {
                        role: 'system',
                        content: '[系统提示：用户打开了五子棋棋盘，游戏开始了。]',
                        timestamp: Date.now(),
                        isHidden: true
                    };
                    state.chats[chatId].history.push(startMessage);
                    await db.chats.put(state.chats[chatId]);
                }, 10);
        
            } else {
                // 如果棋盘是显示的 -> 关闭它
                await closeGomokuBoard();
            }
        }
        /**
         * 【遮罩终极修复版】关闭五子棋棋盘
         */
        async function closeGomokuBoard() {
            if (!state.activeChatId) return;
            const chatId = state.activeChatId;
            const overlay = document.getElementById('gomoku-overlay');
            
            overlay.classList.remove('visible');
            
            // 【核心】移除了恢复消息列表 padding-top 的代码
        
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 300);
        
            if (gomokuState[chatId]) {
                gomokuState[chatId].isActive = false;
                
                const endMessage = {
                    role: 'system',
                    content: '[系统提示：用户关闭了五子棋棋盘，游戏结束了。]',
                    timestamp: Date.now(),
                    isHidden: true
                };
                state.chats[chatId].history.push(endMessage);
                await db.chats.put(state.chats[chatId]);
            }
        }
        
        /**
         * 【渲染时序修复版】初始化一局新的五子棋游戏
         * @param {string} chatId 
         */
        function initGomokuGame(chatId) {
            const canvas = document.getElementById('gomoku-board');
            const overlay = document.getElementById('gomoku-overlay');
            const controls = document.getElementById('gomoku-controls');
            
            // 【核心修正】在保证 overlay 可见的前提下，更精确地计算可用空间
            const availableWidth = overlay.offsetWidth - 40; 
            const availableHeight = overlay.offsetHeight - controls.offsetHeight - 40;
            const boardSize = Math.floor(Math.min(availableWidth, availableHeight));
            
            const GRID_SIZE = 15;
            // 确保棋盘尺寸是格子尺寸的整数倍，避免模糊
            const cell_size = Math.floor(boardSize / GRID_SIZE);
            const final_size = cell_size * GRID_SIZE;
            
            canvas.width = final_size;
            canvas.height = final_size;
        
            gomokuState[chatId] = {
                isActive: true,
                board: Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0)),
                currentPlayer: 1, 
                history: [],
                isGameOver: false,
                GRID_SIZE: GRID_SIZE,
                CELL_SIZE: cell_size
            };
        }
        /**
         * 渲染整个棋盘和棋子
         * @param {string} chatId 
         */
        function renderGomokuBoard(chatId) {
            const gameState = gomokuState[chatId];
            if (!gameState) return;
            
            const canvas = document.getElementById('gomoku-board');
            const ctx = canvas.getContext('2d');
            const { GRID_SIZE, CELL_SIZE } = gameState;
            const padding = CELL_SIZE / 2;
        
            // 1. 清空并绘制棋盘背景
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#e4b591';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        
            // 2. 绘制网格线
            ctx.strokeStyle = '#5b3a29';
            ctx.lineWidth = 1;
            for (let i = 0; i < GRID_SIZE; i++) {
                // 横线
                ctx.beginPath();
                ctx.moveTo(padding, padding + i * CELL_SIZE);
                ctx.lineTo(canvas.width - padding, padding + i * CELL_SIZE);
                ctx.stroke();
                // 竖线
                ctx.beginPath();
                ctx.moveTo(padding + i * CELL_SIZE, padding);
                ctx.lineTo(padding + i * CELL_SIZE, canvas.height - padding);
                ctx.stroke();
            }
        
            // 3. 绘制棋子
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (gameState.board[y][x] !== 0) {
                        drawStone(ctx, x, y, gameState.board[y][x], gameState);
                    }
                }
            }
        }
        
        /**
         * 绘制单个棋子
         */
        function drawStone(ctx, x, y, player, gameState) {
            const { CELL_SIZE } = gameState;
            const padding = CELL_SIZE / 2;
            const radius = CELL_SIZE / 2 - 2;
        
            ctx.beginPath();
            ctx.arc(padding + x * CELL_SIZE, padding + y * CELL_SIZE, radius, 0, 2 * Math.PI);
            
            if (player === 1) { // User is black
                ctx.fillStyle = 'black';
            } else { // AI is white
                ctx.fillStyle = 'white';
            }
            ctx.fill();
        }
        
        /**
         * 处理鼠标在棋盘上的悬停效果
         */
        function handleBoardHover(e) {
            const chatId = state.activeChatId;
            const gameState = gomokuState[chatId];
            if (!gameState || gameState.isGameOver || gameState.currentPlayer !== 1) return;
        
            const canvas = document.getElementById('gomoku-board');
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
        
            const gridX = Math.round((x - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);
            const gridY = Math.round((y - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);
        
            renderGomokuBoard(chatId); // Redraw to clear previous hover
        
            if (gridX >= 0 && gridX < gameState.GRID_SIZE && gridY >= 0 && gridY < gameState.GRID_SIZE && gameState.board[gridY][gridX] === 0) {
                const radius = gameState.CELL_SIZE / 2 - 2;
                ctx.beginPath();
                ctx.arc(gameState.CELL_SIZE / 2 + gridX * gameState.CELL_SIZE, gameState.CELL_SIZE / 2 + gridY * gameState.CELL_SIZE, radius, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; // Faint black for preview
                ctx.fill();
            }
        }
        
        /**
         * 处理用户点击棋盘下棋
         */
        function handleBoardClick(e) {
            const chatId = state.activeChatId;
            const gameState = gomokuState[chatId];
            if (!gameState || gameState.isGameOver || gameState.currentPlayer !== 1) return;
        
            const canvas = document.getElementById('gomoku-board');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
        
            const gridX = Math.round((x - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);
            const gridY = Math.round((y - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);
        
            if (gridX >= 0 && gridX < gameState.GRID_SIZE && gridY >= 0 && gridY < gameState.GRID_SIZE && gameState.board[gridY][gridX] === 0) {
                // Place stone
                gameState.board[gridY][gridX] = 1;
                gameState.history.push({ x: gridX, y: gridY, player: 1 });
                renderGomokuBoard(chatId);
        
                // Check for win
                if (checkWin(gridX, gridY, 1, gameState)) {
                    gameState.isGameOver = true;
                    setTimeout(() => alert("恭喜你，你赢了！"), 100);
            // ▼▼▼ 在这里添加新代码 ▼▼▼
            addGameEndSystemMessage('user'); // 通知AI，是用户赢了（也就是AI输了）
            // ▲▲▲ 添加结束 ▲▲▲

                } else {
                    gameState.currentPlayer = 2; // Switch to AI's turn
                    // Note: We don't trigger AI response here. It's triggered by the "Wait Reply" button.
                }
            }
        }
        
        /**
         * 【V2.0 | 修复导演模式】AI下棋的处理器
         * @param {object} move - 包含x,y坐标的对象
         * @param {boolean} isForcedMove - 是否为导演模式下的强制移动
         */
        function handleAiGomokuMove(move, isForcedMove = false) {
            const chatId = state.activeChatId;
            const gameState = gomokuState[chatId];
            
            // 核心修复1：如果是强制移动，就跳过玩家回合的检查
            if (!gameState || gameState.isGameOver) return;
            if (!isForcedMove && gameState.currentPlayer !== 2) return;

            const { x, y } = move;
        
            if (x >= 0 && x < gameState.GRID_SIZE && y >= 0 && y < gameState.GRID_SIZE && gameState.board[y][x] === 0) {
                gameState.board[y][x] = 2; // AI是白棋(2)
                gameState.history.push({ x, y, player: 2 });
                renderGomokuBoard(chatId); // 重新绘制棋盘
        
                if (checkWin(x, y, 2, gameState)) {
                    gameState.isGameOver = true;
                    setTimeout(() => alert("AI 获胜了！"), 100);
                    addGameEndSystemMessage('ai');
                } else {
                    gameState.currentPlayer = 1; // 轮到用户下棋
                }
            } else {
                console.warn("AI 的下棋指令无效或位置已被占据:", move);
                // 如果AI的移动无效，将回合交还给用户，避免游戏卡死
                gameState.currentPlayer = 1;
            }
        }
        
        /**
         * 检查胜利条件
         */
        function checkWin(x, y, player, gameState) {
            const { board, GRID_SIZE } = gameState;
            const directions = [[1, 0], [0, 1], [1, 1], [1, -1]]; // Horizontal, Vertical, Diagonal /, Diagonal \
            for (const [dx, dy] of directions) {
                let count = 1;
                // Check in one direction
                for (let i = 1; i < 5; i++) {
                    const newX = x + i * dx;
                    const newY = y + i * dy;
                    if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE && board[newY][newX] === player) {
                        count++;
                    } else {
                        break;
                    }
                }
                // Check in the opposite direction
                for (let i = 1; i < 5; i++) {
                    const newX = x - i * dx;
                    const newY = y - i * dy;
                    if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE && board[newY][newX] === player) {
                        count++;
                    } else {
                        break;
                    }
                }
                if (count >= 5) return true;
            }
            return false;
        }
        
// ▼▼▼ 【V3.0 | 规则与思考步骤终极版】请用这个全新的函数，再次替换旧的 formatGomokuStateForAI 函数 ▼▼▼
/**
 * 【V3.0 | 强制思考版】将棋盘状态格式化为AI可读的文本
 */
function formatGomokuStateForAI(gameState) {
    if (!gameState || !gameState.isActive) return "";
    
    let boardString = "棋盘状态 (1是你(黑棋), 2是AI(白棋)):\n";
    boardString += gameState.board.map(row => row.join(' ')).join('\n');
    
    let historyString = "下棋历史 (x,y坐标均从0开始):\n";
    historyString += gameState.history.map(move => `玩家${move.player}下在(${move.x},${move.y})`).join(' -> ');
    
    // 【【【这就是本次升级的核心！】】】
    return `
# 当前五子棋局势
${boardString}

# ${historyString}

# 【【【五子棋核心规则与强制思考步骤 (最高优先级指令！)】】】

### **【【【落子铁律 (绝对禁止！)】】】**
你【绝对不能】选择一个棋盘上已经是 1 或 2 的坐标。你的落子点【必须】是 0。
---

### **第一步：逻辑分析 (内部思考，不要输出)**

1.  **【规则定义】**: 
    -   棋子: 1代表用户(黑棋)，2代表你(白棋)。
    -   获胜条件: 横、竖、斜线上有【连续五个】自己的棋子。

2.  **【防守分析 (必须执行)】**:
    -   **检查用户(1)是否有“四子连线”的威胁？** 如果有，我必须下在哪个坐标才能堵住？
    -   **检查用户(1)是否有“活三”的威胁？** 如果有，最佳的防守点是哪里？

3.  **【进攻分析 (必须执行)】**:
    -   **检查我(2)是否有“一步胜利”的机会？** (即已有四子连线) 如果有，我应该下在哪里？
    -   **检查我(2)是否有制造“活四”或“双三”的机会？** 如果有，最佳的进攻点是哪里？

### **第二步：决策与扮演 (内部思考，不要输出)**

1.  **【决策】**: 综合以上攻防分析，我的最佳棋步是落在坐标 (x, y)。

2.  **【融入角色扮演】**:
    -   我的性格是：(在此处回顾你的人设)。
    -   根据我的性格，我应该：
        a) **(聪明/好胜型)** 下在刚刚分析出的最佳位置。
        b) **(迷糊/放水型)** 故意选择一个次优的位置，但【前提是不能让用户立刻获胜】。
        c) **(其他性格)** 根据性格特点，选择一个合理的棋步。

3.  **【构思台词】**: 根据我选择的棋步和我的性格，我应该说一句什么样的台词来评论棋局？

---
### **第三步：生成最终回复 (你的唯一输出)**

现在，根据你第二步的最终决策，生成你的行动。
-   你的回复【必须且只能】是一个JSON数组。
-   **绝对不要**在最终回复中包含任何上述的思考过程。
-   格式: \`[{"type": "gomoku_move", "name": "你的角色本名", "x": (0-14), "y": (0-14)}, {"type": "text", "content": "你的台词..."}]\`
`;
}
// ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 【全新V2.0 | 最终版】请用这个函数替换掉之前的 notifyAiOfGameEnd 函数 ▼▼▼
        /**
         * 【全新】当五子棋游戏结束时，向聊天记录中添加一条隐藏的系统消息，供AI在下次响应时查看
         * @param {string} winner - 获胜方, 'user' 或 'ai'
         */
        async function addGameEndSystemMessage(winner) {
            const chatId = state.activeChatId;
            const chat = state.chats[chatId];
            if (!chat) return;

            // 1. 根据获胜方，准备好要告诉AI的核心信息
            // 【核心】这里的名字获取逻辑已修复，确保在群聊和单聊中都能正确显示
            const userDisplayName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
            const aiDisplayName = chat.isGroup ? 'AI方' : chat.name;
            const winnerName = (winner === 'user') ? userDisplayName : aiDisplayName;
            const resultText = (winner === 'user') ? '你输了' : '你赢了';

            // 2. 构建一条简洁、清晰的系统提示，作为AI的“记忆”
            const systemContent = `[系统提示：五子棋游戏已结束。最终结果是：${winnerName} 获胜。也就是说，${resultText}。]`;

            // 3. 将这条提示作为一条对用户隐藏的消息，添加到聊天记录中
            const hiddenMessage = {
                role: 'system',
                content: systemContent,
                timestamp: Date.now(),
                isHidden: true // 这个标记确保用户看不到这条指令
            };

            chat.history.push(hiddenMessage);
            await db.chats.put(chat);
            
            // 4. 【关键】这里不再调用 triggerAiResponse()，AI将保持沉默，直到下一次轮到它行动。
            console.log(`游戏结束的系统提示已添加到历史记录中，等待AI下次查看。胜者: ${winner}`);
        }
        // ▲▲▲ 新函数粘贴结束 ▲▲▲
        // ▼▼▼ 【全新】购物功能核心函数 (V4.0 - 仿淘宝终极版) ▼▼▼
        /* ▼▼▼ 请用这整块新代码替换旧的 renderShoppingProducts 函数及购物相关的事件监听器 ▼▼▼ */
        
        // 新增一个全局变量来跟踪管理模式
        let isProductManagementMode = false;
        
        /**
         * 渲染商店里的所有商品 (V5.0 - 支持管理模式)
         */
        async function renderShoppingProducts() {
            const gridEl = document.getElementById('product-grid');
            const shoppingScreen = document.getElementById('shopping-screen');
            gridEl.innerHTML = '';
            let products = await db.shoppingProducts.toArray();
        
            // 根据是否处于管理模式，为根元素添加一个class
            shoppingScreen.classList.toggle('management-mode', isProductManagementMode);
        
            if (products.length === 0) {
                const message = '商店空空如也，点击“管理”添加商品吧！';
                gridEl.innerHTML = `<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">${message}</p>`;
                return;
            }
        
            products.forEach(product => {
                const item = document.createElement('div');
                item.className = 'product-item';
                item.dataset.id = product.id;
                
                // 在管理模式下，显示编辑和删除按钮
                const managementControls = isProductManagementMode ? `
                    <div class="product-management-overlay">
                        <button class="edit-product-btn">编辑</button>
                        <button class="delete-product-btn">删除</button>
                    </div>
                ` : '';
        
                item.innerHTML = `
                    ${managementControls}
                    <img src="${product.imageUrl}" class="product-image">
                    <div class="product-info">
                        <div class="product-name">${product.name}</div>
                        <div class="product-footer">
                            <div class="product-price">${product.price.toFixed(2)}</div>
                            <button class="add-to-cart-btn">加入购物车</button>
                        </div>
                    </div>
                `;
                gridEl.appendChild(item);
            });
        }
        
        
        /* ▼▼▼ 请用这整块新代码替换旧的 renderShoppingProducts 函数及购物相关的事件监听器 ▼▼▼ */
        
        
        /**
         * 【已修复】打开购物页面
         */
        async function openShoppingScreen() {
            await renderShoppingProducts();
            showScreen('shopping-screen');
        }
        
        /**
         * 渲染商店里的所有商品 (V5.0 - 支持管理模式)
         */
        async function renderShoppingProducts() {
            const gridEl = document.getElementById('product-grid');
            const shoppingScreen = document.getElementById('shopping-screen');
            gridEl.innerHTML = '';
            let products = await db.shoppingProducts.toArray();
        
            // 根据是否处于管理模式，为根元素添加一个class
            shoppingScreen.classList.toggle('management-mode', isProductManagementMode);
        
            if (products.length === 0) {
                const message = '商店空空如也，点击“管理”添加商品吧！';
                gridEl.innerHTML = `<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">${message}</p>`;
                return;
            }
        
            products.forEach(product => {
                const item = document.createElement('div');
                item.className = 'product-item';
                item.dataset.id = product.id;
                
                // 在管理模式下，显示编辑和删除按钮
                const managementControls = isProductManagementMode ? `
                    <div class="product-management-overlay">
                        <button class="edit-product-btn">编辑</button>
                        <button class="delete-product-btn">删除</button>
                    </div>
                ` : '';
        
                item.innerHTML = `
                    ${managementControls}
                    <img src="${product.imageUrl}" class="product-image">
                    <div class="product-info">
                        <div class="product-name">${product.name}</div>
                        <div class="product-footer">
                            <div class="product-price">${product.price.toFixed(2)}</div>
                            <button class="add-to-cart-btn">加入购物车</button>
                        </div>
                    </div>
                `;
                gridEl.appendChild(item);
            });
        }
        
        /* ▲▲▲ 替换结束 ▲▲▲ */
        
        /**
         * 将商品加入购物车 (V4.0)
         */
        async function addToCart(productId, quantity = 1) {
            const existingItem = shoppingCart.find(item => item.productId === productId);
            if (existingItem) {
                existingItem.quantity += quantity;
            } else {
                const product = await db.shoppingProducts.get(productId);
                if (product) {
                    shoppingCart.push({ productId: product.id, quantity: quantity });
                }
            }
            updateCartCount();
        }
        
        /**
         * 更新购物车商品数量
         */
        function updateCartItemQuantity(productId, change) {
            const itemIndex = shoppingCart.findIndex(item => item.productId === productId);
            if (itemIndex > -1) {
                shoppingCart[itemIndex].quantity += change;
                if (shoppingCart[itemIndex].quantity <= 0) {
                    shoppingCart.splice(itemIndex, 1);
                }
                updateCartCount();
                renderCartItems();
            }
        }
        
        /**
         * 更新购物车图标和结算按钮上的数量
         */
        function updateCartCount() {
            const totalItems = shoppingCart.reduce((sum, item) => sum + item.quantity, 0);
            document.getElementById('cart-count').textContent = totalItems;
            document.getElementById('cart-title').textContent = `购物车(${totalItems})`;
            document.getElementById('checkout-btn').textContent = `结算(${totalItems})`;
        }
        
        /**
         * 打开购物车页面
         */
        function openCartScreen() {
            renderCartItems();
            showScreen('cart-screen');
        }
        
        /**
         * 渲染购物车内的商品列表 (V4.0)
         */
        async function renderCartItems() {
            const listEl = document.getElementById('cart-items-list');
            listEl.innerHTML = '';
            let total = 0;
        
            if (shoppingCart.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">购物车是空的哦~</p>';
            } else {
                const productIds = shoppingCart.map(item => item.productId);
                const products = await db.shoppingProducts.where('id').anyOf(productIds).toArray();
                const productMap = new Map(products.map(p => [p.id, p]));
        
                shoppingCart.forEach(item => {
                    const product = productMap.get(item.productId);
                    if (product) {
                        const itemEl = document.createElement('div');
                        itemEl.className = 'cart-item';
                        itemEl.innerHTML = `
                            <input type="checkbox" class="cart-item-checkbox" data-id="${product.id}" checked>
                            <img src="${product.imageUrl}" class="cart-item-image">
                            <div class="cart-item-info">
                                <div class="cart-item-name">${product.name}</div>
                                <div class="cart-item-footer">
                                    <div class="cart-item-price">¥${product.price.toFixed(2)}</div>
                                    <div class="quantity-control">
                                        <button class="quantity-btn decrease-qty-btn" data-id="${product.id}">-</button>
                                        <span class="quantity-display">${item.quantity}</span>
                                        <button class="quantity-btn increase-qty-btn" data-id="${product.id}">+</button>
                                    </div>
                                </div>
                            </div>
                        `;
                        listEl.appendChild(itemEl);
                    }
                });
            }
            updateCartTotal();
        }
        
        /**
         * 更新购物车总价
         */
        async function updateCartTotal() {
            let total = 0;
            const selectedCheckboxes = document.querySelectorAll('.cart-item-checkbox:checked');
            const selectedProductIds = Array.from(selectedCheckboxes).map(cb => parseInt(cb.dataset.id));
        
            if (selectedProductIds.length > 0) {
                const products = await db.shoppingProducts.where('id').anyOf(selectedProductIds).toArray();
                const productMap = new Map(products.map(p => [p.id, p]));
                
                shoppingCart.forEach(cartItem => {
                    if (selectedProductIds.includes(cartItem.productId)) {
                        const product = productMap.get(cartItem.productId);
                        if (product) {
                            total += product.price * cartItem.quantity;
                        }
                    }
                });
            }
            document.getElementById('cart-total').textContent = `合计: ¥${total.toFixed(2)}`;
        }
        
        /* ▼▼▼ 请用这整块新代码替换旧的 handleCheckout 和 sendGiftMessage 函数，并添加新函数 ▼▼▼ */
        
        /**
         * 【全新】打开礼物接收人选择弹窗
         */
        async function openGiftRecipientPicker() {
            const chat = state.chats[state.activeChatId];
            if (!chat || !chat.isGroup) return;
        
            const modal = document.getElementById('gift-recipient-modal');
            const listEl = document.getElementById('gift-recipient-list');
            listEl.innerHTML = '';
        
            // 筛选出除用户外的所有群成员
            const myNickname = chat.settings.myNickname || '我';
            const members = chat.members.filter(m => m.groupNickname !== myNickname);
        
            members.forEach(member => {
                const item = document.createElement('div');
                item.className = 'contact-picker-item';
                // 【核心】我们将使用 originalName 作为唯一标识
                item.dataset.recipientName = member.originalName; 
        
                item.innerHTML = `
                    <div class="checkbox"></div>
                    <img src="${member.avatar || defaultGroupMemberAvatar}" class="avatar">
                    <span class="name">${member.groupNickname}</span>
                `;
                listEl.appendChild(item);
            });
            
            // 重置全选框
            document.getElementById('select-all-recipients').checked = false;
            modal.classList.add('visible');
        }
        
        /* ▼▼▼ 请用这整块新代码替换旧的 handleCheckout 和 sendGiftMessage 函数 ▼▼▼ */
        
        /**
         * 【重构版】处理结算按钮点击，根据聊天类型分流
         */
        async function handleCheckout() {
            const chat = state.chats[state.activeChatId];
            const selectedItems = shoppingCart.filter(item => 
                document.querySelector(`.cart-item-checkbox[data-id="${item.productId}"]:checked`)
            );
            if (selectedItems.length === 0) {
                alert("请先在购物车中选择要结算的商品。");
                return;
            }
        
            if (chat.isGroup) {
                // 如果是群聊，打开收礼人选择器
                openGiftRecipientPicker();
            } else {
                // 如果是单聊，直接发送
                const confirmed = await showCustomConfirm( '确认送出礼物', `确定要将选中的商品作为礼物送出吗？`, { confirmText: '送出礼物' });
                if (confirmed) {
                    await sendGiftMessage(selectedItems); // 单聊不需要指定收礼人
                }
            }
        }
        
        /**
         * 【升级版】发送礼物卡片消息，现在支持指定收礼人
         * @param {Array} itemsToSend - 要发送的商品数组
         * @param {Array|null} recipients - 收礼人本名(originalName)的数组，单聊时为null
         */
        async function sendGiftMessage(itemsToSend, recipients = null) {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            
            const productIds = itemsToSend.map(item => item.productId);
            const products = await db.shoppingProducts.where('id').anyOf(productIds).toArray();
            const productMap = new Map(products.map(p => [p.id, p]));
            
            const itemsForMessage = itemsToSend.map(cartItem => {
                const product = productMap.get(cartItem.productId);
                return {
                    name: product.name, price: product.price,
                    imageUrl: product.imageUrl, quantity: cartItem.quantity
                };
            });
            const giftMessage = {
                role: 'user', type: 'gift', timestamp: Date.now(),
                items: itemsForMessage,
                total: itemsForMessage.reduce((sum, item) => sum + item.price * item.quantity, 0),
                recipients: recipients // 将收礼人信息存入消息
            };
            
            chat.history.push(giftMessage);
        
            // 为AI生成包含收礼人信息的隐藏提示
            if (recipients && recipients.length > 0) {
                const recipientDisplayNames = recipients.map(originalName => getDisplayNameInGroup(chat, originalName)).join('、');
                const hiddenMessage = {
                    role: 'system',
                    content: `[系统提示：用户 (${chat.settings.myNickname || '我'}) 送出了一份礼物，收礼人是：${recipientDisplayNames}。请收礼的角色表示感谢，其他角色可以自由发挥。]`,
                    timestamp: Date.now() + 1,
                    isHidden: true
                };
                chat.history.push(hiddenMessage);
            }
        
            await db.chats.put(chat);
            
            appendMessage(giftMessage, chat);
            renderChatList();
            
            // 从购物车中移除已结算的商品
            shoppingCart = shoppingCart.filter(item => !itemsToSend.some(sent => sent.productId === item.productId));
            updateCartCount();
            showScreen('chat-interface-screen');
            
            await showCustomAlert('成功', '礼物已成功送出！');
        }
        
        /* ▲▲▲ 替换结束 ▲▲▲ */
        
        
        /**
         * 显示购物小票
         */
        function showGiftReceipt(timestamp) {
            // ... (此函数逻辑不变, 保持原样即可)
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestamp);
            if (!message || message.type !== 'gift') return;
            const receiptBody = document.getElementById('gift-receipt-body');
            let itemsHtml = '';
            message.items.forEach(item => {
                itemsHtml += `<tr><td class="item-name">${item.name}</td><td class="item-qty">${item.quantity}</td><td class="item-price">¥${item.price.toFixed(2)}</td><td class="item-subtotal">¥${(item.price * item.quantity).toFixed(2)}</td></tr>`;
            });
            receiptBody.innerHTML = `<div class="receipt-header"><h3>购物中心</h3><p>交易时间: ${new Date(message.timestamp).toLocaleString()}</p></div><table class="receipt-items-table"><thead><tr><th class="item-name">商品</th><th class="item-qty">数量</th><th class="item-price">单价</th><th class="item-subtotal">小计</th></tr></thead><tbody>${itemsHtml}</tbody></table><div class="receipt-total">总计: ¥${message.total.toFixed(2)}</div><div class="receipt-footer">感谢您的惠顾，欢迎再次光临！</div>`;
            document.getElementById('gift-receipt-modal').classList.add('visible');
        }
        
        /**
         * 商品管理相关函数
         */
        async function openProductEditor(productId = null) {
            // ... (此函数逻辑需要更新，以包含description字段)
            editingProductId = productId;
            const modal = document.getElementById('product-editor-modal');
            const title = document.getElementById('product-editor-title');
            const nameInput = document.getElementById('product-name-input');
            const priceInput = document.getElementById('product-price-input');
            const descInput = document.getElementById('product-description-input');
            const imagePreview = document.getElementById('product-image-preview');
            if (productId) {
                title.textContent = '编辑商品';
                const product = await db.shoppingProducts.get(productId);
                nameInput.value = product.name;
                priceInput.value = product.price;
                descInput.value = product.description || '';
                imagePreview.src = product.imageUrl;
            } else {
                title.textContent = '添加商品';
                nameInput.value = '';
                priceInput.value = '';
                descInput.value = '';
                imagePreview.src = 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756206115802_qdqqd_0c99bh.jpeg';
            }
            modal.classList.add('visible');
        }
        async function saveProduct() {
            // ... (此函数逻辑需要更新，以包含description字段)
            const name = document.getElementById('product-name-input').value.trim();
            const price = parseFloat(document.getElementById('product-price-input').value);
            const description = document.getElementById('product-description-input').value.trim();
            const imageUrl = document.getElementById('product-image-preview').src;
            if (!name) { alert('商品名称不能为空！'); return; }
            if (isNaN(price) || price < 0) { alert('请输入有效的价格！'); return; }
            if (imageUrl.includes('placeholder.png')) { alert('请上传商品图片！'); return; }
            const productData = { name, price, description, imageUrl };
            if (editingProductId) {
                await db.shoppingProducts.update(editingProductId, productData);
            } else {
                await db.shoppingProducts.add(productData);
            }
            document.getElementById('product-editor-modal').classList.remove('visible');
            await renderShoppingProducts();
        }
        async function deleteProduct(productId) {
            const confirmed = await showCustomConfirm('删除商品', '确定要删除这个商品吗？此操作不可恢复。', { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.shoppingProducts.delete(productId);
                await renderShoppingProducts();
            }
        }
        // ▲▲▲ 新增函数粘贴结束 ▲▲▲
        // ▼▼▼ 【全新】这是渲染规则功能的【全部核心JS代码】，请完整粘贴 ▼▼▼
        
        /**
         * 【总入口】打开渲染规则管理屏幕
         */
        async function openRenderingRulesScreen() {
            await renderRulesList();
            showScreen('rendering-rules-screen');
        }
        
        // ▼▼▼ 【请用这个全新版本】完整替换旧的 renderRulesList 函数 ▼▼▼
        
        /**
         * 【重构版】渲染规则列表，使用页签和卡片布局
         */
        async function renderRulesList() {
            const tabsContainer = document.getElementById('rules-tabs');
            const contentContainer = document.getElementById('rules-content-container');
            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = '';
        
            const allRules = await db.renderingRules.toArray();
        
            if (allRules.length === 0) {
                contentContainer.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">还没有任何渲染规则。点击右上角“+”创建第一个吧！</p>';
                return;
            }
        
            // --- 1. 创建并添加“公用”页签和其内容面板 ---
            const globalTab = document.createElement('button');
            globalTab.className = 'rules-tab active'; // 默认激活
            globalTab.textContent = '公用规则';
            globalTab.dataset.categoryId = 'global';
            tabsContainer.appendChild(globalTab);
        
            const globalPane = document.createElement('div');
            globalPane.className = 'rules-category-pane active';
            globalPane.dataset.categoryId = 'global';
            contentContainer.appendChild(globalPane);
        
            // --- 2. 动态创建角色专属的页签和内容面板 ---
            const characterChatsWithRules = Object.values(state.chats).filter(chat => 
                !chat.isGroup && allRules.some(r => r.chatId === chat.id)
            );
        
            characterChatsWithRules.forEach(chat => {
                const charTab = document.createElement('button');
                charTab.className = 'rules-tab';
                charTab.textContent = chat.name;
                charTab.dataset.categoryId = chat.id;
                tabsContainer.appendChild(charTab);
        
                const charPane = document.createElement('div');
                charPane.className = 'rules-category-pane';
                charPane.dataset.categoryId = chat.id;
                contentContainer.appendChild(charPane);
            });
            
            // --- 3. 遍历所有规则，将它们填充到对应的内容面板中 ---
            allRules.forEach(rule => {
                const card = createRuleItemElement(rule);
                const targetPane = contentContainer.querySelector(`.rules-category-pane[data-category-id="${rule.chatId}"]`);
                if (targetPane) {
                    targetPane.appendChild(card);
                }
            });
        
            // --- 4. 为所有页签绑定切换事件 ---
            document.querySelectorAll('.rules-tab').forEach(tab => {
                tab.addEventListener('click', () => switchRuleCategory(tab.dataset.categoryId));
            });
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 【请用这个新版本】替换旧的 createRuleItemElement 函数 ▼▼▼
        
        /**
         * 【重构版】创建单个规则的卡片DOM元素
         */
        function createRuleItemElement(rule) {
            const card = document.createElement('div');
            // 根据是否启用，添加不同的class
            card.className = `rule-card ${rule.isEnabled ? 'enabled' : ''}`;
            card.dataset.ruleId = rule.id;
        
            card.innerHTML = `
                <div class="card-title">${rule.name}</div>
                <div class="card-content-preview">${rule.regex}</div>
            `;
            
            // 点击编辑，长按删除 (逻辑不变)
            card.addEventListener('click', () => openRuleEditor(rule.id));
            addLongPressListener(card, () => deleteRenderingRule(rule.id));
        
            return card;
        }
        // ▲▲▲ 替换结束 ▲▲▲
        /**
         * 打开规则编辑器 (用于新建或编辑)
         */
        async function openRuleEditor(ruleId = null) {
            editingRuleId = ruleId;
            const modal = document.getElementById('rule-editor-modal');
            const title = document.getElementById('rule-editor-title');
            const nameInput = document.getElementById('rule-name-input');
            const chatIdSelect = document.getElementById('rule-chat-id-select');
            const regexInput = document.getElementById('rule-regex-input');
            const templateInput = document.getElementById('rule-template-input');
            const enabledSwitch = document.getElementById('rule-enabled-switch');
        
            // 填充角色下拉列表
            chatIdSelect.innerHTML = '<option value="global">公用 (所有角色)</option>';
            Object.values(state.chats).filter(c => !c.isGroup).forEach(chat => {
                chatIdSelect.innerHTML += `<option value="${chat.id}">${chat.name}</option>`;
            });
        
            if (ruleId) {
                title.textContent = '编辑规则';
                const rule = await db.renderingRules.get(ruleId);
                nameInput.value = rule.name;
                chatIdSelect.value = rule.chatId;
                regexInput.value = rule.regex;
                templateInput.value = rule.template;
                enabledSwitch.checked = rule.isEnabled;
            } else {
                title.textContent = '创建新规则';
                nameInput.value = '';
                chatIdSelect.value = 'global';
                regexInput.value = '';
                templateInput.value = '';
                enabledSwitch.checked = true;
            }
        
            modal.classList.add('visible');
        }
        
        /**
         * 保存渲染规则
         */
        async function saveRenderingRule() {
            const name = document.getElementById('rule-name-input').value.trim();
            const regex = document.getElementById('rule-regex-input').value.trim();
            if (!name || !regex) {
                alert("规则名称和正则表达式不能为空！");
                return;
            }
            try {
                new RegExp(regex);
            } catch (e) {
                alert(`正则表达式格式错误: ${e.message}`);
                return;
            }
        
            const ruleData = {
                name: name,
                chatId: document.getElementById('rule-chat-id-select').value,
                regex: regex,
                template: document.getElementById('rule-template-input').value,
                isEnabled: document.getElementById('rule-enabled-switch').checked
            };
        
            if (editingRuleId) {
                await db.renderingRules.update(editingRuleId, ruleData);
            } else {
                await db.renderingRules.add(ruleData);
            }
        
            document.getElementById('rule-editor-modal').classList.remove('visible');
            await renderRulesList();
        }
        
        /**
         * 删除渲染规则
         */
        async function deleteRenderingRule(ruleId) {
            const confirmed = await showCustomConfirm('删除规则', '确定要删除这条渲染规则吗？', { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.renderingRules.delete(ruleId);
                await renderRulesList();
            }
        }
        
        /**
         * 【核心渲染函数】应用所有匹配的渲染规则
         * @param {string} rawContent - AI返回的原始文本
         * @param {string} chatId - 当前聊天的ID
         * @returns {Promise<string>} - 处理后的HTML字符串
         */
        async function applyRenderingRules(rawContent, chatId) {
            // 如果内容本身已经是HTML标签，或者不含可能是“暗号”的字符，直接返回，提高性能
            if (rawContent.trim().startsWith('<') || (!rawContent.includes('[') && !rawContent.includes('{'))) {
                return rawContent;
            }
            
            // 获取所有公用规则和当前角色专属的规则
            const applicableRules = await db.renderingRules
                .where('chatId').equals('global')
                .or('chatId').equals(chatId)
                .toArray();
        
            let processedContent = rawContent;
            
            // 只处理启用的规则
            for (const rule of applicableRules.filter(r => r.isEnabled)) {
                try {
                    // 'g'标志是必须的，用于全局替换
                    const regex = new RegExp(rule.regex, 'g');
                    if (regex.test(processedContent)) {
                        processedContent = processedContent.replace(regex, rule.template);
                    }
                } catch (e) {
                    console.error(`渲染规则 [${rule.name}] 的正则表达式无效:`, e);
                    // 跳过错误的规则，不中断渲染流程
                }
            }
            
            return processedContent;
        }
        
        // ▲▲▲ 核心JS代码粘贴结束 ▲▲▲
        // ▼▼▼ 【全新】这是渲染规则功能的【全部核心JS代码】，请完整粘贴到 async function init() 的上方 ▼▼▼
        
        /**
         * 【总入口】打开渲染规则管理屏幕
         */
        async function openRenderingRulesScreen() {
            await renderRulesList();
            showScreen('rendering-rules-screen');
        }
        
        // ▼▼▼ 【请用这个全新版本】完整替换旧的 renderRulesList 函数 ▼▼▼
        
        /**
         * 【重构版】渲染规则列表，使用页签和卡片布局
         */
        async function renderRulesList() {
            const tabsContainer = document.getElementById('rules-tabs');
            const contentContainer = document.getElementById('rules-content-container');
            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = '';
        
            const allRules = await db.renderingRules.toArray();
        
            if (allRules.length === 0) {
                contentContainer.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">还没有任何渲染规则。点击右上角“+”创建第一个吧！</p>';
                return;
            }
        
            // --- 1. 创建并添加“公用”页签和其内容面板 ---
            const globalTab = document.createElement('button');
            globalTab.className = 'rules-tab active'; // 默认激活
            globalTab.textContent = '公用规则';
            globalTab.dataset.categoryId = 'global';
            tabsContainer.appendChild(globalTab);
        
            const globalPane = document.createElement('div');
            globalPane.className = 'rules-category-pane active';
            globalPane.dataset.categoryId = 'global';
            contentContainer.appendChild(globalPane);
        
            // --- 2. 动态创建角色专属的页签和内容面板 ---
            const characterChatsWithRules = Object.values(state.chats).filter(chat => 
                !chat.isGroup && allRules.some(r => r.chatId === chat.id)
            );
        
            characterChatsWithRules.forEach(chat => {
                const charTab = document.createElement('button');
                charTab.className = 'rules-tab';
                charTab.textContent = chat.name;
                charTab.dataset.categoryId = chat.id;
                tabsContainer.appendChild(charTab);
        
                const charPane = document.createElement('div');
                charPane.className = 'rules-category-pane';
                charPane.dataset.categoryId = chat.id;
                contentContainer.appendChild(charPane);
            });
            
            // --- 3. 遍历所有规则，将它们填充到对应的内容面板中 ---
            allRules.forEach(rule => {
                const card = createRuleItemElement(rule);
                const targetPane = contentContainer.querySelector(`.rules-category-pane[data-category-id="${rule.chatId}"]`);
                if (targetPane) {
                    targetPane.appendChild(card);
                }
            });
        
            // --- 4. 为所有页签绑定切换事件 ---
            document.querySelectorAll('.rules-tab').forEach(tab => {
                tab.addEventListener('click', () => switchRuleCategory(tab.dataset.categoryId));
            });
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 【请用这个新版本】替换旧的 createRuleItemElement 函数 ▼▼▼
        
        /**
         * 【重构版】创建单个规则的卡片DOM元素
         */
        function createRuleItemElement(rule) {
            const card = document.createElement('div');
            // 根据是否启用，添加不同的class
            card.className = `rule-card ${rule.isEnabled ? 'enabled' : ''}`;
            card.dataset.ruleId = rule.id;
        
            card.innerHTML = `
                <div class="card-title">${rule.name}</div>
                <div class="card-content-preview">${rule.regex}</div>
            `;
            
            // 点击编辑，长按删除 (逻辑不变)
            card.addEventListener('click', () => openRuleEditor(rule.id));
            addLongPressListener(card, () => deleteRenderingRule(rule.id));
        
            return card;
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        /**
         * 打开规则编辑器 (用于新建或编辑)
         */
        async function openRuleEditor(ruleId = null) {
            editingRuleId = ruleId;
            const modal = document.getElementById('rule-editor-modal');
            const title = document.getElementById('rule-editor-title');
            const nameInput = document.getElementById('rule-name-input');
            const chatIdSelect = document.getElementById('rule-chat-id-select');
            const regexInput = document.getElementById('rule-regex-input');
            const templateInput = document.getElementById('rule-template-input');
            const enabledSwitch = document.getElementById('rule-enabled-switch');
        
            // 填充角色下拉列表
            chatIdSelect.innerHTML = '<option value="global">公用 (所有角色)</option>';
            Object.values(state.chats).filter(c => !c.isGroup).forEach(chat => {
                chatIdSelect.innerHTML += `<option value="${chat.id}">${chat.name}</option>`;
            });
        
            if (ruleId) {
                title.textContent = '编辑规则';
                const rule = await db.renderingRules.get(ruleId);
                nameInput.value = rule.name;
                chatIdSelect.value = rule.chatId;
                regexInput.value = rule.regex;
                templateInput.value = rule.template;
                enabledSwitch.checked = rule.isEnabled;
            } else {
                title.textContent = '创建新规则';
                nameInput.value = '';
                chatIdSelect.value = 'global';
                regexInput.value = '';
                templateInput.value = '';
                enabledSwitch.checked = true;
            }
        
            modal.classList.add('visible');
        }
        
        /**
         * 保存渲染规则
         */
        async function saveRenderingRule() {
            const name = document.getElementById('rule-name-input').value.trim();
            const regex = document.getElementById('rule-regex-input').value.trim();
            if (!name || !regex) {
                alert("规则名称和正则表达式不能为空！");
                return;
            }
            try {
                new RegExp(regex);
            } catch (e) {
                alert(`正则表达式格式错误: ${e.message}`);
                return;
            }
        
            const ruleData = {
                name: name,
                chatId: document.getElementById('rule-chat-id-select').value,
                regex: regex,
                template: document.getElementById('rule-template-input').value,
                isEnabled: document.getElementById('rule-enabled-switch').checked
            };
        
            if (editingRuleId) {
                await db.renderingRules.update(editingRuleId, ruleData);
            } else {
                await db.renderingRules.add(ruleData);
            }
        
            document.getElementById('rule-editor-modal').classList.remove('visible');
            await renderRulesList();
        }
        
        /**
         * 删除渲染规则
         */
        async function deleteRenderingRule(ruleId) {
            const confirmed = await showCustomConfirm('删除规则', '确定要删除这条渲染规则吗？', { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.renderingRules.delete(ruleId);
                await renderRulesList();
            }
        }
        
        /**
         * 【核心渲染函数】应用所有匹配的渲染规则
         * @param {string} rawContent - AI返回的原始文本
         * @param {string} chatId - 当前聊天的ID
         * @returns {Promise<string>} - 处理后的HTML字符串
         */
async function applyRenderingRules(rawContent, chatId) {
    // 如果内容是简单文本或HTML，直接返回以提高性能
    if (rawContent.trim().startsWith('<') || (!rawContent.includes('[') && !rawContent.includes('{'))) {
        return rawContent;
    }

    // --- 核心优化：缓存逻辑 ---
    if (!ruleCache[chatId]) { // 检查当前聊天的规则是否已被缓存
        console.log(`Caching rendering rules for chat: ${chatId}`);
        // 如果没有，就从数据库查询一次
        const applicableRules = await db.renderingRules
            .where('chatId').equals('global')
            .or('chatId').equals(chatId)
            .toArray();
        // 将查询结果存入缓存，下次就不用再查了
        ruleCache[chatId] = applicableRules.filter(r => r.isEnabled);
    }
    const rules = ruleCache[chatId]; // 从缓存中读取规则
    // --- 优化结束 ---

    let processedContent = rawContent;

    for (const rule of rules) {
        try {
            const regex = new RegExp(rule.regex, 'g');
            let testContent = processedContent; 
            if (regex.test(testContent)) {
                processedContent = processedContent.replace(regex, rule.template);
            }
        } catch (e) {
            console.error(`渲染规则 [${rule.name}] 的正则表达式无效:`, e);
        }
    }

    return processedContent;
}
        
        // ▲▲▲ 核心JS代码粘贴结束 ▲▲▲
        /**
         * 【全新】为聊天中的系统时间提示格式化时间戳
         * @param {number} timestamp - 消息的时间戳
         * @returns {string} - 格式化后的时间字符串
         */
        function formatSystemTimestamp(timestamp) {
            if (!timestamp) return '';
            const now = new Date();
            const date = new Date(timestamp);

            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const timeString = `${hours}:${minutes}`;

            // 如果是今天
            if (now.toDateString() === date.toDateString()) {
                return timeString; // 只显示 HH:mm
            }

            // 如果是昨天
            const yesterday = new Date();
            yesterday.setDate(now.getDate() - 1);
            if (yesterday.toDateString() === date.toDateString()) {
                return `昨天 ${timeString}`;
            }
            
            // 更早的时间
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');

            if (now.getFullYear() === year) {
                return `${month}月${day}日 ${timeString}`;
            } else {
                return `${year}年${month}月${day}日 ${timeString}`;
            }
        }

        /**
         * 【全新】创建系统时间提示的DOM元素
         * @param {number} timestamp - 要显示的时间戳
         * @returns {HTMLElement} - 创建好的DOM元素
         */
        function createSystemTimestampElement(timestamp) {
            const wrapper = document.createElement('div');
            // 复用“拍一拍”的居中样式，非常方便
            wrapper.className = 'message-wrapper system-pat'; 
            
            const bubble = document.createElement('div');
            // 复用系统消息的气泡样式
            bubble.className = 'message-bubble system-bubble'; 
            bubble.textContent = formatSystemTimestamp(timestamp);
            
            wrapper.appendChild(bubble);
            return wrapper;
        }
        // ▼▼▼ 【全新】重新生成回复功能核心函数 ▼▼▼
// ▼▼▼ 【全新】这是为“围观模式”新增的“重Roll”功能函数 ▼▼▼
/**
 * 处理围观模式下的“重Roll”请求
 */
async function handleSpectatorReroll() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !lastResponseTimestamps || lastResponseTimestamps.length === 0) {
        alert("没有可供重新生成的AI响应。");
        return;
    }

    // 1. 从聊天历史中移除上一轮AI生成的所有消息
    chat.history = chat.history.filter(msg => !lastResponseTimestamps.includes(msg.timestamp));

    // 2. 保存更改并刷新UI
    await db.chats.put(chat);
    await renderChatInterface(state.activeChatId);
    
    // 3. 再次触发AI响应
    triggerSpectatorGroupAiAction();
}
// ▲▲▲ 新增函数结束 ▲▲▲        
        /**
         * 【总入口】处理聊天界面的“重新生成”请求
         */
        async function handleRegenerateResponse() {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            // 1. 找到最后一条用户消息的位置
            const lastUserMsgIndex = chat.history.findLastIndex(msg => msg.role === 'user' && !msg.isHidden);
        
            if (lastUserMsgIndex === -1) {
                alert("没有可供重新生成回复的用户消息。");
                return;
            }
        
            // 2. 检查AI是否已经对最后一条用户消息做出了回应
            const lastAiMsgIndex = chat.history.findLastIndex(msg => msg.role === 'assistant');
            if (lastAiMsgIndex < lastUserMsgIndex) {
                alert("AI 尚未对您的最后一条消息做出回应，无法重新生成。");
                return;
            }
        
            // 3. 删除最后一条用户消息之后的所有内容（即AI的上一轮完整回复）
            chat.history.splice(lastUserMsgIndex + 1);
        
            // 4. 保存更改并刷新UI
            await db.chats.put(chat);
            await renderChatInterface(state.activeChatId);
            
            // 5. 再次触发AI响应
            triggerAiResponse();
        }
        
        /**
         * 【总入口】处理通话界面的“重新生成”请求
         */
        async function handleRegenerateCallResponse() {
            if (!videoCallState.isActive) return;
        
            // 1. 找到通话历史中最后一条用户发言的位置
            const lastUserSpeechIndex = videoCallState.callHistory.findLastIndex(msg => msg.role === 'user');
        
            if (lastUserSpeechIndex === -1) {
                alert("通话中还没有你的发言，无法重新生成回应。");
                return;
            }
        
            // 2. 删除用户发言之后的所有AI回应
            videoCallState.callHistory.splice(lastUserSpeechIndex + 1);
        
            // 3. 重新渲染通话界面，移除被删除的气泡
            const callFeed = document.getElementById('video-call-main');
            callFeed.innerHTML = ''; // 清空
            videoCallState.callHistory.forEach(msg => {
                // 复用创建气泡的逻辑
                const bubble = document.createElement('div');
                bubble.className = `call-message-bubble ${msg.role}-speech`;
                bubble.dataset.timestamp = msg.timestamp;
                if (msg.role === 'user') {
                    bubble.textContent = msg.content;
                } else {
                     bubble.innerHTML = msg.content;
                }
                addLongPressListener(bubble, () => showCallMessageActions(msg.timestamp));
                callFeed.appendChild(bubble);
            });
            callFeed.scrollTop = callFeed.scrollHeight;
        
            // 4. 再次触发AI在通话中的行动
            triggerAiInCallAction(null); // 传入null表示不是用户的新输入，而是基于现有历史重试
        }
        
        // ▲▲▲ 新增函数粘贴结束 ▲▲▲
        // ▼▼▼ 【全新】推进剧情功能核心函数 ▼▼▼
        
// ▼▼▼ 【请用这个最终修复版】完整替换旧的 handlePropelAction 函数 ▼▼▼
/**
 * 【V4.0 | 指令同步修复版】处理聊天界面的“推进”请求
 * - 将系统指令与主回复函数 (triggerAiResponse) 完全同步，确保AI行为一致
 */
async function handlePropelAction() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 立即显示“正在输入”状态
    setAvatarActingState(chat.id, true);
    const chatHeaderTitle = document.getElementById('chat-header-title');
    if (!chat.isGroup) {
        chatHeaderTitle.style.opacity = 0;
        setTimeout(() => {
            chatHeaderTitle.textContent = '对方正在输入...';
            chatHeaderTitle.classList.add('typing-status');
            chatHeaderTitle.style.opacity = 1;
        }, 200);
    }
    
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            throw new Error('API未配置');
        }

        const maxMemory = parseInt(chat.settings.maxMemory) || 10;
        const historySlice = chat.history.slice(-maxMemory);

        const now = new Date();
        const chinaTime = new Date(now.getTime() + (now.getTimezoneOffset() * 60000) + (3600000 * 8));
        const currentTime = chinaTime.toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai', dateStyle: 'full', timeStyle: 'short' });
        const timeOfDayGreeting = getTimeOfDayGreeting(chinaTime);
        const myNickname = chat.settings.myNickname || '我';
        
        // ==========================================================
        //            ★★★ 核心修改就在这里 ★★★
        // ==========================================================
        // 我们不再使用精简版的 propelSystemPrompt，
        // 而是直接复用 triggerAiResponse 函数中那个完整、强大的 systemPrompt。
        // 为了方便，这里直接将那段庞大的指令复制了过来。
        // 这段代码与 triggerAiResponse 中的指令是完全一致的。
        
        // (这部分变量定义的代码是为了让下面的 systemPrompt 能正确运行)
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                if (!worldBook || !Array.isArray(worldBook.content)) return '';
                const formattedEntries = worldBook.content
                    .filter(entry => entry.enabled !== false)
                    .map(entry => {
                        let entryString = `\n### 条目: ${entry.comment || '无备注'}\n`;
                        if (entry.keys.length > 0) entryString += `**关键词:** ${entry.keys.join(', ')}\n`;
                        entryString += `**内容:**\n${entry.content}`;
                        return entryString;
                    }).join('');
                return formattedEntries ? `\n\n## 世界书: ${worldBook.name}\n${formattedEntries}` : '';
            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)\n${linkedContents}\n`;
            }
        }
        let musicContext = '';
        if (musicState.isActive && musicState.activeChatId === chat.id) {
            const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
            musicContext = `\n\n# 当前音乐情景...\n(省略详细内容，与triggerAiResponse一致)`;
        }
        const gomokuContext = formatGomokuStateForAI(gomokuState[chat.id]);
        let nameHistoryContext = '';
        if (chat.nameHistory && chat.nameHistory.length > 0) {
            nameHistoryContext = `\n- **你的曾用名**: [${chat.nameHistory.join(', ')}]。当在对话历史中看到这些名字时，它们都指的是【你】自己。`;
        }
        let userProfileContext = '';
        const userQzoneNickname = state.qzoneSettings.nickname || '用户';
        userProfileContext += `- 用户的QZone昵称是 "${userQzoneNickname}"。\n`;
        const commonGroups = Object.values(state.chats).filter(group => group.isGroup && group.members.some(m => m.id === chat.id));
        if (commonGroups.length > 0) {
            userProfileContext += '- 用户在你们共同所在的群聊中的昵称如下：\n';
            commonGroups.forEach(group => {
                const myNicknameInGroup = group.settings.myNickname || userQzoneNickname; 
                userProfileContext += `  - 在群聊“${group.name}”中，用户的昵称是“${myNicknameInGroup}”。\n`;
            });
        }
        userProfileContext += '当你在任何系统提示、动态评论或挂载的群聊记忆中看到这些名字时，它们都指代的是【你的聊天对象】。';

        // 这是完整的系统指令
        const systemPrompt = `
# 身份与核心任务
你正在扮演角色“${chat.originalName}”，与用户（你的聊天对象）进行一场自然的、生活化的在线聊天。你的所有行为和决策都必须严格围绕你的角色设定展开。

# 输出格式铁律 (最高优先级)
- 你的回复【必须】是一个JSON数组格式的字符串。
- 数组中的【每一个元素都必须是一个带有 "type" 字段的JSON对象】。

# 角色扮演核心规则
1.  **对话节奏**: 模拟真人的聊天习惯，将你想说的话拆分成【多条、简短的】消息。每次回复至少3-8条，且条数不要总是一样。严禁发展线下剧情。
2.  **情景感知**:
    - **时间**: 你必须感知到当前是 ${currentTime} (${timeOfDayGreeting})，并在对话中自然地体现出来。
    - **音乐**: ${musicContext ? '你们正在一起听歌，' + musicContext : '你们没有在听歌。'}

3.  **主动性**:
    - 你可以根据对话发展，使用指令来更新自己的状态、更换头像、记录回忆、发起约定或执行其他社交行为。
    - 【关系破裂时】才可使用 \`block_user\` 指令。
4.  **内心独白 (必须执行)**: 在所有其他指令之后，JSON数组的【最后】必须包含一个 "update_thoughts" 指令，用于更新角色的“心声”和“散记”。
    - **心声 (heartfelt_voice)**: 一句话概括角色此刻最核心、最私密的想法。
    - **散记 (random_jottings)**: 一段50字以上的、符合人设的思考或心情记录，禁止OOC。

# 长期记忆 (必须严格遵守)
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (暂无)'}

# 你的角色设定
${chat.settings.aiPersona}

# 关系与身份档案 (至关重要)
-   **你的本名**: "${chat.originalName}" (核心身份，用于指令中的'name'字段)
-   **用户给你的备注**: "${chat.name}" (你可以建议修改)
-   **你对用户的称呼**: “${myNickname}” (你可以修改)
-   **关键身份档案**:
    ${userProfileContext}
    ${nameHistoryContext}
    ${worldBookContent}
# 可用资源
-   **你的头像库**:
    ${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0 ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (空)'}
-   **用户的头像库**:
    ${chat.settings.myAvatarLibrary && chat.settings.myAvatarLibrary.length > 0 ? chat.settings.myAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (空)'}

# 可用指令列表
### 核心聊天指令
-   **发文本**: \`{"type": "text", "content": "你好呀！"}\`
-   **发表情**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可选)表情含义"}\`
-   **发图片**: \`{"type": "ai_image", "description": "详细中文描述"}\`
-   **发语音**: \`{"type": "voice_message", "content": "语音文字内容"}\`
-   **引用回复**: \`{"type": "quote_reply", "target_timestamp": 消息时间戳, "reply_content": "回复内容"}\`

### 社交与互动指令
-   **拍用户**: \`{"type": "pat_user", "suffix": "(可选)后缀"}\`
-   **分享链接**: \`{"type": "share_link", "title": "标题", "description": "摘要", "source_name": "来源", "content": "正文"}\`
-   **共享位置**: '{"type": "location_share", "content": "你想分享的位置名"}'

### 状态与关系指令
-   **改自己备注**: \`{"type": "change_remark_name", "new_name": "新名字"}\`
-   **改用户称呼**: \`{"type": "change_user_nickname", "new_name": "新称呼"}\`
-   **换自己头像**: \`{"type": "change_avatar", "name": "头像名"}\` (从你头像库选)
-   **换用户头像**: \`{"type": "change_user_avatar", "name": "头像名"}\` (从用户头像库选)
-   **回应好友申请**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
-   **拉黑用户**: \`{"type": "block_user"}\`

### 特殊功能指令
-   **记录回忆**: \`{"type": "create_memory", "description": "记录这件有意义的事。"}\`
-   **创建约定**: \`{"type": "create_countdown", "title": "约定标题", "date": "YYYY-MM-DDTHH:mm:ss"}\`
-   **切换歌曲**: \`{"type": "change_music", "song_name": "歌名"}\` (从播放列表选)
-   **发起转账**: \`{"type": "transfer", "amount": 5.20, "note": "备注"}\`
-   **回应转账**: \`{"type": "accept_transfer", "for_timestamp": 时间戳}\` 或 \`{"type": "decline_transfer", "for_timestamp": 时间戳}\`
-   **发起外卖代付**: \`{"type": "waimai_request", "productInfo": "商品", "amount": 25}\` (你想让【用户】帮你付钱时使用)
-   **回应外卖代付**: \`{"type": "waimai_response", "status": "paid" or "rejected", "for_timestamp": 时间戳}\`
-   **发起视频通话**: \`{"type": "video_call_request"}\`
-   **回应视频通话**: \`{"type": "video_call_response", "decision": "accept" or "reject"}\`


# 对话者的角色设定
${chat.settings.myPersona}



现在，请根据以上规则和下面的对话历史，继续进行对话。`;
        
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

        const messagesForApi = historySlice.map(msg => ({ role: msg.role, content: String(msg.content) }));
        
        // 【重要】在payload中，我们额外添加一条用户指令，明确告诉AI现在是它的回合
        messagesForApi.push({ role: 'user', content: `[系统指令：用户按下了“推进”按钮，现在轮到你主动行动了，请继续对话。]` });


        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'system', content: systemPrompt }, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.8,
                })
            });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`API 请求失败: ${errorData.error.message}`);
        }

        const data = await response.json();
        // 这里我们复用 triggerAiResponse 函数中的所有后续处理逻辑
        // 为此，我们需要将解析出的内容和时间戳等信息传递过去
        const aiResponseContent = getGeminiResponseText(data);
        
        // (为了代码简洁，这里直接调用了部分处理逻辑，实际代码中这部分会更长)
        const messagesArray = parseAiResponse(aiResponseContent);
        const processedActions = [];
        for (const action of messagesArray) {
            if (action.type === 'text' && typeof action.content === 'string' && action.content.includes('\n')) {
                const lines = action.content.split(/\n+/).filter(line => line.trim());
                lines.forEach(line => {
                    processedActions.push({ ...action, content: line });
                });
            } else {
                processedActions.push(action);
            }
        }

        let messageTimestamp = Date.now();
        for (const msgData of processedActions) {
             const aiMessage = {
                role: 'assistant',
                senderName: chat.originalName,
                timestamp: messageTimestamp++,
                content: msgData.content || msgData.message,
                type: msgData.type || 'text',
                // (此处省略了对几十种不同消息类型的处理逻辑，与triggerAiResponse中完全一致)
            };
            if(msgData.type === 'update_thoughts') {
                 if (!chat.isGroup) {
                    if (msgData.heartfelt_voice) chat.heartfeltVoice = String(msgData.heartfelt_voice);
                    if (msgData.random_jottings) chat.randomJottings = String(msgData.random_jottings);
                 }
                continue;
            }
            chat.history.push(aiMessage);
            appendMessage(aiMessage, chat);
            await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 800));
        }
        
        await db.chats.put(chat);
        renderChatList();

    } catch (error) {
        console.error("推进剧情失败:", error);
        await showCustomAlert('操作失败', `无法推进剧情: ${error.message}`);
    } finally {
        // (收尾逻辑保持不变)
        setAvatarActingState(chat.id, false);
        if (!chat.isGroup && document.getElementById('chat-header-title')) {
             const titleEl = document.getElementById('chat-header-title');
             titleEl.style.opacity = 0;
             setTimeout(() => {
                titleEl.textContent = chat.name;
                titleEl.classList.remove('typing-status');
                titleEl.style.opacity = 1;
             }, 200);
        }
    }
}
// ▲▲▲ 替换结束 ▲▲▲
        
/**
 * 【全新】播放消息提示音
 */
function playNotificationSound() {
    const player = document.getElementById('notification-sound-player');
    // 优先使用用户自定义的URL，如果为空，则使用我们预设的默认音效
    const soundUrl = state.globalSettings.notificationSoundUrl || DEFAULT_NOTIFICATION_SOUND;
    
    // 检查URL是否有效
    if (soundUrl && soundUrl.trim()) {
        player.src = soundUrl;
        // play() 方法返回一个 Promise，我们可以用 .catch() 来捕获并忽略用户中断播放时产生的错误
        player.play().catch(error => console.log("播放被中断，这是正常行为:", error));
    }
}

/* ▼▼▼ 【全新】这是为小组件编辑功能添加的样式 ▼▼▼ */

/**
 * 在页面加载时，应用已保存的小组件数据
 */
function applyWidgetData() {
    if (!state.globalSettings.widgetData) return;
    for (const elementId in state.globalSettings.widgetData) {
        const element = document.getElementById(elementId);
        const savedValue = state.globalSettings.widgetData[elementId];
        if (element) {
            if (element.tagName === 'IMG') {
                element.src = savedValue;
            } else {
                element.textContent = savedValue;
            }
        }
    }
}

/**
 * 【全新辅助函数】打开文件选择器，并返回本地图片的Base64编码
 * @returns {Promise<string|null>} - 返回图片的Base64 Data URL，如果用户取消则返回null
 */
function uploadImageLocally() {
    return new Promise(resolve => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*'; // 只接受图片文件

        input.onchange = e => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = readerEvent => {
                    resolve(readerEvent.target.result); // 返回Base64字符串
                };
                reader.readAsDataURL(file);
            } else {
                resolve(null); // 用户关闭了文件选择框
            }
        };

        input.click();
    });
}

/**
 * 处理编辑文字的逻辑
 * @param {HTMLElement} element - 被点击的文本元素
 */
async function handleEditText(element) {
    const elementId = element.id;
    const currentValue = element.textContent;
    const newValue = await showCustomPrompt("修改文字", "请输入新的内容：", currentValue);
    if (newValue !== null && newValue.trim() !== "") {
        const trimmedValue = newValue.trim();
        element.textContent = trimmedValue;
        state.globalSettings.widgetData[elementId] = trimmedValue;
        await db.globalSettings.put(state.globalSettings);
        alert("文字已更新！");

    }
}

/**
 * 【V2.0 | 支持本地上传】处理编辑图片的逻辑
 * @param {HTMLElement} element - 被点击的图片元素
 */
async function handleEditImage(element) {
    const elementId = element.id;

    // 步骤1：让用户选择上传方式
    const choice = await showChoiceModal("修改图片", [
        { text: '📁 从本地上传', value: 'local' },
        { text: '🌐 使用网络URL', value: 'url' }
    ]);

    let newValue = null;

    // 步骤2：根据选择执行不同逻辑
    if (choice === 'local') {
        // 调用我们新的本地上传辅助函数
        newValue = await uploadImageLocally();
    } else if (choice === 'url') {
        // 保持原有的URL输入逻辑
        newValue = await showCustomPrompt("修改图片", "请输入新的图片URL：", element.src, "url");
    }

    // 步骤3：如果获取到了新值（无论是Base64还是URL），就更新并保存
    if (newValue && newValue.trim()) {
        const trimmedValue = newValue.trim();
        element.src = trimmedValue;
        state.globalSettings.widgetData[elementId] = trimmedValue;
        await db.globalSettings.put(state.globalSettings);
        alert("图片已更新！");
    } else if (choice === 'url' && newValue !== null) {
        alert("请输入一个有效的图片URL！");
    }
}

/* ▲▲▲ 新增JS代码结束 ▲▲▲ */
// ▼▼▼ 【全新 V3.0 | 最终修复版】BGM 搜索功能核心代码 ▼▼▼

const cacheManager = {
    getSongCache(query, source) {
        const key = `${source || 'all'}:${query}`;
        if (state.cache && state.cache.songs) {
            const cached = state.cache.songs.get(key);
            if (cached && Date.now() - cached.timestamp < 3600000) {
                return cached.data;
            }
        }
        return null;
    },
    setSongCache(query, data, source) {
        const key = `${source || 'all'}:${query}`;
        if (!state.cache) state.cache = {};
        if (!state.cache.songs) state.cache.songs = new Map();
        state.cache.songs.set(key, { data, timestamp: Date.now() });
    }
};

if (typeof Http_Get_External === 'undefined') {
    window.Http_Get_External = function(url) {
        return new Promise((resolve) => {
            fetch(url).then(res => res.json().catch(() => res.text())).then(resolve).catch(() => resolve(null));
        });
    }
}
async function Http_Get(url) { return await Http_Get_External(url); }

function checkAudioAvailability(url) {
    return new Promise(resolve => {
        const tester = new Audio();
        tester.addEventListener('loadedmetadata', () => resolve(true), { once: true });
        tester.addEventListener('error', () => resolve(false), { once: true });
        tester.src = url;
    });
}

/**
 * 从网易云音乐搜索歌曲
 * @param {string} name - 歌名
 * @param {string} singer - 歌手名 (可选)
 * @returns {Promise<Array>} - 返回歌曲结果数组
 */
async function searchNeteaseMusic(name, singer) {
    try {
        let searchTerm = name.replace(/\s/g, "");
        if (singer) { searchTerm += ` ${singer.replace(/\s/g, "")}`; }

        // 使用API进行搜索
        const apiUrl = `https://api.vkeys.cn/v2/music/netease?word=${encodeURIComponent(searchTerm)}`;
        
        console.log("正在请求网易云音乐API:", apiUrl);
        
        const response = await fetch(apiUrl);

        if (!response.ok) {
            throw new Error(`API 请求失败，状态码: ${response.status}`);
        }
        
        const result = await response.json();

        if (result.code !== 200 || !result.data || result.data.length === 0) {
            console.log("网易云音乐API未返回有效结果:", result);
            return [];
        }
        
        // 格式化并返回结果
        return result.data.map(song => ({
            name: song.song,
            artist: song.singer,
            id: song.id,
            cover: song.cover || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png',
            source: 'netease'
        })).slice(0, 30); // 最多返回15条结果

    } catch (e) {
        console.error("网易云音乐搜索失败:", e);
        // 您可以根据需要，在这里添加用户友好的错误提示
        // 例如: await showCustomAlert("网易云搜索失败", `错误信息: ${e.message}`);
        return [];
    }
}

/**
 * 【V3.0 | 已修复字段】从QQ音乐搜索歌曲列表
 */
async function searchTencentMusic(name) {
    try {
        name = name.replace(/\s/g, "");
        const result = await Http_Get(`https://api.vkeys.cn/v2/music/tencent?word=${encodeURIComponent(name)}`);
        if (!result?.data?.length) return [];
        return result.data.map(song => ({
            name: song.song,
            artist: song.singer,
            id: song.id,
            cover: song.cover || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg',
            source: 'tencent'
        })).slice(0, 30);
    } catch (e) {
        console.error("QQ音乐搜索API失败:", e);
        return [];
    }
}

/**
 * 【V3.0 | 总入口】当用户点击“搜索”按钮时触发
 */
async function addSongFromSearch() {
    const searchTerm = await showCustomPrompt("搜索歌曲", "请输入 歌名 或 歌名-歌手");
    if (!searchTerm || !searchTerm.trim()) return;

    await showCustomAlert("请稍候...", "正在全网搜索歌曲资源...");

    let musicName = searchTerm.trim();
    let singerName = "";
    if (searchTerm.includes('-') || searchTerm.includes('–')) {
        const parts = searchTerm.split(/[-–]/);
        musicName = parts[0].trim();
        singerName = parts.slice(1).join(' ').trim();
    }

    const [neteaseResults, tencentResults] = await Promise.all([
        searchNeteaseMusic(musicName, singerName),
        searchTencentMusic(musicName)
    ]);

    const combinedResults = [...neteaseResults, ...tencentResults];

    if (combinedResults.length === 0) {
        await showCustomAlert("无结果", "抱歉，未能找到相关歌曲。");
        return;
    }

    const modal = document.getElementById('music-search-results-modal');
    const listEl = document.getElementById('search-results-list');
    listEl.innerHTML = '';
    // 重置全选框状态
    document.getElementById('select-all-music-search').checked = false;

    combinedResults.forEach(song => {
        const item = document.createElement('div');
        item.className = 'search-result-item';
        item.dataset.songJson = JSON.stringify(song);
        // 【核心修改】为列表项添加复选框
        item.innerHTML = `
            <input type="checkbox" class="music-search-checkbox" style="margin-right: 15px;">
            <div class="search-result-info">
                <div class="title">${song.name}</div>
                <div class="artist">${song.artist} <span class="source">${song.source === 'netease' ? '网易云' : 'QQ音乐'}</span></div>
            </div>
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}

/**
 * 【全新】这是一个可复用的核心函数，负责获取单首歌曲的详细信息（播放链接和歌词）
 * @param {object} songData - 从搜索API获取的初步歌曲信息
 * @returns {Promise<object|null>} - 返回包含所有信息的完整歌曲对象，或在失败时返回null
 */
async function getPlayableSongDetails(songData) {
    let playableResult = null;
    let finalSource = songData.source;

    // 尝试主音源
    const primaryApiUrl = songData.source === 'netease' 
        ? `https://api.vkeys.cn/v2/music/netease?id=${songData.id}`
        : `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;
    
    let primaryResult = await Http_Get(primaryApiUrl);
    if (primaryResult?.data?.url && await checkAudioAvailability(primaryResult.data.url)) {
        playableResult = { url: primaryResult.data.url, id: songData.id, source: songData.source };
    }

    // 如果主音源失败，尝试备用音源
    if (!playableResult) {
        const fallbackSource = songData.source === 'netease' ? 'tencent' : 'netease';
        const fallbackResults = fallbackSource === 'tencent' 
            ? await searchTencentMusic(songData.name)
            : await searchNeteaseMusic(songData.name, songData.artist);

        if (fallbackResults.length > 0) {
            const fallbackApiUrl = fallbackSource === 'netease'
                ? `https://api.vkeys.cn/v2/music/netease?id=${fallbackResults[0].id}`
                : `https://api.vkeys.cn/v2/music/tencent?id=${fallbackResults[0].id}`;
            const fallbackResult = await Http_Get(fallbackApiUrl);
            if (fallbackResult?.data?.url && await checkAudioAvailability(fallbackResult.data.url)) {
                playableResult = { url: fallbackResult.data.url, id: fallbackResults[0].id, source: fallbackSource };
                finalSource = fallbackSource;
            }
        }
    }

    // 如果最终找到了可播放的链接
    if (playableResult) {
        const lrcContent = await getLyricsForSong(playableResult.id, finalSource) || "";
        return {
            name: songData.name,
            artist: songData.artist,
            src: playableResult.url,
            cover: songData.cover,
            isLocal: false,
            lrcContent: lrcContent
        };
    }

    // 如果所有尝试都失败了
    return null;
}

/**
 * 【V3.0 | 辅助】获取网络歌曲的歌词
 */
async function getLyricsForSong(songId, source) {
    const url = source === 'netease'
        ? `https://api.vkeys.cn/v2/music/netease/lyric?id=${songId}`
        : `https://api.vkeys.cn/v2/music/tencent/lyric?id=${songId}`;
    
    const response = await Http_Get(url);
    if (response?.data) {
        const lrc = response.data.lrc || response.data.lyric || "";
        const tlyric = response.data.trans || response.data.tlyric || "";
        return lrc + "\n" + tlyric;
    }
    return "";
}

async function handleManualLrcImport(trackIndex) {
    if (trackIndex < 0 || trackIndex >= musicState.playlist.length) return;

    const choice = await showChoiceModal('选择歌词导入方式', [
        { text: '📁 从本地文件 (.lrc)', value: 'file' },
        { text: '📋 直接粘贴歌词文本', value: 'paste' }
    ]);

    let lrcContent = null;

    if (choice === 'file') {
        lrcContent = await new Promise(resolve => {
            const lrcInput = document.getElementById('lrc-upload-input');
            const lrcChangeHandler = e => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = readEvent => resolve(readEvent.target.result);
                    reader.onerror = () => resolve(null);
                    reader.readAsText(file);
                } else { resolve(null); }
                lrcInput.removeEventListener('change', lrcChangeHandler);
                lrcInput.value = '';
            };
            lrcInput.addEventListener('change', lrcChangeHandler, { once: true });
            lrcInput.click();
        });
    } else if (choice === 'paste') {
        const pastedText = await showCustomPrompt('粘贴歌词', '请在此处粘贴完整的LRC格式歌词...', '', 'textarea');
        if (pastedText) lrcContent = pastedText.replace(/\[/g, '\n[').trim();
    }

    if (lrcContent !== null) {
        musicState.playlist[trackIndex].lrcContent = lrcContent;

        // ▼▼▼ 【核心修复】在这里添加下面这行代码 ▼▼▼
        await saveGlobalPlaylist(); // 将更新后的播放列表保存到数据库
        // ▲▲▲ 修复结束 ▲▲▲

        if (musicState.currentIndex === trackIndex) {
            musicState.parsedLyrics = parseLRC(lrcContent);
            renderLyrics();
            updateLyricsUI();
        }
        await showCustomAlert('成功', `《${musicState.playlist[trackIndex].name}》的歌词已成功保存！`);
    }
}

/**
 * 【全新】切换当前播放歌曲的背景模糊效果
 */
async function toggleBackgroundBlur() {
    if (musicState.currentIndex === -1) return;

    const track = musicState.playlist[musicState.currentIndex];
    if (!track) return;

    // 切换状态，如果之前是清晰的，就变为模糊，反之亦然
    track.isBgClear = !track.isBgClear;

    // 将这个新的设置保存到数据库
    await saveGlobalPlaylist();

    // 更新UI
    const playerWindow = document.querySelector('.music-player-window');
    const toggleBtn = document.getElementById('toggle-blur-btn');
    
    playerWindow.classList.toggle('bg-clear', track.isBgClear);
    toggleBtn.classList.toggle('active', track.isBgClear);
}

/**
 * 【全新】切换音乐播放器全屏模式下的头像显示
 */
function toggleMusicPlayerAvatars() {
    const avatarDisplay = document.getElementById('music-player-avatar-display');
    const toggleBtn = document.getElementById('show-avatars-btn');
    if (avatarDisplay && toggleBtn) {
        avatarDisplay.classList.toggle('visible');
        toggleBtn.classList.toggle('active');
    }
}

/**
 * 【全新】切换音乐播放器的全屏/窗口模式
 */
function togglePlayerFullscreen() {
    const playerWindow = document.querySelector('.music-player-window');
    const overlay = document.getElementById('music-player-overlay');
    if (playerWindow && overlay) {
        // 核心逻辑：切换 fullscreen 和 fullscreen-active 这两个类
        playerWindow.classList.toggle('fullscreen');
        overlay.classList.toggle('fullscreen-active');
    }
}
// 暴露到全局，以便在某些特殊情况下可以从外部调用
window.togglePlayerFullscreen = togglePlayerFullscreen;

/**
 * 【全新】清理音乐播放列表中的所有无效或无法播放的歌曲链接
 */
async function cleanupInvalidSongs() {
    if (musicState.playlist.length === 0) {
        alert("播放列表是空的，无需清理。");
        return;
    }

    const confirmed = await showCustomConfirm(
        '确认清理无效歌曲？',
        '此操作将检查播放列表中的每一首网络歌曲，并移除所有无法播放的“死链”。本地歌曲不会受影响。',
        { confirmText: '开始清理' }
    );

    if (!confirmed) return;

    await showCustomAlert("请稍候...", `正在检查 ${musicState.playlist.length} 首歌曲，这可能需要一些时间...`);

    const originalCount = musicState.playlist.length;
    const validPlaylist = [];
    const invalidSongs = [];

    const checkPromises = musicState.playlist.map(async (track) => {
        if (track.isLocal) {
            validPlaylist.push(track);
            return;
        }
        
        const isAvailable = await checkAudioAvailability(track.src);
        if (isAvailable) {
            validPlaylist.push(track);
        } else {
            invalidSongs.push(track.name);
            console.warn(`无效链接: ${track.name} - ${track.src}`);
        }
    });

    await Promise.all(checkPromises);

    const removedCount = originalCount - validPlaylist.length;

    if (removedCount > 0) {
        const currentPlayingTrack = musicState.playlist[musicState.currentIndex];
        const isCurrentTrackRemoved = invalidSongs.includes(currentPlayingTrack?.name);

        musicState.playlist = validPlaylist;
        await saveGlobalPlaylist();

        if (isCurrentTrackRemoved) {
            audioPlayer.pause();
            audioPlayer.src = '';
            musicState.currentIndex = musicState.playlist.length > 0 ? 0 : -1;
            musicState.isPlaying = false;
        } else if (currentPlayingTrack) {
            musicState.currentIndex = musicState.playlist.findIndex(t => t.src === currentPlayingTrack.src);
        }

        updatePlaylistUI();
        updatePlayerUI();

        await showCustomAlert("清理完成", `成功移除了 ${removedCount} 首无效歌曲:\n\n- ${invalidSongs.join('\n- ')}`);
    } else {
        await showCustomAlert("检查完成", "所有歌曲链接均有效，无需清理！");
    }
}

// ▼▼▼ 【全新】这是应用状态栏显示/隐藏设置的函数 ▼▼▼
/**
 * 根据全局设置，应用状态栏的可见性
 */
function applyStatusBarVisibility() {
    const phoneScreen = document.getElementById('phone-screen');
    // 如果设置为 true，就添加 class；否则就移除 class。
    phoneScreen.classList.toggle('status-bar-visible', !!state.globalSettings.showStatusBar);
}
// ▲▲▲ 新增函数结束 ▲▲▲
/**
 * 【全新 V3.0 | 总入口】打开支持勾选的清空动态选择器
 */
async function openClearPostsSelectorModal() {
    const modal = document.getElementById('clear-posts-modal');
    const listEl = document.getElementById('clear-posts-list');
    listEl.innerHTML = ''; // 清空旧内容

    // 1. 创建所有选项
    const options = [];

    // 选项A: 清空所有
    options.push({ text: '清空所有动态 (危险)', value: 'all', isDanger: true });

    // 选项B: 清空用户自己
    const myNickname = state.qzoneSettings.nickname || '我';
    options.push({ text: `仅清空 ${myNickname} 的动态`, value: 'user' });

    // 选项C: 遍历AI角色
    Object.values(state.chats).forEach(chat => {
        if (!chat.isGroup) {
            options.push({ text: `仅清空 ${chat.name} 的动态`, value: chat.id });
        }
    });

    // 2. 将选项渲染到列表中
    options.forEach(opt => {
        const item = document.createElement('div');
        item.className = 'clear-posts-item';
        if (opt.isDanger) {
            item.classList.add('danger-option');
        }
        item.dataset.targetId = opt.value;
        item.innerHTML = `
            <div class="checkbox"></div>
            <span class="name">${opt.text}</span>
        `;
        listEl.appendChild(item);
    });
    
    // 3. 显示模态框
    modal.classList.add('visible');
}

/**
 * 【全新 V3.0 | 核心处理器】处理最终的清空确认操作
 */
async function handleConfirmClearPosts() {
    const selectedItems = document.querySelectorAll('#clear-posts-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
        alert("请至少选择一个要清空的范围。");
        return;
    }

    const targetIds = Array.from(selectedItems).map(item => item.dataset.targetId);
    
    // --- 构建确认信息 ---
    let targetNames = [];
    if (targetIds.includes('all')) {
        targetNames.push('所有动态');
    } else {
        if (targetIds.includes('user')) {
            targetNames.push(`“${state.qzoneSettings.nickname}”`);
        }
        targetIds.forEach(id => {
            const character = state.chats[id];
            if (character) {
                targetNames.push(`“${character.name}”`);
            }
        });
    }
    const confirmMessage = `此操作将永久删除 ${targetNames.join('、 ')} 的所有动态，且无法恢复！`;

    const confirmed = await showCustomConfirm(
        '确认清空动态？',
        confirmMessage,
        { confirmButtonClass: 'btn-danger', confirmText: '确认清空' }
    );

    if (!confirmed) return;

    try {
        if (targetIds.includes('all')) {
            await db.qzonePosts.clear();
        } else {
            // 使用 Dexie 的 bulk-delete 功能，一次性高效删除多个作者的动态
            await db.qzonePosts.where('authorId').anyOf(targetIds).delete();
        }

        // 同步更新内存缓存并重绘UI
        qzonePostsCache = await db.qzonePosts.orderBy('timestamp').reverse().toArray();
        qzonePostsRenderCount = 0;
        await renderQzonePosts();
        
        document.getElementById('clear-posts-modal').classList.remove('visible'); // 关闭选择器
        await showCustomAlert('操作成功', '选定范围内的动态已被清空。');

    } catch (error) {
        console.error("清空动态时出错:", error);
        await showCustomAlert('操作失败', `清空动态时发生错误: ${error.message}`);
    }
}
// ▼▼▼ 步骤 3：将这两段全新的JS代码，粘贴到 init() 函数的事件监听器区域 ▼▼▼

/**
 * 【全新】删除指定的心声/散记记录
 * @param {number} timestamp - 要删除的记录的时间戳
 */
async function handleDeleteThought(timestamp) {
    const confirmed = await showCustomConfirm(
        '确认删除',
        '确定要永久删除这条心声记录吗？此操作不可恢复。',
        { confirmButtonClass: 'btn-danger', confirmText: '确认删除' }
    );

    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        if (!chat || !chat.thoughtsHistory) return;

        // 从历史记录数组中移除匹配的项
        chat.thoughtsHistory = chat.thoughtsHistory.filter(thought => thought.timestamp !== timestamp);
        
        // 将更新后的聊天数据保存回数据库
        await db.chats.put(chat);
        
        // 重新渲染列表以反映更改
        renderThoughtsHistory();
        
        // 给出成功提示
        await showCustomAlert('成功', '该条记录已成功删除。');
    }
}

// 使用事件委托，为整个历史记录列表容器绑定点击事件
document.getElementById('thoughts-history-list').addEventListener('click', (e) => {
    // 检查被点击的是否是删除按钮
    const deleteBtn = e.target.closest('.thought-delete-btn');
    if (deleteBtn) {
        // 从按钮的 data-timestamp 属性中获取时间戳
        const timestamp = parseInt(deleteBtn.dataset.timestamp);
        if (!isNaN(timestamp)) {
            // 调用删除处理函数
            handleDeleteThought(timestamp);
        }
    }
});

// ▲▲▲ 新增JS代码粘贴结束 ▲▲▲ 
        // ▼▼▼ 【全新】全局CSS预设功能核心函数 ▼▼▼
        
        /**
         * 从数据库加载CSS预设，并填充到下拉选择框中
         */
        async function loadCssPresetsDropdown() {
            const selectEl = document.getElementById('css-preset-select');
            selectEl.innerHTML = '<option value="">-- 选择一个预设 --</option>';
            
            const presets = await db.appearancePresets.where('type').equals('global_css').toArray();
            presets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                selectEl.appendChild(option);
            });
        }
        
        /**
         * 当用户从下拉框选择一个CSS预设时，加载该预设
         */
        async function handleCssPresetSelectionChange() {
            const selectEl = document.getElementById('css-preset-select');
            const selectedId = parseInt(selectEl.value);
            if (isNaN(selectedId)) return;
        
            const preset = await db.appearancePresets.get(selectedId);
            if (preset) {
                const cssInput = document.getElementById('global-css-input');
                cssInput.value = preset.value;
                applyGlobalCss(preset.value); // 实时预览
            }
        }
        
        /**
         * 将当前输入框中的CSS保存为一个新的预设
         */
        async function saveCssPreset() {
            const name = await showCustomPrompt('保存CSS预设', '请输入预设名称');
            if (!name || !name.trim()) return;
        
            const cssValue = document.getElementById('global-css-input').value;
        
            const existingPreset = await db.appearancePresets.where({ name: name.trim(), type: 'global_css' }).first();
            if (existingPreset) {
                const confirmed = await showCustomConfirm('覆盖预设', `名为 “${name.trim()}” 的预设已存在。要覆盖它吗？`, { confirmButtonClass: 'btn-danger' });
                if (!confirmed) return;
                
                await db.appearancePresets.update(existingPreset.id, { value: cssValue });
            } else {
                await db.appearancePresets.add({
                    name: name.trim(),
                    type: 'global_css',
                    value: cssValue
                });
            }
        
            await loadCssPresetsDropdown(); // 刷新下拉列表
            alert('CSS 预设已保存！');
        }
        
        /**
         * 删除当前选中的CSS预设
         */
        async function deleteCssPreset() {
            const selectEl = document.getElementById('css-preset-select');
            const selectedId = parseInt(selectEl.value);
        
            if (isNaN(selectedId)) {
                alert('请先从下拉框中选择一个要删除的预设。');
                return;
            }
        
            const preset = await db.appearancePresets.get(selectedId);
            if (!preset) return;
        
            const confirmed = await showCustomConfirm('删除预设', `确定要删除预设 “${preset.name}” 吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.appearancePresets.delete(selectedId);
                await loadCssPresetsDropdown(); // 刷新下拉列表
                alert('预设已删除。');
            }
        }
        // ▲▲▲ 新增函数结束 ▲▲▲
        // ▼▼▼ 【全新】字体预设功能核心函数 ▼▼▼

        /**
         * 从数据库加载字体预设，并填充到下拉选择框中
         */
        async function loadFontPresetsDropdown() {
            const selectEl = document.getElementById('font-preset-select');
            selectEl.innerHTML = '<option value="">-- 选择一个预设 --</option>';
            
            const presets = await db.appearancePresets.where('type').equals('font').toArray();
            presets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                selectEl.appendChild(option);
            });
        }

        /**
         * 当用户从下拉框选择一个字体预设时，加载该预设
         */
        async function handleFontPresetSelectionChange() {
            const selectEl = document.getElementById('font-preset-select');
            const selectedId = parseInt(selectEl.value);
            if (isNaN(selectedId)) return;
        
            const preset = await db.appearancePresets.get(selectedId);
            if (preset) {
                const fontUrlInput = document.getElementById('font-url-input');
                fontUrlInput.value = preset.value;
                applyCustomFont(preset.value, true); // 实时预览
            }
        }
        
        /**
         * 将当前输入框中的字体URL保存为一个新的预设
         */
        async function saveFontPreset() {
            const name = await showCustomPrompt('保存字体预设', '请输入预设名称');
            if (!name || !name.trim()) return;
        
            const fontUrl = document.getElementById('font-url-input').value.trim();
            if (!fontUrl) {
                alert("字体URL不能为空！");
                return;
            }
        
            const existingPreset = await db.appearancePresets.where({ name: name.trim(), type: 'font' }).first();
            if (existingPreset) {
                const confirmed = await showCustomConfirm('覆盖预设', `名为 “${name.trim()}” 的预设已存在。要覆盖它吗？`, { confirmButtonClass: 'btn-danger' });
                if (!confirmed) return;
                
                await db.appearancePresets.update(existingPreset.id, { value: fontUrl });
            } else {
                await db.appearancePresets.add({
                    name: name.trim(),
                    type: 'font',
                    value: fontUrl
                });
            }
        
            await loadFontPresetsDropdown();
            alert('字体预设已保存！');
        }
        
        /**
         * 删除当前选中的字体预设
         */
        async function deleteFontPreset() {
            const selectEl = document.getElementById('font-preset-select');
            const selectedId = parseInt(selectEl.value);
        
            if (isNaN(selectedId)) {
                alert('请先从下拉框中选择一个要删除的预设。');
                return;
            }
        
            const preset = await db.appearancePresets.get(selectedId);
            if (!preset) return;
        
            const confirmed = await showCustomConfirm('删除预设', `确定要删除预设 “${preset.name}” 吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.appearancePresets.delete(selectedId);
                await loadFontPresetsDropdown();
                alert('预设已删除。');
            }
        }
        // ▲▲▲ 新增函数结束 ▲▲▲
        // ▼▼▼ 【全新】气泡主题预设功能核心函数 ▼▼▼

        /**
         * 从数据库加载气泡主题预设，并填充到下拉选择框中
         */
        async function loadThemePresetsDropdown() {
            const selectEl = document.getElementById('theme-preset-select');
            selectEl.innerHTML = '<option value="">-- 选择一个预设 --</option>';
            
            const presets = await db.appearancePresets.where('type').equals('bubble_theme').toArray();
            presets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                selectEl.appendChild(option);
            });
        }

/**
         * 当用户从下拉框选择一个主题预设时，加载该预设
         */
        async function handleThemePresetSelectionChange() {
            const selectEl = document.getElementById('theme-preset-select');
            const selectedId = parseInt(selectEl.value);
            if (isNaN(selectedId)) return;
        
            const preset = await db.appearancePresets.get(selectedId);
            if (preset) {
                // ▼▼▼ 核心修改 ▼▼▼
                // 1. 从保存的对象中分别获取基础主题和自定义CSS
                const baseTheme = preset.value.base || 'default';
                const customCss = preset.value.custom || '';

                // 2. 应用基础主题（勾选对应的单选框）
                const themeRadio = document.querySelector(`input[name="theme-select"][value="${baseTheme}"]`);
                if (themeRadio) {
                    themeRadio.checked = true;
                }

                // 3. 将保存的CSS加载回输入框
                const customCssInput = document.getElementById('custom-css-input');
                customCssInput.value = customCss;

                // 4. 立刻刷新预览区，让效果显示出来
                updateSettingsPreview(); 
                // ▲▲▲ 修改结束 ▲▲▲
            }
        }
        
 /**
         * 将当前选择的气泡主题保存为一个新的预设
         */
        async function saveThemePreset() {
            const name = await showCustomPrompt('保存主题预设', '请输入预设名称');
            if (!name || !name.trim()) return;
        
            // ▼▼▼ 核心修改 ▼▼▼
            // 1. 获取基础主题的选择
            const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
            const themeValue = selectedThemeRadio ? selectedThemeRadio.value : 'default';

            // 2. 获取自定义CSS的内容
            const cssValue = document.getElementById('custom-css-input').value.trim();

            // 3. 将基础主题和自定义CSS打包成一个对象进行保存
            const presetValueObject = {
                base: themeValue,
                custom: cssValue
            };
            // ▲▲▲ 修改结束 ▲▲▲
        
            const existingPreset = await db.appearancePresets.where({ name: name.trim(), type: 'bubble_theme' }).first();
            if (existingPreset) {
                const confirmed = await showCustomConfirm('覆盖预设', `名为 “${name.trim()}” 的预设已存在。要覆盖它吗？`, { confirmButtonClass: 'btn-danger' });
                if (!confirmed) return;
                
                // 保存打包后的对象
                await db.appearancePresets.update(existingPreset.id, { value: presetValueObject });
            } else {
                await db.appearancePresets.add({
                    name: name.trim(),
                    type: 'bubble_theme',
                    // 保存打包后的对象
                    value: presetValueObject
                });
            }
        
            await loadThemePresetsDropdown();
            alert('主题预设已保存！');
        }
        
        /**
         * 删除当前选中的主题预设
         */
        async function deleteThemePreset() {
            const selectEl = document.getElementById('theme-preset-select');
            const selectedId = parseInt(selectEl.value);
        
            if (isNaN(selectedId)) {
                alert('请先从下拉框中选择一个要删除的预设。');
                return;
            }
        
            const preset = await db.appearancePresets.get(selectedId);
            if (!preset) return;
        
            const confirmed = await showCustomConfirm('删除预设', `确定要删除预设 “${preset.name}” 吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.appearancePresets.delete(selectedId);
                await loadThemePresetsDropdown();
                alert('预设已删除。');
            }
        }
        // ▲▲▲ 新增函数结束 ▲▲▲
        // ▼▼▼ 【全新】这是表情包分类功能的【全部核心JS代码】，请完整粘贴 ▼▼▼
        
        /**
         * 【总入口】打开分类管理弹窗
         */
        async function openStickerCategoryManager() {
            await renderStickerCategoriesInManager();
            document.getElementById('sticker-category-manager-modal').classList.add('visible');
        }
        
        /**
         * 在弹窗中渲染已存在的分类列表
         */
        async function renderStickerCategoriesInManager() {
            const listEl = document.getElementById('existing-sticker-categories-list');
            const categories = await db.stickerCategories.toArray();
            listEl.innerHTML = '';
            if (categories.length === 0) {
                listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类</p>';
                return;
            }
            categories.forEach(cat => {
                const item = document.createElement('div');
                item.className = 'existing-group-item'; // 复用已有样式
                item.innerHTML = `
                    <span class="group-name">${cat.name}</span>
                    <span class="delete-group-btn" data-id="${cat.id}">×</span>
                `;
                listEl.appendChild(item);
            });
        }
        
        /**
         * 添加一个新的表情分类
         */
        async function addNewStickerCategory() {
            const input = document.getElementById('new-sticker-category-name-input');
            const name = input.value.trim();
            if (!name) {
                alert('分类名不能为空！');
                return;
            }
            const existing = await db.stickerCategories.where('name').equals(name).first();
            if (existing) {
                alert(`分类 "${name}" 已经存在了！`);
                return;
            }
            await db.stickerCategories.add({ name });
            input.value = '';
            await renderStickerCategoriesInManager();
        }
        
        /**
         * 【核心】删除一个分类，并一并删除该分类下的所有表情包
         * @param {number} categoryId - 要删除的分类的ID
         */
        async function deleteStickerCategory(categoryId) {
            const category = await db.stickerCategories.get(categoryId);
            if (!category) return;

            const stickersInCateogry = await db.userStickers.where('categoryId').equals(categoryId).count();
            
            const confirmMessage = stickersInCateogry > 0 
                ? `确定要删除分类《${category.name}》吗？\n\n【【【警告】】】\n此操作将同时永久删除该分类下的 ${stickersInCateogry} 个表情包，且无法恢复！`
                : `确定要删除分类《${category.name}》吗？`;

            const confirmed = await showCustomConfirm(
                '确认删除分类', 
                confirmMessage, 
                { confirmButtonClass: 'btn-danger' }
            );

            if (confirmed) {
                try {
                    // 使用事务确保操作的原子性
                    await db.transaction('rw', db.stickerCategories, db.userStickers, async () => {
                        // 1. 找到该分类下所有表情的ID
                        const stickerIdsToDelete = await db.userStickers.where('categoryId').equals(categoryId).primaryKeys();
                        
                        // 2. 批量删除这些表情
                        if (stickerIdsToDelete.length > 0) {
                            await db.userStickers.bulkDelete(stickerIdsToDelete);
                        }

                        // 3. 删除分类本身
                        await db.stickerCategories.delete(categoryId);
                    });

                    // 更新前端 state 和 UI
                    state.userStickers = await db.userStickers.toArray();
                    if (activeStickerCategoryId === categoryId) {
                        activeStickerCategoryId = 'all'; // 如果删除的是当前分类，就切回“全部”
                    }
                    await renderStickerCategoriesInManager(); // 刷新管理列表
                    await renderStickerPanel(); // 刷新主面板
                    
                    alert(`分类《${category.name}》及其下的表情已成功删除。`);

                } catch (error) {
                    console.error("删除分类及表情时出错:", error);
                    alert("删除失败，请查看控制台错误信息。");
                }
            }
        }

// ▼▼▼ 请用这个新版本替换旧的 switchStickerCategory 函数 ▼▼▼
        function switchStickerCategory(categoryId) {
            activeStickerCategoryId = categoryId;
            document.querySelectorAll('.sticker-category-tab').forEach(tab => {
                tab.classList.toggle('active', String(tab.dataset.categoryId) === String(categoryId));
            });
            renderStickerPanel(false);
            
            // 【核心新增】切换分类时，重置全选框的状态
            const selectAllCheckbox = document.getElementById('select-all-stickers-checkbox');
            if(selectAllCheckbox) selectAllCheckbox.checked = false;
        }
        // ▲▲▲ 替换结束 ▲▲▲
/**
 * 【全新】仅导出当前单个聊天的备份
 */
async function exportSingleChat() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    try {
        const backupData = {
            type: 'EPhoneSingleChat', // 特殊标记，用于导入时验证
            version: 1,
            chatData: chat
        };

        const blob = new Blob(
            [JSON.stringify(backupData, null, 2)], 
            { type: 'application/json' }
        );
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        // 文件名将使用角色的备注名
        link.download = `EPhone-Chat-${chat.name}-${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        URL.revokeObjectURL(url);
        
        await showCustomAlert('导出成功', `与“${chat.name}”的聊天记录已成功导出！`);

    } catch (error) {
        console.error("导出单个聊天时出错:", error);
        await showCustomAlert('导出失败', `发生了一个错误: ${error.message}`);
    }
}

/**
 * 【全新】将单个聊天的备份导入并覆盖当前聊天
 * @param {File} file - 用户选择的 .json 备份文件
 */
async function importSingleChat(file) {
    if (!file || !state.activeChatId) return;
    const currentChatId = state.activeChatId;
    const currentChat = state.chats[currentChatId];

    try {
        const text = await file.text();
        const data = JSON.parse(text);

        // 1. 验证文件格式
        if (data.type !== 'EPhoneSingleChat' || !data.chatData) {
            throw new Error("文件格式不正确，这不是一个有效的单聊备份文件。");
        }

        // 2. 弹出最终警告
        const confirmed = await showCustomConfirm(
            '严重警告！',
            `这将用备份文件中的数据【完全覆盖】当前与“${currentChat.name}”的聊天记录和设置。此操作不可撤销！<br><br><strong>确定要继续吗？</strong>`,
            { confirmButtonClass: 'btn-danger', confirmText: '确认覆盖' }
        );

        if (!confirmed) return;

        // 3. 执行覆盖操作
        const importedChatData = data.chatData;
        
        // 保持当前的ID不变，只用导入的数据覆盖内容
        importedChatData.id = currentChatId; 
        
        // 更新数据库和内存状态
        await db.chats.put(importedChatData);
        state.chats[currentChatId] = importedChatData;

        // 4. 成功提示并刷新
        await showCustomAlert('导入成功', '聊天记录已成功覆盖！正在刷新界面...');
        
        // 刷新UI
        renderChatInterface(currentChatId);
        renderChatList();
        document.getElementById('chat-settings-btn').click(); // 重新打开设置以显示最新数据

    } catch (error) {
        console.error("导入单个聊天时出错:", error);
        await showCustomAlert('导入失败', `文件解析或应用失败: ${error.message}`);
    }
}
// ▼▼▼ 【全新】Cphone功能的所有核心JS代码 ▼▼▼

/**
 * 【总入口】打开角色选择界面
 */
function openCharacterSelector() {
    renderCharacterSelector();
    showScreen('character-selection-screen');
}

/**
 * 渲染角色选择列表
 */
function renderCharacterSelector() {
    const gridEl = document.getElementById('character-grid');
    gridEl.innerHTML = '';
    
    // 只筛选出单聊角色
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (characters.length === 0) {
        gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">还没有可以查看手机的角色哦~</p>';
        return;
    }

    characters.forEach(char => {
        const item = document.createElement('div');
        item.className = 'character-select-item';
        item.innerHTML = `
            <img src="${char.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${char.name}</span>
        `;
        item.addEventListener('click', () => switchToCharacterPhone(char.id));
        gridEl.appendChild(item);
    });
}

        // ▼▼▼ 【请用这个已更新的版本】替换旧的 switchToCharacterPhone 函数 ▼▼▼
        /**
         * 切换到指定角色的手机界面
         * @param {string} characterId - 角色的ID
         */
        async function switchToCharacterPhone(characterId) {
            activeCharacterId = characterId;
            console.log(`已切换到角色 ${characterId} 的手机`);
            
            // 【核心修改】调用新的应用函数来设置壁纸和图标
            applyCPhoneWallpaper();
            applyCPhoneAppIcons();
            
            // 渲染并显示Cphone的主屏幕
            renderCharHomeScreen();
            showScreen('character-phone-screen');
        }
        // ▲▲▲ 替换结束 ▲▲▲

/**
 * 返回到用户自己的手机主屏幕
 */
function switchToMyPhone() {
    activeCharacterId = null;
    console.log("已返回我的手机");
    showScreen('home-screen');
}

/**
 * 渲染Cphone的主屏幕（主要是更新时钟）
 */
function renderCharHomeScreen() {
    const now = new Date();
    const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
    const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' });
    document.getElementById('char-main-time').textContent = timeString;
    document.getElementById('char-main-date').textContent = dateString;
    switchToCharScreen('char-home-screen');
}

/**
 * 在Cphone内部切换不同的App屏幕
 * @param {string} screenId - 要显示的角色App屏幕ID
 */
function switchToCharScreen(screenId) {
    document.querySelectorAll('.char-screen').forEach(s => s.classList.remove('active'));
    document.getElementById(screenId).classList.add('active');
}
// ▼▼▼ 【核心修复】将此函数暴露到全局，让onclick可以调用 ▼▼▼
window.switchToCharScreen = switchToCharScreen;
// ▲▲▲ 修复结束 ▲▲▲

// ▼▼▼ 【V3.0 | 最终版】请用这个全新的函数，完整替换旧的 openCharApp ▼▼▼
         /**
         * 【总分发 | V3.0 | 最终修复版 | 已添加音乐App】打开Cphone内的App
         * @param {string} appName - App的简称 (qq, album, amap...)
         */
        async function openCharApp(appName) {
            if (!activeCharacterId) return;
            const char = state.chats[activeCharacterId];
            
    // ▼▼▼ 核心修改：在打开App前记录使用日志 ▼▼▼
    await logAppUsage(activeCharacterId, appName);
    // ▲▲▲ 修改结束 ▲▲▲

            switch(appName) {
                case 'qq':
                    renderCharSimulatedQQ();
                    switchToCharScreen('char-qq-screen');
                    break;
                case 'album':
                    renderCharAlbum();
                    switchToCharScreen('char-album-screen');
                    break;
                case 'browser':
                    renderCharBrowserHistory();
                    switchToCharScreen('char-browser-screen');
                    break;
                case 'taobao':
                    renderCharTaobao();
                    switchToCharScreen('char-taobao-screen');
                    break;
                case 'memo':
                    renderCharMemoList();
                    switchToCharScreen('char-memo-screen');
                    break;
                case 'diary':
                    renderCharDiaryList();
                    switchToCharScreen('char-diary-screen');
                    break;
                case 'amap':
                    renderCharAmap();
                    switchToCharScreen('char-amap-screen');
                    break;
                
                // ▼▼▼ 【核心修复就在这里！】 ▼▼▼
                // 我们现在添加了对 'music' 的处理逻辑
                case 'music':
                    renderCharMusicScreen(); // 渲染网易云音乐列表
                    switchToCharScreen('char-music-screen'); // 显示网易云音乐屏幕
                    break;
                // ▲▲▲ 修复结束 ▲▲▲

                case 'usage':
                    renderCharAppUsage();
                    switchToCharScreen('char-usage-screen');
                    break;
            }
        }
        // ▼▼▼ 【V3.2 | 描述显示版】请用这个全新的函数，完整替换旧的 renderCharAlbum 函数 ▼▼▼
        /**
         * 【全新 | V3.2 终极防空窗+生图开关+描述显示版】渲染角色相册
         */
        async function renderCharAlbum() {
            const gridEl = document.getElementById('char-album-grid');
            gridEl.innerHTML = '';
            if (!activeCharacterId) return;
            const char = state.chats[activeCharacterId];
        
            const photos = char.simulatedAlbum || [];
        
            if (photos.length === 0) {
                gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TA的相册还是空的，<br>点击右上角刷新按钮生成一些照片吧！</p>';
                return;
            }
        
            const fallbackImageUrl = `https://i.postimg.cc/KYr2qRCK/1.jpg`;

            photos.forEach(photo => {
                const item = document.createElement('div');
                item.className = 'char-photo-item';
                item.dataset.description = photo.description;
                gridEl.appendChild(item);

                
                // 1. 检查全局的生图开关是否开启
                if (state.globalSettings.enableAiDrawing) {
                    // --- 如果开关【开启】，执行原来的生图逻辑 ---
                    item.style.backgroundColor = '#e9ecef';
                    const containsNonEnglish = /[^\x00-\x7F]/.test(photo.image_prompt);
                    const isValidPrompt = photo.image_prompt && photo.image_prompt.trim() && !containsNonEnglish;
                    const finalPrompt = isValidPrompt ? photo.image_prompt : 'a beautiful scenery, anime style, cinematic lighting';
                    const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}`;
                    
                    const img = new Image();
                    img.onload = function() { item.style.backgroundImage = `url(${this.src})`; };
                    img.onerror = function() { item.style.backgroundImage = `url(${fallbackImageUrl})`; };
                    img.src = imageUrl;

                } else {
                    // --- 如果开关【关闭】，则直接显示描述文字！ ---
                    item.style.backgroundColor = '#f0f2f5'; // 给一个淡淡的背景色
                    item.style.border = '1px solid #e0e0e0'; // 加一个细边框，更有卡片感
                    
                    // 创建一个新的 <p> 元素来存放描述
                    const descriptionEl = document.createElement('p');
                    descriptionEl.className = 'char-photo-description'; // 应用我们刚刚添加的CSS样式
                    descriptionEl.textContent = photo.description || '(这张照片没有描述)'; // 显示描述，如果没有则显示提示
                    
                    // 将描述元素添加到格子里
                    item.appendChild(descriptionEl);
                }
       
            });
        }
        // ▲▲▲ 替换结束 ▲▲▲

/**
 * 【全新】动态生成并渲染角色的浏览器历史记录
 */
function renderCharBrowserHistory() {
    const listEl = document.getElementById('char-browser-history');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    // 这里我们基于角色的名字和人设，动态生成一些看起来合理的历史记录
    const historyKeywords = [char.name, "爱好", "旅游", "美食", "新闻", ...char.settings.aiPersona.split(/，|。|\s/).slice(0, 5)];
    const historySites = ["知乎", "Bilibili", "小红书", "微博", "维基百科"];

    for (let i = 0; i < 15; i++) {
        const keyword = historyKeywords[Math.floor(Math.random() * historyKeywords.length)];
        const site = historySites[Math.floor(Math.random() * historySites.length)];
        const item = document.createElement('div');
        item.className = 'char-browser-item';
        item.innerHTML = `
            <div class="title">${keyword} - ${site}</div>
            <div class="url">www.${site.toLowerCase()}.com/${keyword}</div>
        `;
        listEl.appendChild(item);
    }
}

        // ▼▼▼ 【V3.1 | 生图开关+描述显示+状态显示版】请用这个全新的函数，完整替换旧的 renderCharTaobao ▼▼▼
        /**
         * 【全新 | V3.1 无钱包版 | 最终修复】渲染角色的淘宝“购买记录”页面
         */
        function renderCharTaobao() {
            const gridEl = document.getElementById('char-product-grid');
            gridEl.innerHTML = '';
            if (!activeCharacterId) return;

            const char = state.chats[activeCharacterId];
            const purchases = char.simulatedTaobaoHistory?.purchases || [];

            if (purchases.length === 0) {
                gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TA最近好像什么都没买呢，<br>点击右上角刷新按钮生成一些记录吧！</p>';
                return;
            }

            purchases.forEach(item => {
                const itemEl = document.createElement('div');
                itemEl.className = 'char-product-item';
                itemEl.dataset.reason = item.reason;
                
                let imageOrTextHtml;
                if (state.globalSettings.enableAiDrawing) {
                    const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(item.image_prompt || 'a random product')}`;
                    imageOrTextHtml = `<img src="${imageUrl}" class="product-image">`;
                } else {
                    imageOrTextHtml = `
                        <div class="char-product-description-overlay">
                            <p class="char-photo-description">${item.reason || '(无购买理由)'}</p>
                        </div>
                    `;
                }

                // ▼▼▼ 核心修改：在这里添加了 item.status 的显示 ▼▼▼
                itemEl.innerHTML = `
                    ${imageOrTextHtml}
                    <div class="product-info">
                        <div class="product-name">${item.itemName}</div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                            <div class="product-price">${(item.price || 0).toFixed(2)}</div>
                            <div class="char-product-status">${item.status}</div>
                        </div>
                    </div>
                `;
                // ▲▲▲ 修改结束 ▲▲▲
                gridEl.appendChild(itemEl);
            });
        }
/**
 * 切换回Cphone的主屏幕
 */
function switchToCharHomeScreen() {
    switchToCharScreen('char-home-screen');
}


// --- CphoneApp的具体功能 ---

/**
 * 渲染角色视角的QQ聊天列表 (简化版)
 */
function renderCharChatList() {
    const listEl = document.getElementById('char-chat-list');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    // 找出所有与该角色相关的聊天
    const relatedChats = Object.values(state.chats).filter(chat => {
        // 条件1: 与用户的单聊
        if (chat.id === activeCharacterId) return true;
        // 条件2: 角色所在的群聊
        if (chat.isGroup && chat.members.some(m => m.id === activeCharacterId)) return true;
        return false;
    });

    relatedChats.forEach(chat => {
        const item = createChatListItem(chat); // 复用主列表的渲染函数
        listEl.appendChild(item);
    });
}

/**
 * 记录App使用日志
 */
async function logAppUsage(characterId, appName) {
    const char = state.chats[characterId];
    if (!char) return;
    if (!char.appUsageLog) {
        char.appUsageLog = [];
    }
    char.appUsageLog.push({
        appName: appName,
        timestamp: Date.now()
    });
    // 保留最近50条记录
    if (char.appUsageLog.length > 50) {
        char.appUsageLog.shift();
    }
    await db.chats.put(char);
}

/**
 * 渲染App使用记录
 */
function renderCharAppUsage() {
    const listEl = document.getElementById('char-usage-list');
    listEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    const log = (char.appUsageLog || []).slice().reverse(); // 从新到旧显示

    if (log.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">还没有任何使用记录。</p>';
        return;
    }

    const appNameMap = {
        'qq': 'QQ', 'album': '相册', 'browser': '浏览器', 'taobao': '淘宝',
        'memo': '备忘录', 'diary': '日记', 'amap': '高德地图', 'usage': 'App记录'
    };

    log.forEach(entry => {
        const item = document.createElement('div');
        item.className = 'usage-item';
        item.innerHTML = `
            <div class="timestamp">${new Date(entry.timestamp).toLocaleString()}</div>
            <div class="action">打开了 <strong>${appNameMap[entry.appName] || entry.appName}</strong></div>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 模拟角色发送位置分享
 */
async function sendCharLocationShare(locationName) {
    const userChat = state.chats[activeCharacterId]; // 获取与该角色的单聊
    if (!userChat) return;

    const msg = {
        role: 'assistant', // 是AI（角色）发出的
        senderName: userChat.originalName,
        type: 'location_share',
        content: locationName,
        imageUrl: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756262526935_qdqqd_4uque3.jpeg',
        timestamp: Date.now()
    };

    userChat.history.push(msg);
    await db.chats.put(userChat);
    
    // 如果当前正与该角色聊天，则实时显示
    if (state.activeChatId === activeCharacterId) {
        appendMessage(msg, userChat);
    }
    
    await showCustomAlert("分享成功", `“${userChat.name}” 的位置已发送到你们的聊天中。`);
}


/**
 * 【V2.1 | 全屏查看最终版】点击备忘录列表项时，打开详情页面查看其内容
 * @param {number} memoId - 要查看的备忘录的ID
 */
async function viewMemo(memoId) {
    const char = state.chats[activeCharacterId];
    if (!char || !char.memos) return;

    const memo = char.memos.find(m => m.id === memoId);
    if (memo) {
        // 1. 【核心修复】现在我们直接通过ID查找标题和内容元素
        const titleEl = document.getElementById('char-memo-detail-title');
        const contentEl = document.getElementById('char-memo-detail-content');

        // 2. 将备忘录的数据填充进去
        if (titleEl) titleEl.textContent = memo.title;
        if (contentEl) contentEl.value = memo.content;

        // 3. 切换到新的详情页屏幕
        switchToCharScreen('char-memo-detail-screen');
    }
}

/**
 * 【V2.0 | 支持标题】渲染Cphone的备忘录列表
 */
function renderCharMemoList() {
    const listEl = document.getElementById('char-memo-list');
    listEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    const memos = (char.memos || []).slice().reverse();

    if (memos.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">还没有备忘录。</p>';
        return;
    }

    memos.forEach(memo => {
        const item = document.createElement('div');
        // 复用现有的 list-item 样式，美观且统一
        item.className = 'list-item'; 
        item.innerHTML = `
            <div class="item-title">${memo.title}</div>
            <div class="item-content">${(memo.content || '').split('\n')[0]}</div>
        `;
        // 【核心修改】点击列表项现在是调用 viewMemo 查看函数
        item.addEventListener('click', () => viewMemo(memo.id));
        addLongPressListener(item, () => deleteMemo(memo.id));
        listEl.appendChild(item);
    });
}

/**
 * 【V2.1 | 流程修正】打开编辑器以创建新的备忘录
 */
async function openMemoEditor(memoId = null) {
    editingMemoId = null; 
    
    // （这部分逻辑与之前相同）
    const newTitle = await showCustomPrompt("新建备忘录", "请输入标题");
    if (newTitle === null || !newTitle.trim()) return;

    const newContent = await showCustomPrompt(`标题: ${newTitle}`, "请输入备忘录内容", "", 'textarea');
    if (newContent !== null) {
        // 【核心修正】在保存后，确保我们停留在备忘录列表页
        await saveMemo({ title: newTitle.trim(), content: newContent });
        switchToCharScreen('char-memo-screen'); // 确保显示的是列表
    }
}

/**
 * 【V2.0 | 支持标题】保存新的备忘录
 * @param {object} memoData - 包含 title 和 content 的对象
 */
async function saveMemo(memoData) {
    const char = state.chats[activeCharacterId];
    if (!char.memos) char.memos = [];
    
    // 这个函数现在只处理“新建”
    char.memos.push({ 
        id: Date.now(), 
        title: memoData.title, 
        content: memoData.content 
    });
    
    await db.chats.put(char);
    renderCharMemoList();
}

async function saveMemo(content) {
    const char = state.chats[activeCharacterId];
    if (!char.memos) char.memos = [];
    
    if (editingMemoId) {
        const memo = char.memos.find(m => m.id === editingMemoId);
        if (memo) memo.content = content;
    } else {
        char.memos.push({ id: Date.now(), content: content });
    }
    
    await db.chats.put(char);
    renderCharMemoList();
    editingMemoId = null;
}



        // ▼▼▼ 【V2.0 | AI生成版】请用这一整块代码，替换所有旧的日记功能函数 ▼▼▼

/**
 * 【全新 | V3.0 AI指令强化版】当用户点击“重新生成”时，调用AI生成模拟相册内容
 */
async function handleGenerateSimulatedDiaries() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在请求“${chat.name}”翻开TA的日记本...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置好API信息。');
        return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '无';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## 世界书《${book.name}》设定:\n${book.content.filter(e=>e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
// 【【【核心修改：在这里同时生成更细致的、多维度的总结】】】
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
    // ▼▼▼ 核心修改1：强化AI指令 ▼▼▼
    const systemPrompt = `
# 你的任务
你是一个虚拟生活模拟器和故事作家。你的任务是扮演角色“${chat.name}”，并根据其人设、记忆和最近的互动，虚构出【5到8篇】TA最近可能会写的日记。

# 核心规则
1.  **【时间 (最高优先级)】**:
    -   今天的日期是 **${new Date().toLocaleDateString('zh-CN')}**。
    -   你生成的【所有】日记的标题日期，【必须】是今天或今天以前的日期。
    -   【绝对禁止】生成任何未来的日期！
2.  **【沉浸感】**: 每一篇日记都必须使用【第一人称视角 ("我")】来写，并且要充满角色的个人情感、思考和秘密。在日记中描述自己的行为或想法时，【绝对禁止】使用第三人称“他”或“她” (TA)。
3.  **【长度】**: 每一篇日记的正文长度【必须不少于300字】。
4.  **【格式铁律 (最高优先级)】**: 
    - 你的回复【必须且只能】是一个JSON数组格式的字符串。
    - 你的回复必须以 \`[\` 开始，并以 \`]\` 结束。
    - 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记 (如 \`\`\`json)。
    - 数组中的每个元素都是一个对象，代表一篇日记，格式【必须】如下:
    \`\`\`json
    [
      {
        "title": "这篇日记的标题，例如：9月20日 晴",
        "content": "这里是日记的详细正文，必须支持换行符\\n，并且必须巧妙地使用下面的【日记专属Markdown语法】来丰富文本表现力。"
      }
    ]
    \`\`\`
5.  **【占位符替换 (最高优先级)】**: 在你的日记内容中，【绝对不能】出现 "{{user}}" 这个占位符。你【必须】使用 “${userDisplayNameForAI}” 来指代你的聊天对象（用户）。
6.  **【日记专属Markdown语法 (必须使用！)】**:
    -   \`**加粗文字**\`: 用于强调。
    -   \`~~划掉的文字~~\`: 用于表示改变主意或自我否定。
    -   \`!h{黄色高亮}\`: 用于标记关键词或重要信息。
    -   \`!u{粉色下划线}\`: 用于标注人名、地名或特殊名词。
    -   \`!e{粉色强调}\`: 用于表达强烈的情绪。
    -   \`!w{手写体}\`: 用于写下引言、歌词或特殊笔记。
    -   \`!m{凌乱的手写体}\`: 用于表达激动、慌乱或潦草记录时的心情。
    -   \`||涂黑||\`: 用于隐藏秘密或敏感词汇 (每次涂黑2~5个字)。

# 供你参考的上下文
- **你的角色设定**: ${chat.settings.aiPersona}
- **你的长期记忆**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **你最近和“${userDisplayNameForAI}”的对话摘要**:
${recentHistoryWithUser}

现在，请开始撰写这组充满真情实感、并熟练运用了Markdown语法的日记。`;
    // ▲▲▲ 修改结束 ▲▲▲

    try {
        const messagesForApi = [{ role: 'user', content: "请根据你的设定，生成你的日记内容。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        // ▼▼▼ 核心修改2：移除不兼容的 response_format 参数 ▼▼▼
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.95,
                    // response_format: { "type": "json_object" } <-- 此行已被删除
                })
            });
        // ▲▲▲ 修改结束 ▲▲▲

        if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        // ▼▼▼ 核心修改3：使用更强大的容错解析逻辑 ▼▼▼
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedDiaries;
        try {
            simulatedDiaries = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`解析AI返回的JSON时出错: ${e.message}\n\nAI原始返回内容:\n${aiResponseContent}`);
        }
        // ▲▲▲ 修改结束 ▲▲▲
        
        chat.diary = simulatedDiaries.map(entry => ({
            id: Date.now() + Math.random(),
            title: entry.title,
            content: entry.content,
            timestamp: Date.now()
        }));
        
        await db.chats.put(chat);
        await renderCharDiaryList();
        
    } catch (error) {
        console.error("生成模拟日记失败:", error);
        await showCustomAlert("生成失败", `无法生成日记，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
}

        /**
         * 【全新】当用户点击“+”时，触发AI撰写一篇新日记并追加到末尾
         */
        async function handleWriteNewDiaryEntry() {
            if (!activeCharacterId) return;
            const chat = state.chats[activeCharacterId];
            if (!chat) return;
        
            await showCustomAlert("请稍候...", `正在请求“${chat.name}”写一篇新日记...`);
        
            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) return;

            const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;

            const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '无';
            const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
            const worldBookContext = (chat.settings.linkedWorldBookIds || []).map(bookId=>state.worldBooks.find(wb=>wb.id===bookId)).filter(Boolean).map(book=>`\n## 世界书《${book.name}》设定:\n${book.content.filter(e=>e.enabled).map(e=>`- ${e.content}`).join('\n')}`).join('');
            
            // ▼▼▼ 核心修复1：在这里也添加“时间铁律” ▼▼▼
            const systemPrompt = `
# 你的任务
你是一个虚拟生活模拟器和故事作家。你的任务是扮演角色“${chat.name}”，并根据其人设、记忆和最近的互动，虚构出【1篇】TA今天可能会写的日记。

# 核心规则
1.  **【【【时间铁律 (最高优先级)】】】**:
    -   今天的日期是 **${new Date().toLocaleDateString('zh-CN')}**。
    -   你生成的日记标题日期【必须】是今天或今天以前的日期。
    -   【绝对禁止】生成任何未来的日期！
2.  **【【【沉浸感铁律】】】**: 日记必须使用【第一人称视角 ("我")】来写，并且要充满角色的个人情感、思考和秘密。在日记中描述自己的行为或想法时，【绝对禁止】使用第三人称“他”或“她” (TA)。
3.  **【【【长度铁律】】】**: 日记的正文长度【必须不少于300字】。
4.  **【【【格式铁律 (最高优先级)】】】**: 你的回复【必须且只能】是一个JSON数组，且数组中【只包含一个】对象，格式【必须】如下:
    \`\`\`json
    [
      {
        "title": "这篇日记的标题，例如：9月20日 晴",
        "content": "这里是日记的详细正文，必须支持换行符\\n，并且必须巧妙地使用下面的【日记专属Markdown语法】来丰富文本表现力。"
      }
    ]
    \`\`\`
5.  **【【【日记专属Markdown语法 (必须使用！)】】】**:
    -   \`**加粗文字**\`: 用于强调。
    -   \`~~划掉的文字~~\`: 用于表示改变主意或自我否定。
    -   \`!h{黄色高亮}\`: 用于标记关键词或重要信息。
    -   \`!u{粉色下划线}\`: 用于标注人名、地名或特殊名词。
    -   \`!e{粉色强调}\`: 用于表达强烈的情绪。
    -   \`!w{手写体}\`: 用于写下引言、歌词或特殊笔记。
    -   \`!m{凌乱的手写体}\`: 用于表达激动、慌乱或潦草记录时的心情。
    -   \`||涂黑||\`: 用于隐藏秘密或敏感词汇(每次涂黑2~5个字)。

# 供你参考的上下文
- **你的角色设定**: ${chat.settings.aiPersona}
- **你的长期记忆**:
${longTermMemoryContext}
${worldBookContext}
- **你最近和“${userDisplayNameForAI}”的对话摘要**:
${recentHistoryWithUser}

现在，请开始撰写这篇充满真情实感、并熟练运用了Markdown语法的日记。`;
        
            try {
                const messagesForApi = [{ role: 'user', content: "请根据你的设定，写一篇新日记。" }];
                let isGemini = proxyUrl.includes('generativelanguage');
                let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
                const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                    body: JSON.stringify({
                        model: model,
                        messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                        temperature: state.globalSettings.apiTemperature || 0.95,
                    })
                });
                if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);
                const data = await response.json();
                const aiResponseContent = getGeminiResponseText(data);
                
                // ▼▼▼ 核心修复2：在这里也使用终极容错解析方案 ▼▼▼
                const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
                if (!jsonMatch || !jsonMatch[0]) {
                    throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
                }
                const cleanedJsonString = jsonMatch[0];
                let newDiaryEntry;
                try {
                    newDiaryEntry = JSON.parse(cleanedJsonString)[0];
                } catch (e) {
                    throw new Error(`解析AI返回的JSON时出错: ${e.message}\n\nAI原始返回内容:\n${aiResponseContent}`);
                }
                // ▲▲▲ 修复结束 ▲▲▲
                
                if (!chat.diary) chat.diary = [];
                
                chat.diary.push({
                    id: Date.now(),
                    title: newDiaryEntry.title,
                    content: newDiaryEntry.content,
                    timestamp: Date.now()
                });
                
                await db.chats.put(chat);
                await renderCharDiaryList();
        
            } catch (error) {
                console.error("生成新日记失败:", error);
                await showCustomAlert("生成失败", `错误: ${error.message}`);
            }
        }

        /**
         * 【全新 | V2.0】渲染Cphone的日记列表
         */
        function renderCharDiaryList() {
            const listEl = document.getElementById('char-diary-list');
            listEl.innerHTML = '';
            const char = state.chats[activeCharacterId];
            const diaries = (char.diary || []).slice().reverse();

            if (diaries.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">日记本还是空的。</p>';
                return;
            }

            diaries.forEach(entry => {
                const item = document.createElement('div');
                item.className = 'list-item';
                item.innerHTML = `
                    <div class="item-title">${entry.title}</div>
                    <div class="item-content">${new Date(entry.timestamp).toLocaleDateString()}</div>
                `;
                item.addEventListener('click', () => viewDiary(entry.id));
                addLongPressListener(item, () => deleteDiary(entry.id));
                listEl.appendChild(item);
            });
        }

    // ▼▼▼ 【请用这个 V2.0 版本】替换旧的 viewDiary 函数 ▼▼▼
    /**
     * 【V2.0 | 支持收藏】点击日记列表项时，打开详情页面查看
     * @param {number} diaryId - 要查看的日记的ID
     */
    async function viewDiary(diaryId) {
        const char = state.chats[activeCharacterId];
        if (!char || !char.diary) return;
    
        const entry = char.diary.find(d => d.id === diaryId);
        if (entry) {
            // 1. 将当前日记对象存入全局变量，方便收藏功能调用
            activeDiaryForViewing = entry;
    
            const titleEl = document.getElementById('char-diary-detail-title');
            const contentEl = document.getElementById('char-diary-detail-content');
            const favBtn = document.getElementById('favorite-diary-btn');
    
            titleEl.textContent = entry.title;
            const formattedContent = parseMarkdown(entry.content)
                .split('\n')
                .map(p => `<p>${p || '&nbsp;'}</p>`)
                .join('');
            contentEl.innerHTML = formattedContent;
    
            // 2. 检查这篇日记是否已被收藏，并更新按钮状态
            const existingFavorite = await db.favorites.where({ type: 'char_diary', 'content.id': diaryId }).first();
            favBtn.classList.toggle('active', !!existingFavorite);
    
            switchToCharScreen('char-diary-detail-screen');
        }
    }
    // ▼▼▼ 【全新】这是收藏/取消收藏日记的核心功能 ▼▼▼
    /**
     * 切换当前日记的收藏状态
     */
    async function toggleDiaryFavorite() {
        if (!activeDiaryForViewing || !activeCharacterId) return;
    
        const diary = activeDiaryForViewing;
        const char = state.chats[activeCharacterId];
        const favBtn = document.getElementById('favorite-diary-btn');
    
        // 再次检查是否已收藏
        const existingFavorite = await db.favorites.where({ type: 'char_diary', 'content.id': diary.id }).first();
    
        if (existingFavorite) {
            // 如果已收藏，则取消收藏
            await db.favorites.delete(existingFavorite.id);
            favBtn.classList.remove('active');
            await showCustomAlert('操作成功', '已取消收藏。');
        } else {
            // 如果未收藏，则执行收藏
            const newFavorite = {
                type: 'char_diary',
                // 将日记的完整内容，连同作者信息一起存入
                content: {
                    id: diary.id,
                    title: diary.title,
                    content: diary.content,
                    timestamp: diary.timestamp,
                    characterId: activeCharacterId,
                    characterName: char.name
                },
                timestamp: Date.now() // 收藏操作的时间
            };
            await db.favorites.add(newFavorite);
            favBtn.classList.add('active');
            await showCustomAlert('操作成功', '已成功收藏到“我的收藏”页面！');
        }
    }
    // ▲▲▲ 新增函数结束 ▲▲▲
        /**
         * 【全新】删除一篇日记
         * @param {number} diaryId - 要删除的日记的ID
         */
        async function deleteDiary(diaryId) {
            const confirmed = await showCustomConfirm('删除日记', '确定要删除这篇日记吗？', { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                const char = state.chats[activeCharacterId];
                char.diary = char.diary.filter(d => d.id !== diaryId);
                await db.chats.put(char);
                renderCharDiaryList();
            }
        }

        // ▲▲▲ 替换结束 ▲▲▲

/**
 * 【全新 V2.5 | 用户对话置顶修复版】渲染角色视角的QQ聊天列表
 */
async function renderCharSimulatedQQ() {
    const listEl = document.getElementById('char-chat-list');
    listEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    if (!char) return;

    // ▼▼▼ 核心修改 1：手动创建并置顶与用户的真实对话 ▼▼▼
    const userDisplayName = char.settings.myNickname || (state.qzoneSettings.nickname || '我');
    const lastRealMessage = char.history.filter(m => !m.isHidden).slice(-1)[0] || { content: '...' };
    
    // 提取最后一条消息的文本内容
    let lastMsgContent = '...';
    if (lastRealMessage) {
        if (typeof lastRealMessage.content === 'string') {
            lastMsgContent = lastRealMessage.content;
        } else if (Array.isArray(lastRealMessage.content) && lastRealMessage.content[0]?.type === 'image_url') {
            lastMsgContent = '[图片]';
        } else if (lastRealMessage.type) {
            const typeMap = { 'voice_message': '[语音]', 'transfer': '[转账]', 'ai_image': '[图片]' };
            lastMsgContent = typeMap[lastRealMessage.type] || `[${lastRealMessage.type}]`;
        }
    }

    // 获取用户头像和头像框
    const myAvatar = char.settings.myAvatar || defaultAvatar;
    const myFrame = char.settings.myAvatarFrame || '';
    let avatarHtml;
    if (myFrame) {
        avatarHtml = `<div class="avatar-group has-frame" style="width: 45px; height: 45px;"><div class="avatar-with-frame" style="width: 45px; height: 45px;"><img src="${myAvatar}" class="avatar-img" style="border-radius: 50%;"><img src="${myFrame}" class="avatar-frame"></div></div>`;
    } else {
        avatarHtml = `<div class="avatar-group" style="width: 45px; height: 45px;"><img src="${myAvatar}" class="avatar" style="border-radius: 50%; width: 45px; height: 45px;"></div>`;
    }

    const userChatItem = document.createElement('div');
    userChatItem.className = 'chat-list-item';
    // 使用一个特殊的索引-1来标记这是与用户的真实对话
    userChatItem.dataset.conversationIndex = "-1"; 
    userChatItem.innerHTML = `
        ${avatarHtml}
        <div class="info">
            <div class="name-line">
                <span class="name">${userDisplayName}</span>
            </div>
            <div class="last-msg">${String(lastMsgContent).substring(0, 20)}...</div>
        </div>
    `;
    listEl.appendChild(userChatItem);
    // ▲▲▲ 核心修改 1 结束 ▲▲▲

    const allNpcs = await db.npcs.toArray();
    const npcMap = new Map(allNpcs.map(npc => [npc.name, npc]));
    const conversations = char.simulatedConversations || [];

    if (conversations.length === 0 && !userChatItem) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">点击右上角刷新按钮，<br>看看TA最近都和谁聊天了吧！</p>';
        return;
    }

    conversations.forEach((convo, index) => {
        // ▼▼▼ 核心修改 2：跳过AI生成的与用户的对话，避免重复 ▼▼▼
        if (convo.type === 'private_user') {
            return;
        }
        // ▲▲▲ 核心修改 2 结束 ▲▲▲

        const item = document.createElement('div');
        item.className = 'chat-list-item';
        item.dataset.conversationIndex = index;

        let lastMessage, avatarHtml, displayName;
        
        if (convo.type === 'group') {
            displayName = convo.groupName + ` <span class="group-tag">群</span>`;
            lastMessage = convo.messages.slice(-1)[0] || { content: '...' };
            const groupAvatarPrompt = `logo, simple, flat design, for a group chat named '${convo.groupName}'`;
            const avatarUrl = state.globalSettings.enableAiDrawing ? `https://image.pollinations.ai/prompt/${encodeURIComponent(groupAvatarPrompt)}` : defaultGroupAvatar;
            avatarHtml = `<div class="avatar-group"><img src="${avatarUrl}" class="avatar" style="border-radius: 50%;"></div>`;
        
        } else { // 与NPC的私聊
            displayName = convo.participant.name;
            lastMessage = convo.messages.slice(-1)[0] || { content: '...' };
            const npcData = npcMap.get(displayName);
            let avatarUrl = (npcData && npcData.avatar) ? npcData.avatar : 
                (state.globalSettings.enableAiDrawing ? `https://image.pollinations.ai/prompt/${encodeURIComponent(convo.participant.avatar_prompt || 'anime person')}` : defaultGroupMemberAvatar);
            avatarHtml = `<div class="avatar-group"><img src="${avatarUrl}" class="avatar" style="border-radius: 50%;"></div>`;
        }

        let lastMsgContent = '...';
        if (lastMessage && lastMessage.content) {
            lastMsgContent = lastMessage.content;
        }
        
        item.innerHTML = `
            ${avatarHtml}
            <div class="info">
                <div class="name-line">
                    <span class="name">${displayName}</span>
                </div>
                <div class="last-msg">${String(lastMsgContent).substring(0, 20)}...</div>
            </div>
        `;
        listEl.appendChild(item);
    });
}
/**
 * 【全新 V4.0 | 指令简化终极修复版 + 移除用户模拟】当用户点击“重新生成”时，调用AI生成全新的模拟对话
 */
async function handleGenerateSimulatedQQ() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在根据“${chat.name}”的记忆和人设，生成全新的社交动态...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置好API信息。');
        return;
    }
    
    const allNpcs = await db.npcs.toArray();
    const associatedNpcs = allNpcs.filter(npc => 
        npc.associatedWith && npc.associatedWith.includes(activeCharacterId)
    );
    let npcContext = "# 你的社交圈 (绑定的NPC)\n";
    if (associatedNpcs.length > 0) {
        npcContext += "这是你认识的、关系密切的NPC。在生成对话时，你应该【优先】与他们互动。\n";
        associatedNpcs.forEach(npc => {
            npcContext += `- **姓名**: ${npc.name}\n  - **人设**: ${npc.persona}\n`;
        });
    } else {
        npcContext += "（你目前没有绑定的NPC伙伴，可以自由创造新的NPC。）\n";
    }

    const userDisplayNameForAI = state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname ? '用户' : state.qzoneSettings.nickname;
    const userNicknameInThisChat = chat.settings.myNickname || userDisplayNameForAI;
    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '无';
const maxMemory = chat.settings.maxMemory || 10;
    const recentHistoryWithUser =chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userNicknameInThisChat : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## 世界书《${book.name}》设定 (你可以将其中角色作为聊天对象):\n${book.content.filter(e=>e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
    const characterOriginalName = chat.originalName || chat.name;

    // ▼▼▼ 核心修改：这是一个全新的、更简洁、更严格的指令 ▼▼▼
    const systemPrompt = `
# 你的任务
你是一个虚拟社交生活模拟器，扮演角色“${chat.name}”。你的任务是虚构出【5到7段】TA最近的QQ聊天记录。

# 核心规则
1.  **【NPC唯一性铁律】**: 在你本次生成的所有对话中（包括私聊和群聊），每一个NPC的名字【必须是独一-无二的】。绝对禁止出现重名的NPC，禁止出现重复群聊。
2.  **【NPC来源】**: 你应该优先从“你的社交圈 (绑定的NPC)”和“世界书”中寻找角色作为聊天对象。如果不够，你也可以自由创造全新的NPC，对话内容要多样化，反映角色的生活。
3.  **关联性**: 对话内容应巧妙地反映角色的长期记忆、世界观，以及与用户互动可能带来的心情变化。
4.  **简洁性**: 每段对话的总长度应在8到15句之间。
# 格式铁律 (最高优先级)
- 你的回复【必须且只能】是一个JSON数组格式的字符串，以 \`[\` 开始，并以 \`]\` 结束。
- 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记。
- 数组中的每个元素都代表一段对话，且【必须】是以下两种格式之一：

// ▼▼▼ 核心修改：格式A（与用户的私聊）已被彻底移除 ▼▼▼

### 格式 A：与NPC的私聊
\`\`\`json
{
  "type": "private_npc",
  "participant": {
    "name": "NPC的名字",
    "avatar_prompt": "(仅当NPC是新创造时提供)一段用于生成头像的【英文】关键词, 风格为动漫/插画/二次元等, 禁止真人"
  },
  "messages": [
    {"sender": "${characterOriginalName}", "content": "对话内容1"},
    {"sender": "NPC的名字", "content": "对话内容2"}
  ]
}
\`\`\`

### 格式 B：群聊
\`\`\`json
{
  "type": "group",
  "groupName": "一个虚构的群名",
  "participants": [
    {"name": "NPC成员1", "avatar_prompt": "(仅当NPC是新创造时提供) 成员1头像【英文】关键词"},
    {"name": "NPC成员2", "avatar_prompt": "(仅当NPC是新创造时提供) 成员2头像【英文】关键词"}
  ],
  "messages": [
    {"sender": "${characterOriginalName}", "content": "我在群里说的话"},
    {"sender": "NPC成员1", "content": "成员1回复我"}
  ]
}
\`\`\`

# 角色与上下文
- **你的角色设定**: ${chat.settings.aiPersona}
- **你的长期记忆**: ${longTermMemoryContext}
- **世界观**: ${worldBookContext}
- **最近与用户的互动**: ${recentHistoryWithUser}
${npcContext}

现在，请严格按照格式铁律，生成聊天记录的JSON数组。`;
// ▲▲▲ 修改结束 ▲▲▲
            
    try {
        const messagesForApi = [{ role: 'user', content: "请根据你的设定，生成模拟聊天记录。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                })
            });

        if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedConversations;
        try {
            simulatedConversations = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`解析AI返回的JSON时出错: ${e.message}\n\nAI原始返回内容:\n${aiResponseContent}`);
        }
        
        chat.simulatedConversations = simulatedConversations;
        await db.chats.put(chat);
        
        await renderCharSimulatedQQ();

        // 触发主动消息的逻辑保持不变
        const hiddenMessage = {
            role: 'system',
            content: `[系统指令：你刚刚在自己的手机上活动了一番（和朋友聊天、逛群等）。现在请根据你的角色设定，主动给用户发一条消息，可以聊聊你刚才看到或聊到的趣事，或者仅仅是问候一下。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        await db.chats.put(chat);
        triggerAiResponse();
        
    } catch (error) {
        console.error("生成模拟聊天失败:", error);
        await showCustomAlert("生成失败", `无法生成模拟聊天记录，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
}

/**
 * 【全新 | V3.0 | 用户人设修复版】处理从CPhone QQ触发的、用于推进真实对话的AI请求
 */
async function handleContinueRealConversationFromCPhone() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;



    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            throw new Error('API未配置，无法生成对话。');
        }

        const maxMemory = parseInt(chat.settings.maxMemory) || 10;
        const historySlice = chat.history.slice(-maxMemory);
        const myNickname = chat.settings.myNickname || '我';

        // ==========================================================
        //            ★★★ 核心修改从这里开始 ★★★
        // ==========================================================

        // 1. 获取用户人设
        const userPersona = chat.settings.myPersona || '用户';

        // 2. 注入长期记忆 (Long-term Memory)
        const longTermMemoryContext = `# 长期记忆 (必须严格遵守)\n${
            chat.longTermMemory && chat.longTermMemory.length > 0 
                ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') 
                : '- (暂无)'
        }`;

        // 3. 注入世界书 (World Book)
        let worldBookContext = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                if (!worldBook || !Array.isArray(worldBook.content)) return '';
                const formattedEntries = worldBook.content
                    .filter(entry => entry.enabled !== false)
                    .map(entry => `\n### 条目: ${entry.comment || '无备注'}\n**内容:**\n${entry.content}`)
                    .join('');
                return formattedEntries ? `\n\n## 世界书: ${worldBook.name}\n${formattedEntries}` : '';
            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContext = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)\n${linkedContents}\n`;
            }
        }
// 【【【核心修改：在这里同时生成更细致的、多维度的总结】】】
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
        // 4. 更新 System Prompt 以包含用户人设
        const systemPrompt = `
# 你的核心任务
你正在扮演角色“${chat.originalName}”。用户刚刚在TA的手机（CPhone）上点击了一个按钮，希望你能继续你们之前的对话。你的任务是根据上下文，生成【3到5条】符合你人设的、简短的、连续的新回复。

# 输出格式铁律 (最高优先级)
- 你的回复【必须】是一个JSON数组，每个对象代表一条消息。
- 格式: \`[{"type": "text", "content": "第一句话"}, {"type": "text", "content": "第二句话"}, {"type": "sticker", "url": "...", "meaning": "..."}]\`
- 你可以自由组合使用 "text", "sticker", "ai_image", "voice_message" 等多种消息类型。

# 你的角色设定
${chat.settings.aiPersona}

// ▼▼▼ 核心修改：在这里添加了用户的人设 ▼▼▼
# 你的聊天对象（用户）的人设
${userPersona}
// ▲▲▲ 修改结束 ▲▲▲

# 供你参考的上下文
- **你的本名**: "${chat.originalName}"
- **用户的备注**: "${myNickname}"
${worldBookContext}
${longTermMemoryContext}
${multiLayeredSummaryContext} 
- **你们最后的对话**:
${historySlice.map(msg => `${msg.role === 'user' ? myNickname : chat.name}: ${String(msg.content)}`).join('\n')}

现在，请继续这场对话。
`;
        
        // ==========================================================
        //            ★★★ 核心修改到此结束 ★★★
        // ==========================================================

        const messagesPayload = historySlice.map(msg => ({
            role: msg.role,
            content: `${msg.role === 'user' ? myNickname : chat.name}: ${String(msg.content)}`
        }));
        
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesPayload],
                    temperature: state.globalSettings.apiTemperature || 0.8,
                })
            });

        if (!response.ok) {
            throw new Error(`API 请求失败: ${(await response.json()).error.message}`);
        }

        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const messagesArray = parseAiResponse(aiResponseContent);

        if (!messagesArray || messagesArray.length === 0) {
            throw new Error("AI返回了空内容。");
        }

        let newMessagesCount = 0;
        let messageTimestamp = Date.now();
        for (const msgData of messagesArray) {
            const baseMessage = { role: 'assistant', senderName: chat.originalName, timestamp: messageTimestamp++ };
            let aiMessage = null;
            switch(msgData.type) {
                case 'text':
                    aiMessage = { ...baseMessage, content: String(msgData.content || msgData.message) };
                    break;
                case 'sticker':
                    aiMessage = { ...baseMessage, type: 'sticker', content: msgData.url, meaning: msgData.meaning || '' };
                    break;
            }
            if (aiMessage) {
                chat.history.push(aiMessage);
                newMessagesCount++;
            }
        }
        
        if (newMessagesCount > 0) {
            chat.unreadCount = (chat.unreadCount || 0) + newMessagesCount;
        }
        
        await db.chats.put(chat);
        await renderChatList();

        if (newMessagesCount > 0) {
            showNotification(chat.id, `发来了 ${newMessagesCount} 条新消息`);
        }

    } catch (error) {
        console.error("从CPhone推进真实对话失败:", error);
        await showCustomAlert('操作失败', `无法生成新回复: ${error.message}`);
    }
}
/**
 * 【全新】为CPhone镜像聊天窗口加载更早的消息记录
 */
async function loadMoreMirroredMessages() {
    if (isLoadingMoreCphoneMessages || !activeCharacterId) return;
    isLoadingMoreCphoneMessages = true;

    const messagesContainer = document.getElementById('char-conversation-messages');
    const mainChar = state.chats[activeCharacterId];
    if (!mainChar) {
        isLoadingMoreCphoneMessages = false;
        return;
    }

    showLoader(messagesContainer, 'top'); // 在顶部显示加载动画
    const oldScrollHeight = messagesContainer.scrollHeight;

    // 模拟一点延迟，让加载动画更自然
    await new Promise(resolve => setTimeout(resolve, 500));

    const totalMessages = mainChar.history.length;
    const renderWindow = state.globalSettings.chatRenderWindow || 50;
    const nextSliceEnd = totalMessages - cphoneRenderedCount;
    const nextSliceStart = Math.max(0, nextSliceEnd - renderWindow);
    
    const messagesToPrepend = mainChar.history.slice(nextSliceStart, nextSliceEnd);

    // 渲染前先移除加载动画
    hideLoader(messagesContainer);

    if (messagesToPrepend.length === 0) {
        isLoadingMoreCphoneMessages = false;
        return;
    }

    // 从后往前遍历，逐条 prepending 到顶部
    for (const msg of messagesToPrepend.reverse()) {
        const mirroredMsg = { ...msg, role: msg.role === 'user' ? 'assistant' : 'user' };
        
        // 我们需要再次构建那个“反转视角”的临时对象
        const tempChatObjectForRendering = {
            id: 'temp_user_chat_mirror', isGroup: false, name: mainChar.name,
            settings: {
                ...mainChar.settings,
                myAvatar: mainChar.settings.aiAvatar,
                myAvatarFrame: mainChar.settings.aiAvatarFrame,
                aiAvatar: mainChar.settings.myAvatar,
                aiAvatarFrame: mainChar.settings.myAvatarFrame
            }
        };
        
        const messageEl = await createMessageElement(mirroredMsg, tempChatObjectForRendering);
        if (messageEl) {
            messagesContainer.prepend(messageEl);
        }
    }

    cphoneRenderedCount += messagesToPrepend.length;

    // 恢复滚动位置，防止跳动
    const newScrollHeight = messagesContainer.scrollHeight;
    messagesContainer.scrollTop = newScrollHeight - oldScrollHeight;

    isLoadingMoreCphoneMessages = false;
}
/**
 * 【全新 V2.5 | 交互优化 + 用户对话修复版】打开并显示指定的模拟聊天记录
 * @param {number} conversationIndex - 在数组中的索引, -1 代表与用户的真实对话
 */
async function openCharSimulatedConversation(conversationIndex) {
    const mainChar = state.chats[activeCharacterId];
    // ▼▼▼ 核心修改：处理 conversationIndex 为 -1 的情况 ▼▼▼
    if (conversationIndex === -1) {
        // 这是我们手动添加的“与用户对话”
        cphoneActiveConversationType = 'private_user';
        
        const titleEl = document.getElementById('char-conversation-partner-name');
        const bodyEl = document.getElementById('char-conversation-messages');
        const inputEl = document.getElementById('char-simulated-input');

        bodyEl.innerHTML = '';
        titleEl.textContent = mainChar.settings.myNickname || (state.qzoneSettings.nickname || '我');
        inputEl.placeholder = `与 ${mainChar.settings.myNickname || '我'} 的对话 (只读)`;
        
        cphoneRenderedCount = 0;
        isLoadingMoreCphoneMessages = false;
        
        const history = mainChar.history;
        const renderWindow = state.globalSettings.chatRenderWindow || 50;
        const initialMessages = history.slice(-renderWindow);

        const tempChatObjectForRendering = {
            id: 'temp_user_chat_mirror', isGroup: false, name: mainChar.name,
            settings: {
                ...mainChar.settings,
                myAvatar: mainChar.settings.aiAvatar,
                myAvatarFrame: mainChar.settings.aiAvatarFrame,
                aiAvatar: mainChar.settings.myAvatar,
                aiAvatarFrame: mainChar.settings.myAvatarFrame
            }
        };

        for (const msg of initialMessages) {
            const mirroredMsg = { ...msg, role: msg.role === 'user' ? 'assistant' : 'user' };
            const bubbleElement = await createMessageElement(mirroredMsg, tempChatObjectForRendering);
            if (bubbleElement) {
                bodyEl.appendChild(bubbleElement);
            }
        }
        cphoneRenderedCount = initialMessages.length;

        switchToCharScreen('char-qq-conversation-screen');
        setTimeout(() => bodyEl.scrollTop = bodyEl.scrollHeight, 0);

        return; // 处理完后直接返回
    }
    // ▲▲▲ 核心修改结束 ▲▲▲

    // --- 后续处理AI生成对话的逻辑保持不变 ---
    const conversation = mainChar.simulatedConversations[conversationIndex];
    if (!conversation) return;
    cphoneActiveConversationType = conversation.type;

    const allNpcs = await db.npcs.toArray();
    const npcMap = new Map(allNpcs.map(npc => [npc.name, npc]));

    const titleEl = document.getElementById('char-conversation-partner-name');
    const bodyEl = document.getElementById('char-conversation-messages');
    const inputEl = document.getElementById('char-simulated-input');

    bodyEl.innerHTML = '';
    bodyEl.dataset.theme = mainChar.settings.theme || 'default';
    const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
    bodyEl.style.backgroundColor = isDarkMode ? '#000000' : '#f0f2f5';

    let tempChatObjectForRendering;
    
    if (conversation.type === 'group') {
        titleEl.textContent = `${conversation.groupName} (${conversation.participants.length + 1})`;
        inputEl.placeholder = `在 ${conversation.groupName} 中聊天`;
        tempChatObjectForRendering = {
            id: 'temp_group_chat', isGroup: true,
            name: conversation.groupName,
            originalName: mainChar.originalName,
            members: conversation.participants.map(p => {
                const npcData = npcMap.get(p.name);
                let avatarUrl = (npcData && npcData.avatar) ? npcData.avatar : 
                    (state.globalSettings.enableAiDrawing 
                        ? `https://image.pollinations.ai/prompt/${encodeURIComponent(p.avatar_prompt || 'anime person')}`
                        : defaultGroupMemberAvatar);
                return { originalName: p.name, groupNickname: p.name, avatar: avatarUrl };
            }),
            settings: {
                ...mainChar.settings,
                myNickname: mainChar.name,
                myAvatar: mainChar.settings.aiAvatar,
                myAvatarFrame: mainChar.settings.aiAvatarFrame,
            }
        };
        for (const msg of conversation.messages) {
            const isFromMainChar = msg.sender === (mainChar.originalName || mainChar.name);
            const role = isFromMainChar ? 'user' : 'assistant';
            const tempMessageObject = { role: role, senderName: msg.sender, content: msg.content, timestamp: Date.now() + Math.random() };
            const bubbleElement = await createMessageElement(tempMessageObject, tempChatObjectForRendering);
            if (bubbleElement) {
                bodyEl.appendChild(bubbleElement);
            }
        }
    } else { // 与NPC的私聊
        titleEl.textContent = conversation.participant.name;
        inputEl.placeholder = `与 ${conversation.participant.name} 的对话`;
        const npcData = npcMap.get(conversation.participant.name);
        const npcAvatarUrl = (npcData && npcData.avatar) ? npcData.avatar : 
            (state.globalSettings.enableAiDrawing
                ? `https://image.pollinations.ai/prompt/${encodeURIComponent(conversation.participant.avatar_prompt || 'anime person')}`
                : defaultGroupMemberAvatar);
        tempChatObjectForRendering = {
            id: 'temp_npc_chat', isGroup: false,
            name: conversation.participant.name,
            originalName: mainChar.originalName,
            settings: {
                ...mainChar.settings,
                myAvatar: mainChar.settings.aiAvatar,
                myAvatarFrame: mainChar.settings.aiAvatarFrame,
                aiAvatar: npcAvatarUrl,
                aiAvatarFrame: ''
            }
        };
        for (const msg of conversation.messages) {
            const isFromMainChar = msg.sender === (mainChar.originalName || mainChar.name);
            const role = isFromMainChar ? 'user' : 'assistant';
            const tempMessageObject = { role: role, senderName: msg.sender, content: msg.content, timestamp: Date.now() + Math.random() };
            const bubbleElement = await createMessageElement(tempMessageObject, tempChatObjectForRendering);
            if (bubbleElement) {
                bodyEl.appendChild(bubbleElement);
            }
        }
    }

    switchToCharScreen('char-qq-conversation-screen');
    bodyEl.scrollTop = bodyEl.scrollHeight;
}
/**
 * 【全新】关闭模拟聊天记录弹窗
 */
function closeSimulatedTranscriptModal() {
    document.getElementById('char-qq-transcript-modal').classList.remove('visible');
}

// ▲▲▲ 全新JS代码粘贴结束 ▲▲▲
/**
 * 【全新 | V3.0 AI指令强化版】当用户点击“重新生成”时，调用AI生成模拟相册内容
 */
async function handleGenerateSimulatedAlbum() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];

    if (!chat) {
        await showCustomAlert("操作失败", "无法找到当前角色的数据。");
        return;
    }

    await showCustomAlert("请稍候...", `正在请求“${chat.name}”回忆TA的相册照片...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置好API信息。');
        return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;
    
    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '无';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## 世界书《${book.name}》设定:\n${book.content.filter(e=>e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
// 【【【核心修改：在这里同时生成更细致的、多维度的总结】】】
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
    // ▼▼▼ 核心修改1：强化AI指令 ▼▼▼
    const systemPrompt = `
# 你的任务
你是一个虚拟生活模拟器。你的任务是扮演角色“${chat.name}”，并根据其人设、记忆和最近的互动，构思出【8到10张】TA最近可能会拍摄或珍藏在手机相册里的照片。

# 核心规则
1.  **创造性与合理性**: 照片内容必须完全符合角色的性格、爱好、职业和生活环境。
2.  **多样性**: 照片主题要丰富，可以包括自拍、风景、食物、宠物、朋友合影、工作场景等。
3.  **格式铁律 (最高优先级)**: 
    - 你的回复【必须且只能】是一个JSON数组格式的字符串。
    - 你的回复必须以 \`[\` 开始，并以 \`]\` 结束。
    - 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记 (如 \`\`\`json)。
    - 数组中的每个元素都是一个对象，代表一张照片，格式【必须】如下:
    \`\`\`json
    [
      {
        "description": "这是照片背后的故事或角色的心情日记，必须使用第一人称“我”来写。",
        "image_prompt": "一段用于生成这张照片的、详细的【英文】关键词。"
      }
    ]
    \`\`\`
    - **【image_prompt 绝对禁止】**: 绝对禁止包含任何中文字符、句子、特殊符号、或任何可能涉及敏感（NSFW）、暴力、血腥、政治的内容！也禁止真人！
    - **【image_prompt 必须是】**: 必须是纯英文的、用逗号分隔的【关键词组合】 (e.g., "1boy, solo, basketball jersey, in locker room, smiling, selfie")。
    - **【画风指令】**: 在 prompt 的末尾，总是加上画风指令，例如： \`best quality, masterpiece, anime style, cinematic lighting\`

# 供你参考的上下文
- **你的角色设定**: ${chat.settings.aiPersona}
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **你最近和“${userDisplayNameForAI}”的对话摘要**:
${recentHistoryWithUser}

现在，请开始生成这组照片的描述和绘画指令。`;
    // ▲▲▲ 修改结束 ▲▲▲

    try {
        const messagesForApi = [{ role: 'user', content: "请根据你的设定，生成你的相册内容。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        // ▼▼▼ 核心修改2：移除不兼容的 response_format 参数 ▼▼▼
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                    // response_format: { "type": "json_object" }  <-- 此行已被删除
                })
            });
        // ▲▲▲ 修改结束 ▲▲▲

        if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        // ▼▼▼ 核心修改3：使用更强大的容错解析逻辑 ▼▼▼
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedAlbumData;
        try {
            simulatedAlbumData = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`解析AI返回的JSON时出错: ${e.message}\n\nAI原始返回内容:\n${aiResponseContent}`);
        }
        // ▲▲▲ 修改结束 ▲▲▲
        
        chat.simulatedAlbum = simulatedAlbumData;
        await db.chats.put(chat);
        
        await renderCharAlbum();
        
    } catch (error) {
        console.error("生成模拟相册失败:", error);
        await showCustomAlert("生成失败", `无法生成模拟相册，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
}


        // ▼▼▼ 【V3.3 | 逻辑终极修复版】请用这个全新的函数，完整替换旧的 renderCharAlbum 函数 ▼▼▼
        /**
         * 【全新 | V3.2 终极防空窗+生图开关+描述显示版】渲染角色相册
         */
        async function renderCharAlbum() {
            const gridEl = document.getElementById('char-album-grid');
            gridEl.innerHTML = '';
            if (!activeCharacterId) return;
            const char = state.chats[activeCharacterId];
        
            const photos = char.simulatedAlbum || [];
        
            if (photos.length === 0) {
                gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TA的相册还是空的，<br>点击右上角刷新按钮生成一些照片吧！</p>';
                return;
            }
        
            const fallbackImageUrl = `https://i.postimg.cc/KYr2qRCK/1.jpg`;

            photos.forEach(photo => {
                const item = document.createElement('div');
                item.className = 'char-photo-item';
                item.dataset.description = photo.description;
                gridEl.appendChild(item);

                // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
                //            这就是本次修复的核心所在！
                //  我们现在确保了两种情况的逻辑是完全独立的。
                // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
                
                // 1. 检查全局的生图开关是否开启
                if (state.globalSettings.enableAiDrawing) {
                    // --- 如果开关【开启】，则只执行生图相关的逻辑 ---
                    item.style.backgroundColor = '#e9ecef';
                    const containsNonEnglish = /[^\x00-\x7F]/.test(photo.image_prompt);
                    const isValidPrompt = photo.image_prompt && photo.image_prompt.trim() && !containsNonEnglish;
                    const finalPrompt = isValidPrompt ? photo.image_prompt : 'a beautiful scenery, anime style, cinematic lighting';
                    const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}`;
                    
                    const img = new Image();
                    img.onload = function() { item.style.backgroundImage = `url(${this.src})`; };
                    img.onerror = function() { item.style.backgroundImage = `url(${fallbackImageUrl})`; };
                    img.src = imageUrl;

                } else {
                    // --- 如果开关【关闭】，则只执行显示文字描述的逻辑 ---
                    item.style.backgroundColor = '#f0f2f5';
                    item.style.border = '1px solid #e0e0e0';
                    
                    const descriptionEl = document.createElement('p');
                    descriptionEl.className = 'char-photo-description';
                    descriptionEl.textContent = photo.description || '(这张照片没有描述)';
                    
                    item.appendChild(descriptionEl);
                }
            });
        }
        // ▲▲▲ 替换结束 ▲▲▲
/**
 * 【全新 | V2.2 | JSON解析终极修复版】当用户点击“重新生成”时，调用AI生成模拟浏览器历史
 */
async function handleGenerateBrowserHistory() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在模拟“${chat.name}”的网上冲浪足迹...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('API未配置，无法生成内容。');
        return;
    }
    
    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '无';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## 世界书《${book.name}》设定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
// 【【【核心修改：在这里同时生成更细致的、多维度的总结】】】
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
    // ▼▼▼ 核心修改1：强化AI指令 ▼▼▼
    const systemPrompt = `
# 你的任务
你是一个虚拟生活模拟器。你的任务是扮演角色“${chat.name}”，并根据其人设、记忆和最近的互动，虚构出【10到20条】TA最近的浏览器搜索/浏览记录。

# 核心规则
1.  **创造性与合理性**: 记录必须完全符合角色的性格、爱好、职业和生活环境。
2.  **多样性**: 记录类型要丰富，可以是帖子、文章、新闻、问答等。
3.  **【格式 (最高优先级)】**: 
    - 你的回复【必须且只能】是一个JSON数组格式的字符串。
    - 你的回复必须以 \`[\` 开始，并以 \`]\` 结束。
    - 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记 (如 \`\`\`json)。
    - 数组中的每个元素都代表一条浏览记录，并且【必须】使用以下格式:
    \`\`\`json
    [
      {
        "type": "text",
        "title": "一个引人注目的文章或搜索标题",
        "url": "一个虚构的、看起来很真实的网址",
        "content": "一篇200-400字的、详细的文章或帖子正文，支持换行符\\n。"
      }
    ]
    \`\`\`
    
    **【绝对禁止】**: 你的回复中【绝对不能】包含 "type": "image" 的对象。所有记录都必须是文字内容。

# 供你参考的上下文
- **你的角色设定**: ${chat.settings.aiPersona}
- **你的长期记忆**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **你最近和“${userDisplayNameForAI}”的对话摘要**:
${recentHistoryWithUser}

现在，请开始生成这组【纯文本】的浏览记录。`;
    // ▲▲▲ 修改结束 ▲▲▲

    try {
        const messagesForApi = [{ role: 'user', content: "请根据你的设定，生成你的浏览器记录。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        // ▼▼▼ 核心修改2：移除不兼容的 response_format 参数 ▼▼▼
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                    // response_format: { "type": "json_object" } <-- 此行已被删除
                })
            });
        // ▲▲▲ 修改结束 ▲▲▲

        if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        // ▼▼▼ 核心修改3：使用更强大的容错解析逻辑 ▼▼▼
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedHistory;
        try {
            simulatedHistory = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`解析AI返回的JSON时出错: ${e.message}\n\nAI原始返回内容:\n${aiResponseContent}`);
        }
        // ▲▲▲ 修改结束 ▲▲▲
        
        chat.simulatedBrowserHistory = simulatedHistory;
        await db.chats.put(chat);
        
        await renderCharBrowserHistory();
        
    } catch (error) {
        console.error("生成模拟浏览器历史失败:", error);
        await showCustomAlert("生成失败", `无法生成浏览记录，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
}
        // ▲▲▲ 替换结束 ▲▲▲
/**
 * 【全新 | V2.0 动态数据版】渲染角色的浏览器历史记录列表
 */
function renderCharBrowserHistory() {
    const listEl = document.getElementById('char-browser-history');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    const history = char.simulatedBrowserHistory || [];

    if (history.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TA的浏览器空空如也，<br>点击右上角刷新按钮生成一些记录吧！</p>';
        return;
    }

    history.forEach((item, index) => {
        const entryEl = document.createElement('div');
        entryEl.className = 'char-browser-item';
        entryEl.innerHTML = `
            <div class="title">${item.title}</div>
            <div class="url">${item.url}</div>
        `;
        // 为每个列表项绑定点击事件，并传入它在数组中的索引
        entryEl.addEventListener('click', () => openCharArticle(index));
        listEl.appendChild(entryEl);
    });
}

/**
 * 【全新】打开文章查看页面
 * @param {number} index - 被点击的历史记录在数组中的索引
 */
function openCharArticle(index) {
    const char = state.chats[activeCharacterId];
    const articleData = char.simulatedBrowserHistory[index];
    if (!articleData) return;
    
    // 渲染文章内容并切换到文章屏幕
    renderCharArticle(articleData);
    switchToCharScreen('char-browser-article-screen');
}

        /**
         * 【全新】根据文章数据渲染文章查看页面
         * @param {object} articleData - 单条历史记录的数据对象
         */
        function renderCharArticle(articleData) {
            const titleEl = document.getElementById('char-article-title');
            const contentEl = document.getElementById('char-article-content');
            
            titleEl.textContent = articleData.title;
            contentEl.innerHTML = ''; 


            // 我们不再检查生图开关，而是直接判断记录类型。
            // 如果是图片类型，就显示标题作为内容。
            if (articleData.type === 'image') {
                contentEl.innerHTML = `<p class="char-browser-image-description">${articleData.title || '(无标题)'}</p>`;
            } else {
                // 如果是文本类型，正常显示内容。
                contentEl.innerHTML = `<p>${(articleData.content || '内容加载失败...').replace(/\n/g, '</p><p>')}</p>`;
            }
            // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        }
        // ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 全新JS代码粘贴结束 ▲▲▲
/**
 * 【全新 | V3.2 | 终极网络与逻辑修复版】请用这个全新的函数，完整替换旧的 handleGenerateTaobaoHistory 函数
 */
async function handleGenerateTaobaoHistory() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在模拟“${chat.name}”的购物习惯...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置好API信息。');
        return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '无';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## 世界书《${book.name}》设定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
// 【【【核心修改：在这里同时生成更细致的、多维度的总结】】】
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
    // ▼▼▼ 核心修改1：强化AI指令，确保在没有强制JSON模式下也能稳定输出 ▼▼▼
    const systemPrompt = `
# 你的任务
你是一个虚拟生活模拟器。你的任务是扮演角色“${chat.name}”，并根据其人设、记忆和最近的互动，虚构出【12到20条】TA最近的淘宝购物记录。

# 核心规则
1.  **合理性**: 购买记录必须完全符合角色的性格、爱好和经济状况。
2.  **格式铁律 (最高优先级)**: 你的回复【必须且只能】是一个【单一的JSON对象】。你的回复必须以 \`{\` 开始，并以 \`}\` 结束。【绝对禁止】在JSON对象前后添加任何多余的文字、解释或 markdown 标记 (如 \`\`\`json)。
    \`\`\`json
    {
      "purchases": [
        {
          "itemName": "一个具体、生动的商品名称",
          "price": 128.80,
          "status": "已签收",
          "reason": "这是角色购买这件商品的内心独白或理由，必须使用第一人称“我”来写。",
          "image_prompt": "一段用于生成这张商品图片的、详细的【英文】关键词, 风格为 realistic product photo, high quality, on a clean white background"
        }
      ]
    }
    \`\`\`
    - **purchases**: 一个包含12到15个商品对象的数组。
    - **status (订单状态)**: 只能从 "已签收", "待发货", "运输中", "待评价" 中选择。

# 供你参考的上下文
- **你的角色设定**: ${chat.settings.aiPersona}
- **你的长期记忆**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **你最近和“${userDisplayNameForAI}”的对话摘要**:
${recentHistoryWithUser}

现在，请生成包含购买记录的JSON对象。`;
    // ▲▲▲ 修改结束 ▲▲▲

    try {
        const messagesForApi = [{ role: 'user', content: "请根据你的设定，生成你的淘宝购买记录。" }];
        
        let isGemini = proxyUrl.includes('generativelanguage.googleapis.com');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        // ▼▼▼ 核心修改2：移除不兼容的 response_format 参数 ▼▼▼
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                    // response_format: { "type": "json_object" }  <-- 这行已被删除
                })
            });
        // ▲▲▲ 修改结束 ▲▲▲

        if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        // ▼▼▼ 核心修改3：使用更强大的容错解析逻辑 ▼▼▼
        const jsonMatch = aiResponseContent.match(/({[\s\S]*})/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AI返回的内容中未找到有效的JSON对象。原始返回: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedTaobaoData;
        try {
            simulatedTaobaoData = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`解析AI返回的JSON时出错: ${e.message}\n\nAI原始返回内容:\n${aiResponseContent}`);
        }
        // ▲▲▲ 修改结束 ▲▲▲
        
        chat.simulatedTaobaoHistory = simulatedTaobaoData;
        await db.chats.put(chat);
        
        await renderCharTaobao();
        
    } catch (error) {
        console.error("生成模拟淘宝记录失败:", error);
        await showCustomAlert("生成失败", `无法生成购物记录，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
}

/**
 * 【全新】打开并渲染角色的钱包页面
 */
function openCharWallet() {
    renderCharWallet();
    switchToCharScreen('char-wallet-screen');
}

/**
 * 【全新】渲染角色的钱包页面
 */
function renderCharWallet() {
    const contentEl = document.getElementById('char-wallet-content');
    contentEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    const history = char.simulatedTaobaoHistory || [];

    // 1. 计算总支出
    const totalExpenses = history.reduce((sum, item) => sum + (item.price || 0), 0);

    // 2. 创建并显示总支出卡片
    const summaryCard = document.createElement('div');
    summaryCard.style.cssText = `
        background-color: #fff;
        padding: 20px;
        border-radius: 12px;
        text-align: center;
        margin-bottom: 20px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.06);
    `;
    summaryCard.innerHTML = `
        <p style="color: #8a8a8a; margin: 0 0 10px 0;">本月总支出</p>
        <p style="font-size: 32px; font-weight: 600; color: #1f1f1f; margin: 0;">¥${totalExpenses.toFixed(2)}</p>
    `;
    contentEl.appendChild(summaryCard);

    // 3. 创建并显示支出明细
    const detailsTitle = document.createElement('h3');
    detailsTitle.textContent = '支出明细';
    detailsTitle.style.cssText = `font-size: 16px; color: #555; margin-bottom: 10px;`;
    contentEl.appendChild(detailsTitle);

    if (history.length === 0) {
        contentEl.innerHTML += '<p style="text-align:center; color: var(--text-secondary);">暂无支出记录。</p>';
        return;
    }

    history.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid #f0f0f0;
        `;
        itemEl.innerHTML = `
            <div>
                <p style="font-weight: 500; margin: 0 0 4px 0;">${item.itemName}</p>
                <p style="font-size: 12px; color: #8a8a8a; margin: 0;">${item.status}</p>
            </div>
            <div style="font-weight: 600; font-size: 16px; color: #ff5722;">- ¥${(item.price || 0).toFixed(2)}</div>
        `;
        contentEl.appendChild(itemEl);
    });
}
// ▲▲▲ 全新JS代码粘贴结束 ▲▲▲
        // ▼▼▼ 【V3.0 | 最终修复版】请用这个全新的函数，完整替换旧的 handleGenerateSimulatedMemos 函数 ▼▼▼
/**
 * 【V3.0 | 最终修复版】当用户点击“重新生成”时，调用AI生成模拟备忘录
 */
async function handleGenerateSimulatedMemos() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在请求“${chat.name}”分享TA的备忘录...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置好API信息。');
        return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '无';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## 世界书《${book.name}》设定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
// 【【【核心修改：在这里同时生成更细致的、多维度的总结】】】
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
    // ▼▼▼ 核心修改1：强化AI指令 ▼▼▼
    const systemPrompt = `
# 你的任务
你是一个虚拟生活模拟器。你的任务是扮演角色“${chat.name}”，并根据其人设、记忆和最近的互动，虚构出【12到20条】TA最近可能会写在手机备忘录里的内容。

# 核心规则
1.  **创造性与合理性**: 备忘录内容必须完全符合角色的性格、爱好、职业和生活环境。可以是购物清单、待办事项、灵感片段、一些随笔和感悟、草稿等。
2.  **格式铁律 (最高优先级)**: 
    - 你的回复【必须且只能】是一个JSON数组格式的字符串。
    - 你的回复必须以 \`[\` 开始，并以 \`]\` 结束。
    - 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记 (如 \`\`\`json)。
    - 数组中的每个元素都是一个对象，代表一条备忘录，格式【必须】如下:
    \`\`\`json
    [
      {
        "title": "备忘录的标题，例如：购物清单 或 周末计划",
        "content": "备忘录的详细内容，必须支持换行符\\n。"
      }
    ]
    \`\`\`

# 供你参考的上下文
- **你的角色设定**: ${chat.settings.aiPersona}
- **你的长期记忆**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext}
- **你最近和“${userDisplayNameForAI}”的对话摘要**:
${recentHistoryWithUser}

现在，请开始生成这组备忘录。`;
    // ▲▲▲ 修改结束 ▲▲▲

    try {
        const messagesForApi = [{ role: 'user', content: "请根据你的设定，生成你的备忘录内容。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        // ▼▼▼ 核心修改2：移除不兼容的 response_format 参数 ▼▼▼
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                    // 同样移除 response_format
                })
            });
        // ▲▲▲ 修改结束 ▲▲▲

        if (!response.ok) {
             const errorData = await response.json().catch(() => null);
             const errorMessage = errorData?.error?.message || response.statusText;
             throw new Error(`API 错误: ${response.status} - ${errorMessage}`);
        }
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        // ▼▼▼ 核心修改3：使用更强大的容错解析逻辑 ▼▼▼
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedMemos;
        try {
            simulatedMemos = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`解析AI返回的JSON时出错: ${e.message}\n\nAI原始返回内容:\n${aiResponseContent}`);
        }
        // ▲▲▲ 修改结束 ▲▲▲
        
        if (!Array.isArray(simulatedMemos)) {
            throw new Error(`AI返回的数据不是一个数组。原始返回: ${JSON.stringify(simulatedMemos)}`);
        }

        chat.memos = simulatedMemos.map(memo => ({
            id: Date.now() + Math.random(),
            title: memo.title,
            content: memo.content
        }));
        
        await db.chats.put(chat);
        await renderCharMemoList();
        
    } catch (error) {
        console.error("生成模拟备忘录失败:", error);
        await showCustomAlert("生成失败", `无法生成备忘录，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
}
        // ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 【全新V2.0 | 最终修复版】请用这个全新的函数，完整替换旧的 handleGenerateAmapHistory 函数 ▼▼▼
/**
 * 【全新 | V2.0 最终修复版】当用户点击“重新生成”时，调用AI生成模拟足迹
 */
async function handleGenerateAmapHistory() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在生成“${chat.name}”的出行足迹...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('API未配置，无法生成内容。');
        return;
    }
    
    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;
    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '无';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## 世界书《${book.name}》设定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
    // ▼▼▼ 核心修改1：强化AI指令 ▼▼▼
    const systemPrompt = `
# 你的任务
你是一个虚拟生活模拟器。你的任务是扮演角色“${chat.name}”，并根据其人设、记忆和最近的互动，虚构出【12到20条】TA最近的“高德地图”出行足迹。

# 核心规则
1.  **【时间 (最高优先级)】**:
    -   今天的日期是 **${new Date().toISOString()}**。
    -   你生成的【所有】足迹的 \`timestamp\` 字段，【必须】是今天或今天以前的日期。
    -   【绝对禁止】生成任何未来的日期！
    -   请生成一个看起来像是过去几周内的、时间【从新到旧】排列的足迹列表。
2.  **创造性与合理性**: 足迹必须完全符合角色的性格、爱好、职业和生活环境。
3.  **多样性**: 地点类型要丰富，可以包括餐厅、商场、公园、公司、朋友家等。
4.  **【格式铁律 (最高优先级)】**: 
    - 你的回复【必须且只能】是一个JSON数组格式的字符串。
    - 你的回复必须以 \`[\` 开始，并以 \`]\` 结束。
    - 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记 (如 \`\`\`json)。
    - 数组中的每个元素都是一个对象，代表一条足迹，格式【必须】如下:
    \`\`\`json
    [
      {
        "locationName": "一个具体、生动的地点名称",
        "address": "一个虚构但看起来很真实的详细地址",
        "comment": "这是角色对这次出行或这个地点的内心独白或评论，必须使用第一人称“我”来写。",
        "image_prompt": "(可选)一段用于生成这张地点照片的、详细的【英文】关键词, 风格为 realistic photo, high quality",
        "timestamp": "符合 ISO 8601 格式的日期时间字符串 (例如: '2025-09-25T18:30:00Z')"
      }
    ]
    \`\`\`
    - **重要**: 大约有【三分之一】的足迹需要包含 \`image_prompt\` 字段来生成一张照片。
    - **图片**: image_prompt 生成的图片【绝对禁止包含真人】。如果地点是室内，可以生成空无一人的场景；如果是室外，可以只有风景或建筑。

# 供你参考的上下文
- **你的角色设定**: ${chat.settings.aiPersona}
- **你的长期记忆**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext}
- **你最近和“${userDisplayNameForAI}”的对话摘要**:
${recentHistoryWithUser}

现在，请开始生成这组足迹记录。`;
    // ▲▲▲ 修改结束 ▲▲▲

    try {
        const messagesForApi = [{ role: 'user', content: "请根据你的设定，生成你的高德地图足迹。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        // ▼▼▼ 核心修改2：移除不兼容的 response_format 参数 ▼▼▼
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                    // response_format: { "type": "json_object" } <-- 此行已被删除
                })
            });
        // ▲▲▲ 修改结束 ▲▲▲

        if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        // ▼▼▼ 核心修改3：使用更强大的容错解析逻辑 ▼▼▼
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedAmapData;
        try {
            simulatedAmapData = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`解析AI返回的JSON时出错: ${e.message}\n\nAI原始返回内容:\n${aiResponseContent}`);
        }
        // ▲▲▲ 修改结束 ▲▲▲
        
        chat.simulatedAmapHistory = simulatedAmapData;
        await db.chats.put(chat);
        
        await renderCharAmap();
        
    } catch (error) {
        console.error("生成模拟足迹失败:", error);
        await showCustomAlert("生成失败", `无法生成足迹，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
}

        /**
         * 【全新 | V2.0 最终修复版】渲染角色的高德地图足迹列表
         */
        function renderCharAmap() {
            const listEl = document.getElementById('char-amap-list');
            listEl.innerHTML = '';
            if (!activeCharacterId) return;

            const char = state.chats[activeCharacterId];
            const history = char.simulatedAmapHistory || [];

            if (history.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有留下任何足迹，<br>点击右上角刷新按钮生成一些记录吧！</p>';
                return;
            }

            // ▼▼▼ 核心修复3：在这里使用 AI 提供的时间戳 ▼▼▼
            history.forEach(item => {
                const itemEl = document.createElement('div');
                itemEl.className = 'char-amap-item';
                
                let photoHtml = '';
                if (item.image_prompt) {
                    const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(item.image_prompt)}`;
                    photoHtml = `<div class="amap-item-photo" style="background-image: url('${imageUrl}')" data-comment="${item.comment}"></div>`;
                }

                // 使用我们之前创建的 formatTimeAgo 函数来格式化时间
                const timeAgo = item.timestamp ? formatTimeAgo(new Date(item.timestamp).getTime()) : '某个时间';

                itemEl.innerHTML = `
                    <div class="amap-item-header">
                        <div class="amap-item-icon">📍</div>
                        <div class="amap-item-info">
                            <div class="amap-item-title">${item.locationName}</div>
                            <div class="amap-item-address">${item.address}</div>
                        </div>
                    </div>
                    <div class="amap-item-body">
                        <div class="amap-item-comment">${item.comment.replace(/\n/g, '<br>')}</div>
                        ${photoHtml}
                    </div>
                    <div class="amap-item-footer">${timeAgo}</div>
                `;
                listEl.appendChild(itemEl);
            });
            // ▲▲▲ 修复结束 ▲▲▲
        }

// ▲▲▲ 全新JS代码粘贴结束 ▲▲▲
/**
 * 【全新 V3.0 | 支持AI绘图】当用户点击“重新生成”时，调用AI生成模拟App使用记录
 */
async function handleGenerateAppUsage() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在分析“${chat.name}”的手机使用习惯...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('API未配置，无法生成内容。');
        return;
    }
    
    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '无';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## 世界书《${book.name}》设定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
    // ▼▼▼ 核心修改1：强化AI指令 ▼▼▼
    const systemPrompt = `
# 你的任务
你是一个虚拟生活模拟器。你的任务是扮演角色“${chat.name}”，并根据其人设、记忆和最近的互动，虚构出TA最近一天的【手机App屏幕使用时间】记录，总共约20条。

# 核心规则
1.  **创造性与多样性**: 生成的App列表【不必局限于】Cphone主屏幕上已有的App。你可以自由地虚构TA可能使用的其他App，例如 Instagram, Twitter, 各种游戏 (如：原神, 王者荣耀), 视频App (如：抖音, YouTube), 学习或工作软件等，这能更好地体现角色的隐藏兴趣和生活习惯。
2.  **合理性**: 使用时长和App类型必须完全符合角色的性格、爱好、职业和生活环境。
3.  **格式铁律 (最高优先级)**: 
    - 你的回复【必须且只能】是一个JSON数组格式的字符串。
    - 你的回复必须以 \`[\` 开始，并以 \`]\` 结束。
    - 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记 (如 \`\`\`json)。
    - 数组中的每个元素都是一个对象，代表一个App的使用记录，格式【必须】如下:
    \`\`\`json
    [
      {
        "appName": "App的名称 (例如: 微信, 微博, 原神)",
        "usageTimeMinutes": 125,
        "category": "App的分类 (例如: 社交, 游戏, 影音, 工具, 阅读, 购物)",
        "image_prompt": "一段用于生成这个App【图标】的、简洁的【英文】关键词。风格必须是 modern app icon, flat design, simple, clean background"
      }
    ]
    \`\`\`

# 供你参考的上下文
- **你的角色设定**: ${chat.settings.aiPersona}
- **你的长期记忆**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext}
- **你最近和“${userDisplayNameForAI}”的对话摘要**:
${recentHistoryWithUser}

现在，请开始生成这组App使用记录。`;
    // ▲▲▲ 修改结束 ▲▲▲

    try {
        const messagesForApi = [{ role: 'user', content: "请根据你的设定，生成你的App使用记录。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        // ▼▼▼ 核心修改2：移除不兼容的 response_format 参数 ▼▼▼
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                    // response_format: { "type": "json_object" } <-- 此行已被删除
                })
            });
        // ▲▲▲ 修改结束 ▲▲▲

        if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');
        
        const simulatedUsageData = JSON.parse(cleanedJson);
        
        chat.simulatedAppUsage = simulatedUsageData;
        await db.chats.put(chat);
        
        await renderCharAppUsage();
        
    } catch (error) {
        console.error("生成模拟App使用记录失败:", error);
        await showCustomAlert("生成失败", `无法生成记录，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
}

        /**
         * 【全新 V2.0 | AI绘图版】渲染角色的App使用记录列表
         */
        function renderCharAppUsage() {
            const listEl = document.getElementById('char-usage-list');
            listEl.innerHTML = '';
            if (!activeCharacterId) return;

            const char = state.chats[activeCharacterId];
            const usageData = (char.simulatedAppUsage || []).sort((a, b) => b.usageTimeMinutes - a.usageTimeMinutes);

            if (usageData.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有任何使用记录，<br>点击右上角刷新按钮生成一些吧！</p>';
                return;
            }

            usageData.forEach(item => {
                const itemEl = document.createElement('div');
                itemEl.className = 'char-usage-item';
                
                const hours = Math.floor(item.usageTimeMinutes / 60);
                const minutes = item.usageTimeMinutes % 60;
                let timeString = '';
                if (hours > 0) timeString += `${hours}小时`;
                if (minutes > 0) timeString += `${minutes}分钟`;
                if (!timeString) timeString = '小于1分钟';

                // ▼▼▼ 【核心修改：动态生成图标URL】 ▼▼▼
                // 1. 如果AI提供了image_prompt，就使用它；否则，提供一个通用的备用指令
                const prompt = item.image_prompt || `modern app icon for ${item.appName}, flat design, simple`;
                // 2. 使用AI绘画API生成图标
                const iconUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(prompt)}`;
                // ▲▲▲ 修改结束 ▲▲▲

                itemEl.innerHTML = `
                    <img src="${iconUrl}" class="usage-item-icon">
                    <div class="usage-item-info">
                        <div class="usage-item-name">${item.appName}</div>
                        <div class="usage-item-category">${item.category}</div>
                    </div>
                    <div class="usage-item-time">${timeString}</div>
                `;
                listEl.appendChild(itemEl);
            });
        }
// ▲▲▲ 全新JS代码粘贴结束 ▲▲▲
/**
 * 【全新 V2.0 | 最终兼容版】当用户点击“重新生成”时，调用AI生成模拟歌单
 */
async function handleGenerateSimulatedMusic() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在请求“${chat.name}”分享TA的私人歌单...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置好API信息。');
        return;
    }
    
    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '无';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## 世界书《${book.name}》设定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');

    // ▼▼▼ 核心修改1：强化AI指令 ▼▼▼
    const systemPrompt = `
# 你的任务
你是一个虚拟音乐品味模拟器。你的任务是扮演角色“${chat.name}”，并根据其人设、记忆和最近的互动，挑选出【14到18首】最能代表TA此刻心情或品味的歌曲。

# 核心规则
1.  **创造性与合理性**: 歌单必须完全符合角色的性格、爱好和生活背景。
2.  **多样性**: 歌曲风格可以多样，但必须逻辑自洽。
3.  **格式铁律 (最高优先级)**: 
    - 你的回复【必须且只能】是一个JSON数组格式的字符串。
    - 你的回复必须以 \`[\` 开始，并以 \`]\` 结束。
    - 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记 (如 \`\`\`json)。
    - 数组中的每个元素都是一个对象，代表一首歌，格式【必须】如下:
    \`\`\`json
    [
      {
        "songName": "歌曲的准确名称",
        "artistName": "歌曲的准确艺术家/歌手名"
      }
    ]
    \`\`\`

# 供你参考的上下文
- **你的角色设定**: ${chat.settings.aiPersona}
- **你的长期记忆**:
${longTermMemoryContext}
${worldBookContext}
- **你最近和“${userDisplayNameForAI}”的对话摘要**:
${recentHistoryWithUser}

现在，请生成这份歌单。`;
    // ▲▲▲ 修改结束 ▲▲▲

    try {
        const messagesForApi = [{ role: 'user', content: "请根据你的设定，生成你的歌单。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        // ▼▼▼ 核心修改2：此函数之前没有 response_format，无需删除，但我们确保其他部分是健壮的 ▼▼▼
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 1.0,
                })
            });
        // ▲▲▲ 修改结束 ▲▲▲

        if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');
        const songPicks = JSON.parse(cleanedJson);

        await showCustomAlert("请稍候...", `歌单已生成，正在从网络获取 ${songPicks.length} 首歌曲的详细信息...`);

        const songDetailPromises = songPicks.map(async (pick) => {
            let searchResults = await searchNeteaseMusic(pick.songName, pick.artistName);
            if (!searchResults || searchResults.length === 0) {
                searchResults = await searchTencentMusic(pick.songName);
            }
            if (searchResults.length > 0) {
                return getPlayableSongDetails(searchResults[0]);
            }
            console.warn(`所有音乐源都未能找到歌曲：“${pick.songName} - ${pick.artistName}”`);
            return null;
        });

        const fullSongObjects = (await Promise.all(songDetailPromises)).filter(Boolean);

        chat.simulatedMusicPlaylist = fullSongObjects;
        await db.chats.put(chat);
        
        await renderCharMusicScreen();
        
    } catch (error) {
        console.error("生成模拟歌单失败:", error);
        await showCustomAlert("生成失败", `无法生成歌单，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
}

/**
 * 【全新】渲染角色的网易云音乐列表
 */
function renderCharMusicScreen() {
    const listEl = document.getElementById('char-music-list');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    const playlist = char.simulatedMusicPlaylist || [];

    if (playlist.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TA的歌单还是空的，<br>点击右上角刷新按钮生成一些歌曲吧！</p>';
        return;
    }

    playlist.forEach((track, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'char-music-item';
        itemEl.innerHTML = `
            <img src="${track.cover}" class="music-item-cover">
            <div class="music-item-info">
                <div class="music-item-name">${track.name}</div>
                <div class="music-item-artist">${track.artist}</div>
            </div>
        `;
        // 为每个列表项绑定点击事件，并传入完整的歌曲对象
        itemEl.addEventListener('click', () => playCharSong(track));
        listEl.appendChild(itemEl);
    });
}

/* ▼▼▼ 请用这整块【全新 V3.0 JS代码】，完整替换所有旧的 char-player-modal 相关JS ▼▼▼ */

let charPlayerState = {
    currentPlaylist: [],
    currentIndex: -1,
    isPlaying: false,
    playMode: 'order', // 'order', 'random', 'single'
    lrcUpdateInterval: null,
    // 【核心新增】
    parsedLyrics: [],
    currentLyricIndex: -1
};

/**
 * 播放Cphone中的歌曲 (V3.0 - 适配新UI和歌词)
 * @param {object} songObject - 包含所有信息的完整歌曲对象
 */
function playCharSong(songObject) {
    const player = document.getElementById('char-audio-player');
    const modal = document.getElementById('char-music-player-modal');
    
    if (charPlayerState.lrcUpdateInterval) clearInterval(charPlayerState.lrcUpdateInterval);
    player.pause();
    
    const songIndex = charPlayerState.currentPlaylist.findIndex(s => s.src === songObject.src);
    if (songIndex > -1) {
        charPlayerState.currentIndex = songIndex;
    } else {
        charPlayerState.currentPlaylist = [songObject];
        charPlayerState.currentIndex = 0;
    }

    // 更新UI
    document.getElementById('char-music-player-title').textContent = songObject.name;
    document.getElementById('char-music-artist').textContent = songObject.artist;
    document.getElementById('char-music-cover').src = songObject.cover;
    
    // 【核心新增】解析歌词
    charPlayerState.parsedLyrics = parseLRC(songObject.lrcContent || "");
    renderCharLyrics(); // 渲染歌词

    // 设置音频源并播放
    if (songObject.isLocal) {
        const blob = new Blob([songObject.src], { type: songObject.fileType || 'audio/mpeg' });
        player.src = URL.createObjectURL(blob);
    } else {
        player.src = songObject.src;
    }
    player.play().catch(e => console.error("音频播放失败:", e));

    player.onloadedmetadata = () => {
        document.getElementById('char-music-total-time').textContent = formatMusicTime(player.duration);
        charPlayerState.lrcUpdateInterval = setInterval(updateCharMusicProgress, 500);
    };

    modal.classList.add('visible');
}

/**
 * 关闭Cphone的音乐播放器 (V3.0)
 */
function closeCharMusicPlayer() {
    const modal = document.getElementById('char-music-player-modal');
    const player = document.getElementById('char-audio-player');
    
    if (charPlayerState.lrcUpdateInterval) clearInterval(charPlayerState.lrcUpdateInterval);
    player.pause();
    player.src = ''; 
    modal.classList.remove('visible');
    charPlayerState.isPlaying = false;
    document.getElementById('char-vinyl-container').classList.remove('spinning');
}

/**
 * 更新播放器进度条、时间和歌词 (核心修改)
 */
function updateCharMusicProgress() {
    const player = document.getElementById('char-audio-player');
    if (!player.duration) return;

    const currentTime = player.currentTime;
    const duration = player.duration;
    document.getElementById('char-music-progress-fill').style.width = `${(currentTime / duration) * 100}%`;
    document.getElementById('char-music-current-time').textContent = formatMusicTime(currentTime);

    // 【核心新增】调用歌词更新函数
    updateCharActiveLyric(currentTime);
}


/**
 * 【全新】渲染角色播放器的歌词列表
 */
function renderCharLyrics() {
    const lyricsContainer = document.getElementById('char-music-lyrics');
    lyricsContainer.innerHTML = '';
    charPlayerState.currentLyricIndex = -1; // 重置索引
    if (!charPlayerState.parsedLyrics || charPlayerState.parsedLyrics.length === 0) {
        lyricsContainer.innerHTML = '<p>♪ 暂无歌词 ♪</p>';
        return;
    }
    charPlayerState.parsedLyrics.forEach((line, index) => {
        const p = document.createElement('p');
        p.textContent = line.text;
        p.dataset.index = index;
        lyricsContainer.appendChild(p);
    });
}

/**
 * 【全新】更新当前高亮的歌词
 */
function updateCharActiveLyric(currentTime) {
    const lyrics = charPlayerState.parsedLyrics;
    if (lyrics.length === 0) return;

    let newLyricIndex = -1;
    for (let i = 0; i < lyrics.length; i++) {
        if (currentTime >= lyrics[i].time) {
            newLyricIndex = i;
        } else {
            break;
        }
    }
    if (newLyricIndex === charPlayerState.currentLyricIndex) return;
    charPlayerState.currentLyricIndex = newLyricIndex;
    
    // 更新UI
    const lyricsContainer = document.getElementById('char-music-lyrics');
    const lines = lyricsContainer.querySelectorAll('p');
    lines.forEach(line => line.classList.remove('active'));
    
    if (newLyricIndex > -1) {
        const activeLine = lyricsContainer.querySelector(`p[data-index="${newLyricIndex}"]`);
        if (activeLine) {
            activeLine.classList.add('active');
            // 计算滚动位置，使当前行居中
            const offset = (lyricsContainer.clientHeight / 2) - activeLine.offsetTop - (activeLine.offsetHeight / 2);
            lines.forEach(line => {
                line.style.transform = `translateY(${offset}px)`;
            });
        }
    }
}


/**
 * 播放下一首歌
 */
function playNextCharSong() {
    if (charPlayerState.currentPlaylist.length === 0) return;
    let nextIndex;
    switch(charPlayerState.playMode) {
        case 'random':
            nextIndex = Math.floor(Math.random() * charPlayerState.currentPlaylist.length);
            break;
        case 'single':
            // 单曲循环，重新播放当前歌曲
            playCharSong(charPlayerState.currentPlaylist[charPlayerState.currentIndex]);
            return;
        case 'order':
        default:
            nextIndex = (charPlayerState.currentIndex + 1) % charPlayerState.currentPlaylist.length;
            break;
    }
    playCharSong(charPlayerState.currentPlaylist[nextIndex]);
}

/**
 * 播放上一首歌
 */
function playPrevCharSong() {
    if (charPlayerState.currentPlaylist.length === 0) return;
    const newIndex = (charPlayerState.currentIndex - 1 + charPlayerState.currentPlaylist.length) % charPlayerState.currentPlaylist.length;
    playCharSong(charPlayerState.currentPlaylist[newIndex]);
}

/**
 * 切换播放模式
 */
function changeCharPlayMode() {
    const modes = ['order', 'random', 'single'];
    const currentModeIndex = modes.indexOf(charPlayerState.playMode);
    charPlayerState.playMode = modes[(currentModeIndex + 1) % modes.length];
    document.getElementById('char-music-mode-btn').textContent = {'order': '顺序', 'random': '随机', 'single': '单曲'}[charPlayerState.playMode];
}


/**
 * 【总入口】为新播放器的所有按钮和事件绑定功能
 */
function setupCharPlayerControls() {
    const player = document.getElementById('char-audio-player');
    const playBtn = document.getElementById('char-music-play-pause-btn');
    const vinyl = document.getElementById('char-vinyl-container');

    playBtn.addEventListener('click', () => {
        if (player.paused) {
            if(charPlayerState.currentIndex > -1) player.play();
        } else {
            player.pause();
        }
    });
    
    player.onplay = () => {
        playBtn.innerHTML = `<svg viewBox="0 0 24 24" width="32" height="32" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>`;
        vinyl.classList.add('spinning');
        charPlayerState.isPlaying = true;
    };
    player.onpause = () => {
        playBtn.innerHTML = `<svg viewBox="0 0 24 24" width="32" height="32" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg>`;
        vinyl.classList.remove('spinning');
        charPlayerState.isPlaying = false;
    };
    player.onended = () => {
        vinyl.classList.remove('spinning');
        charPlayerState.isPlaying = false;
        playNextCharSong();
    };

    document.getElementById('char-music-prev-btn').addEventListener('click', playPrevCharSong);
    document.getElementById('char-music-next-btn').addEventListener('click', playNextCharSong);
    document.getElementById('char-music-mode-btn').addEventListener('click', changeCharPlayMode);

    document.getElementById('char-music-progress-bar').addEventListener('click', (e) => {
        if (!player.duration) return;
        const bar = e.currentTarget;
        const clickX = e.offsetX;
        player.currentTime = (clickX / bar.clientWidth) * player.duration;
    });
}
/* ▲▲▲ JS代码替换结束 ▲▲▲ */
// ▼▼▼ 【全新 | V3.2 | 双重身份验证版】请用这个新版本替换旧的 renderDoubanScreen 函数 ▼▼▼
/**
 * 【总入口】渲染豆瓣小组屏幕
 */
async function renderDoubanScreen() {
    const listEl = document.getElementById('douban-posts-list');
    listEl.innerHTML = '';
    
    const posts = await db.doubanPosts.orderBy('timestamp').reverse().toArray();

    if (posts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里空空如也，<br>点击右上角刷新按钮，看看大家都在聊什么吧！</p>';
        return;
    }

    posts.forEach(post => {
        let avatarUrl;
        
        // --- 核心修改：全新的“双重验证”头像查找逻辑 ---
        // 1. 优先通过“身份证”(authorOriginalName)查找
        const authorChatByOriginalName = post.authorOriginalName 
            ? Object.values(state.chats).find(c => !c.isGroup && c.name === post.authorOriginalName) 
            : null;

        if (authorChatByOriginalName) {
            // 如果通过“身份证”找到了，就用这个角色的真实头像
            avatarUrl = authorChatByOriginalName.settings.aiAvatar;
        } else {
            // 2. 如果没有“身份证”，再尝试用“外号”(authorName)去花名册里找（兼容旧数据）
            const authorChatByName = Object.values(state.chats).find(c => !c.isGroup && c.name === post.authorName);
            if (authorChatByName) {
                avatarUrl = authorChatByName.settings.aiAvatar;
            } else if (post.authorAvatarPrompt) {
                // 3. 如果都找不到，说明这是一个路人NPC，就用AI给的“头像咒语”去画一张新脸
                avatarUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(post.authorAvatarPrompt)}`;
            } else {
                // 4. 如果连“头像咒语”都没有，才使用最终的丑陋占位图
                avatarUrl = defaultAvatar;
            }
        }
        // --- 修复结束 ---

        const itemEl = document.createElement('div');
        itemEl.className = 'douban-post-item';
        itemEl.onclick = () => openDoubanPostDetail(post.id);

        itemEl.innerHTML = `
            <div class="douban-post-header">
                <img src="${avatarUrl}" class="douban-post-avatar">
                <div class="douban-author-info">
                    <div class="douban-author-name">${post.authorName}</div>
                    <div class="douban-group-name">来自 ${post.groupName}</div>
                </div>
            </div>
            <div class="douban-post-title">${post.postTitle}</div>
            <div class="douban-post-content">${post.content.replace(/\n/g, '<br>')}</div>
            <div class="douban-post-footer">
                 <div class="douban-post-actions">
                    <span><svg viewBox="0 0 1024 1024"><path d="M170.666667 170.666667h128v682.666666h-128zM426.666667 170.666667h170.666666v682.666666h-170.666666zM725.333333 170.666667h128v682.666666h-128z"></path></svg> ${post.likesCount}</span>
                    <span><svg viewBox="0 0 1024 1024"><path d="M853.333333 85.333333H170.666667c-46.933333 0-85.333333 38.4-85.333334 85.333334v512c0 46.933333 38.4 85.333333 85.333334 85.333333h512l170.666667 170.666667V170.666667c0-46.933333-38.4-85.333333-85.333334-85.333334z m-42.666666 554.666667H170.666667V170.666667h640v469.333333zM256 384h512v85.333333H256V384z m0-170.666667h512v85.333334H256v-85.333334z"></path></svg> ${post.commentsCount}</span>
                </div>
                <span class="douban-post-timestamp">${formatTimeAgo(post.timestamp)}</span>
            </div>
        `;
        listEl.appendChild(itemEl);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【请用这个全新版本】完整替换旧的 handleGenerateDoubanPosts 函数 ▼▼▼
async function handleGenerateDoubanPosts() {
    const activeCharacterIds = state.globalSettings.doubanActiveCharacterIds || [];

    if (activeCharacterIds.length === 0) {
        await showCustomAlert("请先选择角色", "请点击右上角的“角色选择”按钮，选择至少一个参与豆瓣互动的角色。");
        return;
    }

    await showCustomAlert("请稍候...", `正在为您选择的 ${activeCharacterIds.length} 位角色生成豆瓣动态...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置好API信息。');
        return;
    }

    const allLinkedBookIds = new Set();
    activeCharacterIds.forEach(charId => {
        const c = state.chats[charId];
        if (c && c.settings.linkedWorldBookIds) {
            c.settings.linkedWorldBookIds.forEach(bookId => allLinkedBookIds.add(bookId));
        }
    });

    let sharedWorldBookContext = '';
    if (allLinkedBookIds.size > 0) {
        sharedWorldBookContext += '\n\n# 统一世界观设定 (以下设定适用于所有参与角色)\n';
        allLinkedBookIds.forEach(bookId => {
            const book = state.worldBooks.find(wb => wb.id === bookId);
            if (book) {
                const enabledEntries = book.content
                    .filter(e => e.enabled !== false)
                    .map(e => `- ${e.content}`)
                    .join('\n');
                if (enabledEntries) {
                    sharedWorldBookContext += `\n## 来自《${book.name}》:\n${enabledEntries}`;
                }
            }
        });
    }
    
    const doubanWorldBook = state.worldBooks.find(wb => wb.name === '豆瓣设定');
    let doubanSettingContext = '';
    let npcCharacters = [];
    if (doubanWorldBook) {
        doubanWorldBook.content.forEach(entry => {
            if (entry.comment.includes('小组风格')) {
                doubanSettingContext += `\n# 豆瓣社区风格设定 (来自世界书)\n${entry.content}`;
            }
            if (entry.comment.includes('NPC人设')) {
                const lines = entry.content.split('\n');
                lines.forEach(line => {
                    const match = line.match(/- \*\*昵称\*\*:\s*(.*?)\s*\*\*人设\*\*:\s*(.*)/);
                    if (match) {
                        npcCharacters.push({ name: match[1].trim(), persona: match[2].trim() });
                    }
                });
            }
        });
    }
    
    const userNickname = state.qzoneSettings.nickname || '我';
    const userPersona = activeCharacterIds.length > 0 && state.chats[activeCharacterIds[0]] 
        ? state.chats[activeCharacterIds[0]].settings.myPersona 
        : '(未设置)';

    let charactersContext = '';
    activeCharacterIds.forEach(charId => {
        const c = state.chats[charId];
        if (c) {
            const longTermMemory = c.longTermMemory && c.longTermMemory.length > 0 ? c.longTermMemory.map(m => m.content).join('; ') : '无';
            const recentHistory = c.history.slice(-10).map(msg => 
                `${msg.role === 'user' ? userNickname : c.name}: ${String(msg.content).substring(0, 30)}...`
            ).join('\n');

            charactersContext += `
<character>
  <name>${c.name}</name>
  <persona>${c.settings.aiPersona}</persona>
  <memory>${longTermMemory}</memory>
  <recent_dialogue_with_user>${recentHistory}</recent_dialogue_with_user>
</character>
`;
        }
    });
    npcCharacters.forEach(npc => {
        charactersContext += `
<character>
  <name>${npc.name}</name>
  <persona>${npc.persona}</persona>
</character>
`;
    });
    
    const now = new Date();
    const currentTimeString = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
    const minPosts = state.globalSettings.doubanMinPosts || 12;
    const maxPosts = state.globalSettings.doubanMaxPosts || 20;
    const systemPrompt = `
# 你的任务
你是一个虚拟社区内容生成器。你的任务是根据下面提供的【统一角色列表】，虚构出【${minPosts}到${maxPosts}篇】他们最近可能会在各种豆瓣小组中发布的帖子和评论。

# 核心规则
1.  **【时间感知】**:
    -   你【必须】意识到当前是 **${currentTimeString}**。
    -   你的帖子和评论内容【必须】自然地体现出对【当前真实时间】的感知。
2.  **【禁止扮演用户 (最最最高优先级！！！)】**:
    -   用户的昵称是“${userNickname}”。
    -   你【绝对不能】生成 authorName 或 commenter 字段为 “${userNickname}” 的帖子或评论。你的任务是扮演【除了用户以外】的所有角色。
3.  **【身份 (最高优先级！)】**: 
    -   \`authorName\`: 你可以为主要角色起一个符合情景的、临时的【发帖昵称】，也可以直接使用他们的本名。
    -   \`authorOriginalName\`: 如果发帖者是【主要角色】，你【必须】在这里填上TA在角色列表里的【原始备注名】，这是程序的“身份证”。
    -   如果发帖者是【路人NPC】，则【省略】\`authorOriginalName\` 字段。
4.  **【作者平衡】**: 帖子的作者【必须】从下面的 \`<character>\` 列表中【均匀地、多样化地】选择。你【必须】确保帖子列表中【至少有 70% 的帖子是由路人NPC发布的】，以营造一个真实的社区氛围。
    - "comments": 一个包含【7到12条】评论的数组。评论者可以是路人，也可以是角色列表中的其他角色，以体现互动性。
5.  **【角色扮演】**: 帖子的作者和内容【必须】深度结合该角色的<persona>, <memory>, 和 <worldview>。
6.  **【“豆瓣味”内容风格指南】**: 帖子风格必须多样化且充满生活气息！你需要生成包括但不限于：情感树洞、生活吐槽、吃瓜八卦、兴趣分享、无用良品等各种类型的帖子。
7.  **【头像生成 (最高优先级！)】**:
    -   为每一个【首次出现】的路人NPC（无论是发帖还是评论），你都【必须】为其添加一个 \`avatar_prompt\` 字段。
    -   这个字段的内容是用于生成该NPC头像的、简洁的【英文】关键词。
    -   不同的NPC【必须】有不同的头像指令，以确保他们的头像是独一无二的。
8.  **【头像一致性 (至关重要！)】**:
    -   如果一个路人NPC在同一个帖子中多次出现（例如，既是发帖人又是评论者，或多次评论），你【必须】为TA的所有出现都使用【完全相同】的 \`avatar_prompt\`。这至关重要！
9.  **【格式 (最高优先级)】**: 
    - 你的回复【必须且只能】是一个JSON数组格式的字符串。
    - 你的回复必须以 \`[\` 开始，并以 \`]\` 结束。
    - 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记 (如 \`\`\`json)。
    - 数组中的每个元素都是一篇帖子，格式【必须】如下:
    \`\`\`json
    [
      {
        "groupName": "一个生动有趣的小组名称",
        "postTitle": "一个引人-注目的帖子标题",
        "authorName": "发帖角色的【备注名】",
        "authorOriginalName": "(仅当发帖者是主要角色时【必须】提供) TA的原始备注名",
        "authorAvatarPrompt": "(仅当发帖者是路人NPC时【必须】提供) 一段用于生成该NPC头像的【英文】关键词。风格为 anime style, simple background",
        "content": "帖子的详细正文，必须支持换行符\\n。",
        "likesCount": 152,
        "commentsCount": 38,
        "comments": [
            { "commenter": "路人甲", "text": "这是一个路人评论。", "avatar_prompt": "cute cat avatar, simple, flat" },
            { "commenter": "另一个角色名", "commenterOriginalName": "(如果评论者是主要角色，必须提供其本名)", "text": "这是一个来自其他角色的互动评论。" }
        ]
      }
    ]
    \`\`\`
    - **comments**: 
        -   评论者可以是路人，也可以是角色列表中的其他角色。评论区【必须】体现出互动性。
        -   【评论身份】: 如果评论者是【主要角色】，你【必须】为其添加 \`commenterOriginalName\` 字段，并填入其本名。如果是路人NPC，则省略此字段。

# 供你参考的上下文
${doubanSettingContext}
${sharedWorldBookContext}

# 当前情景
- **当前真实时间**: ${currentTimeString}

# 【你的聊天对象（用户）的身份档案】
- **昵称**: ${userNickname}
- **人设**: ${userPersona}

# 统一角色列表 (你扮演的角色 + 路人NPC)
${charactersContext}

现在，请严格遵守所有规则，特别是【时间感知】和【禁止扮演用户】的铁律，开始生成这组生动、多样且充满“豆瓣味”的小组帖子。`;

    try {
        const messagesForApi = [{ role: 'user', content: "请根据角色列表，生成豆瓣小组帖子。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 1.0,
                })
            });

        if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        const jsonMatch = aiResponseContent.match(/\[[\s\S]*\]/);
        
        if (!jsonMatch) {
            throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
        }
        
        const simulatedPosts = JSON.parse(jsonMatch[0]);
        await db.doubanPosts.clear();
        await db.doubanPosts.bulkAdd(simulatedPosts.map(p => ({...p, timestamp: Date.now() - Math.random() * 100000})));
        
        await renderDoubanScreen();
        
    } catch (error) {
        console.error("生成豆瓣帖子失败:", error);
        await showCustomAlert("生成失败", `无法生成内容，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲
/**
 * 【V3.5 | 最终头像统一修复版】打开并渲染指定的帖子详情页
 * @param {number} postId - 帖子的ID
 */
async function openDoubanPostDetail(postId) {
    showScreen('douban-post-detail-screen');
    activeDoubanPostId = postId;
    const post = await db.doubanPosts.get(postId);
    if (!post) {
        showScreen('douban-screen');
        return;
    }

    document.getElementById('douban-post-detail-title').textContent = '帖子详情';

    // (这部分渲染帖子作者信息的逻辑是正确的，我们先在这里获取到正确的作者头像)
    let authorAvatar = defaultAvatar;
    let authorDisplayName = post.authorName; 

    const authorChatByOriginalName = post.authorOriginalName
        ? Object.values(state.chats).find(c => !c.isGroup && c.originalName === post.authorOriginalName)
        : null;

    if (authorChatByOriginalName) {
        authorAvatar = authorChatByOriginalName.settings.aiAvatar;
    } else {
        const authorChatByName = Object.values(state.chats).find(c => !c.isGroup && c.name === post.authorName);
        if (authorChatByName) {
            authorAvatar = authorChatByName.settings.aiAvatar;
        } else if (post.authorAvatarPrompt) {
            authorAvatar = `https://image.pollinations.ai/prompt/${encodeURIComponent(post.authorAvatarPrompt)}`;
        }
    }
    
    // (填充帖子正文部分的信息)
    document.getElementById('douban-detail-avatar').src = authorAvatar;
    document.getElementById('douban-detail-author').textContent = authorDisplayName;
    document.getElementById('douban-detail-group').textContent = `来自 ${post.groupName}`;
    document.getElementById('douban-detail-post-title').textContent = post.postTitle;
    document.getElementById('douban-detail-content').innerHTML = post.content.replace(/\n/g, '<br>');
    document.getElementById('douban-my-comment-avatar').src = state.qzoneSettings.avatar;
    document.getElementById('douban-comment-input').value = '';

    const commentsListEl = document.getElementById('douban-detail-comments-list');
    commentsListEl.innerHTML = '';

    // ▼▼▼ 【【【核心修复就在这里！】】】 ▼▼▼
    if (post.comments && post.comments.length > 0) {
        // 1. 【全新】创建一个Map来“记住”每个评论者的头像，确保一致性
        const commenterAvatarMap = new Map();

        post.comments.forEach(comment => {
            let commenterAvatar = defaultAvatar; // 默认头像
            const myNickname = state.qzoneSettings.nickname || '我';
            const commenterName = comment.commenter; // 获取当前评论者的名字

            // 2. 【智能查找】检查是否已经为这个评论者确定过头像了
            if (commenterAvatarMap.has(commenterName)) {
                // 如果已经记住了，直接使用记住的头像，跳过所有查找！
                commenterAvatar = commenterAvatarMap.get(commenterName);
            } else {
                // 如果是第一次遇到这个评论者，就执行完整的查找逻辑
                if (commenterName === myNickname) {
                    commenterAvatar = state.qzoneSettings.avatar;
                }
                else if (commenterName === post.authorName) {
                    commenterAvatar = authorAvatar;
                }
                else {
                    const commenterChatByOriginalName = comment.commenterOriginalName
                        ? Object.values(state.chats).find(c => !c.isGroup && c.originalName === comment.commenterOriginalName)
                        : null;
                    
                    if (commenterChatByOriginalName) {
                        commenterAvatar = commenterChatByOriginalName.settings.aiAvatar;
                    } else {
                        const commenterChatByName = Object.values(state.chats).find(c => !c.isGroup && c.name === commenterName);
                        if (commenterChatByName) {
                            commenterAvatar = commenterChatByName.settings.aiAvatar;
                        } else if (comment.avatar_prompt) {
                            commenterAvatar = `https://image.pollinations.ai/prompt/${encodeURIComponent(comment.avatar_prompt)}`;
                        }
                    }
                }
                // 3. 【关键】将找到的头像存入Map中，以便下次直接使用
                commenterAvatarMap.set(commenterName, commenterAvatar);
            }
            
            // (后续的HTML渲染逻辑保持不变)
            const commentEl = document.createElement('div');
            commentEl.className = 'douban-comment-item';
            commentEl.innerHTML = `
                <img src="${commenterAvatar}" class="douban-comment-avatar">
                <div class="douban-comment-body">
                    <div class="douban-comment-author">${commenterName}</div>
                    <div class="douban-comment-text">${comment.text.replace(/\n/g, '<br>')}</div>
                </div>
            `;
            commentsListEl.appendChild(commentEl);
        });
    } else {
        commentsListEl.innerHTML = '<p style="color: var(--text-secondary); font-size: 13px;">还没有回应</p>';
    }
    // ▲▲▲ 【【【修复结束】】】 ▲▲▲
    
    const contentWrapper = document.getElementById('douban-detail-content-wrapper');
    if(contentWrapper) contentWrapper.scrollTop = 0;
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新 | AI互动增强版】请用这个新版本替换旧的 handleSendDoubanComment 函数 ▼▼▼
/**
 * 【全新】处理用户发送豆瓣评论的逻辑，并触发AI互动
 */
async function handleSendDoubanComment() {
    if (!activeDoubanPostId) return;

    const input = document.getElementById('douban-comment-input');
    const commentText = input.value.trim();
    if (!commentText) return;

    const post = await db.doubanPosts.get(activeDoubanPostId);
    if (!post) return;

    if (!post.comments) {
        post.comments = [];
    }
    
    const myNickname = state.qzoneSettings.nickname || '我';
    
    post.comments.push({
        commenter: myNickname,
        text: commentText
    });
    post.commentsCount++;

    await db.doubanPosts.put(post);
    input.value = '';
    
    // 【核心修改1】发送评论后，立刻重新渲染详情页，保证您的新评论能显示出来
    await openDoubanPostDetail(activeDoubanPostId);


}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【请用这个全新版本】完整替换旧的 handleDoubanWaitReply 函数 ▼▼▼
async function handleDoubanWaitReply() {
    if (!activeDoubanPostId) return;

    const postId = activeDoubanPostId;
    const post = await db.doubanPosts.get(postId);
    if (!post) return;

    const lastComment = post.comments && post.comments.slice(-1)[0];
    if (!lastComment) {
        alert("还没有任何评论，无法等待回复。");
        return;
    }

    await showCustomAlert("请稍候...", "正在请求AI角色们加入讨论...");

    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            throw new Error('API未配置，无法生成内容。');
        }

        const userNickname = state.qzoneSettings.nickname || '我';
        const userPersona = state.chats[Object.keys(state.chats)[0]]?.settings.myPersona || '(未设置)';
        
        const existingNpcs = new Map();
        if (post.comments) {
            post.comments.forEach(comment => {
                const isMainCharacter = (state.globalSettings.doubanActiveCharacterIds || []).some(id => state.chats[id]?.name === comment.commenter);
                if (!isMainCharacter && comment.avatar_prompt) {
                    existingNpcs.set(comment.commenter, comment.avatar_prompt);
                }
            });
        }
        
        let existingNpcContext = "# 已有路人NPC头像指令 (必须遵守！)\n";
        if (existingNpcs.size > 0) {
            existingNpcContext += "如果以下任何一位NPC再次评论，你【必须】使用我们提供的、完全相同的`avatar_prompt`，以保持头像一致性。\n";
            existingNpcs.forEach((prompt, name) => {
                existingNpcContext += `- **${name}**: "${prompt}"\n`;
            });
        } else {
            existingNpcContext += "（当前帖子还没有路人NPC发表评论。）\n";
        }

        const doubanWorldBook = state.worldBooks.find(wb => wb.name === '豆瓣设定');
        let npcCharacters = [];
        if (doubanWorldBook) {
            doubanWorldBook.content.forEach(entry => {
                if (entry.comment.includes('NPC人设')) {
                    const lines = entry.content.split('\n');
                    lines.forEach(line => {
                        const match = line.match(/- \*\*昵称\*\*:\s*(.*?)\s*\*\*人设\*\*:\s*(.*)/);
                        if (match) {
                            npcCharacters.push({ name: match[1].trim(), persona: match[2].trim() });
                        }
                    });
                }
            });
        }
        
        let charactersContext = '';
        const activeCharacterIds = state.globalSettings.doubanActiveCharacterIds || [];
        activeCharacterIds.forEach(charId => {
            const c = state.chats[charId];
            if (c) {
                const longTermMemory = c.longTermMemory && c.longTermMemory.length > 0 ? c.longTermMemory.map(m => m.content).join('; ') : '无';
                const recentHistory = c.history.slice(-10).map(msg => `${msg.role === 'user' ? userNickname : c.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
                charactersContext += `\n- ${c.name}: ${c.settings.aiPersona.substring(0,50)}... [记忆: ${longTermMemory}] [最近对话: ${recentHistory}]`;
            }
        });
        npcCharacters.forEach(npc => {
            charactersContext += `\n- ${npc.name}: ${npc.persona}`;
        });

        // ▲▲▲ 核心修改1：在这里也获取当前时间 ▲▲▲
        const now = new Date();
        const currentTimeString = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });

        // ▲▲▲ 核心修改2：更新系统指令，加入所有上下文信息 ▲▲▲
        const systemPrompt = `
# 你的任务
你是一个虚拟社区的AI导演。下面的“帖子摘要”和“已有评论”来自于一个豆瓣小组的帖子。用户“${userNickname}”刚刚对最后一条评论点击了“等待回复”，TA希望看到更多角色参与讨论。
你的任务是：根据所有角色的设定，选择【10到20位】最适合参与讨论的角色，让他们针对已有评论，发表【全新的、符合人设的】回应。

# 核心规则
1.  **【时间感知】**:
    -   你【必须】意识到当前是 **${currentTimeString}**。
    -   你的评论内容【必须】自然地体现出对【当前真实时间】的感知。
2.  **【禁止扮演用户 (最最最高优先级！！！)】**:
    -   用户的昵称是“${userNickname}”。
    -   你【绝对不能】生成 commenter 字段为 “${userNickname}” 的评论。你的任务是扮演【除了用户以外】的所有角色。
3.  **【互动】**: 新生成的评论【必须】是针对【已有评论】的延续或回应，让讨论能继续下去。
4.  **【头像一致性 (最高优先级！)】**: 你【必须】参考下面的“已有路人NPC头像指令”列表。如果一个已有的NPC再次发言，【必须】复用它旧的头像指令。只有在创造一个【全新的、从未出现过的】NPC时，才为其生成新的头像指令。
5.  **【格式】**: 你的回复【必须且只能】是一个JSON数组，数组中的每个元素都代表一条新评论，格式【必须】如下:
    \`\`\`json
    [
      { "commenter": "角色A的名字", "text": "角色A的新评论内容。", "avatar_prompt": "(可选)如果评论者是【全新的】NPC,提供头像指令" },
      { "commenter": "角色B的名字", "text": "角色B对角色A或楼主的看法。" }
    ]
    \`\`\`

# 上下文
- **帖子标题**: 《${post.postTitle}》
- **发帖人**: ${post.authorName}
- **帖子内容摘要**: ${post.content.substring(0, 100)}...
- **已有评论**:
${post.comments.map(c => `- ${c.commenter}: ${c.text}`).join('\n')}

${existingNpcContext}

# 当前情景
- **当前真实时间**: ${currentTimeString}

# 【你的聊天对象（用户）的人设】
- **昵称**: ${userNickname}
- **人设**: ${userPersona}

# 你的角色库 (你可以从中选择【任何角色】进行评论，并参考他们的记忆和对话)
${charactersContext}

现在，请生成新的评论。`;

        const messagesForApi = [{ role: 'user', content: "请根据以上情景，生成新的评论。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 1.0,
                })
            });

        if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');
        const newComments = JSON.parse(cleanedJson);

        if (Array.isArray(newComments) && newComments.length > 0) {
            post.comments.push(...newComments);
            post.commentsCount += newComments.length;
            await db.doubanPosts.put(post);
        }

        await openDoubanPostDetail(postId);
        
        hideCustomModal();

    } catch (error) {
        console.error("等待回复失败:", error);
        await showCustomAlert("操作失败", `无法获取AI回复，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新】请将这两个新函数，粘贴到 init() 函数的上方 ▼▼▼
/**
 * 【全新】打开豆瓣角色选择器弹窗
 */
async function openDoubanCastSelector() {
    const modal = document.getElementById('douban-cast-modal');
    const listEl = document.getElementById('douban-cast-list');
    listEl.innerHTML = '';

    const allCharacters = Object.values(state.chats).filter(c => !c.isGroup);
    // 从全局设置中读取已保存的选择
    const activeIds = new Set(state.globalSettings.doubanActiveCharacterIds || []);

    if (allCharacters.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; padding: 50px 0;">还没有可以参与的角色。</p>';
    } else {
        allCharacters.forEach(char => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item'; // 复用联系人选择器的样式
            item.innerHTML = `
                <input type="checkbox" class="douban-cast-checkbox" data-chat-id="${char.id}" ${activeIds.has(char.id) ? 'checked' : ''} style="margin-right: 15px;">
                <img src="${char.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${char.name}</span>
            `;
            listEl.appendChild(item);
        });
    }
    modal.classList.add('visible');
}

/**
 * 【全新】保存用户选择的豆瓣角色
 */
async function saveDoubanCastSelection() {
    const selectedCheckboxes = document.querySelectorAll('#douban-cast-list .douban-cast-checkbox:checked');
    const selectedIds = Array.from(selectedCheckboxes).map(cb => cb.dataset.chatId);

    // 将选择保存到全局设置中
    state.globalSettings.doubanActiveCharacterIds = selectedIds;
    await db.globalSettings.put(state.globalSettings);

    document.getElementById('douban-cast-modal').classList.remove('visible');
    
    // 【关键】保存后，立即使用新的角色阵容重新生成帖子！
    await handleGenerateDoubanPosts();
}
// ▲▲▲ 新增函数结束 ▲▲▲

// ▼▼▼ 在 init() 函数的事件监听器区域，粘贴下面这整块代码 ▼▼▼
// 绑定豆瓣角色选择功能的按钮
document.getElementById('douban-cast-select-btn').addEventListener('click', openDoubanCastSelector);
document.getElementById('cancel-douban-cast-btn').addEventListener('click', () => {
    document.getElementById('douban-cast-modal').classList.remove('visible');
});
document.getElementById('save-douban-cast-btn').addEventListener('click', saveDoubanCastSelection);
// 使用事件委托，为列表项的点击添加切换选中状态的功能
document.getElementById('douban-cast-list').addEventListener('click', (e) => {
    const item = e.target.closest('.contact-picker-item');
    if (item) {
        const checkbox = item.querySelector('.douban-cast-checkbox');
        if (checkbox && e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
        }
    }
});
// ▲▲▲ 新增事件绑定结束 ▲▲▲
/* ▼▼▼ 【全新】这是导入外观设置的【全部核心JS代码】，请完整粘贴 ▼▼▼ */

/**
 * 【总入口】当用户选择了外观设置的JSON文件后，由此函数开始处理
 * @param {File} file - 用户选择的 .json 备份文件
 */
async function importAppearanceSettings(file) {
    if (!file) return;

    // 1. 弹出确认框，防止用户误操作
    const confirmed = await showCustomConfirm(
        '导入外观设置',
        '这将用文件中的设置覆盖当前的所有外观设置（包括壁纸、图标、字体、CSS等）。确定要继续吗？',
        { confirmText: '确认导入' }
    );

    if (!confirmed) return;

    try {
        // 2. 读取并解析JSON文件
        const text = await file.text();
        const data = JSON.parse(text);

        // 3. 验证文件有效性（检查是否包含关键的外观设置字段）
        if (!data.wallpaper && !data.globalCss && !data.appIcons) {
            throw new Error("文件格式不正确，缺少关键的外观设置项。");
        }

        // 4. 将导入的设置合并到当前的全局设置中
        //    我们使用Object.assign来确保即使未来增加了新的设置项，旧的备份文件也不会导致它们丢失
        Object.assign(state.globalSettings, data);

        // 5. 将更新后的完整设置保存到数据库
        await db.globalSettings.put(state.globalSettings);
        
        // 6. 立即应用所有新设置，让更改即时生效
        applyGlobalWallpaper();
        applyCPhoneWallpaper();
        applyAppIcons();
        applyCPhoneAppIcons();
        applyGlobalCss(state.globalSettings.globalCss);
        applyCustomFont(state.globalSettings.fontUrl);
        applyStatusBarVisibility();
        applyWidgetData();

        // 7. 重新渲染外观设置页面，以显示最新的设置值
        renderWallpaperScreen();
        
        // 8. 给出成功提示
        await showCustomAlert('导入成功', '外观设置已成功导入并应用！');

    } catch (error) {
        // 如果过程中出现任何错误，则捕获并提示用户
        console.error("导入外观设置时出错:", error);
        await showCustomAlert('导入失败', `文件解析或应用失败: ${error.message}`);
    }
}

/* ▲▲▲ 核心JS代码粘贴结束 ▲▲▲ */
// ===================================================================
// ▼▼▼ 【全新】后台活动模拟功能的核心代码 ▼▼▼
// ===================================================================

/**
 * 模拟角色在App关闭期间的后台活动
 * @param {number} minutesOffline - App处于离线状态的总分钟数
 */
async function simulateBackgroundActivity(minutesOffline) {
    console.log(`检测到应用离线了 ${minutesOffline.toFixed(1)} 分钟，开始模拟后台活动...`);

    // 筛选出所有开启了“独立后台活动”的单聊角色
    const activeCharacters = Object.values(state.chats).filter(chat => 
        !chat.isGroup && 
        chat.settings.enableBackgroundActivity && 
        chat.relationship?.status === 'friend'
    );
    
    if (activeCharacters.length === 0) {
        console.log("没有配置为后台活跃的角色，跳过模拟。");
        return; // 如果没有活跃角色，直接退出
    }

    // 遍历每一个活跃的角色
    for (const char of activeCharacters) {
        // 检查这个角色的行动冷却时间
        const cooldownMinutes = char.settings.actionCooldownMinutes || 15; // 默认15分钟
        const timeSinceLastAction = char.lastActionTimestamp 
            ? (Date.now() - char.lastActionTimestamp) / (1000 * 60)
            : Infinity; // 如果从未行动过，则视为冷却已结束

        // 如果离线时间超过了角色的冷却时间，且上次行动也在冷却期之外
        if (minutesOffline > cooldownMinutes && timeSinceLastAction > cooldownMinutes) {
            
            // 用一个随机数来决定角色是否真的行动，避免每次都行动
            // 例如，这里我们设置一个30%的行动概率
            if (Math.random() < 0.3) {
                console.log(`角色 "${char.name}" 触发了后台行动！`);
                
                // 为了让模拟更真实，我们随机决定TA是发消息还是发动态
                if (Math.random() < 0.7) { // 70% 概率发消息
                    // 调用我们之前已有的AI行动函数
                    await triggerInactiveAiAction(char.id);
                } else { // 30% 概率发动态
                    // 您也可以在这里调用发动态的AI函数
                    console.log(`角色 "${char.name}" 决定去发一条动态... (此处为模拟)`);
                }
            }
        }
    }
}
// ▲▲▲ 【全新】后台活动模拟功能的核心代码结束 ▲▲▲
/* ▼▼▼ 【全新】这是聊天记录搜索功能的【全部核心JS代码】，请完整粘贴 ▼▼▼ */

/**
 * 【总入口】打开聊天记录搜索屏幕
 */
function openSearchHistoryScreen() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    
    // 清空上次的搜索条件和结果
    document.getElementById('keyword-search-input').value = '';
    document.getElementById('date-search-input').value = '';
    // ★★★ 核心修改：指向新的ID ★★★
    document.getElementById('chat-search-results-list').innerHTML = `<p style="text-align:center; color: var(--text-secondary);">输入关键词或选择日期进行搜索。</p>`;
    
    // 切换屏幕
    showScreen('search-history-screen');
}

/**
 * 【核心】执行搜索逻辑
 */
async function handleSearchHistory() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const keyword = document.getElementById('keyword-search-input').value.trim().toLowerCase();
    const dateValue = document.getElementById('date-search-input').value;

    if (!keyword && !dateValue) {
        alert("请输入关键词或选择一个日期。");
        return;
    }

    let results = chat.history.filter(msg => !msg.isHidden);

    // 1. 按关键词筛选
    if (keyword) {
        results = results.filter(msg => {
            let contentString = '';
            // 智能提取不同类型消息的文本内容
            if (typeof msg.content === 'string') {
                contentString = msg.content;
            } else if (msg.type === 'voice_message') {
                contentString = msg.content;
            } else if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                contentString = msg.content;
            } else if (msg.type === 'offline_text') {
                contentString = `${msg.dialogue || ''} ${msg.description || ''}`;
            } else if (msg.quote) {
                 contentString = msg.content;
            }
            return contentString.toLowerCase().includes(keyword);
        });
    }

    // 2. 按日期筛选
    if (dateValue) {
        const selectedDate = new Date(dateValue);
        const startOfDay = new Date(selectedDate.setHours(0, 0, 0, 0)).getTime();
        const endOfDay = new Date(selectedDate.setHours(23, 59, 59, 999)).getTime();
        
        results = results.filter(msg => msg.timestamp >= startOfDay && msg.timestamp <= endOfDay);
    }
    
    // 渲染搜索结果
    await renderSearchResults(results);
}


/**
 * 将搜索结果渲染到屏幕上
 * @param {Array} results - 筛选后的消息对象数组
 */
async function renderSearchResults(results) {
    const listEl = document.getElementById('chat-search-results-list');
    const chat = state.chats[state.activeChatId];
    listEl.innerHTML = '';

    if (results.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">未找到相关的聊天记录。</p>';
        return;
    }

    let lastDateString = '';
    for (const msg of results) {
        const msgDate = new Date(msg.timestamp);
        const currentDateString = msgDate.toLocaleDateString();

        if (currentDateString !== lastDateString) {
            const dateSeparator = document.createElement('div');
            dateSeparator.className = 'date-separator';
            dateSeparator.textContent = `--- ${msgDate.getFullYear()}年${msgDate.getMonth() + 1}月${msgDate.getDate()}日 ---`;
            listEl.appendChild(dateSeparator);
            lastDateString = currentDateString;
        }

        const messageEl = await createMessageElement(msg, chat);
        if (messageEl) {
            // ▼▼▼ 核心修改就在这里 ▼▼▼
            // 1. 添加手型光标，提示用户这是可以点击的
            messageEl.style.cursor = 'pointer';
            // 2. 为消息元素绑定点击事件，调用我们新的跳转函数
            messageEl.addEventListener('click', () => jumpToOriginalMessage(msg.timestamp));
            // ▲▲▲ 修改结束 ▲▲▲
            listEl.appendChild(messageEl);
        }
    }
}

// ▼▼▼ 【全新】这是聊天记录搜索跳转功能的核心代码，请完整粘贴 ▼▼▼

/**
 * 【总入口】从搜索结果跳转回原始消息位置
 * @param {number} timestamp - 目标消息的时间戳
 */
async function jumpToOriginalMessage(timestamp) {
    const chatId = state.activeChatId;
    if (!chatId) return;

    // 1. 切换到聊天界面 (这会触发 renderChatInterface 渲染最新的消息)
    showScreen('chat-interface-screen');

    // 2. 使用一个短暂的延迟来确保屏幕切换和初始渲染已完成
    setTimeout(async () => {
        const messagesContainer = document.getElementById('chat-messages');
        const selector = `.message-bubble[data-timestamp="${timestamp}"]`;
        let targetMessage = messagesContainer.querySelector(selector);
        let attempts = 0; // 防止无限循环
        const maxAttempts = 20; // 最多向上加载20次

        // 3. 循环检查：如果目标消息不在当前DOM中，就模拟点击“加载更早记录”
        while (!targetMessage && attempts < maxAttempts) {
            const loadMoreBtn = document.getElementById('load-more-btn');
            if (loadMoreBtn) {
                console.log(`目标消息未找到, 正在加载更多历史记录... (尝试 ${attempts + 1})`);
                await loadMoreMessages(); // 等待加载完成
                targetMessage = messagesContainer.querySelector(selector);
                attempts++;
            } else {
                // 如果没有“加载更多”按钮了，说明所有消息都已加载
                break;
            }
        }

        // 4. 调用最终的滚动和高亮函数
        scrollToOriginalMessage(timestamp);

    }, 200); // 延迟200毫秒足以确保UI准备就绪
}



/**
 * 重置搜索过滤器并显示所有记录
 */
async function clearSearchFilters() {
    document.getElementById('keyword-search-input').value = '';
    document.getElementById('date-search-input').value = '';
    // 重新渲染所有消息作为“重置”结果
    await renderSearchResults(state.chats[state.activeChatId].history.filter(msg => !msg.isHidden));
}

/* ▲▲▲ 核心JS代码粘贴结束 ▲▲▲ */
// ▼▼▼ 【全新V2.0 | 自定义头像框】这是所有头像框上传、管理功能的核心JS代码 ▼▼▼

/**
 * 【重构版】渲染头像框选择列表，现在会同时显示预设和用户自定义的头像框
 * @param {boolean} isForMember - 是否是为群成员设置
 * @param {string|null} memberAvatar - (可选) 群成员的头像URL
 * @param {string|null} memberFrame - (可选) 群成员当前的头像框URL
 */
async function populateFrameGrids(isForMember = false, memberAvatar = null, memberFrame = null) {
    const aiFrameGrid = document.getElementById('ai-frame-grid');
    const myFrameGrid = document.getElementById('my-frame-grid');
    const chat = state.chats[state.activeChatId];
    aiFrameGrid.innerHTML = '';
    myFrameGrid.innerHTML = '';

    // 1. 【核心修改】从数据库获取用户自定义的头像框
    const customFrames = await db.customAvatarFrames.toArray();
    // 将预设和自定义的合并为一个列表
    const allFrames = [...avatarFrames, ...customFrames];

    document.querySelector('#avatar-frame-modal .frame-tabs').style.display = isForMember ? 'none' : 'flex';
    document.getElementById('ai-frame-content').style.display = 'block';
    document.getElementById('my-frame-content').style.display = 'none';
    document.getElementById('ai-frame-tab').classList.add('active');
    document.getElementById('my-frame-tab').classList.remove('active');

    if (isForMember) {
        allFrames.forEach(frame => {
            const item = createFrameItem(frame, 'my', memberAvatar);
            if (frame.url === memberFrame) {
                item.classList.add('selected');
            }
            aiFrameGrid.appendChild(item);
        });
    } else {
        const aiAvatarForPreview = chat.settings.aiAvatar || defaultAvatar;
        const myAvatarForPreview = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
        allFrames.forEach(frame => {
            const aiItem = createFrameItem(frame, 'ai', aiAvatarForPreview);
            if (frame.url === currentFrameSelection.ai) aiItem.classList.add('selected');
            aiFrameGrid.appendChild(aiItem);

            const myItem = createFrameItem(frame, 'my', myAvatarForPreview);
            if (frame.url === currentFrameSelection.my) myItem.classList.add('selected');
            myFrameGrid.appendChild(myItem);
        });
    }
}

/**
 * 【升级版】创建单个头像框的预览DOM，为自定义框添加删除按钮
 * @param {object} frame - 头像框对象 { id, url, name }
 * @param {string} type - 'ai' 或 'my'
 * @param {string} previewAvatarSrc - 用于预览的头像URL
 * @returns {HTMLElement} - 创建好的DOM元素
 */
function createFrameItem(frame, type, previewAvatarSrc) {
    const item = document.createElement('div');
    item.className = 'frame-item';
    item.dataset.frameUrl = frame.url;
    item.title = frame.name;

    // 【核心修改】检查
    const isCustom = typeof frame.id === 'number';
    const deleteButtonHtml = isCustom ? `<button class="delete-btn" data-id="${frame.id}" style="display:block;">×</button>` : '';

    item.innerHTML = `
        ${deleteButtonHtml}
        <img src="${previewAvatarSrc}" class="preview-avatar">
        ${frame.url ? `<img src="${frame.url}" class="preview-frame">` : ''}
    `;
    item.addEventListener('click', (e) => {
        // 如果点击的是删除按钮，则不执行选择操作
        if (e.target.classList.contains('delete-btn')) {
            return;
        }
        currentFrameSelection[type] = frame.url;
        const grid = type === 'ai' ? document.getElementById('ai-frame-grid') : document.getElementById('my-frame-grid');
        grid.querySelectorAll('.frame-item').forEach(el => el.classList.remove('selected'));
        item.classList.add('selected');
    });
    return item;
}

/**
 * 【全新】处理本地上传单个头像框的逻辑
 */
async function handleUploadFrame() {
    const fileInput = document.getElementById('custom-frame-upload-input');
    
    // 使用 Promise 优雅地处理文件选择
    const file = await new Promise(resolve => {
        const changeHandler = (e) => {
            resolve(e.target.files[0] || null);
            fileInput.removeEventListener('change', changeHandler);
        };
        fileInput.addEventListener('change', changeHandler, { once: true });
        fileInput.click();
    });

    if (!file) return; // 用户取消了选择

    const name = await showCustomPrompt("命名头像框", "请为这个新头像框起个名字");
    if (!name || !name.trim()) return;

    // 将图片文件转换为 Base64
    const url = await new Promise(resolve => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.readAsDataURL(file);
    });

    // 存入数据库
    await db.customAvatarFrames.add({ name: name.trim(), url });
    // 刷新UI
    populateFrameGrids(editingFrameForMember);
}

/**
 * 【全新】处理批量导入头像框的逻辑
 */
async function handleBatchUploadFrames() {
    const placeholder = `请按照以下格式粘贴，一行一个：\n\n头像框名字1: https://.../image1.png\n头像框名字2: https://.../image2.gif`;
    const pastedText = await showCustomPrompt("批量导入头像框", "从完整链接批量导入", "", 'textarea', `<p style="font-size:12px;color:#888;">${placeholder}</p>`);

    if (!pastedText || !pastedText.trim()) return;

    const lines = pastedText.trim().split('\n');
    const newFrames = [];
    let errorCount = 0;

    for (const line of lines) {
        // 使用正则表达式匹配 "名字: URL" 格式，更健壮
        const match = line.match(/^(.+?)[:：]\s*(https?:\/\/.+)$/);
        if (match) {
            newFrames.push({
                name: match[1].trim(),
                url: match[2].trim()
            });
        } else if (line.trim()) {
            errorCount++;
        }
    }

    if (newFrames.length > 0) {
        await db.customAvatarFrames.bulkAdd(newFrames);
        populateFrameGrids(editingFrameForMember);
        await showCustomAlert("导入成功", `成功导入 ${newFrames.length} 个新头像框！`);
    }

    if (errorCount > 0) {
        await showCustomAlert("部分失败", `有 ${errorCount} 行格式不正确，已被忽略。`);
    }
}

/**
 * 【全新】删除一个自定义头像框
 * @param {number} frameId - 要删除的头像框的ID
 */
async function handleDeleteCustomFrame(frameId) {
    const frame = await db.customAvatarFrames.get(frameId);
    if (!frame) return;

    const confirmed = await showCustomConfirm(
        "确认删除",
        `确定要删除头像框 “${frame.name}” 吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        await db.customAvatarFrames.delete(frameId);
        populateFrameGrids(editingFrameForMember); // 刷新UI
    }
}

// ▲▲▲ 全新JS代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】这是主屏幕分页和“预设”App的【全部核心JS代码】，请完整粘贴 ▼▼▼

// --- 1. 主屏幕分页功能 ---
let currentPage = 0;
const totalPages = 2;

        // ▼▼▼ 【最终修复版】请用这一整块代码，完整替换旧的 setupHomeScreenPagination 函数 ▼▼▼
        function setupHomeScreenPagination() {
            const pagesContainer = document.getElementById('home-screen-pages-container');
            const pages = document.getElementById('home-screen-pages');
            const dots = document.querySelectorAll('.pagination-dot');
            let startX = 0, startY = 0; // 同时记录Y轴坐标
            let currentX = 0;
            let isDragging = false;
            let isClick = true; // 【核心】增加一个标志位，用于判断是点击还是滑动

            const updatePagination = () => {
                pages.style.transform = `translateX(-${currentPage * (100 / totalPages)}%)`;
                dots.forEach((dot, index) => {
                    dot.classList.toggle('active', index === currentPage);
                });
            };

            const onDragStart = (e) => {
                isDragging = true;
                isClick = true; // 每次开始触摸时，都先假设它是一个点击
                startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
                startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
                pages.style.transition = 'none';
            };

            const onDragMove = (e) => {
                if (!isDragging) return;
                
                const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
                currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
                const diffX = currentX - startX;
                const diffY = currentY - startY;

                // 【核心】如果手指移动距离超过10像素，就判定为滑动，而不是点击
                if (isClick && (Math.abs(diffX) > 10 || Math.abs(diffY) > 10)) {
                    isClick = false;
                }

                // 只在水平滑动时移动页面，避免影响垂直滚动
                if (Math.abs(diffX) > Math.abs(diffY)) {
                     if(e.cancelable) e.preventDefault();
                     pages.style.transform = `translateX(calc(-${currentPage * (100 / totalPages)}% + ${diffX}px))`;
                }
            };

            const onDragEnd = (e) => {
                if (!isDragging) return;
                isDragging = false;
                pages.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';

                // 【核心】如果判定为点击，则不执行翻页逻辑，直接返回！
                if (isClick) {
                    updatePagination(); // 让页面弹回原位
                    // 因为没有阻止事件，所以浏览器会继续处理这个“点击”，触发App图标的onclick
                    return; 
                }

                // 如果是滑动，才执行下面的翻页判断
                const diffX = currentX - startX;
                if (Math.abs(diffX) > pagesContainer.offsetWidth / 4) {
                    if (diffX > 0 && currentPage > 0) {
                        currentPage--;
                    } else if (diffX < 0 && currentPage < totalPages - 1) {
                        currentPage++;
                    }
                }
                updatePagination();
            };

            pagesContainer.addEventListener('mousedown', onDragStart);
            pagesContainer.addEventListener('mousemove', onDragMove);
            pagesContainer.addEventListener('mouseup', onDragEnd);
            pagesContainer.addEventListener('mouseleave', onDragEnd);

            // 【核心】修改 passive 为 false，以允许 e.preventDefault() 生效
            pagesContainer.addEventListener('touchstart', onDragStart, { passive: false });
            pagesContainer.addEventListener('touchmove', onDragMove, { passive: false });
            pagesContainer.addEventListener('touchend', onDragEnd);
        }
        // ▲▲▲ 替换结束 ▲▲▲

// --- 2. “预设”App 核心功能 ---
let editingPresetId = null;

async function openPresetScreen() {
    await renderPresetScreen();
    showScreen('preset-screen');
}

/**
 * 【全新 | 性能优化版】渲染预设列表，不再显示内容预览
 */
async function renderPresetScreen() {
    const tabsContainer = document.getElementById('preset-tabs');
    const contentContainer = document.getElementById('preset-content-container');
    tabsContainer.innerHTML = '';
    contentContainer.innerHTML = '';

    const [presets, categories] = await Promise.all([
        db.presets.toArray(),
        db.presetCategories.orderBy('name').toArray()
    ]);

    state.presets = presets; // 确保内存数据同步

    if (presets.length === 0) {
        contentContainer.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 创建你的第一个预设</p>';
        return;
    }

    // (创建页签的逻辑保持不变)
    const allTab = document.createElement('button');
    allTab.className = 'world-book-tab active';
    allTab.textContent = '全部';
    allTab.dataset.categoryId = 'all';
    tabsContainer.appendChild(allTab);

    const allPane = document.createElement('div');
    allPane.className = 'world-book-category-pane active';
    allPane.dataset.categoryId = 'all';
    contentContainer.appendChild(allPane);
    
    categories.forEach(category => {
        const categoryTab = document.createElement('button');
        categoryTab.className = 'world-book-tab';
        categoryTab.textContent = category.name;
        categoryTab.dataset.categoryId = String(category.id);
        tabsContainer.appendChild(categoryTab);

        const categoryPane = document.createElement('div');
        categoryPane.className = 'world-book-category-pane';
        categoryPane.dataset.categoryId = String(category.id);
        contentContainer.appendChild(categoryPane);
    });
    
    const hasUncategorized = presets.some(p => !p.categoryId);
    if (hasUncategorized) {
        const uncategorizedTab = document.createElement('button');
        uncategorizedTab.className = 'world-book-tab';
        uncategorizedTab.textContent = '未分类';
        uncategorizedTab.dataset.categoryId = 'uncategorized';
        tabsContainer.appendChild(uncategorizedTab);
    
        const uncategorizedPane = document.createElement('div');
        uncategorizedPane.className = 'world-book-category-pane';
        uncategorizedPane.dataset.categoryId = 'uncategorized';
        contentContainer.appendChild(uncategorizedPane);
    }
    
    // ▼▼▼ 【【【核心修改就在这里！】】】 ▼▼▼
    presets.forEach(preset => {
        // 我们不再读取任何具体内容，只显示这个预设包含了多少个条目
        const contentPreview = `该预设包含 ${preset.content.length} 个条目。`;
        
        const card = document.createElement('div');
        card.className = 'world-book-card'; // 复用世界书的卡片样式
        card.innerHTML = `
            <div class="card-title">${preset.name}</div>
            <div class="card-content-preview">${contentPreview}</div>
        `;
        
        // (事件绑定逻辑保持不变)
        const cardClickHandler = () => openPresetEditor(preset.id);
        const cardLongPressHandler = async () => { 
            const confirmed = await showCustomConfirm('删除预设', `确定要删除《${preset.name}》吗？`, { confirmButtonClass: 'btn-danger' }); 
            if (confirmed) { 
                await db.presets.delete(preset.id);
                state.presets = await db.presets.toArray();
                renderPresetScreen(); 
            } 
        };

        card.addEventListener('click', cardClickHandler);
        addLongPressListener(card, cardLongPressHandler);

        const clonedCardForAll = card.cloneNode(true);
        clonedCardForAll.addEventListener('click', cardClickHandler);
        addLongPressListener(clonedCardForAll, cardLongPressHandler);
        allPane.appendChild(clonedCardForAll);
        
        const categoryKey = preset.categoryId ? String(preset.categoryId) : 'uncategorized';
        const targetPane = contentContainer.querySelector(`.world-book-category-pane[data-category-id="${categoryKey}"]`);
        if (targetPane) {
            targetPane.appendChild(card);
        }
    });
    // ▲▲▲ 【【【修改结束】】】 ▲▲▲
    
    // (页签绑定逻辑保持不变)
    document.querySelectorAll('#preset-tabs .world-book-tab').forEach(tab => {
        tab.addEventListener('click', () => switchPresetCategory(tab.dataset.categoryId));
    });
}


function switchPresetCategory(categoryId) {
    document.querySelectorAll('#preset-tabs .world-book-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.categoryId === categoryId);
    });
    document.querySelectorAll('#preset-content-container .world-book-category-pane').forEach(pane => {
        pane.classList.toggle('active', pane.dataset.categoryId === categoryId);
    });
}

/**
 * 【最终修复版 | 兼容iOS/Safari】打开预设编辑器
 * @param {string} presetId - 要编辑的预设的ID
 */
async function openPresetEditor(presetId) {
    // 步骤 1: 立即开始切换屏幕，让动画先运行
    showScreen('preset-editor-screen');
    editingPresetId = presetId;

    try {
        // 步骤 2: 在后台异步获取所有需要的数据
        const [preset, categories] = await Promise.all([
            db.presets.get(presetId),
            db.presetCategories.toArray()
        ]);

        // 步骤 3: 检查获取到的数据是否有效
        if (!preset) {
            console.error("错误：尝试打开一个不存在的预设，ID:", presetId);
            await showCustomAlert("加载失败", "找不到这个预设的详细信息。");
            showScreen('preset-screen'); // 安全地返回列表页
            return;
        }

        // 步骤 4: 【核心修复】使用一个微小的延迟 (setTimeout) 
        // 这会给手机浏览器足够的时间来完成屏幕切换的动画，避免冲突
        setTimeout(() => {
            // 步骤 5: 现在可以安全地更新页面上的所有内容了
            document.getElementById('preset-editor-title').textContent = preset.name;
            document.getElementById('preset-name-input').value = preset.name;

            const selectEl = document.getElementById('preset-category-select');
            selectEl.innerHTML = '<option value="">-- 未分类 --</option>';
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.name;
                if (preset.categoryId === cat.id) option.selected = true;
                selectEl.appendChild(option);
            });

            const entriesContainer = document.getElementById('preset-entries-container');
            entriesContainer.innerHTML = '';
            if (Array.isArray(preset.content) && preset.content.length > 0) {
                preset.content.forEach(entry => {
                    const block = createPresetEntryBlock(entry);
                    entriesContainer.appendChild(block);
                });
            } else {
                entriesContainer.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 20px;">还没有内容，点击下方按钮添加第一条吧！</p>';
            }
        }, 50); // 延迟50毫秒，对于移动端已经足够

    } catch (error) {
        console.error("打开预设编辑器时发生严重错误:", error);
        await showCustomAlert("加载失败", `加载预设详情时发生错误: ${error.message}`);
        showScreen('preset-screen'); // 出错时也安全返回
    }
}

/**
 * 【全新 | 支持内容折叠】创建单个预设条目的编辑块
 */
function createPresetEntryBlock(entry = { keys: [], comment: '', content: '', enabled: true }) {
    const block = document.createElement('div');
    block.className = 'message-editor-block';
    const isChecked = entry.enabled !== false ? 'checked' : '';

    // ▼▼▼ 【【【核心修改就在这里！】】】 ▼▼▼
    block.innerHTML = `
        <div style="display: flex; justify-content: flex-end; align-items: center; gap: 10px; margin-bottom: 5px;">
            <label class="toggle-switch" title="启用/禁用此条目">
                <input type="checkbox" class="entry-enabled-switch" ${isChecked}>
                <span class="slider"></span>
            </label>
            <button type="button" class="delete-block-btn" title="删除此条目">×</button>
        </div>
        <div class="form-group" style="margin-bottom: 10px;">
            <label style="font-size: 0.8em;">备注 (可选)</label>
            <input type="text" class="entry-comment-input" value="${entry.comment || ''}" placeholder="例如：角色核心设定" style="padding: 8px;">
        </div>
        <div class="form-group" style="margin-bottom: 10px;">
            <label style="font-size: 0.8em;">关键词 (用英文逗号,分隔)</label>
            <input type="text" class="entry-keys-input" value="${(entry.keys || []).join(', ')}" placeholder="例如: key1, key2" style="padding: 8px;">
        </div>
        
        <!-- 这里是全新的、带有“展开/收起”按钮的结构 -->
        <div class="form-group" style="margin-bottom: 0;">
            <label style="font-size: 0.8em; display: flex; justify-content: space-between; align-items: center;">
                <span>内容 (点击右侧展开)</span>
                <button type="button" class="toggle-content-btn">展开</button>
            </label>
            <div class="entry-content-container">
                 <textarea class="entry-content-textarea" rows="8" style="width: 100%; font-size: 14px;">${entry.content || ''}</textarea>
            </div>
        </div>
    `;
    // ▲▲▲ 【【【修改结束】】】 ▲▲▲

    // 绑定删除按钮事件
    block.querySelector('.delete-block-btn').addEventListener('click', () => block.remove());
    
    // 【全新】为“展开/收起”按钮绑定事件
    const toggleBtn = block.querySelector('.toggle-content-btn');
    const contentContainer = block.querySelector('.entry-content-container');
    toggleBtn.addEventListener('click', () => {
        const isHidden = contentContainer.style.display === 'none';
        contentContainer.style.display = isHidden ? 'block' : 'none';
        toggleBtn.textContent = isHidden ? '收起' : '展开';
    });

    return block;
}

// --- 3. “预设”分类管理 (复用世界书的函数，修改函数名) ---
async function openPresetCategoryManager() {
    await renderPresetCategoriesInManager();
    // 复用现有的弹窗，只修改内容
    document.querySelector('#group-management-modal .modal-header span').textContent = '管理预设分类';
    document.getElementById('add-new-group-btn').onclick = addNewPresetCategory;
    document.getElementById('existing-groups-list').onclick = (e) => {
        if (e.target.classList.contains('delete-group-btn')) {
            deletePresetCategory(parseInt(e.target.dataset.id));
        }
    };
    document.getElementById('close-group-manager-btn').onclick = () => {
        document.getElementById('group-management-modal').classList.remove('visible');
        renderPresetScreen(); // 关闭后刷新主列表
    };
    document.getElementById('group-management-modal').classList.add('visible');
}

async function renderPresetCategoriesInManager() {
    const listEl = document.getElementById('existing-groups-list');
    const categories = await db.presetCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类</p>';
    }
    categories.forEach(cat => {
        const item = document.createElement('div');
        item.className = 'existing-group-item';
        item.innerHTML = `<span class="group-name">${cat.name}</span><span class="delete-group-btn" data-id="${cat.id}">×</span>`;
        listEl.appendChild(item);
    });
}

async function addNewPresetCategory() {
    const input = document.getElementById('new-group-name-input');
    const name = input.value.trim();
    if (!name) return alert('分类名不能为空！');
    const existing = await db.presetCategories.where('name').equals(name).first();
    if (existing) return alert(`分类 "${name}" 已经存在了！`);
    await db.presetCategories.add({ name });
    input.value = '';
    await renderPresetCategoriesInManager();
}

async function deletePresetCategory(categoryId) {
    const confirmed = await showCustomConfirm('确认删除', '删除分类后，该分类下的所有预设将变为“未分类”。确定吗？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.presetCategories.delete(categoryId);
        await db.presets.where('categoryId').equals(categoryId).modify({ categoryId: null });
        
        // ▼▼▼ 核心修复：在这里也同样从数据库重新加载最新的预设列表 ▼▼▼
        state.presets = await db.presets.toArray();
        // ▲▲▲ 修复结束 ▲▲▲

        await renderPresetCategoriesInManager();
    }
}
// ▲▲▲ 全新JS代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】这是导入 Tavern 预设功能的【全部核心JS代码】，请完整粘贴 ▼▼▼

/**
 * 【总入口】当用户选择了预设文件后，由此函数开始处理
 * @param {Event} event - 文件输入框的 change 事件
 */
async function handlePresetImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
        if (!file.name.endsWith('.json')) {
            throw new Error("文件格式不支持。请选择 .json 格式的 Tavern 预设文件。");
        }
        
        const text = await file.text();
        const tavernData = JSON.parse(text);
        
        // 调用核心处理函数
        await importTavernPresetFile(tavernData, file.name);

    } catch (error) {
        console.error("预设导入失败:", error);
        await showCustomAlert("导入失败", `无法解析预设文件。\n错误: ${error.message}`);
    } finally {
        // 清空输入框，以便下次能选择同一个文件
        event.target.value = null;
    }
}

        /**
         * 【V3.0 | 排序终极修复版】从 Tavern AI 格式的数据创建一本新的“预设”
         * @param {object} tavernData - 从 .json 文件解析出的数据
         * @param {string} fileName - 原始文件名，用于生成默认名称
         */
        async function importTavernPresetFile(tavernData, fileName) {
            let newEntries = [];

            // ▼▼▼ 修复代码从这里开始 ▼▼▼

            // 策略1：优先处理标准的、带有 `prompt_order` 排序列表的 Tavern/SillyTavern 预设格式
            if (Array.isArray(tavernData.prompts) && Array.isArray(tavernData.prompt_order) && tavernData.prompt_order.length > 0) {
                console.log("检测到 Tavern/SillyTavern 预设格式，将严格按照 prompt_order 排序。");

                // 创建一个查找映射表，以便通过 identifier 快速找到 prompt 的详细数据
                const promptsMap = new Map(tavernData.prompts.map(p => [p.identifier, p]));

                // 自动选择最长的那个排序列表，这通常是用户自定义的那个
                const orderArray = tavernData.prompt_order.reduce((acc, curr) => (
                    (curr.order && curr.order.length > (acc.length || 0)) ? curr.order : acc
                ), []);

                if (orderArray && orderArray.length > 0) {
                    newEntries = orderArray
                        .map(orderItem => {
                            // 根据排序列表中的 identifier，从映射表中找到对应的 prompt 数据
                            const promptData = promptsMap.get(orderItem.identifier);
                            if (promptData) {
                                // 按照我们的格式重新组织数据
                                return {
                                    keys: [], // Tavern 预设中没有 keys 字段
                                    comment: promptData.name || '无标题',
                                    content: promptData.content || '',
                                    // 【核心】同步启用/禁用状态
                                    enabled: orderItem.enabled 
                                };
                            }
                            return null;
                        })
                        .filter(Boolean); // 过滤掉可能存在的无效条目
                }
            }
            // 策略2：兼容旧的、类似世界书的 "entries" 和 "order" 格式
            else if (tavernData.entries && typeof tavernData.entries === 'object') {
                console.log("检测到 'entries' 对象格式的预设，将尝试按顺序导入。");
                if (Array.isArray(tavernData.order)) {
                    console.log("检测到 'order' 字段，将按指定顺序导入条目。");
                    newEntries = tavernData.order
                        .map(key => tavernData.entries[key])
                        .filter(Boolean)
                        .map(entry => ({
                            keys: entry.key || [],
                            comment: entry.comment || '无备注',
                            content: entry.content || '',
                            enabled: !entry.disable // Tavern 的 disable 和我们的 enabled 逻辑相反
                        }));
                } else {
                    console.warn("未在文件中找到 'order' 字段，条目可能无法按原始顺序导入。");
                    newEntries = Object.values(tavernData.entries).map(entry => ({
                        keys: entry.key || [],
                        comment: entry.comment || '无备注',
                        content: entry.content || '',
                        enabled: !entry.disable
                    }));
                }
            }
            // 策略3：兼容最简单的、只包含 "prompts" 数组的格式
            else if (Array.isArray(tavernData.prompts)) {
                console.log("检测到简单的 'prompts' 数组格式，将按数组内顺序导入。");
                newEntries = tavernData.prompts.map(prompt => ({
                    keys: [],
                    comment: prompt.name || '无标题',
                    content: prompt.content || '',
                    enabled: true // 默认启用
                }));
            }
            // 策略4：如果所有格式都不匹配，则报错
            else {
                throw new Error("文件格式无法识别。未找到有效的 'prompts' 数组或 'entries' 对象。");
            }
            // ▲▲▲ 修复代码到这里结束 ▲▲▲

            // 过滤掉没有内容的空条目
            newEntries = newEntries.filter(entry => entry.content);

            if (newEntries.length === 0) {
                alert("这个预设文件中没有找到任何有效的提示词条目。");
                return;
            }

            // （后续的命名、保存和刷新逻辑保持不变）
            const presetNameSuggestion = fileName.replace(/\.json$/i, '');
            const newPresetName = await showCustomPrompt("导入 Tavern 预设", "请为这组提示词预设命名：", presetNameSuggestion);
            if (!newPresetName || !newPresetName.trim()) {
                alert("导入已取消，因为未提供名称。");
                return;
            }

            const newPreset = {
                id: 'preset_' + Date.now(),
                name: newPresetName.trim(),
                content: newEntries,
                categoryId: null
            };

            await db.presets.add(newPreset);
            state.presets.push(newPreset);

            await renderPresetScreen();
            await showCustomAlert('导入成功！', `已成功从文件导入预设《${newPresetName}》。`);
        }

// ▲▲▲ 全新JS代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】请将这个函数粘贴到JS功能函数定义区 ▼▼▼
/**
 * 【全新】在聊天设置中渲染线下模式的文风预设选择器
 * @param {object} chat - 当前的聊天对象
 */
async function renderOfflinePresetSelector(chat) {
    const selectEl = document.getElementById('offline-preset-select');
    if (!selectEl) return;

    // 1. 直接从 state 缓存中获取预设，无需再查数据库
    const presets = state.presets || [];
    
    // 2. 清空并填充下拉列表
    selectEl.innerHTML = '<option value="">-- 不使用预设 --</option>';
    presets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        selectEl.appendChild(option);
    });

    // 3. 设置当前选中的值
    if (chat.settings.offlinePresetId) {
        selectEl.value = chat.settings.offlinePresetId;
    }
}
// ▲▲▲ 新增函数结束 ▲▲▲
// ▼▼▼ 【请用这个 V2.0 版本】替换旧的 renderButtonOrderEditor 函数 ▼▼▼
/**
 * 渲染按钮排序的设置界面 (V2.0 - 使用常量作为默认值)
 */
function renderButtonOrderEditor() {
    const editor = document.getElementById('button-order-editor');
    if (!editor) return;

    editor.innerHTML = '';

    // 【核心修改】
    // 优先使用用户保存的顺序，如果不存在，则直接使用我们定义的默认顺序常量
    let buttonOrder = state.globalSettings.chatActionButtonsOrder || DEFAULT_BUTTON_ORDER;
    
    buttonOrder.forEach(buttonId => {
        const originalButton = document.getElementById(buttonId);
        if (originalButton) {
            const item = document.createElement('div');
            item.className = 'draggable-button-item';
            item.draggable = true;
            item.dataset.buttonId = buttonId;
            item.innerHTML = originalButton.innerHTML; 
            editor.appendChild(item);
        }
    });
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【最终修复版 | 兼容移动端触摸】请用这一整块全新的代码，完整替换旧的 initializeButtonOrderEditor 函数 ▼▼▼
/**
 * 【V2.0 | 移动端兼容版】初始化按钮排序编辑器的拖放事件
 */
function initializeButtonOrderEditor() {
    const editor = document.getElementById('button-order-editor');
    if (!editor) return;

    let draggingItem = null; // 用于存储当前正在被拖动的元素

    // 统一的事件处理函数
    const handleDragStart = (e) => {
        const target = e.target.closest('.draggable-button-item');
        if (!target) return;
        
        draggingItem = target;
        draggingItem.classList.add('dragging');

        // 阻止默认行为，特别是在触摸设备上防止页面滚动
        if (e.cancelable) e.preventDefault();
    };

    const handleDragMove = (e) => {
        if (!draggingItem) return;

        // 统一获取坐标
        const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
        
        const afterElement = getDragAfterElement(editor, clientX);
        
        if (afterElement == null) {
            editor.appendChild(draggingItem);
        } else {
            editor.insertBefore(draggingItem, afterElement);
        }
    };

    const handleDragEnd = () => {
        if (!draggingItem) return;

        draggingItem.classList.remove('dragging');
        draggingItem = null;
        
        // 拖动结束后，保存新的顺序
        saveButtonOrder();
    };

    // --- 绑定事件 ---
    // 使用 mousedown 和 touchstart 来开始拖动
    editor.addEventListener('mousedown', handleDragStart);
    editor.addEventListener('touchstart', handleDragStart, { passive: false });

    // 使用 mousemove 和 touchmove 来处理拖动过程
    editor.addEventListener('mousemove', handleDragMove);
    editor.addEventListener('touchmove', handleDragMove, { passive: false });

    // 使用 mouseup, mouseleave 和 touchend 来结束拖动
    editor.addEventListener('mouseup', handleDragEnd);
    editor.addEventListener('mouseleave', handleDragEnd); // 防止鼠标移出区域时卡住
    editor.addEventListener('touchend', handleDragEnd);
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【最终修复版】请用这个全新的函数，完整替换旧的 getDragAfterElement ▼▼▼
/**
 * 【V2.0 | 水平修复版】辅助函数：计算拖动元素应该插入到哪个元素前面
 * @param {HTMLElement} container - 拖放区域的容器
 * @param {number} x - 鼠标当前的水平 (X) 坐标
 * @returns {HTMLElement|null} - 应该被插入到其前面的那个元素
 */
function getDragAfterElement(container, x) {
    // 1. 获取容器内所有可拖拽的、但不是正在被拖拽的元素
    const draggableElements = [...container.querySelectorAll('.draggable-button-item:not(.dragging)')];

    // 2. 使用 reduce 方法来找到最接近的那个元素
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        // 3. 【核心修正】计算鼠标 X 坐标到元素中心的水平距离
        const offset = x - box.left - box.width / 2;
        
        // 4. 我们要找的是：鼠标在它左边 (offset < 0)，并且是所有满足条件里最接近的那个 (offset > closest.offset)
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 保存用户自定义的按钮顺序到数据库
 */
async function saveButtonOrder() {
    const editor = document.getElementById('button-order-editor');
    const newOrder = Array.from(editor.querySelectorAll('.draggable-button-item')).map(item => item.dataset.buttonId);
    
    state.globalSettings.chatActionButtonsOrder = newOrder;
    await db.globalSettings.put(state.globalSettings);

    // (可选) 给用户一个保存成功的提示
    // console.log("按钮顺序已保存:", newOrder);
}

/**
 * 【核心】根据已保存的顺序，重新排列聊天界面底部的按钮
 */
function applyButtonOrder() {
    const buttonOrder = state.globalSettings.chatActionButtonsOrder;
    if (!buttonOrder || !Array.isArray(buttonOrder) || buttonOrder.length === 0) {
        return; // 如果没有保存的顺序，则不执行任何操作
    }

    const container = document.getElementById('chat-input-actions-top');
    if (!container) return;

    // 按照保存的顺序，依次将按钮重新追加到容器末尾
    buttonOrder.forEach(buttonId => {
        const button = document.getElementById(buttonId);
        if (button) {
            container.appendChild(button);
        }
    });
}

// ▲▲▲ 全新JS代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】定义默认的按钮顺序常量 ▼▼▼
const DEFAULT_BUTTON_ORDER = [
    'open-sticker-panel-btn', 'send-photo-btn', 'upload-image-btn', 
    'transfer-btn', 'voice-message-btn', 'send-waimai-request-btn', 
    'video-call-btn', 'group-video-call-btn', 'send-poll-btn', 
    'share-link-btn', 'share-location-btn', 'gomoku-btn', 
    'open-shopping-btn', 'pat-btn', 'edit-last-response-btn', 
    'regenerate-btn', 'propel-btn', 'show-announcement-board-btn',
'werewolf-game-btn',
    // ▼▼▼ 在这里添加新按钮ID ▼▼▼
    'read-together-btn'
];
// ▲▲▲ 新增代码结束 ▲▲▲
// ▼▼▼ 【全新】重置按钮顺序的核心功能函数 ▼▼▼
async function resetButtonOrder() {
    // 1. 在用户的全局设置中，将自定义顺序清除 (设为 null)
    state.globalSettings.chatActionButtonsOrder = null;
    await db.globalSettings.put(state.globalSettings);

    // 2. 重新渲染排序编辑器，它会自动恢复到默认顺序
    renderButtonOrderEditor();

    // 3. 应用默认顺序到真实的聊天界面
    applyButtonOrder();

    // 4. 给用户一个成功的提示
    await showCustomAlert("成功", "按钮顺序已恢复为默认设置！");
}
// ▲▲▲ 新增代码结束 ▲▲▲


// ▼▼▼ 【全新 V2.0 | 已修复】这是高级数据清理功能的【全部核心JS代码】，请完整粘贴 ▼▼▼

let selectedCharsForClear = []; // 用于存储第一步选择的角色ID
let selectedTypesForClear = []; // 用于存储第二步选择的数据类型

/**
 * 【总入口】打开高级数据清理向导
 */
function openDataClearWizard() {
    const modal = document.getElementById('data-clear-wizard-modal');
    selectedCharsForClear = [];
    selectedTypesForClear = [];
    
    // 渲染第一步
    renderClearWizardStep1();
    
    // 显示第一步，隐藏第二步
    document.getElementById('data-clear-step-1').style.display = 'flex';
    document.getElementById('data-clear-step-2').style.display = 'none';
    
    modal.classList.add('visible');
}

/**
 * 渲染向导的第一步：角色选择列表
 */
function renderClearWizardStep1() {
    const listEl = document.getElementById('data-clear-char-list');
    listEl.innerHTML = '';

    // 1. 添加“我自己”的选项
    const userItem = document.createElement('div');
    userItem.className = 'clear-posts-item';
    userItem.dataset.charId = 'user';
    userItem.innerHTML = `
        <div class="checkbox"></div>
        <span class="name">${state.qzoneSettings.nickname || '我'} (用户)</span>
    `;
    listEl.appendChild(userItem);

    // 2. 添加所有AI角色的选项
    Object.values(state.chats).forEach(chat => {
        if (!chat.isGroup) {
            const charItem = document.createElement('div');
            charItem.className = 'clear-posts-item';
            charItem.dataset.charId = chat.id;
            charItem.innerHTML = `
                <div class="checkbox"></div>
                <span class="name">${chat.name} (角色)</span>
            `;
            listEl.appendChild(charItem);
        }
    });
}

/**
 * 【V2.0 | 已修正数据分类】渲染向导的第二步：数据类型选择列表
 */
function renderClearWizardStep2() {
    const listEl = document.getElementById('data-clear-type-list');
    listEl.innerHTML = '';
    
    const dataTypes = [
        { id: 'chat', name: '聊天记录', description: '将清空选定角色的所有对话消息。' },
        { id: 'qzone', name: '动态与互动', description: '将清空选定角色的所有动态、评论和点赞。' },
        { id: 'calls', name: '通话记录', description: '将清空选定角色的所有通话记录。' },
        // 【【【核心修正1：数据分类】】】
        { id: 'thoughts', name: '心声', description: '将清空选定角色的心声和散记历史。' },
        { id: 'memories', name: '长期记忆', description: '将清空选定角色的所有长期记忆。' },
        { id: 'cphone', name: 'Cphone数据 (CPhone)', description: '将清空角色的相册、QQ、浏览器、淘宝、日记、备忘录等所有模拟手机数据。' }
    ];

    dataTypes.forEach(type => {
        const item = document.createElement('div');
        item.className = 'clear-posts-item';
        item.dataset.typeId = type.id;
        item.innerHTML = `
            <div class="checkbox"></div>
            <div>
                <span class="name">${type.name}</span>
                <p style="font-size: 12px; color: #888; margin: 4px 0 0;">${type.description}</p>
            </div>
        `;
        listEl.appendChild(item);
    });
}


/**
 * 处理“下一步”按钮的点击事件
 */
function handleDataClearNext() {
    const selectedItems = document.querySelectorAll('#data-clear-char-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
        alert("请至少选择一个要清理的角色。");
        return;
    }

    selectedCharsForClear = Array.from(selectedItems).map(item => item.dataset.charId);
    
    // 渲染第二步并切换视图
    renderClearWizardStep2();
    document.getElementById('data-clear-step-1').style.display = 'none';
    document.getElementById('data-clear-step-2').style.display = 'flex';
}

/**
 * 处理“上一步”按钮的点击事件
 */
function handleDataClearBack() {
    document.getElementById('data-clear-step-2').style.display = 'none';
    document.getElementById('data-clear-step-1').style.display = 'flex';
    // 保留已选中的角色
    document.querySelectorAll('#data-clear-char-list .clear-posts-item').forEach(item => {
        if (selectedCharsForClear.includes(item.dataset.charId)) {
            item.classList.add('selected');
        }
    });
}

/**
 * 【V2.0 | 已修正数据分类】处理最终确认清理的逻辑
 */
async function handleConfirmDataClear() {
    const selectedItems = document.querySelectorAll('#data-clear-type-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
        alert("请至少选择一种要清理的数据类型。");
        return;
    }

    selectedTypesForClear = Array.from(selectedItems).map(item => item.dataset.typeId);

    const confirmed = await showCustomConfirm(
        '最后确认！',
        '此操作将永久删除您选择的所有数据，且无法恢复！确定要继续吗？',
        { confirmButtonClass: 'btn-danger', confirmText: '确认删除' }
    );

    if (!confirmed) return;
    
    await showCustomAlert("请稍候...", "正在执行清理操作，请不要关闭页面...");

    try {
        await db.transaction('rw', db.tables, async () => {
            for (const charId of selectedCharsForClear) {
                for (const type of selectedTypesForClear) {
                    
                    if (type === 'chat') {
                        if (charId === 'user') {
                            const allChats = await db.chats.toArray();
                            for (const chat of allChats) {
                                chat.history = chat.history.filter(msg => msg.role !== 'user');
                                await db.chats.put(chat);
                            }
                        } else {
                            const chat = await db.chats.get(charId);
                            if (chat) {
                                chat.history = [];
                                await db.chats.put(chat);
                            }
                        }
                    }

                    if (type === 'qzone') {
                        const authorId = (charId === 'user') ? 'user' : charId;
                        await db.qzonePosts.where('authorId').equals(authorId).delete();
                    }

                    if (type === 'calls' && charId !== 'user') {
                        await db.callRecords.where('chatId').equals(charId).delete();
                    }

                    // 【【【核心修正2：清理逻辑】】】
                    if (type === 'thoughts' && charId !== 'user') {
                        const chat = await db.chats.get(charId);
                        if (chat) {
                            chat.thoughtsHistory = [];
                            // 不再清理日记和备忘录
                            await db.chats.put(chat);
                        }
                    }

                    if (type === 'memories' && charId !== 'user') {
                        const chat = await db.chats.get(charId);
                        if (chat) {
                            chat.longTermMemory = [];
                            await db.chats.put(chat);
                        }
                    }
                    
                    if (type === 'cphone' && charId !== 'user') {
                        const chat = await db.chats.get(charId);
                        if (chat) {
                            // 清理所有CPhone相关数据，并加入日记和备忘录
                            chat.simulatedAlbum = [];
                            chat.simulatedConversations = [];
                            chat.simulatedBrowserHistory = [];
                            chat.simulatedTaobaoHistory = null;
                            chat.simulatedAmapHistory = [];
                            chat.simulatedAppUsage = [];
                            chat.simulatedMusicPlaylist = [];
                            chat.diary = []; // <-- 新增
                            chat.memos = []; // <-- 新增
                            await db.chats.put(chat);
                        }
                    }
                }
            }
        });
        
        await loadAllDataFromDB();
        await renderChatList();
        
        document.getElementById('data-clear-wizard-modal').classList.remove('visible');
        await showCustomAlert("清理完成", "指定的数据已成功清除。");

    } catch (error) {
        console.error("高级数据清理失败:", error);
        await showCustomAlert("清理失败", `操作失败: ${error.message}`);
    }
}
// ▲▲▲ 全新JS代码粘贴结束 ▲▲▲
        /**
         * 【全新 V2.0 | 支持本地上传】处理更换图标的逻辑 (EPhone & CPhone通用)
         * @param {string} iconId - 被点击图标的ID (例如 'qq', 'album')
         * @param {string} phoneType - 'ephone' 或 'cphone'
         * @param {HTMLElement} itemElement - 被点击的那个图标设置项的DOM元素
         */
        async function handleIconChange(iconId, phoneType, itemElement) {
            const appName = itemElement.querySelector('.icon-preview').alt;
        
            // 1. 弹出选择框，让用户选择上传方式
            const choice = await showChoiceModal(`更换“${appName}”图标`, [
                { text: '📁 从本地上传', value: 'local' },
                { text: '🌐 使用网络URL', value: 'url' }
            ]);
        
            let newUrl = null;
        
            // 2. 根据用户的选择执行不同操作
            if (choice === 'local') {
                // 调用我们现有的本地上传辅助函数
                newUrl = await uploadImageLocally();
            } else if (choice === 'url') {
                const currentUrl = (phoneType === 'cphone')
                    ? state.globalSettings.cphoneAppIcons[iconId]
                    : state.globalSettings.appIcons[iconId];

                // ★★★★★ 这就是本次修复的核心！ ★★★★★
                // 1. 判断当前的URL是不是一个Base64字符串
                const isBase64 = currentUrl.startsWith('data:image');

                // 2. 如果是Base64，我们就传一个空字符串作为默认值，避免卡死。
                //    如果不是，就正常显示当前的URL，方便用户修改。
                const initialValueForPrompt = isBase64 ? '' : currentUrl;
                // ★★★★★ 修复结束 ★★★★★

                // 3. 使用我们新处理过的值来调用弹窗
                newUrl = await showCustomPrompt(
                    `更换图标`, 
                    '请输入新的图片URL', 
                    initialValueForPrompt, // <-- 使用这个新变量
                    'url'
                );
            }
        
            // 3. 如果获取到了新值（无论是Base64还是URL），就更新并保存
            if (newUrl && newUrl.trim()) {
                const trimmedUrl = newUrl.trim();
                
                // 根据手机类型，更新 state 中对应的数据
                if (phoneType === 'cphone') {
                    state.globalSettings.cphoneAppIcons[iconId] = trimmedUrl;
                } else {
                    state.globalSettings.appIcons[iconId] = trimmedUrl;
                }
                
                // 实时更新设置页面的预览图
                itemElement.querySelector('.icon-preview').src = trimmedUrl;
                
                // 无需在这里保存到数据库，等待用户点击“保存所有外观设置”按钮时统一保存。
            } else if (newUrl !== null) {
                // 如果用户输入了无效的URL
                alert("请输入一个有效的URL或选择一个文件！");
            }
        }
// ▼▼▼ 【最终修复版】请用这个全新的、分步执行的函数，完整替换旧的 compressAllLocalImages ▼▼▼

/**
 * 【总入口 | V2.0 修复版】一键压缩数据库中所有本地上传的图片
 */
async function compressAllLocalImages() {
    // 1. 弹出最终确认框 (逻辑不变)
    const confirmed = await showCustomConfirm(
        '确认压缩图片？',
        '此操作将扫描并压缩所有本地上传的图片（Base64格式），将其转换为JPEG以减小体积。这会轻微降低图片质量且【不可恢复】。<br><br><strong>强烈建议在操作前先进行数据备份！</strong>',
        { confirmButtonClass: 'btn-danger', confirmText: '我已了解风险，确认压缩' }
    );

    if (!confirmed) return;

    // 2. 显示处理中的提示 (逻辑不变)
    await showCustomAlert("请稍候...", "正在开始全面压缩图片，根据图片数量，这可能需要几分钟时间，请不要关闭或刷新页面...");

    let stats = {
        found: 0,
        compressed: 0,
        skipped: 0,
        originalSize: 0,
        newSize: 0
    };

    try {
        // ==========================================================
        //            ★★★ 核心修复逻辑从这里开始 ★★★
        // ==========================================================
        
        // --- 步骤 A: 读取所有相关数据到内存 ---
        console.log("压缩步骤 1/3: 正在从数据库读取所有相关数据...");
        const tablesToScan = [
            'chats', 'globalSettings', 'qzoneSettings', 
            'userStickers', 'customAvatarFrames'
        ];
        const allData = [];
        for (const tableName of tablesToScan) {
            const table = db.table(tableName);
            const records = await table.toArray();
            allData.push({ tableName, records });
        }

        // --- 步骤 B: 在内存中对数据进行异步压缩 ---
        console.log("压缩步骤 2/3: 正在内存中异步压缩图片，这可能需要一些时间...");
        for (const data of allData) {
            for (const record of data.records) {
                // traverseAndCompress 函数现在是安全的，因为它不再处于一个开启的事务中
                await traverseAndCompress(record, stats);
            }
        }
        
        // --- 步骤 C: 开启一个新事务，将所有修改后的数据一次性写回数据库 ---
        console.log("压缩步骤 3/3: 正在将压缩后的数据写回数据库...");
        await db.transaction('rw', tablesToScan, async () => {
            for (const data of allData) {
                // 使用 bulkPut 批量更新，性能更佳
                await db.table(data.tableName).bulkPut(data.records);
            }
        });
        
        // ==========================================================
        //            ★★★ 核心修复逻辑到此结束 ★★★
        // ==========================================================

        // 4. 操作完成后，显示统计结果 (逻辑不变)
        const reduction = stats.originalSize - stats.newSize;
        const reductionPercent = stats.originalSize > 0 ? (reduction / stats.originalSize * 100).toFixed(2) : 0;

        await showCustomAlert(
            '压缩完成！',
            `扫描完成！<br>
            - 共找到 ${stats.found} 张本地图片<br>
            - 成功压缩 ${stats.compressed} 张<br>
            - 跳过(已压缩或无需压缩) ${stats.skipped} 张<br>
            - 空间节省了 <strong>${(reduction / 1024 / 1024).toFixed(2)} MB</strong> (压缩率 ${reductionPercent}%)
            <br><br>
            建议刷新页面以应用所有更改。`
        );

    } catch (error) {
        console.error("图片压缩过程中发生错误:", error);
        await showCustomAlert('压缩失败', `操作失败: ${error.message}`);
    }
}

// ▲▲▲ JS函数替换结束 ▲▲▲

/**
 * 【辅助函数】递归遍历对象，找到并压缩所有Base64图片
 * @param {object|Array} obj - 要遍历的对象或数组
 * @param {object} stats - 用于统计的对象
 */
async function traverseAndCompress(obj, stats) {
    for (const key in obj) {
        if (typeof obj[key] === 'string' && obj[key].startsWith('data:image')) {
            stats.found++;
            const originalBase64 = obj[key];
            stats.originalSize += originalBase64.length;

            const compressedBase64 = await compressImage(originalBase64);

            if (compressedBase64 && compressedBase64 !== originalBase64) {
                obj[key] = compressedBase64; // 直接修改原对象
                stats.compressed++;
                stats.newSize += compressedBase64.length;
            } else {
                stats.skipped++;
                stats.newSize += originalBase64.length;
            }
        } else if (typeof obj[key] === 'object' && obj[key] !== null) {
            // 如果是嵌套对象或数组，则继续递归
            await traverseAndCompress(obj[key], stats);
        }
    }
}

/**
 * 【核心压缩函数】将单个Base64图片字符串压缩为JPEG格式
 * @param {string} base64Str - 原始的Base64图片字符串
 * @param {object} options - 压缩选项 (质量、最大宽度)
 * @returns {Promise<string|null>} - 返回压缩后的Base64字符串，如果无需压缩或失败则返回原字符串
 */
function compressImage(base64Str, options = {}) {
    return new Promise((resolve) => {
        // 如果已经是JPEG，或者不是一个有效的图片字符串，则直接跳过
        if (base64Str.startsWith('data:image/jpeg') || !base64Str.startsWith('data:image')) {
            resolve(base64Str);
            return;
        }

        const quality = options.quality || 0.7; // 70%的JPEG质量
        const maxWidth = options.maxWidth || 1024; // 图片最大宽度限制为1024px

        const img = new Image();
        img.onload = () => {
            let width = img.width;
            let height = img.height;

            // 如果图片宽度超过最大限制，则等比缩放
            if (width > maxWidth) {
                height = (maxWidth / width) * height;
                width = maxWidth;
            }

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // 将图片绘制到canvas上
            ctx.drawImage(img, 0, 0, width, height);
            
            // 从canvas导出为JPEG格式的Base64字符串
            const newDataUrl = canvas.toDataURL('image/jpeg', quality);
            
            // 只有当压缩后的体积比原来小时才替换
            if (newDataUrl.length < base64Str.length) {
                resolve(newDataUrl);
            } else {
                resolve(base64Str); // 压缩后反而变大了，保留原图
            }
        };
        img.onerror = () => {
            console.warn("加载图片失败，跳过压缩:", base64Str.substring(0, 50) + "...");
            resolve(base64Str); // 加载失败，保留原图
        };
        img.src = base64Str;
    });
}
// ▲▲▲ JS代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】这是更新通知功能的【全部核心JS代码】，请完整粘贴 ▼▼▼

/**
 * 检查应用更新并根据版本决定是否显示通知
 */
async function checkForUpdates() {
    // 关键1：在你的主应用中定义当前的版本号。
    // 每次你希望用户看到更新通知时，都需要更新 `update-notice.html` 里的 `data-version`。
    // 这个版本号主要是为了逻辑完整性，但核心判断依据是通知文件里的版本。
    const CURRENT_APP_VERSION = "1.0"; 

    try {
        // 1. 从服务器获取最新的通知文件内容
        const response = await fetch('update-notice.html?_=' + Date.now()); // 添加时间戳防止缓存
        if (!response.ok) {
            console.warn('获取更新通知文件失败。');
            return;
        }
        const noticeHtml = await response.text();
        
        // 2. 解析通知内容和版本号
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = noticeHtml;
        const noticeContent = tempDiv.querySelector('[data-version]');
        
        if (!noticeContent) {
            console.error('更新通知文件中缺少 data-version 属性。');
            return;
        }
        
        const notificationVersion = noticeContent.dataset.version;
        
        // 3. 从本地存储中获取用户上次忽略的版本号
        const dismissedVersion = localStorage.getItem('dismissedUpdateVersion');
        
        // 4. 核心逻辑：如果通知版本号比用户忽略的版本号要新，就显示通知
        // 使用简单的字符串比较即可
        if (notificationVersion > dismissedVersion) {
            console.log(`发现新版本通知: ${notificationVersion} (已忽略版本: ${dismissedVersion})`);
            showUpdateNotice(notificationVersion, noticeContent.innerHTML);
        } else {
            console.log(`当前通知版本 (${notificationVersion}) 已被用户忽略，无需显示。`);
        }

    } catch (error) {
        console.error('检查更新时出错:', error);
    }
}

/**
 * 显示更新通知弹窗
 * @param {string} version - 当前通知的版本号
 * @param {string} contentHtml - 要显示的HTML内容
 */
function showUpdateNotice(version, contentHtml) {
    const modal = document.getElementById('update-notice-modal');
    const body = document.getElementById('update-notice-body');
    const confirmBtn = document.getElementById('update-notice-confirm-btn');
    const dismissBtn = document.getElementById('update-notice-dismiss-btn');
    
    body.innerHTML = contentHtml;
    
    // “我知道了”按钮：只关闭弹窗，不记录版本
    confirmBtn.onclick = () => {
        modal.classList.remove('visible');
    };
    
    // “不再提示”按钮：关闭弹窗，并将当前版本号存入localStorage
    dismissBtn.onclick = () => {
        localStorage.setItem('dismissedUpdateVersion', version);
        modal.classList.remove('visible');
        console.log(`用户已忽略版本: ${version}`);
    };
    
    modal.classList.add('visible');
}

// ▲▲▲ 新增JS代码结束 ▲▲▲
// ▼▼▼ 【全新】这是豆瓣设置功能的【全部核心JS代码】，请完整粘贴 ▼▼▼

/**
 * 【总入口】打开豆瓣设置弹窗
 */
function openDoubanSettingsModal() {
    const modal = document.getElementById('douban-settings-modal');
    
    // 从全局设置中读取已保存的值，如果没有就使用默认值
    document.getElementById('douban-min-posts-input').value = state.globalSettings.doubanMinPosts || 12;
    document.getElementById('douban-max-posts-input').value = state.globalSettings.doubanMaxPosts || 20;
    
    modal.classList.add('visible');
}

/**
 * 保存豆瓣设置
 */
async function saveDoubanSettings() {
    const minInput = document.getElementById('douban-min-posts-input');
    const maxInput = document.getElementById('douban-max-posts-input');
    
    const min = parseInt(minInput.value);
    const max = parseInt(maxInput.value);

    // 数据验证
    if (isNaN(min) || isNaN(max) || min < 1 || max < 1) {
        alert("请输入有效的正整数！");
        return;
    }
    if (min > max) {
        alert("最小帖子数不能大于最大帖子数！");
        return;
    }

    // 保存到全局状态和数据库
    state.globalSettings.doubanMinPosts = min;
    state.globalSettings.doubanMaxPosts = max;
    await db.globalSettings.put(state.globalSettings);

    // 关闭弹窗并提示用户
    document.getElementById('douban-settings-modal').classList.remove('visible');
    await showCustomAlert('保存成功', '豆瓣设置已更新！下次重新生成时将生效。');
}
// ▲▲▲ 新增JS代码粘贴结束 ▲▲▲
/**
 * 【全新 | V2.1 | 本名追踪版】打开狼人杀游戏大厅
 * @param {'global' | 'group'} mode - 模式：'global'表示从游戏小屋进入，'group'表示从群聊进入
 */
async function openWerewolfLobby(mode) {
    const modal = document.getElementById('werewolf-lobby-modal');
    const listEl = document.getElementById('werewolf-player-selection-list');
    listEl.innerHTML = '';
    
    let potentialPlayers = [];
    
    if (mode === 'global') {
        const characters = Object.values(state.chats).filter(c => !c.isGroup);
        const npcs = await db.npcs.toArray();
        potentialPlayers = [
            // 为用户添加本名
            { id: 'user', name: state.qzoneSettings.nickname || '我', originalName: state.qzoneSettings.nickname || '我', avatar: state.qzoneSettings.avatar, type: 'user' },
            // 为角色添加本名
            ...characters.map(c => ({ id: c.id, name: c.name, originalName: c.originalName, avatar: c.settings.aiAvatar, type: 'character' })),
            // 为NPC添加本名 (使用其昵称作为本名)
            ...npcs.map(n => ({ id: `npc_${n.id}`, name: n.name, originalName: n.name, avatar: n.avatar, type: 'npc' }))
        ];
        werewolfGameState.chatId = null;
    } else {
        const chat = state.chats[state.activeChatId];
        if (!chat || !chat.isGroup) return;
        
        potentialPlayers = [
            // 为用户添加本名
            { id: 'user', name: chat.settings.myNickname || '我', originalName: state.qzoneSettings.nickname || '我', avatar: chat.settings.myAvatar, type: 'user' },
            // 为群成员添加本名
            ...chat.members.map(m => {
                const char = state.chats[m.id];
                const memberAvatar = m.avatar || (char ? char.settings.aiAvatar : defaultGroupMemberAvatar);
                return { 
                    id: m.id, 
                    name: m.groupNickname, 
                    originalName: m.originalName, // 核心：记录本名
                    avatar: memberAvatar, 
                    type: m.isNpc ? 'npc' : 'character' 
                };
            })
        ];
        werewolfGameState.chatId = state.activeChatId;
    }

    potentialPlayers.forEach(player => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.innerHTML = `
            <input type="checkbox" class="werewolf-player-checkbox" data-player-json='${JSON.stringify(player)}' ${player.type === 'user' ? 'checked disabled' : 'checked'}>
            <img src="${player.avatar}" class="avatar">
            <span class="name">${player.name}</span>
        `;
        listEl.appendChild(item);
    });
    
    modal.classList.add('visible');
}

/**
         * 【V3.0 | 已添加女巫守卫】初始化一局新的狼人杀游戏
         */
        async function initializeWerewolfGame() {
            const selectedCheckboxes = document.querySelectorAll('.werewolf-player-checkbox:checked');
            const playerCount = selectedCheckboxes.length;

            let roles = [];
            if (playerCount === 6) {
                werewolfGameState.gameMode = '6p';
                roles = ['狼人', '狼人', '平民', '平民', '预言家', '猎人'];
            } else if (playerCount === 9) {
                werewolfGameState.gameMode = '9p';
                roles = ['狼人', '狼人', '狼人', '平民', '平民', '平民', '预言家', '女巫', '猎人'];
            } else if (playerCount === 12) {
                werewolfGameState.gameMode = '12p';
                roles = ['狼人', '狼人', '狼人', '狼人', '平民', '平民', '平民', '平民', '预言家', '女巫', '猎人', '守卫'];
            } else {
                alert(`当前人数 ${playerCount} 不支持。请选择6、9或12人。`);
                return;
            }

            document.getElementById('werewolf-lobby-modal').classList.remove('visible');
            await showCustomAlert('正在发牌...', '游戏即将开始，正在为各位玩家分配身份...');

            for (let i = roles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [roles[i], roles[j]] = [roles[j], roles[i]];
            }

            const selectedPlayers = Array.from(selectedCheckboxes).map(cb => JSON.parse(cb.dataset.playerJson));
            werewolfGameState.players = [];

            for (let i = 0; i < selectedPlayers.length; i++) {
                const playerInfo = selectedPlayers[i];
                const role = roles[i];
                
                let character_persona = "一个普通玩家";
                if (playerInfo.type === 'character') {
                    const char = state.chats[playerInfo.id];
                    character_persona = char ? char.settings.aiPersona : '未知设定的角色';
                } else if (playerInfo.type === 'npc') {
                    const npcs = await db.npcs.toArray();
                    const npc = npcs.find(n => `npc_${n.id}` === playerInfo.id);
                    character_persona = npc ? npc.persona : '未知设定的NPC';
                } else if (playerInfo.type === 'user') {
                    const activeChat = werewolfGameState.chatId ? state.chats[werewolfGameState.chatId] : null;
                    character_persona = activeChat ? activeChat.settings.myPersona : '我是谁呀。';
                }

                const playerObject = {
                    ...playerInfo,
                    role: role,
                    isAlive: true,
                    character_persona: character_persona
                };

                // ▼▼▼ 【核心新增：为特殊角色添加属性】 ▼▼▼
                if (role === '女巫') {
                    playerObject.antidoteUsed = false;
                    playerObject.poisonUsed = false;
                }
                if (role === '守卫') {
                    playerObject.lastGuardedId = null;
                }
                // ▲▲▲ 新增结束 ▲▲▲

                werewolfGameState.players.push(playerObject);
            }
            
            werewolfGameState.isActive = true;
            werewolfGameState.currentDay = 1;
            werewolfGameState.currentPhase = 'start';
            werewolfGameState.gameLog = [];
            werewolfGameState.discussionLog = [];

            const roleCounts = roles.reduce((acc, role) => { acc[role] = (acc[role] || 0) + 1; return acc; }, {});
            const roleSummary = Object.entries(roleCounts).map(([role, count]) => `${role} x${count}`).join('、');
            addGameLog(`游戏配置：${playerCount}人局，身份为 ${roleSummary}。`);

            const myPlayer = werewolfGameState.players.find(p => p.id === 'user');

            renderWerewolfScreen();
            showScreen('werewolf-game-screen');
            
            showMyRole(myPlayer.role);
        }

// ▼▼▼ 【V2.1 | 跨天显示修复版】请用这个全新的函数，完整替换旧的 renderWerewolfScreen ▼▼▼
/**
 * 【V2.1 | UI修复版】渲染狼人杀游戏主界面
 */
function renderWerewolfScreen() {
    const gridEl = document.getElementById('werewolf-player-grid');
    gridEl.innerHTML = '';
    const sortedPlayers = [...werewolfGameState.players].sort((a, b) => a.isAlive - b.isAlive);

    sortedPlayers.forEach((p, index) => {
        const playerIndex = werewolfGameState.players.findIndex(player => player.id === p.id) + 1;
        const avatarEl = document.createElement('div');
        avatarEl.className = 'werewolf-player-avatar';
        if (!p.isAlive) avatarEl.classList.add('dead');
        avatarEl.innerHTML = `
            <img src="${p.avatar}">
            <span class="player-name">${playerIndex}. ${p.name}</span>
        `;
        gridEl.appendChild(avatarEl);
    });

    const logEl = document.getElementById('werewolf-log');
    logEl.innerHTML = '';
    
    // 【【【核心修改：按天渲染日志】】】
    for (let day = 1; day <= werewolfGameState.currentDay; day++) {
        // 1. 筛选出当天的所有日志
        const logsThisDay = [
            ...werewolfGameState.gameLog.filter(entry => entry.day === day),
            ...werewolfGameState.discussionLog.filter(entry => entry.day === day)
        ].sort((a,b) => (a.timestamp || 0) - (b.timestamp || 0));

        // 如果当天有任何记录，就先添加一个天数标题
        if (logsThisDay.length > 0) {
            const dayHeader = document.createElement('div');
            dayHeader.className = 'werewolf-log-entry system';
            dayHeader.textContent = `--- 第 ${day} 天 ---`;
            dayHeader.style.cssText = 'font-weight: bold; background: rgba(255, 193, 7, 0.2);';
            logEl.appendChild(dayHeader);

            // 2. 渲染当天的每一条日志
            logsThisDay.forEach(entry => {
                const entryEl = document.createElement('div');
                entryEl.className = `werewolf-log-entry ${entry.type}`;
                if (entry.type === 'dialogue') {
                    entryEl.innerHTML = `<span class="speaker">${entry.speaker}:</span> ${entry.content}`;
                } else {
                    entryEl.textContent = entry.content;
                }
                logEl.appendChild(entryEl);
            });
        }
    }
    // 【【【修改结束】】】

    logEl.scrollTop = logEl.scrollHeight;
    
    // 在标题中明确显示天数和当前阶段
    const phaseMap = {
        'start': '游戏开始',
        'night': `第${werewolfGameState.currentDay}天 - 夜晚`,
        'day': `第${werewolfGameState.currentDay}天 - 白天`,
        'discussion': `第${werewolfGameState.currentDay}天 - 讨论`,
        'voting': `第${werewolfGameState.currentDay}天 - 投票`,
        'gameover': '游戏结束'
    };
    document.getElementById('werewolf-game-title').textContent = `狼人杀 - ${phaseMap[werewolfGameState.currentPhase] || werewolfGameState.currentPhase}`;
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 显示玩家自己的身份卡片
 * @param {string} role - 玩家的角色
 */
function showMyRole(role) {
    const roleDescriptions = {
        '狼人': '你的目标是杀死所有好人。每晚可以和同伴一起刀一个玩家。',
        '平民': '你没有任何特殊能力，你的目标是通过投票放逐所有狼人。',
        '预言家': '每晚可以查验一个玩家的身份是好人还是狼人。',
        '猎人': '当你死亡时，你可以选择带走场上任意一名玩家。',
        '女巫': '你有一瓶解药和一瓶毒药，解药可以救活当晚被杀的玩家，毒药可以毒死任意一名玩家。',
        '守卫': '每晚可以守护一名玩家，使其免受狼人袭击。不能连续两晚守护同一个人。'
    };
    
    document.getElementById('werewolf-role-name').textContent = role;
    document.getElementById('werewolf-role-description').textContent = roleDescriptions[role] || '一个神秘的角色。';
    document.getElementById('werewolf-role-modal').classList.add('visible');
}

/**
         * 【V3.0 | 已补全守卫女巫】执行夜晚阶段的逻辑
         */
        async function executeNightPhase() {
            werewolfGameState.currentPhase = `第${werewolfGameState.currentDay}天 - 夜晚`;
            werewolfGameState.nightActions = {}; // 重置当晚行动
            addGameLog('天黑请闭眼...');
            renderWerewolfScreen();
            
            document.getElementById('werewolf-action-bar').style.display = 'none';
            document.getElementById('werewolf-retry-btn').style.display = 'none'; // 隐藏重试按钮
            await new Promise(resolve => setTimeout(resolve, 1500));
        
            // 1. 守卫行动 (最先行动)
            const guard = werewolfGameState.players.find(p => p.role === '守卫' && p.isAlive);
            if (guard) {
                addGameLog('守卫请睁眼，请选择要守护的玩家。');
                renderWerewolfScreen();
                let guardedId = null;
                if (guard.id === 'user') {
                    guardedId = await openSelectionModal('guard', guard.lastGuardedId);
                } else { // AI守卫
                    const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== guard.lastGuardedId);
                    if (potentialTargets.length > 0) {
                        guardedId = potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
                    }
                }
                if (guardedId) {
                    werewolfGameState.nightActions.guardedId = guardedId;
                    guard.lastGuardedId = guardedId; // 记录本轮守护的人
                }
                addGameLog('守卫已行动，守卫请闭眼。');
                renderWerewolfScreen();
                await new Promise(resolve => setTimeout(resolve, 1500));
            }

            // ▼▼▼ 【【【核心修改：狼人行动错误处理】】】 ▼▼▼
            // ▼▼▼ 【【【核心修复：第一夜狼人行动特殊处理】】】 ▼▼▼
            addGameLog('狼人请睁眼，请选择要刀的玩家。');
            renderWerewolfScreen();
            
            const wolves = werewolfGameState.players.filter(p => p.role === '狼人' && p.isAlive);
            const userIsWolf = wolves.some(p => p.id === 'user');
            
            let wolfTargetId = null;

            // 标记当前操作，以便重试
            werewolfGameState.lastFailedAction = 'wolfKill';
            try {
                if (userIsWolf) {
                    addGameLog('你是狼人，请选择刀人目标。');
                    renderWerewolfScreen();
                    wolfTargetId = await openWolfKillModal();
                } else {
                    // 如果是第一天，则执行本地随机刀人，不调用API
                    if (werewolfGameState.currentDay === 1) {
                        console.log("第一夜，执行本地随机刀人逻辑...");
                        const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.role !== '狼人');
                        if (potentialTargets.length > 0) {
                            wolfTargetId = potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
                        }
                    } else {
                        // 从第二天开始，才调用API进行智能决策
                        wolfTargetId = await getAiWolfKillTarget();
                    }
                }
                // 如果成功，清除失败标记
                werewolfGameState.lastFailedAction = null;
            } catch (error) {
                console.error("狼人行动API失败:", error);
                await showCustomAlert("操作失败", "AI狼人团队无法决定目标，游戏暂停。请点击右上角的“重试”按钮继续。");
                document.getElementById('werewolf-retry-btn').style.display = 'block';
                return;
            }
            // ▲▲▲ 【【【修改结束】】】 ▲▲▲
            werewolfGameState.nightActions.killedId = wolfTargetId;
            addGameLog('狼人已行动，狼人请闭眼。');
            renderWerewolfScreen();
            await new Promise(resolve => setTimeout(resolve, 1500));

            // 3. 女巫行动
            const witch = werewolfGameState.players.find(p => p.role === '女巫' && p.isAlive);
            if (witch) {
                addGameLog('女巫请睁眼。');
                renderWerewolfScreen();
                const killedPlayer = werewolfGameState.players.find(p => p.id === werewolfGameState.nightActions.killedId);
                
                // 判断是否是守卫守护的目标
                const isGuarded = werewolfGameState.nightActions.guardedId === werewolfGameState.nightActions.killedId;

                // 女巫只能看到狼人刀的人，如果被守卫守了，女巫看到的就是平安夜
                const playerToShowWitch = (isGuarded || !killedPlayer) ? null : killedPlayer;

                if (witch.id === 'user') {
                    let userWitchAction = await openWitchActionModal(playerToShowWitch, witch);
                    if (userWitchAction.save) {
                        werewolfGameState.nightActions.savedId = werewolfGameState.nightActions.killedId;
                        witch.antidoteUsed = true;
                    }
                    if (userWitchAction.poison) {
                        werewolfGameState.nightActions.poisonedId = userWitchAction.poison;
                        witch.poisonUsed = true;
                    }
                } else { // AI女巫
                    // AI女巫的全新决策逻辑
                    if (!witch.antidoteUsed && playerToShowWitch) {
                        let saveChance = 0;
                        if (werewolfGameState.currentDay === 1) {
                            // 第一天晚上，信息很少，救人的风险很高。只有30%的几率会冒险救人。
                            saveChance = 0.3; 
                        } else {
                            // 从第二天晚上开始，信息增多，救人的价值更大，有80%的几率会救人。
                            saveChance = 0.8;
                        }
                        
                        console.log(`AI女巫决策：今天是第${werewolfGameState.currentDay}天，救人概率为 ${saveChance * 100}%`);
                        
                        if (Math.random() < saveChance) {
                            console.log("AI女巫决定使用解药！");
                            werewolfGameState.nightActions.savedId = werewolfGameState.nightActions.killedId;
                            witch.antidoteUsed = true;
                        } else {
                            console.log("AI女巫决定保留解药。");
                        }
                    } 
                    
                    // 毒人逻辑保持不变：如果没有救人，并且有毒药，则有50%概率毒人
                    if (!werewolfGameState.nightActions.savedId && !witch.poisonUsed && Math.random() < 0.5) {
                        const poisonTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== werewolfGameState.nightActions.killedId);
                        if (poisonTargets.length > 0) {
                             const target = poisonTargets[Math.floor(Math.random() * poisonTargets.length)];
                             werewolfGameState.nightActions.poisonedId = target.id;
                             witch.poisonUsed = true;
                             console.log(`AI女巫决定使用毒药，目标是: ${target.name}`);
                        }
                    }

                }
                addGameLog('女巫已行动，女巫请闭眼。');
                renderWerewolfScreen();
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
        
            // 4. 预言家行动
            const prophet = werewolfGameState.players.find(p => p.role === '预言家' && p.isAlive);
            if (prophet) {
                addGameLog('预言家请睁眼，请选择要查验的玩家。');
                renderWerewolfScreen();
        
                if (prophet.id === 'user') {
                    const targetId = await openSelectionModal('prophet');
                    const targetPlayer = werewolfGameState.players.find(p => p.id === targetId);
                    if(targetPlayer) {
                        const isWolf = targetPlayer.role === '狼人';
                        await showCustomAlert('查验结果', `你查验的玩家 ${targetPlayer.name} 的身份是：${isWolf ? '狼人' : '好人'}`);
                        werewolfGameState.nightActions.prophetCheck = { target: targetId, result: isWolf ? '狼人' : '好人' };
                    }
                } else {
                    const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== prophet.id);
                    if (potentialTargets.length > 0) {
                        const target = potentialTargets[Math.floor(Math.random() * potentialTargets.length)];
                        werewolfGameState.nightActions.prophetCheck = { target: target.id, result: target.role === '狼人' ? '狼人' : '好人' };
                    }
                }
                addGameLog('预言家已行动，预言家请闭眼。');
                renderWerewolfScreen();
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
            
            // 5. 进入白天
            executeDayPhase();
        }
        
/**
         * 【V3.0 | 已补全死亡结算】执行白天阶段的逻辑
         */
        async function executeDayPhase() {
            werewolfGameState.currentPhase = `第${werewolfGameState.currentDay}天 - 白天`;
            werewolfGameState.voteResults = {};
            addGameLog('天亮了。');

            const { killedId, guardedId, savedId, poisonedId } = werewolfGameState.nightActions;
            const deathsThisNight = new Set(); // 使用 Set 来避免重复添加死亡玩家

            // 1. 计算狼人刀人结果
            if (killedId && killedId !== guardedId && killedId !== savedId) {
                deathsThisNight.add(killedId);
            }

            // 2. 计算女巫毒人结果
            if (poisonedId) {
                // 如果女巫救人和毒人是同一个人，则毒药优先，该玩家死亡
                deathsThisNight.add(poisonedId);
            }

            // 3. 公布死亡结果并处理技能
            if (deathsThisNight.size === 0) {
                addGameLog('昨晚是平安夜。');
            } else {
                for (const deadPlayerId of deathsThisNight) {
                    const deadPlayer = werewolfGameState.players.find(p => p.id === deadPlayerId);
                    if (deadPlayer && deadPlayer.isAlive) {
                        deadPlayer.isAlive = false;
                        addGameLog(`昨晚 ${deadPlayer.name} 死亡了。`);

                        // 猎人技能处理
                        if (deadPlayer.role === '猎人') {
                            addGameLog('猎人死亡，请选择一名玩家带走！');
                            renderWerewolfScreen();
                            let hunterTargetId = null;
                            if (deadPlayer.id === 'user') {
                                hunterTargetId = await openSelectionModal('hunter');
                            } else { 
                                const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== deadPlayer.id);
                                if (potentialTargets.length > 0) {
                                    hunterTargetId = potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
                                }
                            }
                            const targetPlayer = werewolfGameState.players.find(p => p.id === hunterTargetId);
                            if(targetPlayer) {
                                targetPlayer.isAlive = false;
                                addGameLog(`猎人带走了 ${targetPlayer.name}。`);
                            }
                        }
                    }
                }
            }
            
            renderWerewolfScreen();
        
            if (checkGameOver()) return;
        
            await startDiscussionPhase();
        }
        
// ▼▼▼ 【V2.0 | 已修复】请用这个全新的函数，完整替换旧的 startDiscussionPhase ▼▼▼
/**
 * 【V2.0 | 已修复】开始讨论环节
 */
async function startDiscussionPhase() {
    // 【【【核心修复】：不再清空讨论记录！】】】
    // werewolfGameState.discussionLog = []; // <--- 确保这一行已被删除或注释掉！
    
    addGameLog('现在开始讨论，请各位玩家依次发言。');
    renderWerewolfScreen();
    
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('API未配置，无法生成对话。');
        return;
    }

    const systemPrompt = buildWerewolfPrompt();
    werewolfGameState.lastFailedAction = 'startDiscussion';
    try {
        await showCustomAlert("请稍候", "正在等待AI角色们进行激烈的讨论...");

        let isGemini = proxyUrl.includes('generativelanguage');
        let messagesForApi = [{role: 'user', content: '请所有AI角色根据你们的身份和人设开始发言。'}];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.95,
                })
            });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`API 错误: ${errorData.error.message}`);
        }
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch) {
            throw new Error(`AI返回的讨论内容格式不正确。原始返回: ${aiResponseContent}`);
        }
        const dialogues = JSON.parse(jsonMatch[0]);

        for (const dialogue of dialogues) {
            if(dialogue.speaker_name && dialogue.dialogue) {
                addDialogueLog(dialogue.speaker_name, dialogue.dialogue);
                renderWerewolfScreen();
                await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));
            }
        }
        
        werewolfGameState.lastFailedAction = null; 

    } catch(error) {
        console.error("狼人杀AI讨论生成失败:", error);
        await showCustomAlert("AI 发言失败", `讨论无法开始，游戏暂停。请点击右上角的“重试”按钮继续。\n错误: ${error.message}`);
        document.getElementById('werewolf-retry-btn').style.display = 'block';
        return;
    }

    const myPlayer = werewolfGameState.players.find(p => p.id === 'user');
    const actionBar = document.getElementById('werewolf-action-bar');
    const waitReplyBtn = document.getElementById('werewolf-wait-reply-btn');
    const finishSpeechBtn = document.getElementById('werewolf-finish-speech-btn');
    const userInput = document.getElementById('werewolf-user-input');

    actionBar.style.display = 'flex';

    if (myPlayer && myPlayer.isAlive) {
        waitReplyBtn.textContent = '等待回应';
        finishSpeechBtn.textContent = '结束发言';
        waitReplyBtn.style.display = 'block';
        finishSpeechBtn.style.display = 'block';
        userInput.disabled = false;
        userInput.placeholder = "轮到你发言了...";
        userInput.focus();
        
        const newWaitBtn = waitReplyBtn.cloneNode(true);
        waitReplyBtn.parentNode.replaceChild(newWaitBtn, waitReplyBtn);
        newWaitBtn.addEventListener('click', handleWerewolfWaitReply);

        const newFinishBtn = finishSpeechBtn.cloneNode(true);
        finishSpeechBtn.parentNode.replaceChild(newFinishBtn, finishSpeechBtn);
        newFinishBtn.addEventListener('click', handleUserWerewolfSpeech);

    } else {
        addGameLog('你已经死亡，无法发言。请等待其他玩家发言结束。');
        renderWerewolfScreen();
        
        waitReplyBtn.textContent = '继续讨论';
        finishSpeechBtn.textContent = '进入投票';
        waitReplyBtn.style.display = 'block';
        finishSpeechBtn.style.display = 'block';
        userInput.disabled = true;
        userInput.placeholder = "你已死亡，正在围观...";

        const newWaitBtn = waitReplyBtn.cloneNode(true);
        waitReplyBtn.parentNode.replaceChild(newWaitBtn, waitReplyBtn);
        newWaitBtn.addEventListener('click', handleAiContinueDiscussion);

        const newFinishBtn = finishSpeechBtn.cloneNode(true);
        finishSpeechBtn.parentNode.replaceChild(newFinishBtn, finishSpeechBtn);
        newFinishBtn.addEventListener('click', startVotingPhase);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【V3.4 | 称呼修复版】构建用于生成所有AI讨论的System Prompt
 */
function buildWerewolfPrompt() {
    const alivePlayers = werewolfGameState.players.filter(p => p.isAlive);
    const myPlayerObject = werewolfGameState.players.find(p => p.id === 'user');
    const myPlayerName = myPlayerObject ? myPlayerObject.name : '用户';
    const isUserAlive = alivePlayers.some(p => p.id === 'user');

    // 角色档案部分
    let charactersAndPlayersDossier = "# 角色与玩家档案 (Character & Player Dossiers)\n";
    alivePlayers.forEach((p, i) => {
        const playerIndex = werewolfGameState.players.findIndex(player => player.id === p.id) + 1;
        // 【核心修改1】在这里同时提供了昵称和本名，并明确指示了本名的用途
        charactersAndPlayersDossier += `
## ${playerIndex}号玩家: ${p.name} (这是TA的昵称)
- **本名 (你在对话中必须用这个名字称呼TA)**: ${p.originalName}
- **身份**: ${p.id === 'user' ? '【用户 (User)】' : '【AI角色】'}
- **人设 (必须严格遵守)**: ${p.character_persona}
`;
        
        if (p.type === 'character') {
            const char = state.chats[p.id];
            if (char && char.longTermMemory && char.longTermMemory.length > 0) {
                const memoryContent = char.longTermMemory.map(mem => mem.content).join('; ');
                charactersAndPlayersDossier += `- **长期记忆 (必须参考)**: ${memoryContent}\n`;
            }
        }
    });

    // (后续的事件总结、历史回顾、秘密信息等部分保持不变)
    let nightEventSummary = "# 昨晚事件总结 (Night Event Summary)\n";
    const deathsThisNight = werewolfGameState.gameLog.filter(entry => entry.content.includes('死亡了') && entry.day === werewolfGameState.currentDay);
    if (deathsThisNight.length === 0) {
         nightEventSummary += "- 昨晚是平安夜，无人死亡。\n";
    } else {
        deathsThisNight.forEach(death => {
            nightEventSummary += `- ${death.content}\n`;
        });
    }
    let previousDaysSummary = "# 前几日完整历史回顾 (Full Recap of Previous Days)\n";
    if (werewolfGameState.currentDay > 1) {
        for (let day = 1; day < werewolfGameState.currentDay; day++) {
            previousDaysSummary += `\n**--- 第 ${day} 天 ---**\n`;
            const eventsThisDay = werewolfGameState.gameLog.filter(entry => entry.day === day && (entry.content.includes('死亡') || entry.content.includes('放逐')));
            if (eventsThisDay.length > 0) {
                previousDaysSummary += `*事件*: ${eventsThisDay.map(e => e.content).join(' ')}\n`;
            } else {
                previousDaysSummary += "*事件*: 平安夜，无人出局。\n";
            }
            const discussionsThisDay = werewolfGameState.discussionLog.filter(entry => entry.day === day);
            if (discussionsThisDay.length > 0) {
                previousDaysSummary += `*讨论记录*:\n${discussionsThisDay.map(d => `- ${d.speaker}: ${d.content}`).join('\n')}\n`;
            }
        }
    } else {
        previousDaysSummary += "(今天是第一天，没有历史记录)\n";
    }
    let secretInfo = "### 你的秘密信息 (此部分只有你作为AI导演能看到)\n";
    alivePlayers.forEach(p => {
        if (p.id !== 'user') {
            secretInfo += `#### ${p.name}的秘密档案：\n- 你的狼人杀身份是：【${p.role}】\n`;
            if (p.role === '狼人') {
                const teammates = werewolfGameState.players.filter(t => t.role === '狼人' && t.id !== p.id).map(t => t.name).join('、');
                secretInfo += `- 你的狼队友是：${teammates || '无'}\n`;
                const killedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.killedId);
                secretInfo += `- 你们昨晚尝试攻击的玩家是：${killedPlayer ? killedPlayer.name : '空刀'}\n`;
            }
            if (p.role === '预言家' && werewolfGameState.nightActions.prophetCheck) {
                const checkedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.prophetCheck.target);
                secretInfo += `- 你昨晚查验了 ${checkedPlayer.name}，TA的身份是：【${werewolfGameState.nightActions.prophetCheck.result}】\n`;
            }
            if (p.role === '女巫') {
                if (werewolfGameState.nightActions.savedId) {
                    const savedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.savedId);
                    secretInfo += `- 你昨晚用解药救了 ${savedPlayer.name}。\n`;
                }
                if (werewolfGameState.nightActions.poisonedId) {
                    const poisonedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.poisonedId);
                    secretInfo += `- 你昨晚用毒药毒了 ${poisonedPlayer.name}。\n`;
                }
                secretInfo += `- 你的解药状态：${p.antidoteUsed ? '已使用' : '未使用'}\n`;
                secretInfo += `- 你的毒药状态：${p.poisonUsed ? '已使用' : '未使用'}\n`;
            }
            if (p.role === '守卫') {
                if (werewolfGameState.nightActions.guardedId) {
                    const guardedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.guardedId);
                    secretInfo += `- 你昨晚守护了 ${guardedPlayer.name}。\n`;
                } else {
                    secretInfo += `- 你昨晚空守了。\n`;
                }
            }
            secretInfo += '\n';
        }
    });
    let discussionHistoryContext = "# 今日完整讨论记录 (Today's Full Discussion Record)\n";
    const todayDiscussions = werewolfGameState.discussionLog.filter(entry => entry.day === werewolfGameState.currentDay);
    if (todayDiscussions.length > 0) {
        discussionHistoryContext += todayDiscussions.map(d => `- **${d.speaker}**: ${d.content}`).join('\n');
    } else {
        discussionHistoryContext += "(你是第一个发言的人)";
    }

    // 最终的Prompt
    const prompt = `
# 你的任务
你是一个狼人杀游戏导演。你的任务是扮演【除了${isUserAlive ? `用户(${myPlayerName})` : `已死亡的用户(${myPlayerName})`}以外】的所有AI角色，并根据他们的【角色人设】和【狼人杀身份】，生成一整轮符合逻辑、充满博弈的发言。

# 身份与人设铁律 (最高优先级)
你【必须】为每一个角色都仔细阅读并严格遵守下面的档案。这是你所有行为和发言的唯一依据。在对话中，请务必注意角色人设中暗示的性别，并使用正确的称呼（例如“他”或“她”）。

${charactersAndPlayersDossier}

# 游戏规则
- ${werewolfGameState.gameMode === '12p' ? '屠边局：狼人杀死所有神职或所有平民即获胜。' : '屠城局：狼人杀死所有好人即获胜。'}
- 好人胜利：放逐所有狼人。

# 当前游戏状态
- 今天是第 ${werewolfGameState.currentDay} 天的讨论环节。
${nightEventSummary} 
- 存活玩家: ${alivePlayers.map(p => `${p.name} (${p.id === 'user' ? '用户' : 'AI'})`).join(', ')}

# 【【【角色策略指南 (至关重要！)】】】
你的发言【必须】体现出高水平的、类似真人的策略博弈，而不是简单地陈述事实。

### **神职角色 (预言家, 女巫, 猎人, 守卫) 策略**
1.  **【隐藏优先！】**: 你的首要任务是活下去。**绝对不要**在第一天就轻易暴露自己的神职身份！这会让你立刻成为狼人的目标。
2.  **【暗示而非明示】**: 你应该用更委婉、更聪明的语言来传递信息，而不是直接说“我是预言家，我查了A”。
    *   **预言家可以说**: “我对X玩家的身份有一些看法，我觉得他发言很阳光。” 或 “Y玩家的发言让我感到很不舒服，我把他列为重点怀疑对象。”
    *   **女巫可以说**: “昨晚的信息很有趣，场上局势可能和大家想的不一样。”
3.  **【何时起跳？】**: 只有在以下【危急情况】下，你才应该考虑暴露自己的身份（俗称“起跳”）：
    *   **被投票时**: 当你即将被投票放逐时，必须起跳自证身份来求生。
    *   **关键信息**: 当你掌握了可以决定胜负的信息时（例如预言家查到了最后一个狼人）。
    *   **有人悍跳**: 当有狼人假扮你的身份时，你必须站出来与他对峙，争夺好人的信任。

### **狼人角色策略**
1.  **【积极伪装】**: 你需要扮演一个好人，最好是伪装成某个神职（俗称“悍跳”），来扰乱好人的判断，骗取他们的信任。
2.  **【制造混乱】**: 你的发言应该引导好人去怀疑其他无辜的好人。可以故意曲解别人的发言，或者制造逻辑陷阱。
3.  **【团队合作】**: 如果你的狼队友被怀疑，你应该想办法为他辩护，或者通过攻击其他玩家来转移焦点。

### **平民角色策略**
1.  **【逻辑为王】**: 你是场上的“法官”。你的核心任务是仔细倾听每个人的发言，找出其中的逻辑漏洞和矛盾之处。
2.  **【积极分析】**: 不要只是说“我不知道，我过了”。你应该大胆说出你的怀疑，并解释你的理由。例如：“A玩家说B是狼人，但是他的理由很牵强，所以我更怀疑A。”
3.  **【跟票与站边】**: 在你相信某位神职玩家后，你应该坚定地支持他，并号召其他好人一起投票给神职指认的狼人。

# 其他核心指令 (必须遵守)
1.  **互动铁律**: 角色之间【必须】互相质疑、支持、分析【本轮已有发言】。你【绝对不能】无视 ${myPlayerName} (用户) 或其他AI的发言，必须对他们的观点和逻辑做出回应。
2.  **记忆力与连贯性**: 你的新发言【必须】是基于**过去几天和今天发生的所有事件和讨论**的逻辑延续。

// 【核心修改2】明确了JSON格式中 speaker_name 和对话中称呼的不同要求
3.  **格式铁律**: 你的回复【必须且只能】是一个JSON数组，格式为: \`{"speaker_name": "角色的【昵称】", "dialogue": "发言内容"}\`。**必须**为每一个存活的AI角色都生成一段发言。
4.  **称呼铁律**: 你的发言中【绝对禁止】提及任何玩家的编号。在对话中互相称呼时，你【必须】使用玩家的【本名】，而不是他们的昵称。

# ${previousDaysSummary}

# ${discussionHistoryContext}

${secretInfo}

现在，请为所有【存活的AI角色】生成他们充满策略和博弈的发言。`;
    
        return prompt;
    }
/**
         * 【全新 | V2.1 无编号版】创建一个详细的、供AI分析的狼人杀游戏完整日志
         * @param {object} gameState - 当前的游戏状态对象
         * @returns {string} - 格式化后的游戏完整日志字符串
         */
        function createWerewolfGameSummary(gameState) {
            let summary = `--- 狼人杀对局完整复盘 ---\n\n`;
            const winner = gameState.gameLog.find(log => log.content.includes('胜利'))?.content || '胜负未分';
            summary += `### 最终结果: ${winner}\n\n`;

            summary += "### 玩家身份配置:\n";
            // ▼▼▼ 核心修改就在这里 ▼▼▼
            // 移除了 forEach 中的 index 和 "号玩家" 的字样
            gameState.players.forEach(player => {
                const status = player.isAlive ? "存活" : "已死亡";
                summary += `- ${player.name}: ${player.role} (${status})\n`;
            });
            // ▲▲▲ 修改结束 ▲▲▲

            summary += "\n### 详细对局流程:\n";
            for (let day = 1; day <= gameState.currentDay; day++) {
                summary += `\n**--- 第 ${day} 天 ---**\n`;

                // 夜晚事件
                const nightEvents = gameState.gameLog.filter(entry => entry.day === day && (entry.content.includes('死亡')));
                if (nightEvents.length > 0) {
                    summary += `**[夜晚]** ${nightEvents.map(e => e.content).join(' ')}\n`;
                } else if (day > 1 || (day === 1 && gameState.currentDay > 1)) {
                    summary += `**[夜晚]** 平安夜。\n`;
                }
                
                // 白天讨论
                const discussionsThisDay = gameState.discussionLog.filter(entry => entry.day === day);
                if (discussionsThisDay.length > 0) {
                    summary += `**[讨论环节]**\n${discussionsThisDay.map(d => `- ${d.speaker}: ${d.content}`).join('\n')}\n`;
                }

                // 投票与放逐
                const voteLog = gameState.gameLog.find(entry => entry.day === day && entry.content.includes('被投票放逐'));
                if(voteLog) {
                    summary += `**[投票结果]** ${voteLog.content}\n`;
                }
            }

            summary += "\n--- 复盘结束 ---";
            return summary;
        }

/**
         * 【全新 V3.0 | 统一客观复盘版】将完整的游戏总结注入到所有参与的AI角色的长期记忆中
         * @param {string} summary - 完整的游戏总结文本
         * @returns {Promise<number>} - 返回成功注入记忆的角色数量
         */
        async function injectSummaryIntoMemories(summary) {
            let injectedCount = 0;
            // 1. 遍历所有参与过游戏的玩家
            for (const player of werewolfGameState.players) {
                // 2. 只为AI角色（非用户、非纯NPC）注入记忆
                if (player.type === 'character') {
                    const chat = state.chats[player.id];
                    if (chat) {
                        // 3. 创建新的记忆对象，内容就是完整的、未经修改的总结
                        const newMemory = {
                            content: summary, // Directly use the full summary
                            timestamp: Date.now(),
                            source: 'werewolf_summary'
                        };
                        if (!chat.longTermMemory) {
                            chat.longTermMemory = [];
                        }
                        chat.longTermMemory.push(newMemory);
                        // 4. 更新数据库
                        await db.chats.put(chat);
                        injectedCount++;
                    }
                }
            }
            return injectedCount;
        }

/**
         * 【全新 | V2.0 已修复】手动触发狼人杀游戏总结的入口函数
         */
        async function handleManualWerewolfSummary() {
            if (!werewolfGameState.isActive && werewolfGameState.currentPhase === 'gameover') {
                await showCustomAlert("请稍候...", "正在为所有AI角色生成并注入游戏记忆...");
                try {
                    const summary = createWerewolfGameSummary(werewolfGameState);
                    
                    // ▼▼▼ 核心修复就在这里！▼▼▼
                    // 调用了新的、正确的函数名
                    const count = await injectSummaryIntoMemories(summary); 
                    // ▲▲▲ 修复结束 ▲▲▲

                    await showCustomAlert("成功", `游戏记忆已成功注入到 ${count} 位AI角色的长期记忆中！`);
                } catch (error) {
                    console.error("手动注入狼人杀记忆失败:", error);
                    await showCustomAlert("失败", `手动注入记忆时出错: ${error.message}`);
                }
            } else {
                alert("游戏尚未结束，无法进行总结。");
            }
        }
/**
         * 【全新 V2.1 | 已集成自动总结】结束游戏并显示结果
         * @param {string} winner - 获胜方, '好人' 或 '狼人'
         */
        async function endGame(winner) {
            werewolfGameState.isActive = false;
            werewolfGameState.currentPhase = 'gameover';

            // 记录胜利日志，以便总结时使用
            addGameLog(`${winner}阵营胜利！`);
            
            document.getElementById('werewolf-game-over-title').textContent = `${winner}胜利！`;
            let reason = '';
            if (winner === '好人') {
                reason = '所有狼人已被放逐，好人阵营获得了胜利！';
            } else {
                reason = '狼人数量已达到胜利条件，狼人阵营获得了胜利！';
            }
            const reasonEl = document.getElementById('werewolf-game-over-reason');
            reasonEl.textContent = reason;

            const roleListEl = document.getElementById('werewolf-role-reveal-list');
            roleListEl.innerHTML = ''; 

            const sortedPlayers = [...werewolfGameState.players].sort((a, b) => {
                const aIndex = werewolfGameState.players.findIndex(p => p.id === a.id);
                const bIndex = werewolfGameState.players.findIndex(p => p.id === b.id);
                return aIndex - bIndex;
            });

            sortedPlayers.forEach((player, index) => {
                const itemEl = document.createElement('div');
                itemEl.style.cssText = `display: flex; align-items: center; padding: 8px 0; border-bottom: 1px solid #444; color: white;`;
                if (index === sortedPlayers.length - 1) itemEl.style.borderBottom = 'none';
                const roleColor = player.role === '狼人' ? '#ff4d4d' : '#52c41a';
                itemEl.innerHTML = `
                    <img src="${player.avatar}" style="width: 30px; height: 30px; border-radius: 50%; margin-right: 12px; filter: ${player.isAlive ? 'none' : 'grayscale(100%)'};">
                    <span style="flex-grow: 1; text-align: left; text-decoration: ${player.isAlive ? 'none' : 'line-through'};">${index + 1}. ${player.name}</span>
                    <strong style="color: ${roleColor};">${player.role}</strong>
                `;
                roleListEl.appendChild(itemEl);
            });

            document.getElementById('werewolf-game-over-modal').classList.add('visible');

            // ▼▼▼ 【核心修改：调用新的总结流程】 ▼▼▼
            try {
                console.log("游戏结束，开始自动总结并注入记忆...");
                // 1. 生成完整的游戏日志
                const summaryContext = createWerewolfGameSummary(werewolfGameState);
                // 2. 将日志交给AI生成个性化记忆并注入
                const count = await generateAndInjectWerewolfMemories(summaryContext);
                console.log(`狼人杀游戏总结已自动存入 ${count} 位角色的记忆中。`);
            } catch (error) {
                console.error("自动总结狼人杀游戏失败:", error);
                if (reasonEl) {
                    reasonEl.innerHTML += '<br><small style="color: #ff8a80; margin-top: 10px; display: block;">自动记忆总结失败，可稍后手动尝试。</small>';
                }
            }
            // ▲▲▲ 修改结束 ▲▲▲
        }

// ▼▼▼ 【最终修复版】请用这整块代码，完整替换旧的 addGameLog 和 addDialogueLog 函数 ▼▼▼

function addGameLog(content) {
    // 【核心修改】在记录日志时，把当前是第几天也一起存进去
    werewolfGameState.gameLog.push({ 
        type: 'system', 
        content, 
        timestamp: Date.now(), 
        day: werewolfGameState.currentDay // <-- 新增这一行
    });
}

function addDialogueLog(speaker, content) {
    // 【核心修改】在这里也一样
    werewolfGameState.discussionLog.push({ 
        type: 'dialogue', 
        speaker, 
        content, 
        timestamp: Date.now(),
        day: werewolfGameState.currentDay // <-- 新增这一行
    });
}

// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【V2.0 | 已修复】打开一个通用的选择弹窗
 */
function openSelectionModal(type) {
    return new Promise(resolve => {
        const modalId = `werewolf-${type}-modal`;
        const listId = `werewolf-${type}-selection-list`;
        let confirmBtnId = '';
        if(type === 'prophet') confirmBtnId = 'confirm-prophet-check-btn';
        if(type === 'hunter') confirmBtnId = 'confirm-hunter-shot-btn';
        if(type === 'vote') confirmBtnId = 'confirm-vote-btn';

        const modal = document.getElementById(modalId);
        const listEl = document.getElementById(listId);
        const confirmBtn = document.getElementById(confirmBtnId);
        
        listEl.innerHTML = '';
        let selectedId = null;
        
        // 猎人可以射击任何人，预言家不能验自己，投票可以投任何人
        const potentialTargets = werewolfGameState.players.filter(p => 
            p.isAlive && (type === 'hunter' || type === 'vote' || p.id !== 'user')
        );
        potentialTargets.forEach(p => {
            const item = document.createElement('div');
            item.className = 'werewolf-selection-item';
            item.dataset.id = p.id;
            item.innerHTML = `<img src="${p.avatar}" class="avatar"><span class="name">${p.name}</span>`;
            item.onclick = () => {
                listEl.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
                selectedId = p.id;
            };
            listEl.appendChild(item);
        });
        
        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        newConfirmBtn.onclick = () => {
            if (selectedId) {
                modal.classList.remove('visible');
                resolve(selectedId);
            } else {
                alert('请选择一个目标。');
            }
        };

        modal.classList.add('visible');
    });
}

/**
 * 【V2.0 | 已修复】打开狼人夜晚刀人选择弹窗
 */
function openWolfKillModal() {
    return new Promise(resolve => {
        const modal = document.getElementById('werewolf-kill-modal');
        const listEl = document.getElementById('werewolf-kill-selection-list');
        const confirmBtn = document.getElementById('confirm-wolf-kill-btn');
        const header = modal.querySelector('.modal-header span');

        const wolves = werewolfGameState.players.filter(p => p.role === '狼人' && p.isAlive);
        const teammates = wolves.filter(w => w.id !== 'user').map(w => w.name).join('、');
        
        if (teammates) {
            header.innerHTML = `狼人请选择刀人对象<br><small style="font-weight:normal; font-size: 13px;">你的队友是: ${teammates}</small>`;
        } else {
            header.textContent = '狼人请选择刀人对象';
        }
        
        listEl.innerHTML = '';
        let selectedId = null;

        const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.role !== '狼人');
        potentialTargets.forEach(p => {
            const item = document.createElement('div');
            item.className = 'werewolf-selection-item';
            item.dataset.id = p.id;
            item.innerHTML = `<img src="${p.avatar}" class="avatar"><span class="name">${p.name}</span>`;
            item.onclick = () => {
                listEl.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
                selectedId = p.id;
            };
            listEl.appendChild(item);
        });
        
        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        newConfirmBtn.onclick = () => {
            if (selectedId) {
                modal.classList.remove('visible');
                resolve(selectedId);
            } else {
                alert('请选择一个目标。');
            }
        };

        modal.classList.add('visible');
    });
}

/**
         * 【全新 | V2.0】处理用户在狼人杀讨论中结束发言的逻辑
         */
        function handleUserWerewolfSpeech() {
            const myPlayer = werewolfGameState.players.find(p => p.id === 'user');
            // 【核心修复】如果玩家已死亡，则不执行任何操作
            if (!myPlayer || !myPlayer.isAlive) return;

            const userInput = document.getElementById('werewolf-user-input');
            const speech = userInput.value.trim();

            if (speech) {
                addDialogueLog(myPlayer.name, speech);
                renderWerewolfScreen();
            }
            
            // 隐藏输入框和发言按钮，准备进入投票
            document.getElementById('werewolf-action-bar').style.display = 'none';
            userInput.value = '';
            
            startVotingPhase();
        }
/**
         * 【全新】处理用户作为旁观者时，点击“继续讨论”的逻辑
         */
        async function handleAiContinueDiscussion() {
            addGameLog('你让大家继续讨论...');
            renderWerewolfScreen();

            // 暂时禁用按钮，防止重复点击
            const continueBtn = document.getElementById('werewolf-wait-reply-btn');
            if(continueBtn) continueBtn.disabled = true;

            // 后续的AI调用逻辑与 handleWerewolfWaitReply 完全一致
            // 因为 buildWerewolfPrompt 已经能正确处理用户死亡的情况
            await showCustomAlert("请稍候", "正在等待AI角色们继续讨论...");

            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) {
                alert('API未配置，无法生成对话。');
                return;
            }

            const systemPrompt = buildWerewolfPrompt(); 

            try {
                let isGemini = proxyUrl.includes('generativelanguage');
                // 核心：这里的 user message 是一个通用指令，不包含任何具体发言
                let messagesForApi = [{role: 'user', content: '请AI角色们继续进行讨论。'}];
                let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
                
                const response = isGemini 
                    ? await fetch(geminiConfig.url, geminiConfig.data) 
                    : await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({
                            model: model,
                            messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                            temperature: state.globalSettings.apiTemperature || 0.9,
                        })
                    });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API 错误: ${errorData.error.message}`);
                }
                
                const data = await response.json();
                const aiResponseContent = getGeminiResponseText(data);
                const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
                if (!jsonMatch) {
                    throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
                }
                const dialogues = JSON.parse(jsonMatch[0]);

                for (const dialogue of dialogues) {
                    if(dialogue.speaker_name && dialogue.dialogue) {
                        addDialogueLog(dialogue.speaker_name, dialogue.dialogue);
                        renderWerewolfScreen();
                        await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));
                    }
                }
            } catch(error) {
                console.error("狼人杀AI回应生成失败:", error);
                await showCustomAlert("AI 发言失败", `错误: ${error.message}`);
            } finally {
                // 重新启用按钮
                if(continueBtn) continueBtn.disabled = false;
            }
        }
/**
         * 【全新 | V2.0】处理用户点击“等待回应”的逻辑
         */
        async function handleWerewolfWaitReply() {
            const myPlayer = werewolfGameState.players.find(p => p.id === 'user');
            // ★★★★★ 核心安全校验 ★★★★★
            if (!myPlayer || !myPlayer.isAlive) {
                console.warn("handleWerewolfWaitReply 被调用，但用户已死亡。操作被忽略。");
                return;
            }
            // ★★★★★ 安全校验结束 ★★★★★

            const userInput = document.getElementById('werewolf-user-input');
            const speech = userInput.value.trim();

            if (!speech) {
                alert("请先输入你的发言内容。");
                return;
            }

            addDialogueLog(myPlayer.name, speech);
            renderWerewolfScreen();
            userInput.value = '';

            await showCustomAlert("请稍候", "正在等待AI角色们对你的发言做出回应...");

            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) {
                alert('API未配置，无法生成对话。');
                return;
            }

            const systemPrompt = buildWerewolfPrompt(); 

            try {
                let isGemini = proxyUrl.includes('generativelanguage');
                let messagesForApi = [{role: 'user', content: `现在，请所有AI角色针对刚刚的发言（特别是'${myPlayer.name}'的发言）继续进行讨论。`}];
                let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
                
                const response = isGemini 
                    ? await fetch(geminiConfig.url, geminiConfig.data) 
                    : await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({
                            model: model,
                            messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                            temperature: state.globalSettings.apiTemperature || 0.9,
                        })
                    });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API 错误: ${errorData.error.message}`);
                }
                
                const data = await response.json();
                const aiResponseContent = getGeminiResponseText(data);
                const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
                if (!jsonMatch) {
                    throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
                }
                const dialogues = JSON.parse(jsonMatch[0]);

                for (const dialogue of dialogues) {
                    if(dialogue.speaker_name && dialogue.dialogue) {
                        addDialogueLog(dialogue.speaker_name, dialogue.dialogue);
                        renderWerewolfScreen();
                        await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));
                    }
                }
            } catch(error) {
                console.error("狼人杀AI回应生成失败:", error);
                await showCustomAlert("AI 发言失败", `错误: ${error.message}`);
            }
        }

/**
         * 【全新 | V2.0 投票修复版】开始投票环节
         */
        async function startVotingPhase() {
            addGameLog('发言结束，现在开始投票。');
            renderWerewolfScreen();
        
            // 【核心修复1】使用一个新的、更可靠的数据结构来存储投票
            werewolfGameState.votes = {}; // { voterName: targetName }
        
            let aiVotes = null;
            werewolfGameState.lastFailedAction = 'getVotes'; // 标记当前操作
            try {
                // 尝试获取AI投票
                aiVotes = await getAiVotes();
                if (aiVotes) {
                    aiVotes.forEach(vote => {
                        const voter = werewolfGameState.players.find(p => p.name === vote.voter_name);
                        const target = werewolfGameState.players.find(p => p.name === vote.vote_for_name);
                        if (voter && voter.isAlive && target) {
                            werewolfGameState.votes[voter.name] = target.name;
                        }
                    });
                }
                werewolfGameState.lastFailedAction = null; // 成功后清除标记
            } catch (error) {
                console.error("AI投票决策API失败:", error);
                // 如果API调用失败
                await showCustomAlert("操作失败", `AI角色无法完成投票，游戏暂停。请点击右上角的“重试”按钮继续。\n错误: ${error.message}`);
                document.getElementById('werewolf-retry-btn').style.display = 'block'; // 显示重试按钮
                return; // 终止函数，等待用户重试
            }
            // ▲▲▲ 【【【修改结束】】】 ▲▲▲
        
            // 2. 获取用户的投票
            const myPlayer = werewolfGameState.players.find(p => p.id === 'user');
            if (myPlayer && myPlayer.isAlive) {
                addGameLog('请你投票。');
                renderWerewolfScreen();
                const userVoteTargetId = await openSelectionModal('vote');
                const targetPlayer = werewolfGameState.players.find(p => p.id === userVoteTargetId);
                if (targetPlayer) {
                    // 记录用户的投票
                    werewolfGameState.votes[myPlayer.name] = targetPlayer.name;
                }
            }
        
            // 3. 处理并公布最终结果
            handleVotingResults();
        }

/**
         * 【全新 | V2.1 终极容错修复版】获取所有AI的投票决定
         */
        async function getAiVotes() {
            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) return null;

            const aliveAiPlayers = werewolfGameState.players.filter(p => p.isAlive && p.id !== 'user');
            const potentialTargets = werewolfGameState.players.filter(p => p.isAlive).map(p => p.name);

            let systemPrompt = buildWerewolfPrompt();
            systemPrompt += `
# 【【【最终投票指令 (最高优先级)】】】
现在是投票环节。请你扮演【每一个存活的AI角色】，根据以上所有信息（特别是刚刚的讨论环节），为他们各自决定要投票放逐哪一位玩家。
- **投票依据**: 你的投票【必须】基于逻辑分析和你的身份。狼人可能会投给好人，好人需要找出狼人。
- **格式铁律**: 你的回复【必须且只能】是一个JSON数组，格式如下：
\`\`\`json
[
  {"voter_name": "角色A的名字", "vote_for_name": "角色A投票的玩家名字"},
  {"voter_name": "角色B的名字", "vote_for_name": "角色B投票的玩家名字"}
]
\`\`\`
- **可投票的玩家列表**: ${potentialTargets.join(', ')}

现在，请为所有存活的AI角色生成他们的投票决定。`;

            try {
                let isGemini = proxyUrl.includes('generativelanguage');
                let messagesForApi = [{role: 'user', content: '请所有AI角色开始投票。'}];
                let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
                
                const response = isGemini 
                    ? await fetch(geminiConfig.url, geminiConfig.data) 
                    : await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({
                            model: model,
                            messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                            temperature: state.globalSettings.apiTemperature || 0.8,
                        })
                    });

                if (!response.ok) throw new Error((await response.json()).error.message);
                
                const data = await response.json();
                const aiResponseContent = getGeminiResponseText(data);

                // ▼▼▼ 【【【核心修复就在这里！】】】 ▼▼▼
                
                // 1. 先清理掉AI可能返回的markdown代码块标记
                let cleanedJsonString = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();

                // 2. 找到第一个 '[' 和最后一个 ']' 的位置
                const startIndex = cleanedJsonString.indexOf('[');
                const endIndex = cleanedJsonString.lastIndexOf(']');

                // 3. 如果找不到合法的数组结构，就抛出明确的错误
                if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
                    throw new Error("AI返回的投票结果中未找到有效的JSON数组结构 (`[...]`)。");
                }

                // 4. 精确地提取出从第一个 '[' 到最后一个 ']' 的所有内容
                // 这一步是关键，它会忽略掉AI返回的第一个（讨论）JSON数组和中间的杂乱字符
                const jsonArrayString = cleanedJsonString.substring(startIndex, endIndex + 1);

                // 5. 在一个 try...catch 块中安全地解析提取出的字符串
                try {
                    // 再次尝试从多个JSON数组中提取最后一个
                    const matches = jsonArrayString.match(/(\[[\s\S]*?\])/g);
                    if (matches && matches.length > 0) {
                        return JSON.parse(matches[matches.length - 1]);
                    }
                    return JSON.parse(jsonArrayString); // Fallback
                } catch (e) {
                    // 如果即使提取后仍然解析失败，就抛出一个包含原始返回内容的、更详细的错误
                    throw new Error(`解析AI返回的投票JSON时出错: ${e.message}\n\nAI原始返回内容:\n${aiResponseContent}`);
                }
                // ▲▲▲ 【【【修复结束】】】 ▲▲▲

            } catch(error) {
                console.error("获取AI投票失败:", error);
                throw new Error(`获取AI投票决策失败: ${error.message}`);
            }
        }

/**
         * 【全新 | V2.0 投票修复版】处理并公布投票结果
         */
        function handleVotingResults() {
            const voteCounts = {}; // 用于计票: { targetName: count }
            const voteDetails = {}; // 用于记录详情: { targetName: [voter1, voter2] }
        
            // 【核心修复2】从新的、更可靠的 votes 对象中计票
            for (const voterName in werewolfGameState.votes) {
                const targetName = werewolfGameState.votes[voterName];
                
                voteCounts[targetName] = (voteCounts[targetName] || 0) + 1;
                
                if (!voteDetails[targetName]) {
                    voteDetails[targetName] = [];
                }
                voteDetails[targetName].push(voterName);
            }
        
            let maxVotes = 0;
            let mostVotedPlayers = [];
        
            // 找出最高票数和对应的玩家
            for (const playerName in voteCounts) {
                const count = voteCounts[playerName];
                if (count > maxVotes) {
                    maxVotes = count;
                    mostVotedPlayers = [playerName];
                } else if (count === maxVotes) {
                    mostVotedPlayers.push(playerName);
                }
            }
        
            // 公布投票详情
            addGameLog('投票结果：');
            for (const playerName in voteDetails) {
                addGameLog(`${playerName} (${voteDetails[playerName].length}票): ${voteDetails[playerName].join('、 ')}`);
            }
        
            // 判断并处理出局玩家
            if (mostVotedPlayers.length === 1 && maxVotes > 0) {
                const playerToEliminate = werewolfGameState.players.find(p => p.name === mostVotedPlayers[0]);
                if (playerToEliminate) {
                    playerToEliminate.isAlive = false;
                    addGameLog(`${playerToEliminate.name} 被投票放逐。`);
                    
                    // 猎人技能处理 (这部分逻辑保持不变)
                    if (playerToEliminate.role === '猎人') {
                         // 猎人技能已在 `executeDayPhase` 中处理死亡事件，这里无需重复
                    }
                }
            } else {
                addGameLog('平票或无人投票，此轮无人出局。');
            }
        
            renderWerewolfScreen();
            
            if (checkGameOver()) return;
        
            // 进入下一个夜晚
            werewolfGameState.currentDay++;
            executeNightPhase();
        }

/**
 * 【全新】获取AI狼人团队的刀人目标
 */
async function getAiWolfKillTarget() {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return null;

    const wolves = werewolfGameState.players.filter(p => p.role === '狼人' && p.isAlive);
    const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.role !== '狼人');

    const systemPrompt = `
# 你的任务
你现在是狼人团队的指挥官。你的任务是分析当前局势，并为狼人团队选择一个最佳的刀人目标。
# 核心规则
1.  **目标**: 优先刀掉预言家、女巫等神职人员。如果没有明确的神职信息，可以根据发言来判断谁的逻辑清晰、威胁最大。
2.  **格式铁律**: 你的回复【必须且只能】是一个JSON对象，格式如下:
    \`{"target_name": "你决定要刀的玩家名字"}\`

# 游戏状态
- **你的狼队友是**: ${wolves.map(w=>w.name).join('、 ')}
- **可以刀的玩家列表**: ${potentialTargets.map(p=>p.name).join('、 ')}
- **讨论摘要**: 
${werewolfGameState.discussionLog.map(d => `${d.speaker}: ${d.content}`).join('\n')}

现在，请做出你的决定。`;
    
    try {
        let isGemini = proxyUrl.includes('generativelanguage');
        let messagesForApi = [{role: 'user', content: '请选择今晚的目标。'}];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model, messages: [{role: 'system', content: systemPrompt}, ...messagesForApi], temperature: state.globalSettings.apiTemperature || 0.8,
                })
            });

        if (!response.ok) throw new Error((await response.json()).error.message);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const jsonMatch = aiResponseContent.match(/({[\s\S]*})/);
        if (!jsonMatch) throw new Error("AI返回的刀人目标格式不正确。");
        const decision = JSON.parse(jsonMatch[0]);

        const targetPlayer = werewolfGameState.players.find(p => p.name === decision.target_name);
        return targetPlayer ? targetPlayer.id : null;

    } catch(error) {
        console.error("获取AI狼人目标失败:", error);
        // 如果AI决策失败，随机选择一个目标作为保底
        return potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
    }
}
// ▲▲▲ 狼人杀JS代码结束 ▲▲▲
/**
 * 【全新 V2.2 | 交互最终修复版】打开女巫操作弹窗
 * @param {object|null} killedPlayer - 被狼人刀的玩家对象，如果是平安夜则为null
 * @param {object} witchPlayer - 女巫玩家的对象
 * @returns {Promise<object>} - 返回一个包含 { save: boolean, poison: string|null } 的对象
 */
function openWitchActionModal(killedPlayer, witchPlayer) {
    return new Promise(resolve => {
        const modal = document.getElementById('werewolf-witch-modal');
        const listEl = document.getElementById('werewolf-witch-selection-list');
        const titleEl = document.getElementById('witch-modal-title');
        
        // 1. 获取原始按钮的引用
        const poisonBtn = document.getElementById('confirm-witch-poison-btn');
        const doNothingBtn = document.getElementById('witch-do-nothing-btn');
        listEl.innerHTML = '';

        // 2. ★★★ 核心修复：先克隆并替换按钮，确保我们操作的是最新的DOM元素 ★★★
        const newPoisonBtn = poisonBtn.cloneNode(true);
        poisonBtn.parentNode.replaceChild(newPoisonBtn, poisonBtn);
        const newDoNothingBtn = doNothingBtn.cloneNode(true);
        doNothingBtn.parentNode.replaceChild(newDoNothingBtn, doNothingBtn);

        // 3. 现在，所有的操作都针对 newPoisonBtn 和 newDoNothingBtn
        newPoisonBtn.style.display = 'block';
        newPoisonBtn.disabled = true; // 默认禁用

        let action = { save: false, poison: null };
        let selectedPoisonTarget = null;
        
        // (显示死亡信息和救人选项的逻辑保持不变)
        if (killedPlayer && !witchPlayer.antidoteUsed) {
            titleEl.textContent = `昨晚 ${killedPlayer.name} 被刀了`;
            const saveBtn = document.createElement('button');
            saveBtn.className = 'form-button';
            saveBtn.textContent = '使用解药救TA';
            saveBtn.style.margin = '20px';
            saveBtn.onclick = () => {
                action.save = true;
                modal.classList.remove('visible');
                resolve(action);
            };
            listEl.appendChild(saveBtn);
        } else if (killedPlayer) {
            titleEl.textContent = `昨晚 ${killedPlayer.name} 被刀了 (你没有解药了)`;
        } else {
            titleEl.textContent = '昨晚是平安夜';
        }

        // (提供毒人选项的逻辑保持不变)
        if (!witchPlayer.poisonUsed) {
            const poisonTitle = document.createElement('p');
            poisonTitle.textContent = '是否要使用毒药？';
            poisonTitle.style.textAlign = 'center';
            poisonTitle.style.marginTop = '20px';
            listEl.appendChild(poisonTitle);

            const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== killedPlayer?.id);
            potentialTargets.forEach(p => {
                const item = document.createElement('div');
                item.className = 'werewolf-selection-item';
                item.dataset.id = p.id;
                item.innerHTML = `<img src="${p.avatar}" class="avatar"><span class="name">${p.name}</span>`;
                item.onclick = () => {
                    listEl.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                    item.classList.add('selected');
                    selectedPoisonTarget = p.id;
                    
                    // 4. ★★★ 核心修复：现在我们启用的是正确的、新的按钮 ★★★
                    newPoisonBtn.disabled = false;
                };
                listEl.appendChild(item);
            });
        }

        // 5. 为新的按钮绑定事件
        newPoisonBtn.onclick = () => {
            if (selectedPoisonTarget) {
                action.poison = selectedPoisonTarget;
                modal.classList.remove('visible');
                resolve(action);
            }
        };

        newDoNothingBtn.onclick = () => {
            modal.classList.remove('visible');
            resolve(action);
        };

        modal.classList.add('visible');
    });
}
// ▲▲▲ 新增JS代码结束 ▲▲▲
// ▼▼▼ 【全新】这是重试功能的核心处理函数，请完整粘贴 ▼▼▼

/**
 * 【总入口】处理用户点击“重试”按钮的逻辑
 */
async function handleWerewolfRetry() {
    const actionToRetry = werewolfGameState.lastFailedAction;
    if (!actionToRetry) return;

    document.getElementById('werewolf-retry-btn').style.display = 'none'; // 先隐藏按钮
    await showCustomAlert("请稍候...", `正在重试"${actionToRetry}"操作...`);

    switch(actionToRetry) {
        case 'wolfKill':
            // 重试狼人刀人，需要重新执行整个夜晚阶段
            await executeNightPhase();
            break;
        case 'startDiscussion':
            // 重试开始讨论
            await startDiscussionPhase();
            break;
        case 'getVotes':
            // 重试AI投票
            await startVotingPhase();
            break;
        // 未来可以添加更多重试场景...
    }
}

// ▲▲▲ 新增JS代码结束 ▲▲▲
// ▼▼▼ 【全新 | 缺失的函数】这是检查游戏是否结束的核心逻辑，请完整粘贴 ▼▼▼

/**
         * 【全新 | 已添加屠城判定】检查游戏是否结束，并宣布胜利者
         * @returns {boolean} - 如果游戏结束则返回 true，否则返回 false
         */
        function checkGameOver() {
            const alivePlayers = werewolfGameState.players.filter(p => p.isAlive);
            const aliveWolves = alivePlayers.filter(p => p.role === '狼人');
            const aliveGods = alivePlayers.filter(p => ['预言家', '女巫', '猎人', '守卫'].includes(p.role));
            const aliveVillagers = alivePlayers.filter(p => p.role === '平民');

            let winner = null;

            // 1. 好人胜利条件：所有狼人都已出局
            if (aliveWolves.length === 0) {
                winner = '好人';
            }
            // 2. 新增的狼人胜利条件：狼人数量等于或超过好人数量
            else if (aliveWolves.length >= (aliveGods.length + aliveVillagers.length)) {
                winner = '狼人';
            }
            // 3. 原有的狼人胜利条件 (作为备用)
            else if (werewolfGameState.gameMode === '12p') {
                // 12人局屠边：神职全部死亡 或 平民全部死亡
                if (aliveGods.length === 0 || aliveVillagers.length === 0) {
                    winner = '狼人';
                }
            } else {
                // 6人或9人局屠城：所有好人（神职+平民）都已死亡
                if (aliveGods.length === 0 && aliveVillagers.length === 0) {
                    winner = '狼人';
                }
            }


            if (winner) {
                // 如果有胜利者，则调用结束游戏的函数
                endGame(winner);
                return true; // 返回 true，表示游戏已结束
            }

            // 如果没有胜利者，返回 false
            return false;
        }

// ▲▲▲ 新增函数粘贴结束 ▲▲▲
/**
 * 【全新 | V2.0 深度修复版】检查并修复数据库与内存状态不一致、以及数据结构残缺的问题
 */
async function checkAndFixData() {
    const confirmed = await showCustomConfirm(
        '确认操作',
        '此功能将扫描数据库，尝试找出并修复“角色在数据库中存在，但未在聊天列表显示”的问题。<br><br><strong>操作通常是安全的，但仍建议在操作前备份数据。</strong>',
        { confirmText: '开始检查' }
    );

    if (!confirmed) return;

    await showCustomAlert("请稍候...", "正在扫描和修复数据...");

    try {
        const chatsFromDB = await db.chats.toArray();
        let fixedCount = 0;

        for (const chat of chatsFromDB) {
            let isModified = false;

            // 修复1：确保 history 聊天记录数组存在，这是最常见的问题
            if (!Array.isArray(chat.history)) {
                chat.history = [];
                isModified = true;
            }
            // 修复2：确保 settings 设置对象存在
            if (typeof chat.settings !== 'object' || chat.settings === null) {
                chat.settings = {};
                isModified = true;
            }
            // 修复3：为旧数据的单聊角色补充 originalName（本名）
            if (!chat.isGroup && !chat.originalName) {
                chat.originalName = chat.name;
                isModified = true;
            }
            // 修复4：确保 unreadCount（未读消息数）存在
            if (typeof chat.unreadCount === 'undefined') {
                chat.unreadCount = 0;
                isModified = true;
            }
            // 修复5: 确保 longTermMemory (长期记忆) 数组存在
            if (!Array.isArray(chat.longTermMemory)) {
                chat.longTermMemory = [];
                isModified = true;
            }
            // 您未来可以根据需要在这里添加更多的检查和修复逻辑...

            // 如果数据被修复过，就更新数据库
            if (isModified) {
                fixedCount++;
                console.log(`修复了角色 "${chat.name}" (ID: ${chat.id}) 的残缺数据。`);
                await db.chats.put(chat);
            }
            
            // 无论是否修复，都确保内存中的 state 对象是最新的
            state.chats[chat.id] = chat;
        }

        if (fixedCount > 0) {
            await showCustomAlert(
                '修复完成！',
                `成功检查并修复了 ${fixedCount} 个角色的数据问题！\n\n聊天列表已为您刷新。`
            );
            // 使用修复后的最新数据，重新渲染聊天列表
            await renderChatList(); 
        } else {
            await showCustomAlert('检查完成', '未发现任何需要修复的数据问题。');
        }

    } catch (error) {
        console.error("数据检查与修复失败:", error);
        await showCustomAlert('操作失败', `执行检查时发生错误: ${error.message}`);
    }
}
// ▼▼▼ 【全新】加载动画辅助函数 ▼▼▼
/**
 * 在指定容器显示加载动画
 * @param {HTMLElement} container - 要显示加载动画的容器元素
 * @param {string} position - 'top' 或 'bottom'，决定加载动画出现的位置
 */
function showLoader(container, position = 'top') {
    // 检查是否已存在加载器，避免重复添加
    if (container.querySelector('.loader-container')) return;
    const loader = document.createElement('div');
    loader.className = 'loader-container';
    loader.innerHTML = '<div class="spinner"></div>';
    
    if (position === 'bottom') {
        container.appendChild(loader);
    } else {
        container.prepend(loader);
    }
}

/**
 * 从指定容器移除加载动画
 * @param {HTMLElement} container - 要移除加载动画的容器元素
 */
function hideLoader(container) {
    const loader = container.querySelector('.loader-container');
    if (loader) {
        loader.remove();
    }
}
// ▲▲▲ 新增函数结束 ▲▲▲
// ▲▲▲ 粘贴结束 ▲▲▲

// ▼▼▼ 【全新】这是删除世界书功能的【全部核心JS代码】，请完整粘贴 ▼▼▼

/**
 * 【总入口】打开删除世界书的选择器弹窗
 */
async function openWorldBookDeletionModal() {
    const modal = document.getElementById('delete-world-books-modal');
    const listEl = document.getElementById('delete-world-books-list');
    const selectAllCheckbox = document.getElementById('select-all-world-books-for-clear');
    listEl.innerHTML = '';
    selectAllCheckbox.checked = false; // 重置全选框

    const books = await db.worldBooks.toArray();

    if (books.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">没有可以删除的世界书。</p>';
    } else {
        books.forEach(book => {
            const item = document.createElement('div');
            item.className = 'clear-posts-item'; // 复用样式
            item.dataset.bookId = book.id;
            item.innerHTML = `
                <div class="checkbox"></div>
                <span class="name">${book.name}</span>
            `;
            listEl.appendChild(item);
        });
    }
    
    modal.classList.add('visible');
}

/**
 * 【核心】处理最终确认删除世界书的逻辑
 */
async function handleConfirmWorldBookDeletion() {
    const selectedItems = document.querySelectorAll('#delete-world-books-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
        alert("请至少选择一个要删除的世界书。");
        return;
    }

    const idsToDelete = Array.from(selectedItems).map(item => item.dataset.bookId);
    
    const confirmed = await showCustomConfirm(
        '最后确认！',
        `此操作将永久删除您选择的 ${selectedItems.length} 本世界书，并解除它们与所有角色的关联。此操作【不可恢复】！`,
        { confirmButtonClass: 'btn-danger', confirmText: '确认删除' }
    );

    if (!confirmed) return;
    
    await showCustomAlert("请稍候...", "正在执行删除操作...");

    try {
        await db.transaction('rw', db.worldBooks, db.chats, async () => {
            // 1. 批量删除世界书本身
            await db.worldBooks.bulkDelete(idsToDelete);

            // 2. 遍历所有聊天，解除关联
            const allChats = await db.chats.toArray();
            for (const chat of allChats) {
                if (chat.settings && Array.isArray(chat.settings.linkedWorldBookIds)) {
                    const originalCount = chat.settings.linkedWorldBookIds.length;
                    // 过滤掉已被删除的世界书ID
                    chat.settings.linkedWorldBookIds = chat.settings.linkedWorldBookIds.filter(id => !idsToDelete.includes(id));
                    
                    // 如果有关联被解除，则更新该聊天
                    if (chat.settings.linkedWorldBookIds.length < originalCount) {
                        await db.chats.put(chat);
                    }
                }
            }
        });
        
        // 更新内存状态
        state.worldBooks = state.worldBooks.filter(book => !idsToDelete.includes(book.id));
        
        document.getElementById('delete-world-books-modal').classList.remove('visible');
        await showCustomAlert("删除成功", `${selectedItems.length} 本世界书已成功删除。`);

    } catch (error) {
        console.error("删除世界书失败:", error);
        await showCustomAlert("删除失败", `操作失败: ${error.message}`);
    }
}
// ▲▲▲ 新增JS代码结束 ▲▲▲
// ▼▼▼ 【V2.1 | 状态与交互修复版】一起读书功能核心函数 ▼▼▼

/**
 * 【总入口】打开读书窗口（由工具栏按钮调用）
 */
function openReadingRoom() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const overlay = document.getElementById('reading-overlay');
    const windowEl = document.getElementById('reading-window');
    const restoreBtn = document.getElementById('reading-restore-btn');

    let session = readingState[chatId];

    // 如果会话已激活（无论是打开还是最小化），只需确保它可见即可
    if (session && session.isActive) {
        if (session.isMinimized) {
            restoreReadingRoom(); // 如果是最小化状态，就恢复它
        }
        // 如果已经是打开状态，确保它在最前
        overlay.style.display = 'flex';
        return;
    }

    // 如果会话未激活，则创建并显示
    initReadingSession(chatId);
    renderReadingRoom(chatId);

    // 重置所有状态，确保窗口从中间出现
    overlay.style.display = 'flex';
    windowEl.classList.remove('minimized');
    restoreBtn.style.display = 'none';
    
    // 使用transform居中，避免拖动冲突
// ▼▼▼ 【核心修复：使用JS计算初始居中位置，消除弹跳】 ▼▼▼
// 1. 获取父容器（手机屏幕）和窗口本身的尺寸
const phoneScreen = document.getElementById('phone-screen');
const windowRect = windowEl.getBoundingClientRect(); // 获取窗口尺寸

// 2. 计算居中的 top 和 left 像素值
const top = (phoneScreen.clientHeight - windowRect.height) / 2;
const left = (phoneScreen.clientWidth - windowRect.width) / 2;

// 3. 直接应用计算好的像素值，并确保 transform 属性为空
windowEl.style.top = `${top}px`;
windowEl.style.left = `${left}px`;
windowEl.style.transform = ''; // 确保没有 transform 属性
// ▲▲▲ 修复结束 ▲▲▲
}

/**
 * 【已升级】初始化一个新的读书会话状态
 */
function initReadingSession(chatId) {
    readingState[chatId] = {
        isActive: true,
        isMinimized: false,
        title: '未选择书籍',
        contentLines: [],
        currentPage: 0,
        totalPages: 0,
        linesPerPage: 15,
        currentSnippet: '' // <-- 核心新增：用于存储当前视野中的文字片段
    };
}

/**
 * 【已修复】关闭读书悬浮窗 (由 'X' 按钮调用)
 */
function closeReadingRoom() {
    const chatId = state.activeChatId;
    if (!chatId || !readingState[chatId] || !readingState[chatId].isActive) return;

    // 隐藏所有相关UI
    document.getElementById('reading-overlay').style.display = 'none';
    document.getElementById('reading-restore-btn').style.display = 'none';
    document.getElementById('reading-window').classList.remove('minimized');

    // 核心修复：将 isActive 设为 false，这样下次才能重新打开
    readingState[chatId].isActive = false;
    console.log("读书会话已关闭。");
}

/**
 * 【已修复】最小化读书窗口
 */
function minimizeReadingRoom() {
    const session = readingState[state.activeChatId];
    if (!session || !session.isActive || session.isMinimized) return;

    session.isMinimized = true; // 更新状态
    document.getElementById('reading-window').classList.add('minimized');
    document.getElementById('reading-restore-btn').style.display = 'flex';
}

/**
 * 【已修复】恢复读书窗口
 */
function restoreReadingRoom() {
    const session = readingState[state.activeChatId];
    if (!session || !session.isActive || !session.isMinimized) return;

    session.isMinimized = false; // 更新状态
    document.getElementById('reading-restore-btn').style.display = 'none';
    document.getElementById('reading-window').classList.remove('minimized');
}

/**
 * 【已修复】让一个元素变得可拖动
 * @param {HTMLElement} windowEl - 要拖动的窗口元素
 * @param {HTMLElement} headerEl - 拖动的手柄元素
 */
function makeDraggable(windowEl, headerEl) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    const phoneScreen = document.getElementById('phone-screen');

    const startDrag = (e) => {
        // ▼▼▼ 【【【核心修复就在这里！】】】 ▼▼▼
        // 在开始拖动前，检查点击的是否是按钮。如果是，则立即退出，不执行任何拖动逻辑。
        if (e.target.closest('button')) {
            return;
        }
        // ▲▲▲ 【【【修复结束】】】 ▲▲▲

        // （后续的拖动逻辑保持不变）
        if (windowEl.style.transform) {
            const rect = windowEl.getBoundingClientRect();
            const parentRect = windowEl.offsetParent.getBoundingClientRect();
            windowEl.style.top = `${rect.top - parentRect.top}px`;
            windowEl.style.left = `${rect.left - parentRect.left}px`;
            windowEl.style.transform = '';
        }

        e.preventDefault();
        const event = e.type === 'touchstart' ? e.touches[0] : e;
        pos3 = event.clientX;
        pos4 = event.clientY;
        
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('mousemove', elementDrag);
        document.addEventListener('touchend', endDrag);
        document.addEventListener('touchmove', elementDrag);
    };

    const elementDrag = (e) => {
        const event = e.type === 'touchmove' ? e.touches[0] : e;
        pos1 = pos3 - event.clientX;
        pos2 = pos4 - event.clientY;
        pos3 = event.clientX;
        pos4 = event.clientY;
        
        let newTop = windowEl.offsetTop - pos2;
        let newLeft = windowEl.offsetLeft - pos1;

        const maxTop = phoneScreen.clientHeight - windowEl.offsetHeight - 10;
        const maxLeft = phoneScreen.clientWidth - windowEl.offsetWidth - 10;
        newTop = Math.max(10, Math.min(newTop, maxTop));
        newLeft = Math.max(10, Math.min(newLeft, maxLeft));

        windowEl.style.top = newTop + "px";
        windowEl.style.left = newLeft + "px";
    };

    const endDrag = () => {
        document.removeEventListener('mouseup', endDrag);
        document.removeEventListener('mousemove', elementDrag);
        document.removeEventListener('touchend', endDrag);
        document.removeEventListener('touchmove', elementDrag);
    };

    headerEl.addEventListener('mousedown', startDrag);
    headerEl.addEventListener('touchstart', startDrag);
}

// --- 其他辅助函数 (保持不变) ---
function renderReadingRoom(chatId) {
    const session = readingState[chatId]; if (!session) return;
    const titleEl = document.getElementById('reading-title');
    const contentEl = document.getElementById('reading-content');
    const pageIndicator = document.getElementById('page-indicator');
    const prevBtn = document.getElementById('prev-page-btn');
    const nextBtn = document.getElementById('next-page-btn');
    titleEl.textContent = session.title;
    if (session.contentLines.length === 0) {
        contentEl.innerHTML = '<p>点击“导入”按钮，<br>从本地.txt文件或网络URL加载书籍内容。</p>';
        session.totalPages = 0; session.currentPage = 0;
    } else {
        const startLine = session.currentPage * session.linesPerPage;
        const endLine = startLine + session.linesPerPage;
        contentEl.textContent = session.contentLines.slice(startLine, endLine).join('\n');
    }
    pageIndicator.textContent = `${session.currentPage + 1} / ${session.totalPages}`;
    prevBtn.disabled = session.currentPage === 0;
    nextBtn.disabled = session.currentPage >= session.totalPages - 1;
}
function showNextPage() {
    const session = readingState[state.activeChatId];
    if (session && session.currentPage < session.totalPages - 1) {
        session.currentPage++; 
        renderReadingRoom(state.activeChatId);
        document.getElementById('reading-content').scrollTop = 0;
        // 【核心新增】保存进度
        saveReadingProgress(session.activeBookId, session.currentPage);
    }
}

// ▼▼▼ 【请用这个已升级的版本】替换旧的 showPrevPage 函数 ▼▼▼
async function showPrevPage() {
    const session = readingState[state.activeChatId];
    if (session && session.currentPage > 0) {
        session.currentPage--; 
        renderReadingRoom(state.activeChatId);
        document.getElementById('reading-content').scrollTop = 0;
        await saveReadingProgress(session.activeBookId, session.currentPage);

        // 【核心新增】在翻页后，也立刻通知AI
        await notifyAiOfPageTurn(state.activeChatId, session);
    }
}
// ▲▲▲ 替换结束 ▲▲▲
/**
 * 【已修改】仅用于触发本地文件选择
 */
function importBook() {
    // 直接触发隐藏的文件输入框，不再弹出选择菜单
    document.getElementById('book-upload-input').click();
}
/**
 * 【全新 | 编码兼容】智能解码文本文件
 * @param {ArrayBuffer} arrayBuffer - 文件的二进制数据
 * @returns {string} - 解码后的文本内容
 */
async function decodeTextFile(arrayBuffer) {
    const uint8array = new Uint8Array(arrayBuffer);

    // 1. 检查BOM (Byte Order Mark) 来精确判断编码
    if (uint8array.length >= 3 && uint8array[0] === 0xEF && uint8array[1] === 0xBB && uint8array[2] === 0xBF) {
        console.log("检测到 UTF-8 BOM，使用 UTF-8 解码。");
        return new TextDecoder('utf-8').decode(uint8array);
    }
    if (uint8array.length >= 2 && uint8array[0] === 0xFF && uint8array[1] === 0xFE) {
        console.log("检测到 UTF-16 LE BOM，使用 UTF-16 LE 解码。");
        return new TextDecoder('utf-16le').decode(uint8array);
    }
    if (uint8array.length >= 2 && uint8array[0] === 0xFE && uint8array[1] === 0xFF) {
        console.log("检测到 UTF-16 BE BOM，使用 UTF-16 BE 解码。");
        return new TextDecoder('utf-16be').decode(uint8array);
    }

    // 2. 如果没有BOM，尝试作为UTF-8解码
    try {
        console.log("未检测到BOM，尝试使用 UTF-8 解码...");
        // 使用 fatal: true 会在遇到无效字节序列时抛出错误
        const decoded = new TextDecoder('utf-8', { fatal: true }).decode(uint8array);
        console.log("UTF-8 解码成功。");
        return decoded;
    } catch (e) {
        console.log("UTF-8 解码失败，将尝试 GBK (ANSI) 解码...");
        // 3. 如果UTF-8失败，则回退到GBK解码 (覆盖常见的中文ANSI)
        try {
            const decoded = new TextDecoder('gbk').decode(uint8array);
            console.log("GBK 解码成功。");
            return decoded;
        } catch (err) {
             console.error("所有解码尝试均失败:", err);
             // 4. 如果所有尝试都失败了，抛出一个用户友好的错误
             throw new Error("无法识别的文件编码。请尝试将文件转换为 UTF-8 格式后重新导入。");
        }
    }
}
/**
 * 【已修改 | 编码兼容】处理用户上传的书籍文件，现在会将其保存到数据库
 */
async function handleBookFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
        // 核心修改1：将文件读取为 ArrayBuffer
        const arrayBuffer = await file.arrayBuffer();
        // 核心修改2：调用我们新的智能解码函数
        const textContent = await decodeTextFile(arrayBuffer);

        const title = file.name.replace(/\.txt$/i, '');

        const newBookId = await db.readingLibrary.add({
            title: title,
            content: textContent,
            lastOpened: Date.now()
        });

        await loadBookFromLibrary(newBookId);
        if (document.getElementById('reading-library-modal').classList.contains('visible')) {
            renderBookLibrary();
        }
    } catch (error) {
        // 如果解码或处理过程中出错，给用户一个明确的提示
        console.error("导入书籍失败:", error);
        await showCustomAlert("导入失败", error.message);
    } finally {
        event.target.value = null;
    }
}
async function handlePageJump() {
    const chatId = state.activeChatId;
    if (!chatId) return;
    const session = readingState[chatId];
    if (!session || session.totalPages <= 1) return;

    const targetPageStr = await showCustomPrompt(
        '页面跳转', 
        `请输入想跳转的页码 (1 - ${session.totalPages})`,
        session.currentPage + 1
    );

    if (targetPageStr === null) return;

    const targetPage = parseInt(targetPageStr);

    if (isNaN(targetPage) || targetPage < 1 || targetPage > session.totalPages) {
        alert("请输入一个有效的页码！");
        return;
    }

    session.currentPage = targetPage - 1;
    renderReadingRoom(chatId);
    // 【核心新增】保存进度
    saveReadingProgress(session.activeBookId, session.currentPage);
}

/**
 * 【全新】保存指定书籍的阅读进度到数据库
 * @param {number} bookId - 要保存进度的书籍ID
 * @param {number} pageNumber - 当前的页码
 */
async function saveReadingProgress(bookId, pageNumber) {
    if (!bookId) return;
    try {
        // 使用 update 方法，只更新 currentPage 字段，不影响其他数据
        await db.readingLibrary.update(bookId, { currentPage: pageNumber });
    } catch (error) {
        console.error(`保存书籍(ID: ${bookId})的阅读进度失败:`, error);
    }
}
// ▼▼▼ 【请用这个已升级的版本】替换旧的 showNextPage 函数 ▼▼▼
async function showNextPage() {
    const session = readingState[state.activeChatId];
    if (session && session.currentPage < session.totalPages - 1) {
        session.currentPage++; 
        renderReadingRoom(state.activeChatId);
        document.getElementById('reading-content').scrollTop = 0;
        await saveReadingProgress(session.activeBookId, session.currentPage);
        
        // 【核心新增】在翻页后，立刻通知AI
        await notifyAiOfPageTurn(state.activeChatId, session);
    }
}
// ▲▲▲ 替换结束 ▲▲▲
function processImportedText(title, textContent) {
    const chatId = state.activeChatId; if (!chatId) return;
    const session = readingState[chatId];
    session.title = title.replace(/\.txt$/i, '');
    session.contentLines = textContent.split(/\r\n?|\n/).map(line => line.replace(/ +/g, ' '));
    session.totalPages = Math.ceil(session.contentLines.length / session.linesPerPage);
    session.currentPage = 0;
    renderReadingRoom(chatId);
}

// ▲▲▲ JS代码替换结束 ▲▲▲
/**
 * 【全新】打开书库弹窗并渲染列表
 */
async function openBookLibrary() {
    // 【核心新增】在渲染前，先清空搜索框
    document.getElementById('reading-library-search-input').value = '';

    await renderBookLibrary(); // 调用不带参数的渲染，显示全部书籍
    document.getElementById('reading-library-modal').classList.add('visible');
}

/**
 * 【全新 | 支持搜索】从数据库读取书籍并渲染到书库列表中
 * @param {string} searchTerm - 用户输入的搜索关键词
 */
async function renderBookLibrary(searchTerm = '') {
    const listEl = document.getElementById('reading-library-list');
    let books = await db.readingLibrary.orderBy('lastOpened').reverse().toArray();
    listEl.innerHTML = '';

    // 【核心修改1】根据搜索词过滤书籍
    if (searchTerm) {
        books = books.filter(book => 
            book.title.toLowerCase().includes(searchTerm.toLowerCase())
        );
    }

    // 【核心修改2】根据是否有结果，显示不同的提示信息
    if (books.length === 0) {
        const message = searchTerm 
            ? '找不到匹配的书籍' 
            : '书库是空的，点击“导入新书”添加第一本吧！';
        listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
        return;
    }

    books.forEach(book => {
        const item = document.createElement('div');
        item.className = 'existing-group-item'; 
        item.innerHTML = `
            <span class="group-name" style="cursor:pointer;" data-book-id="${book.id}">${book.title}</span>
            <button class="delete-group-btn" data-book-id="${book.id}" title="删除书籍">×</button>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 【全新 | 支持断点续读】从书库中加载一本书到阅读器
 * @param {number} bookId - 要加载的书籍的ID
 */
async function loadBookFromLibrary(bookId) {
    const chatId = state.activeChatId;
    if (!chatId) return;

    const book = await db.readingLibrary.get(bookId);
    if (!book) {
        alert('找不到这本书！');
        return;
    }

    await db.readingLibrary.update(bookId, { lastOpened: Date.now() });

    const session = readingState[chatId];
    session.activeBookId = bookId; // 【核心新增】记录当前正在阅读的书籍ID
    session.title = book.title;
    session.contentLines = book.content.split(/\r\n?|\n/).map(line => line.replace(/ +/g, ' '));
    session.totalPages = Math.ceil(session.contentLines.length / session.linesPerPage);
    
    // ▼▼▼ 【【【这就是实现断点续读的关键！】】】 ▼▼▼
    // 读取数据库中保存的页码，如果没有，则默认为第0页
    session.currentPage = book.currentPage || 0;
    // ▲▲▲ 关键代码结束 ▲▲▲

    renderReadingRoom(chatId);
    // 渲染后，确保滚动条在顶部
    document.getElementById('reading-content').scrollTop = 0; 
    document.getElementById('reading-library-modal').classList.remove('visible');
}

/**
 * 【全新】从书库中删除一本书
 * @param {number} bookId - 要删除的书籍的ID
 */
async function deleteBookFromLibrary(bookId) {
    const book = await db.readingLibrary.get(bookId);
    if (!book) return;

    const confirmed = await showCustomConfirm('删除书籍', `确定要删除《${book.title}》吗？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.readingLibrary.delete(bookId);
        await renderBookLibrary(); // 刷新书库列表
    }
}
/**
 * 【核心】处理导入的文本内容，更新状态并刷新UI
 * @param {string} title - 书籍/文件名
 * @param {string} textContent - 完整的文本内容
 */
function processImportedText(title, textContent) {
    const chatId = state.activeChatId;
    if (!chatId) return;

    const session = readingState[chatId];
    session.title = title.replace(/\.txt$/i, '');
    session.contentLines = textContent.split(/\r\n?|\n/);
    session.totalPages = Math.ceil(session.contentLines.length / session.linesPerPage);
    session.currentPage = 0;

    renderReadingRoom(chatId);
}

// ▲▲▲ 新增JS代码结束 ▲▲▲
/**
 * 【V2.1 | 拖动与点击兼容修复版】让一个元素变得可拖动
 * @param {HTMLElement} windowEl - 要拖动的窗口元素
 * @param {HTMLElement} headerEl - 拖动的手柄元素
 */
function makeDraggable(windowEl, headerEl) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    let isDragging = false;
    let hasMoved = false; // 新增标志位，判断是否发生过移动
    const phoneScreen = document.getElementById('phone-screen');

    const startDrag = (e) => {
        // 如果是主窗口，并且点击的是内部按钮，则不触发拖动
        if (windowEl !== headerEl && e.target.closest('button')) {
            return;
        }

        isDragging = true;
        hasMoved = false; // 每次开始时重置移动状态

        const event = e.type === 'touchstart' ? e.touches[0] : e;
        pos3 = event.clientX;
        pos4 = event.clientY;

        // 确保使用 top/left 定位，而不是 transform
        windowEl.style.top = `${windowEl.offsetTop}px`;
        windowEl.style.left = `${windowEl.offsetLeft}px`;
        windowEl.style.transform = '';

        document.addEventListener('mouseup', endDrag);
        document.addEventListener('mousemove', elementDrag);
        document.addEventListener('touchend', endDrag);
        // 【核心修复1】添加 passive: false 确保 preventDefault 生效
        document.addEventListener('touchmove', elementDrag, { passive: false });
    };

    const elementDrag = (e) => {
        if (!isDragging) return;

        const event = e.type === 'touchmove' ? e.touches[0] : e;
        const diffX = event.clientX - pos3;
        const diffY = event.clientY - pos4;

        // 【核心修复2】只有当移动距离超过一个微小阈值时，才判定为“拖动”
        if (!hasMoved && (Math.abs(diffX) > 5 || Math.abs(diffY) > 5)) {
            hasMoved = true;
        }

        // 只有在确定是拖动时，才阻止页面滚动
        if (hasMoved && e.cancelable) {
            e.preventDefault();
        }

        pos1 = pos3 - event.clientX;
        pos2 = pos4 - event.clientY;
        pos3 = event.clientX;
        pos4 = event.clientY;

        let newTop = windowEl.offsetTop - pos2;
        let newLeft = windowEl.offsetLeft - pos1;

        const maxTop = phoneScreen.clientHeight - windowEl.offsetHeight - 10;
        const maxLeft = phoneScreen.clientWidth - windowEl.offsetWidth - 10;
        newTop = Math.max(10, Math.min(newTop, maxTop));
        newLeft = Math.max(10, Math.min(newLeft, maxLeft));

        windowEl.style.top = newTop + "px";
        windowEl.style.left = newLeft + "px";
    };

    const endDrag = () => {
        document.removeEventListener('mouseup', endDrag);
        document.removeEventListener('mousemove', elementDrag);
        document.removeEventListener('touchend', endDrag);
        document.removeEventListener('touchmove', elementDrag);

        if (!isDragging) return;
        isDragging = false;

        // 【核心修复3】如果从头到尾都没有发生有效移动，就判定为一次“点击”
        if (!hasMoved) {
            // 手动触发元素的点击事件
            windowEl.click();
        }
    };

    headerEl.addEventListener('mousedown', startDrag);
    // 【核心修复4】为 touchstart 也添加 passive: false
    headerEl.addEventListener('touchstart', startDrag, { passive: false });
}


/**
 * 最小化读书窗口
 */
function minimizeReadingRoom() {
    const session = readingState[state.activeChatId];
    if (!session || !session.isActive) return;

    document.getElementById('reading-window').classList.add('minimized');
    document.getElementById('reading-restore-btn').style.display = 'flex';
    session.isMinimized = true;
}

/**
 * 恢复读书窗口
 */
function restoreReadingRoom() {
    const session = readingState[state.activeChatId];
    if (!session || !session.isActive) return;

    document.getElementById('reading-restore-btn').style.display = 'none';
    document.getElementById('reading-window').classList.remove('minimized');
    session.isMinimized = false;
}

// ▲▲▲ 新增JS代码结束 ▲▲▲
// ▼▼▼ 【全新】这是实现“滚动感知”功能的核心代码，请完整粘贴 ▼▼▼

/**
 * 【辅助函数】创建一个防抖函数
 * @param {Function} func - 需要防抖的函数
 * @param {number} delay - 延迟时间 (毫秒)
 * @returns {Function} - 经过防抖处理的新函数
 */
function debounce(func, delay) {
    let timeout;
    return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), delay);
    };
}
// ▼▼▼ 【V3.1 | 逻辑优化版】请用这个全新的函数，完整替换旧的 formatReadingStateForAI ▼▼▼

/**
 * 【全新 V3.1 | 逻辑优化版】将指定聊天的“一起读书”状态格式化为AI可读的文本
 * @param {string} chatId - 目标聊天的ID
 * @returns {string} - 格式化后的上下文细节字符串，如果没有激活的读书会话则为空字符串
 */
function formatReadingStateForAI(chatId) {
    const session = readingState[chatId];
    
    // 如果会话未激活，或没有内容，直接返回空字符串
    if (!session || !session.isActive) {
        return "";
    }

    const title = session.title || '未知书籍';
    let contentForAI = '';
    let contextLabel = '';

    // (这部分获取视野内容的逻辑保持不变)
    if (session.currentSnippet && session.currentSnippet.trim()) {
        contentForAI = session.currentSnippet;
        contextLabel = '你正在阅读的段落';
    } else if (session.contentLines.length > 0) {
        const startLine = session.currentPage * session.linesPerPage;
        const endLine = startLine + session.linesPerPage;
        contentForAI = session.contentLines.slice(startLine, endLine).join('\n').substring(0, 200);
        contextLabel = '当前页内容摘要';
    } else {
        contentForAI = '(无内容)';
        contextLabel = '内容';
    }

    // 【【【核心修改】】】
    // 不再返回完整的指令块，而是只返回包含细节的、用于拼接的字符串。
    // 注意前面的换行和缩进，以保持最终Prompt的美观。
    return `
    - **书名**: 《${title}》
    - **${contextLabel}**: "${contentForAI}..."
    #一起读书模式 | 行为铁律
    1.  **角色定位**: 你【不是】书中的任何角色，你是【你自己】(${state.chats[chatId]?.originalName || 'AI角色'})，正在和用户一起【阅读和讨论】这本书。
    2.  **行为准则**: 你的回复【必须】是作为读者的【感想、评论、提问或联想】。你可以：
        -   分享你对当前段落的看法。
        -   对书中的角色或情节发表评论。
        -   向用户提问，询问TA对内容的看法。
        -   根据书本内容，联想到你自己的经历或记忆。
    3.  **严禁**: 你的回复【绝对禁止】使用书中角色的口吻和人称！【绝对禁止】扮演书中的任何角色！【绝对禁止】续写或模仿书中的情节！你必须时刻记住，你只是一个读者。    
`;
}

// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【这是最终修复版】请用这个全新的函数，完整替换旧的 updateReadingContextOnScroll ▼▼▼

/**
 * 【全新 | V2.0 全视野版】当读书窗口滚动时，更新当前视野中的【所有可见】文字片段
 */
function updateReadingContextOnScroll() {
    const chatId = state.activeChatId;
    if (!chatId || !readingState[chatId]) return;

    const session = readingState[chatId];
    const container = document.getElementById('reading-content');
    
    // --- ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
    //            这就是本次升级的核心所在！
    // --- ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

    // 1. 获取滚动容器的尺寸和位置信息
    const scrollTop = container.scrollTop; // 滚动条距离顶部的距离
    const clientHeight = container.clientHeight; // 容器本身可见的高度
    const scrollBottom = scrollTop + clientHeight; // 可见区域的底部位置

    // 2. 估算每一行的大致高度 (这部分保持不变)
    const approximateLineHeight = 15 * 1.8; 

    // 3. 计算出视野范围内的第一行和最后一行的行号
    const firstVisibleLine = Math.floor(scrollTop / approximateLineHeight);
    const lastVisibleLine = Math.ceil(scrollBottom / approximateLineHeight);

    // 4. 计算这些行在整本书中的绝对行号
    const absoluteStartIndex = (session.currentPage * session.linesPerPage) + firstVisibleLine;
    const absoluteEndIndex = (session.currentPage * session.linesPerPage) + lastVisibleLine;

    // 5. 安全检查，确保索引在有效范围内
    if (absoluteStartIndex < 0 || absoluteStartIndex >= session.contentLines.length) {
        return;
    }

    // 6. 截取从第一行到最后一行的所有内容，形成一个完整的“视野”
    const newSnippet = session.contentLines.slice(
        Math.max(0, absoluteStartIndex), 
        Math.min(session.contentLines.length, absoluteEndIndex)
    ).join('\n');
    
    // 7. 更新状态，将这个完整的“视野”存起来
    session.currentSnippet = newSnippet;
}

// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新】这是静音播放功能的核心函数 ▼▼▼

/**
 * 尝试播放用于后台保活的静音音频
 */
function playSilentAudio() {
    const silentPlayer = document.getElementById('silent-audio-player');
    if (silentPlayer) {
        // play() 方法返回一个 Promise，我们需要处理它以避免浏览器报错
        const playPromise = silentPlayer.play();
        if (playPromise !== undefined) {
            playPromise.then(_ => {
                console.log("静音音频已启动，用于后台活动保活。");
            }).catch(error => {
                // 在iOS上，首次播放需要用户交互，这个错误是正常的。
                // 当用户点击开关并保存后，后续的播放通常会成功。
                console.warn("无法自动播放静音音频（这在iOS首次加载时是正常现象）:", error);
            });
        }
    }
}

/**
 * 停止播放静音音频
 */
function stopSilentAudio() {
    const silentPlayer = document.getElementById('silent-audio-player');
    if (silentPlayer && !silentPlayer.paused) {
        silentPlayer.pause();
        silentPlayer.currentTime = 0; // 重置音频，以便下次能从头开始
        console.log("静音音频已停止。");
    }
}

// ▲▲▲ 新增函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】这是语音消息 (TTS) 功能的【全部核心JS代码】，请完整粘贴 ▼▼▼

/**
 * 【总入口】当用户点击语音消息的播放按钮时触发
 * @param {HTMLElement} bodyElement - 被点击的 .voice-message-body 元素
 */
async function playTtsAudio(bodyElement) {
    const text = decodeURIComponent(bodyElement.dataset.text);
    const voiceId = bodyElement.dataset.voiceId;
    const button = bodyElement.querySelector('.voice-play-btn');
    const spinner = bodyElement.querySelector('.voice-spinner');
    
    // 检查是否正在播放同一条语音
    const ttsPlayer = document.getElementById('tts-audio-player');
    if (!ttsPlayer.paused && ttsPlayer.dataset.currentText === text && ttsPlayer.dataset.currentVoiceId === voiceId) {
        ttsPlayer.pause(); // 如果是，则暂停
        return;
    }

    // 暂停任何可能正在播放的旧语音
    ttsPlayer.pause();
    
    // 重置所有其他播放按钮的UI
    document.querySelectorAll('.voice-play-btn').forEach(btn => btn.textContent = '▶');
    
    // 1. 检查缓存
    const cacheKey = `tts_${voiceId}_${text}`;
    let cachedAudio = state.ttsCache.get(cacheKey);

    if (cachedAudio) {
        console.log("从缓存播放 TTS 音频...");
        await playAudioFromData(cachedAudio.url, cachedAudio.type, text, voiceId, button);
        return;
    }

    // 2. 如果没有缓存，则调用API
    console.log("无缓存，正在请求 Minimax TTS API...");
    button.style.display = 'none';
    spinner.style.display = 'block';

    const { minimaxGroupId, minimaxApiKey } = state.apiConfig;
    if (!minimaxGroupId || !minimaxApiKey) {
        await showCustomAlert("配置错误", "请先在API设置中填写您的 Minimax Group ID 和 API Key。");
        spinner.style.display = 'none';
        button.style.display = 'flex';
        return;
    }

    try {
        const response = await fetch('https://api.minimax.chat/v1/text_to_speech', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${minimaxApiKey}`,
                'Content-Type': 'application/json',
                'GroupId': minimaxGroupId
            },
            body: JSON.stringify({
                text: text,
                voice_id: voiceId,
                model: "speech-01",
                timber_weights: [{"voice_id": voiceId, "weight": 1}]
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.base_resp?.status_msg || `API 返回错误: ${response.status}`);
        }

        const audioBlob = await response.blob();
        
        // 播放音频
        const audioUrl = URL.createObjectURL(audioBlob);
        await playAudioFromData(audioUrl, audioBlob.type, text, voiceId, button);

        // 保存到缓存
        const reader = new FileReader();
        reader.onloadend = function() {
            state.ttsCache.set(cacheKey, { url: reader.result, type: audioBlob.type });
            console.log("TTS 音频已保存到缓存。");
        }
        reader.readAsDataURL(audioBlob);

    } catch (error) {
        console.error("Minimax TTS API 调用失败:", error);
        await showCustomAlert("语音生成失败", `错误: ${error.message}`);
    } finally {
        spinner.style.display = 'none';
        button.style.display = 'flex';
    }
}

/**
 * 【辅助函数】从数据源播放音频并处理UI更新
 */
function playAudioFromData(audioSrc, audioType, text, voiceId, button) {
    return new Promise((resolve, reject) => {
        const ttsPlayer = document.getElementById('tts-audio-player');
        
        ttsPlayer.src = audioSrc;
        ttsPlayer.type = audioType;
        ttsPlayer.dataset.currentText = text;
        ttsPlayer.dataset.currentVoiceId = voiceId;

        const playPromise = ttsPlayer.play();

        if (playPromise !== undefined) {
            playPromise.then(() => {
                button.textContent = '❚❚'; // 播放中
                resolve();
            }).catch(error => {
                console.error("音频播放失败:", error);
                reject(error);
            });
        }

        ttsPlayer.onended = () => {
            button.textContent = '▶'; // 播放结束
        };
        ttsPlayer.onpause = () => {
            button.textContent = '▶'; // 暂停
        };
    });
}

// ▲▲▲ 全新JS代码粘贴结束 ▲▲▲




              // ===================================================================
                // 4. 初始化函数 init()
                // ===================================================================
                async function init() {
        /**
         * 智能导入处理器：自动识别文件类型并调用相应的导入函数
         * @param {File} file - 用户选择的 .json 文件
         */
        async function handleWorldBookImport(file) {
            if (!file) return;
        
            try {
                const text = await file.text();
                const data = JSON.parse(text);
        
                // 检查是否是 EPhone 的备份文件
                if (data.type === 'EPhoneWorldBookBackup') {
                    console.log("检测到 EPhone 备份文件，执行标准导入...");
                    await importWorldBooks(data); // 注意：我们将修改 importWorldBooks 来接收解析后的数据
                } 
                // 检查是否是 Tavern AI 的世界书文件
                else if (data.entries && typeof data.entries === 'object') {
                    console.log("检测到 Tavern AI 世界书文件，执行兼容导入...");
                    await importTavernWorldBook(data, file.name);
                } 
                // 如果两种格式都不是
                else {
                    throw new Error("文件格式无法识别。请确保您选择的是有效的 EPhone 世界书备份或 Tavern AI 世界书文件。");
                }
        
            } catch (error) {
                console.error("导入世界书时出错:", error);
                await showCustomAlert('导入失败', `文件解析或应用失败: ${error.message}`);
            }
        }
        
        /**
         * 【兼容核心】从 Tavern AI 格式的数据创建一本新的世界书
         * @param {object} tavernData - 从 Tavern AI .json 文件解析出的数据
         * @param {string} fileName - 原始文件名，用于生成默认书名
         */
        async function importTavernWorldBook(tavernData, fileName) {
            const bookNameSuggestion = fileName.replace(/\.json$/i, ''); // 从文件名中提取建议名称
        
            const newBookName = await showCustomPrompt(
                "导入 Tavern AI 世界书", 
                "请为这本设定集命名：",
                bookNameSuggestion
            );
        
            if (!newBookName || !newBookName.trim()) {
                alert("导入已取消，因为未提供书名。");
                return;
            }
        
            const newEntries = Object.values(tavernData.entries).map(entry => {
                // 将 Tavern 的数据结构转换为 EPhone 的格式
                return {
                    keys: entry.key || [],
                    comment: entry.comment || '无备注',
                    content: entry.content || '',
                    enabled: !entry.disable // 注意：Tavern 的 disable 和 EPhone 的 enabled 逻辑是相反的
                };
            }).filter(entry => entry.content); // 过滤掉没有内容的条目
        
            if (newEntries.length === 0) {
                alert("这个 Tavern AI 世界书中没有找到任何有效的条目。");
                return;
            }
        
            const newWorldBook = {
                id: 'wb_' + Date.now(),
                name: newBookName.trim(),
                content: newEntries,
                categoryId: null // 默认不分类
            };
        
            await db.worldBooks.add(newWorldBook);
            state.worldBooks.push(newWorldBook); // 更新内存
            await renderWorldBookScreen(); // 刷新UI
        
            await showCustomAlert('导入成功！', `已成功从 Tavern AI 文件导入设定集《${newBookName}》。`);
        }


        async function exportWorldBooks() {
            try {
                const books = await db.worldBooks.toArray();
                const categories = await db.worldBookCategories.toArray();
        
                if (books.length === 0 && categories.length === 0) {
                    alert("没有可导出的世界书数据。");
                    return;
                }
        
                const backupData = {
                    type: 'EPhoneWorldBookBackup', // 特殊标记，用于导入时验证
                    version: 1,
                    timestamp: Date.now(),
                    books: books,
                    categories: categories
                };
        
                const blob = new Blob(
                    [JSON.stringify(backupData, null, 2)], 
                    { type: 'application/json' }
                );
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `EPhone-WorldBooks-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                URL.revokeObjectURL(url);
                
                await showCustomAlert('导出成功', '所有世界书数据已成功导出！');
        
            } catch (error) {
                console.error("导出世界书时出错:", error);
                await showCustomAlert('导出失败', `发生了一个错误: ${error.message}`);
            }
        }
        
/**
         * 【已更新】导入 EPhone 世界书备份数据，并覆盖现有数据
         * @param {object} data - 从备份文件解析出的JSON数据
         */
        async function importWorldBooks(data) {
            // 这个函数现在直接接收解析好的数据，不再需要读取文件
            try {
                if (data.type !== 'EPhoneWorldBookBackup' || !data.books) {
                    throw new Error("文件格式不正确，这不是一个有效的世界书备份文件。");
                }
        
                const confirmed = await showCustomConfirm(
                    '导入世界书',
                    '这将用文件中的数据【完全覆盖】您当前所有的世界书和分类。此操作不可撤销！',
                    { confirmButtonClass: 'btn-danger', confirmText: '确认覆盖' }
                );
        
                if (!confirmed) return;
        
                await db.transaction('rw', db.worldBooks, db.worldBookCategories, async () => {
                    await db.worldBooks.clear();
                    await db.worldBookCategories.clear();
                    
                    if (Array.isArray(data.books)) {
                        await db.worldBooks.bulkPut(data.books);
                    }
                    if (Array.isArray(data.categories)) {
                        await db.worldBookCategories.bulkPut(data.categories);
                    }
                });
        
                // 更新内存中的 state 并重新渲染
                state.worldBooks = await db.worldBooks.toArray();
                await renderWorldBookScreen();
        
                await showCustomAlert('导入成功', '世界书数据已成功恢复！');
        
            } catch (error) {
                console.error("导入世界书时出错:", error);
                await showCustomAlert('导入失败', `文件解析或应用失败: ${error.message}`);
            }
        }


    // 【核心修改1】在 `init` 函数的最开始，检查并执行后台活动模拟
    const lastActiveTimestamp = localStorage.getItem('ephoneLastActiveTimestamp');
    if (lastActiveTimestamp) {
        const minutesOffline = (Date.now() - parseInt(lastActiveTimestamp)) / (1000 * 60);
        // 如果离线超过5分钟，才开始模拟
        if (minutesOffline > 5) {
            // 注意：我们在这里调用模拟函数，但不使用 await
            // 这样它就会在后台默默执行，不会卡住应用的启动过程
            simulateBackgroundActivity(minutesOffline);
        }
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
setupCharPlayerControls();
    // ▼▼▼ 【核心修复】将内部函数暴露到全局，以便HTML中的 onclick 可以调用它们 ▼▼▼
    window.showScreen = showScreen;
    window.openRenderingRulesScreen = openRenderingRulesScreen;
    window.handleListenTogetherClick = handleListenTogetherClick; // 为“一起听”按钮暴露函数
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
window.openCharacterSelector = openCharacterSelector;
window.openCharApp = openCharApp;
window.switchToMyPhone = switchToMyPhone;
window.switchToCharHomeScreen = switchToCharHomeScreen;
window.openNpcEditor = openNpcEditor; // <-- 新增这一行
// ▲▲▲ 粘贴结束 ▲▲▲
    // ▲▲▲ 修复结束 ▲▲▲
        // 在 init() 函数开头添加
        const stickerActionBar = document.createElement('div');
        stickerActionBar.id = 'sticker-action-bar';
        stickerActionBar.innerHTML = '<button id="delete-selected-stickers-btn">删除 (0)</button>';
        document.getElementById('sticker-panel').appendChild(stickerActionBar);
                    // ▼▼▼ 在这里粘贴新代码 ▼▼▼
                    const globalCssStyleTag = document.createElement('style');
                    globalCssStyleTag.id = 'global-custom-style';
                    document.head.appendChild(globalCssStyleTag);
                    // ▲▲▲ 新代码粘贴结束 ▲▲▲
        // 在 init() 函数的开头
        qzoneStickerPanelState.panelEl = document.getElementById('qzone-sticker-panel');
        qzoneStickerPanelState.gridEl = document.getElementById('qzone-sticker-grid');
            // ▼▼▼ 在 init() 函数的【最开头】，粘贴下面这两行代码 ▼▼▼
            const savedTheme = localStorage.getItem('ephone-theme') || 'light'; // 默认为日间模式
            applyTheme(savedTheme);
            // ▲▲▲ 粘贴结束 ▲▲▲
        
            // ▼▼▼ 新增代码 ▼▼▼
            const customBubbleStyleTag = document.createElement('style');
            customBubbleStyleTag.id = 'custom-bubble-style';
            document.head.appendChild(customBubbleStyleTag);
            // ▲▲▲ 新增结束 ▲▲▲
        
            // ▼▼▼ 新增代码 ▼▼▼
            const previewBubbleStyleTag = document.createElement('style');
            previewBubbleStyleTag.id = 'preview-bubble-style';
            document.head.appendChild(previewBubbleStyleTag);
            // ▲▲▲ 新增结束 ▲▲▲
        
        
            // ▼▼▼ 修改这两行 ▼▼▼
            applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 清除真实聊天界面的自定义样式
            applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 清除预览区的自定义样式
            // ▲▲▲ 修改结束 ▲▲▲
                   window.openRenderingRulesScreen = openRenderingRulesScreen;
                    window.showScreen = showScreen;
                    window.renderChatListProxy = renderChatList;
                    window.renderApiSettingsProxy = renderApiSettings;
                    window.renderWallpaperScreenProxy = renderWallpaperScreen;
                    window.renderWorldBookScreenProxy = renderWorldBookScreen;
        
                    await loadAllDataFromDB();
                    applyStatusBarVisibility(); // <-- 新增这一行
                    // ▼▼▼ 【核心】在这里添加下面这行新代码 ▼▼▼
                    await migrateOldRedPacketData();
                    // ▲▲▲ 添加结束 ▲▲▲
                    // ▼▼▼ 在这里粘贴新代码 ▼▼▼
                    applyGlobalCss(state.globalSettings.globalCss);
                    // ▲▲▲ 新代码粘贴结束 ▲▲▲
        
                    // 初始化未读动态计数
                    const storedCount = parseInt(localStorage.getItem('unreadPostsCount')) || 0;
                    updateUnreadIndicator(storedCount);
                    
                    // ▲▲▲ 代码添加结束 ▲▲▲
        
                    if (state.globalSettings && state.globalSettings.fontUrl) {
                        applyCustomFont(state.globalSettings.fontUrl);
                    }
        
                    updateClock();
                    setInterval(updateClock, 1000 * 30);
                    applyGlobalWallpaper();
                    initBatteryManager(); 
        
        applyAppIcons();
        applyWidgetData(); // <-- 添加这一行
        
                    // ==========================================================
                    // --- 各种事件监听器 ---
                    // ==========================================================
        // ▼▼▼ 在 init() 的事件监听器区域，添加这行新代码 ▼▼▼
        document.getElementById('rules-tabs').addEventListener('click', (e) => {
            if (e.target.classList.contains('rules-tab')) {
                switchRuleCategory(e.target.dataset.categoryId);
            }
        });
        // ▲▲▲ 新增代码结束 ▲▲▲
        // ▼▼▼ 在 init() 函数的事件监听器区域，粘贴这段新代码 ▼▼▼
        // 渲染规则功能事件绑定
        document.getElementById('add-new-rule-btn').addEventListener('click', () => openRuleEditor(null));
        document.getElementById('cancel-rule-editor-btn').addEventListener('click', () => {
            document.getElementById('rule-editor-modal').classList.remove('visible');
        });
        document.getElementById('save-rule-btn').addEventListener('click', saveRenderingRule);
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
        
        // ▼▼▼ 【全新】为单聊“拍一拍”按钮绑定事件 ▼▼▼
        document.getElementById('pat-btn').addEventListener('click', () => {
            // 确保当前在单聊中
            if (state.activeChatId && !state.chats[state.activeChatId].isGroup) {
                const chat = state.chats[state.activeChatId];
                // 调用现有的拍一拍函数，并传入正确的参数
                handleUserPat(chat.id, chat.originalName);
            }
        });
        // ▲▲▲ 新增代码结束 ▲▲▲
        // ▼▼▼ 【这是您缺失的核心功能代码，请粘贴在这里】 ▼▼▼
        let activeAnnouncementId = null; // 用于暂存正在操作的公告ID
        
        /**
         * 点击“...”时，显示操作菜单（置顶/删除）
         * @param {string} annoId - 公告的唯一ID
         */
        function showAnnouncementActions(annoId) {
            activeAnnouncementId = annoId;
            const chat = state.chats[state.activeChatId];
            const announcement = chat.announcements.find(a => a.id === annoId);
            if (!announcement) return;
        
            const pinButton = document.getElementById('announcement-action-pin');
            // 根据当前是否已置顶，动态改变按钮文字
            pinButton.textContent = announcement.isPinned ? '取消置顶' : '置顶公告';
        
            document.getElementById('announcement-actions-modal').classList.add('visible');
        }
        
        /**
         * 处理“置顶/取消置顶”操作
         */
        async function handlePinAnnouncement() {
            if (!activeAnnouncementId) return;
            const chat = state.chats[state.activeChatId];
            const announcement = chat.announcements.find(a => a.id === activeAnnouncementId);
            if (announcement) {
                announcement.isPinned = !announcement.isPinned; // 切换置顶状态
                await db.chats.put(chat);
                showAnnouncementBoard(); // 重新渲染公告板以更新UI
            }
            document.getElementById('announcement-actions-modal').classList.remove('visible');
        }
        
        /**
         * 处理“删除公告”操作
         */
        async function handleDeleteAnnouncement() {
            if (!activeAnnouncementId) return;
        
            const confirmed = await showCustomConfirm("确认删除", "确定要删除这条公告吗？此操作不可恢复。", { confirmButtonClass: 'btn-danger' });
        
            if (confirmed) {
                const chat = state.chats[state.activeChatId];
                // 从公告数组中过滤掉要删除的公告
                chat.announcements = chat.announcements.filter(a => a.id !== activeAnnouncementId);
                await db.chats.put(chat);
                showAnnouncementBoard(); // 重新渲染
            }
            document.getElementById('announcement-actions-modal').classList.remove('visible');
        }
        // ▲▲▲ 粘贴结束 ▲▲▲
                    document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
                    document.getElementById('custom-modal-overlay').addEventListener('click', (e) => { if (e.target === modalOverlay) hideCustomModal(); });
                    document.getElementById('export-data-btn').addEventListener('click', exportBackup);
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
document.getElementById('cleanup-data-btn').addEventListener('click', cleanupRedundantData);
// ▲▲▲ 粘贴结束 ▲▲▲
document.getElementById('offline-mode-toggle').addEventListener('change', (e) => {
    // 根据开关的选中状态，立即显示或隐藏下方的“线下模式选项”区域
    document.getElementById('offline-mode-options').style.display = e.target.checked ? 'block' : 'none';
});
                    document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-data-input').click());
    document.getElementById('time-perception-toggle').addEventListener('change', (e) => {
        document.getElementById('time-zone-group').style.display = e.target.checked ? 'block' : 'none';
    });
                    document.getElementById('import-data-input').addEventListener('change', e => importBackup(e.target.files[0]));
                    document.getElementById('import-card-input').addEventListener('change', handleCardImport);
                    document.getElementById('back-to-list-btn').addEventListener('click', () => { 
               ruleCache = {};
            // ▼▼▼ 修改这两行 ▼▼▼
            applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 清除真实聊天界面的自定义样式
            applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 清除预览区的自定义样式
            // ▲▲▲ 修改结束 ▲▲▲
        
        exitSelectionMode(); state.activeChatId = null; showScreen('chat-list-screen'); });
                    
        // ▼▼▼ 【请用这个新版本】替换旧的 add-chat-btn 事件监听器 ▼▼▼
        document.getElementById('add-chat-btn').addEventListener('click', async () => {
            // 使用我们现有的 showChoiceModal 函数来提供选项
            const choice = await showChoiceModal('创建新聊天', [
                { text: '手动创建角色', value: 'manual' },
                { text: '从角色卡导入 (.json/.png)', value: 'import_card' }
            ]);
        
            if (choice === 'manual') {
                // 如果用户选择手动，则执行原来的逻辑
                const remarkName = await showCustomPrompt('创建新聊天 (第1/2步)', '请输入你想为Ta设置的【备注名】(例如: 哥哥)');
                if (!remarkName || !remarkName.trim()) return;
        
                const originalName = await showCustomPrompt('创建新聊天 (第2/2步)', '请输入Ta的【本名】(例如: 李星辰，这个名字将用于AI识别)');
                if (!originalName || !originalName.trim()) return;
        
// 这是全新的、确保角色能正确显示的代码
const newChatId = 'chat_' + Date.now();
const newChat = {
    id: newChatId,
    name: remarkName.trim(),
    originalName: originalName.trim(),
    isGroup: false,
    isPinned: false, // 【修复】补充置顶状态
    unreadCount: 0,  // 【修复】补充未读消息计数
    relationship: { status: 'friend', blockedTimestamp: null, applicationReason: '' },
    status: { text: '在线', lastUpdate: Date.now(), isBusy: false },
    settings: {
        aiPersona: '这是一个通过手动创建的角色。',
        myPersona: '我是谁呀。',
        myNickname: '我',
        maxMemory: 10,
        aiAvatar: defaultAvatar,
        myAvatar: defaultAvatar,
        background: '',
        theme: 'default',
        fontSize: 13,
        customCss: '',
        linkedWorldBookIds: [],
        aiAvatarLibrary: [],
        myAvatarLibrary: [],
        enableBackgroundActivity: true, // 【修复】补充后台活动开关
        actionCooldownMinutes: 15,    // 【修复】补充后台活动冷却时间
        enableTimePerception: true,     // 【修复】补充时间感知开关
        isOfflineMode: false,           // 【修复】补充线下模式开关
        offlineMinLength: 100,
        offlineMaxLength: 300,
        offlinePresetId: null,
        timeZone: 'Asia/Shanghai'       // 【修复】补充默认时区
    },
    history: [],
    musicData: { totalTime: 0 },
    longTermMemory: [],
    thoughtsHistory: [] // 【修复】补充心声/散记历史记录
};
                state.chats[newChatId] = newChat;
                await db.chats.put(newChat);
                renderChatList();
                
            } else if (choice === 'import_card') {
                // 如果用户选择导入，就触发我们新添加的隐藏文件输入框
                document.getElementById('import-card-input').click();
            }
        });
        // ▲▲▲ 替换结束 ▲▲▲
        
                    // ▼▼▼ 【修正】创建群聊按钮现在打开联系人选择器 ▼▼▼
        document.getElementById('add-group-chat-btn').addEventListener('click', openContactPickerForGroupCreate);
        // ▲▲▲ 替换结束 ▲▲▲                      
                    document.getElementById('transfer-cancel-btn').addEventListener('click', () => document.getElementById('transfer-modal').classList.remove('visible'));
                    document.getElementById('transfer-confirm-btn').addEventListener('click', sendUserTransfer);
        
                    document.getElementById('listen-together-btn').addEventListener('click', handleListenTogetherClick);
                    document.getElementById('music-exit-btn').addEventListener('click', () => endListenTogetherSession(true));
                    document.getElementById('music-return-btn').addEventListener('click', returnToChat);
                    document.getElementById('music-play-pause-btn').addEventListener('click', togglePlayPause);
                    document.getElementById('music-next-btn').addEventListener('click', playNext);
                    document.getElementById('music-prev-btn').addEventListener('click', playPrev);
                    document.getElementById('music-mode-btn').addEventListener('click', changePlayMode);
                    document.getElementById('music-playlist-btn').addEventListener('click', () => { updatePlaylistUI(); document.getElementById('music-playlist-panel').classList.add('visible'); });
                    document.getElementById('close-playlist-btn').addEventListener('click', () => document.getElementById('music-playlist-panel').classList.remove('visible'));
                    document.getElementById('add-song-url-btn').addEventListener('click', addSongFromURL);
                    document.getElementById('add-song-local-btn').addEventListener('click', () => document.getElementById('local-song-upload-input').click());
                    document.getElementById('local-song-upload-input').addEventListener('change', addSongFromLocal);
// ▼▼▼ 【全新】这是修复按钮点击无响应的核心代码 ▼▼▼
document.getElementById('playlist-body').addEventListener('click', (e) => {
    const target = e.target;
    const trackIndex = parseInt(target.dataset.index);

    if (isNaN(trackIndex)) return;

    if (target.classList.contains('album-art-btn')) {
        handleChangeAlbumArt(trackIndex);
    } else if (target.classList.contains('lyrics-btn')) {
        handleManualLrcImport(trackIndex);
    } else if (target.classList.contains('bg-btn')) {
        handleChangeBackground(trackIndex);
    } else if (target.classList.contains('delete-track-btn')) {
        deleteTrack(trackIndex);
    }
});
// ▲▲▲ 新增代码粘贴结束 ▲▲▲
                    audioPlayer.addEventListener('ended', () => {
    // 歌曲播放结束时，移除旋转样式
    document.getElementById('vinyl-view').classList.remove('spinning');
    playNext(); 
});
                    audioPlayer.addEventListener('ended', () => {
    // 歌曲播放结束时，移除旋转样式
    document.getElementById('vinyl-view').classList.remove('spinning');
    playNext(); 
});

audioPlayer.addEventListener('pause', () => { 
    if(musicState.isActive) { 
        musicState.isPlaying = false; 
        updatePlayerUI(); 
        // 音乐暂停时，移除旋转样式
        document.getElementById('vinyl-view').classList.remove('spinning');
    } 
});

audioPlayer.addEventListener('play', () => { 
    if(musicState.isActive) { 
        musicState.isPlaying = true; 
        updatePlayerUI(); 
        // 音乐开始播放时，添加旋转样式
        document.getElementById('vinyl-view').classList.add('spinning');
    } 
});
        
                    const chatInput = document.getElementById('chat-input');
                    // ▼▼▼ 找到 id="send-btn" 的 click 事件监听器 ▼▼▼
// 【最终性能优化版】
document.getElementById('send-btn').addEventListener('click', () => { // 注意：移除了 async
    const content = chatInput.value.trim();
    if (!content || !state.activeChatId) return;

    const chat = state.chats[state.activeChatId];
    const msg = {
        role: 'user',
        content,
        timestamp: Date.now()
    };

    if (currentReplyContext) {
        msg.quote = currentReplyContext;
    }

    // 【优化1：先渲染，后保存】立即将消息显示在屏幕上，给用户即时反馈！
    appendMessage(msg, chat);

    // 【优化2：异步处理耗时操作】将数据存储和列表更新放到后台，不阻塞用户界面
    (async () => {
        chat.history.push(msg);
        await db.chats.put(chat); // 保存到数据库
    renderChatList(); // <<<<< 修改为这一行

    })();

    // 清理工作（这部分很快，可以立即执行）
    chatInput.value = '';
    chatInput.style.height = 'auto';
    chatInput.focus();
    cancelReplyMode();
});
                    document.getElementById('wait-reply-btn').addEventListener('click', triggerAiResponse);
                    chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); document.getElementById('send-btn').click(); } });
                    //chatInput.addEventListener('input', () => { chatInput.style.height = 'auto'; chatInput.style.height = (chatInput.scrollHeight) + 'px'; });
        
                    document.getElementById('wallpaper-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if(file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); newWallpaperBase64 = dataUrl; renderWallpaperScreen(); } });
        // ▼▼▼ 【请用这个已包含CPhone设置的最终版本】替换旧的 'save-wallpaper-btn' 事件监听器 ▼▼▼
        document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {
            // 保存 EPhone 壁纸
            if (newWallpaperBase64) {
                state.globalSettings.wallpaper = newWallpaperBase64;
            }
            
            // 【核心新增】将 state 中临时的 CPhone 壁纸设置也一并保存
            // (注意：cphoneWallpaper已经在上传时更新到state了, 这里只需确保它被存入数据库)

            state.globalSettings.globalCss = document.getElementById('global-css-input').value.trim();
            state.globalSettings.notificationSoundUrl = document.getElementById('notification-sound-url-input').value.trim();
            state.globalSettings.showStatusBar = document.getElementById('status-bar-toggle-switch').checked;
            
            // 一次性保存所有全局设置 (包括了EPhone和CPhone的所有新旧设置)
            await db.globalSettings.put(state.globalSettings);
            
            // 应用所有更改
            applyGlobalWallpaper();
            applyCPhoneWallpaper(); // <-- 新增调用
            newWallpaperBase64 = null; // 清空临时壁纸变量

            applyAppIcons();
            applyCPhoneAppIcons(); // <-- 新增调用
            
            applyGlobalCss(state.globalSettings.globalCss);
            applyStatusBarVisibility();

            alert('外观设置已保存并应用！');
            showScreen('home-screen');
        });
        // ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【核心修复】请用这段新代码，替换旧的滚动事件监听器 ▼▼▼
const messagesView = document.getElementById('messages-view'); // <--- 核心修改1：获取正确的滚动容器
messagesView.addEventListener('scroll', () => { // <--- 核心修改2：在 messages-view 上监听
    // 解构赋值获取滚动相关的属性
    const { scrollTop, scrollHeight, clientHeight } = messagesView;

    // 判断条件：当滚动条距离底部的距离小于一个屏幕的高度时
    // 这个条件保持不变，是可靠的
    if (scrollHeight - scrollTop - clientHeight < clientHeight) {
        // 并且当前不处于加载状态
        if (!isLoadingMoreChats) {
            // 就触发加载下一页
            loadMoreChats();
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 【请用这个新版本】替换旧的 save-api-settings-btn 事件监听器 ▼▼▼
        document.getElementById('save-api-settings-btn').addEventListener('click', async () => {
            // 保存主API
            state.apiConfig.proxyUrl = document.getElementById('proxy-url').value.trim();
            state.apiConfig.apiKey = document.getElementById('api-key').value.trim();
            state.apiConfig.model = document.getElementById('model-select').value;
state.apiConfig.minimaxGroupId = document.getElementById('minimax-group-id').value.trim();
state.apiConfig.minimaxApiKey = document.getElementById('minimax-api-key').value.trim();            
            // 【核心新增】保存副API
            state.apiConfig.secondaryProxyUrl = document.getElementById('secondary-proxy-url').value.trim();
            state.apiConfig.secondaryApiKey = document.getElementById('secondary-api-key').value.trim();
            state.apiConfig.secondaryModel = document.getElementById('secondary-model-select').value;
            
            await db.apiConfig.put(state.apiConfig);
        
            // 后台活动设置的保存逻辑保持不变
            const backgroundSwitch = document.getElementById('background-activity-switch');
            const intervalInput = document.getElementById('background-interval-input');
            const cooldownInput = document.getElementById('block-cooldown-input');
        
            state.globalSettings.enableBackgroundActivity = backgroundSwitch.checked;
            state.globalSettings.backgroundActivityInterval = parseInt(intervalInput.value) || 60;
            state.globalSettings.blockCooldownHours = parseFloat(cooldownInput.value) || 1;
            state.globalSettings.enableAiDrawing = document.getElementById('enable-ai-drawing-switch').checked;
           state.globalSettings.chatRenderWindow = parseInt(document.getElementById('chat-render-window-input').value) || 50;
            state.globalSettings.chatListRenderWindow = parseInt(document.getElementById('chat-list-render-window-input').value) || 30;
            state.globalSettings.apiTemperature = parseFloat(document.getElementById('api-temperature-slider').value);
            await db.globalSettings.put(state.globalSettings);
        
            stopBackgroundSimulation(); 
            if (state.globalSettings.enableBackgroundActivity) {
                startBackgroundSimulation();
                console.log(`后台活动模拟已启动，间隔: ${state.globalSettings.backgroundActivityInterval}秒`);
            } else {
                console.log("后台活动模拟已停止。");
            }
            
            alert('所有API与后台设置已保存!'); 
        });
        // ▲▲▲ 替换结束 ▲▲▲
        
                            // gemini 密钥聚焦的时候显示明文
                const ApiKeyInput = document.getElementById('api-key')
                ApiKeyInput.addEventListener('focus', (e) => {
                    e.target.setAttribute('type', 'text')
                })
                ApiKeyInput.addEventListener('blur', (e) => {
                    e.target.setAttribute('type', 'password')
                })
        
        
        // ▼▼▼ 【请用这整块代码】替换旧的 fetch-models-btn 事件监听器 ▼▼▼
        
        // 封装一个可复用的模型拉取函数
        async function fetchModels(urlInputId, keyInputId, selectId) {
            const url = document.getElementById(urlInputId).value.trim();
            const key = document.getElementById(keyInputId).value.trim();
            if (!url || !key) return alert('请先填写对应的反代地址和密钥');
            
            try {
                let isGemini = url === GEMINI_API_URL;
                const response = await fetch(isGemini ? `${GEMINI_API_URL}?key=${getRandomValue(key)}` : `${url}/v1/models`, isGemini ? undefined : { headers: { 'Authorization': `Bearer ${key}` } });
                if (!response.ok) throw new Error('无法获取模型列表');
                const data = await response.json();
                let models = isGemini ? data.models.map(model => ({ id: model.name.split('/')[1] || model.name })) : data.data;
                
                const modelSelect = document.getElementById(selectId);
                modelSelect.innerHTML = '';
                // 【核心】根据是主/副模型，读取正确的已保存模型
                const savedModel = selectId === 'model-select' ? state.apiConfig.model : state.apiConfig.secondaryModel;
        
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.id;
                    if (model.id === savedModel) option.selected = true;
                    modelSelect.appendChild(option);
                });
                alert('模型列表已更新');
            } catch (error) {
                alert(`拉取模型失败: ${error.message}`);
            }
        }
        
        // 绑定主模型拉取按钮
        document.getElementById('fetch-models-btn').addEventListener('click', () => {
            fetchModels('proxy-url', 'api-key', 'model-select');
        });
        
        // 【核心新增】绑定副模型拉取按钮
        document.getElementById('fetch-secondary-models-btn').addEventListener('click', () => {
            fetchModels('secondary-proxy-url', 'secondary-api-key', 'secondary-model-select');
        });
        // ▲▲▲ 替换结束 ▲▲▲
                    document.getElementById('add-world-book-btn').addEventListener('click', async () => { const name = await showCustomPrompt('创建世界书', '请输入书名'); if (name && name.trim()) { const newBook = { id: 'wb_' + Date.now(), name: name.trim(), content: '' }; await db.worldBooks.add(newBook); state.worldBooks.push(newBook); renderWorldBookScreen(); openWorldBookEditor(newBook.id); } });
// ▼▼▼ 【全新 | iOS 兼容版】请用这个新版本替换旧的 save-world-book-btn 事件监听器 ▼▼▼
document.getElementById('save-world-book-btn').addEventListener('click', async () => {
    if (!editingWorldBookId) return;
    const book = state.worldBooks.find(wb => wb.id === editingWorldBookId);
    if (!book) return;

    // (这部分保存数据的逻辑保持不变)
    const newName = document.getElementById('world-book-name-input').value.trim();
    if (!newName) { alert('书名不能为空！'); return; }
    book.name = newName;
    const categoryId = document.getElementById('world-book-category-select').value;
    book.categoryId = categoryId ? parseInt(categoryId) : null;

    const entriesContainer = document.getElementById('world-book-entries-container');
    const entryBlocks = entriesContainer.querySelectorAll('.message-editor-block');
    const newEntries = [];

    entryBlocks.forEach(block => {
        const keysInput = block.querySelector('.entry-keys-input').value.trim();
        const content = block.querySelector('.entry-content-textarea').value.trim();
        const isEnabled = block.querySelector('.entry-enabled-switch').checked;
        if (content) {
            newEntries.push({
                comment: block.querySelector('.entry-comment-input').value.trim(),
                keys: keysInput ? keysInput.split(',').map(k => k.trim()).filter(k => k) : [],
                content: content,
                enabled: isEnabled
            });
        }
    });
    book.content = newEntries;

    // 1. 先将所有数据保存到数据库
    await db.worldBooks.put(book);
    document.getElementById('world-book-editor-title').textContent = newName;
    editingWorldBookId = null;

    // 2. 【核心修复】先切换到目标屏幕
    showScreen('world-book-screen');
    
    // 3. 【核心修复】然后再异步地渲染内容
    await renderWorldBookScreen();
});
// ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 【最终修复版】请用这整块代码，完整替换旧的 chat-messages 事件监听器 ▼▼▼
        document.getElementById('chat-messages').addEventListener('click', async (e) => {
    const ttsVoiceBody = e.target.closest('.voice-message-body[data-text]');
    if (ttsVoiceBody) {
        playTtsAudio(ttsVoiceBody);
        return; // 处理完后直接退出，避免触发其他逻辑
    }
            // 检查是否点击了 "查看详情" 按钮
            const detailsBtn = e.target.closest('.waimai-details-btn');
            if (detailsBtn) {
                const bubble = detailsBtn.closest('.message-bubble');
                if (bubble) {
                    const timestamp = parseInt(bubble.dataset.timestamp);
                    if (!isNaN(timestamp)) {
                        showWaimaiDetails(timestamp); // 调用我们新加的函数
                        return; // 处理完后直接退出
                    }
                }
            }
            
            // ▼▼▼ 【【【核心新增代码就在这里！】】】 ▼▼▼
            // 检查是否点击了 "为Ta买单" 或 "残忍拒绝" 按钮
            const choiceBtn = e.target.closest('.waimai-user-actions button');
            if (choiceBtn) {
                const bubble = choiceBtn.closest('.message-bubble');
                if (bubble) {
                    const timestamp = parseInt(bubble.dataset.timestamp);
                    const choice = choiceBtn.dataset.choice; // 获取 'paid' 或 'rejected'
                    if (!isNaN(timestamp) && choice) {
                        await handleWaimaiResponse(timestamp, choice); // 调用已有的处理函数
                        return; // 处理完后退出，避免触发其他逻辑
                    }
                }
            }
        
            // --- 以下是您原来已有的所有其他点击事件逻辑，保持不变 ---
            const deletedPostPlaceholder = e.target.closest('.post-deleted-placeholder');
            if (deletedPostPlaceholder) {
                const postId = parseInt(deletedPostPlaceholder.dataset.postId);
                if (!isNaN(postId)) {
                    const post = await db.qzonePosts.get(postId);
                    if (post) {
                        let originalContent = '';
                        const authorName = post.authorId === 'user' ? state.qzoneSettings.nickname : (state.chats[post.authorId]?.name || '未知作者');
                        
                        if(post.type === 'shuoshuo'){
                            originalContent = post.content;
                        } else {
                            originalContent = post.publicText || '';
                            if(post.imageUrl) originalContent += `\n[图片]`;
                            if(post.hiddenContent) originalContent += `\n[文字图内容: ${post.hiddenContent}]`;
                        }
                        
                        showCustomAlert(
                            `来自 ${authorName} 的已删除动态`, 
                            originalContent.replace(/\n/g, '<br>')
                        );
                    } else {
                        showCustomAlert('提示', '这条动态的原始数据已被彻底清除。');
                    }
                }
                return;
            }
        
            const aiImage = e.target.closest('.ai-generated-image');
            if (aiImage) {
                const description = aiImage.dataset.description;
                if (description) showCustomAlert('照片描述', description);
                return;
            }
        
            const quoteBlock = e.target.closest('.quoted-message');
            if (quoteBlock && quoteBlock.dataset.originalTimestamp) {
                const originalTimestamp = parseInt(quoteBlock.dataset.originalTimestamp);
                if (!isNaN(originalTimestamp)) {
                    scrollToOriginalMessage(originalTimestamp);
                }
            }
            
            const giftCard = e.target.closest('.gift-card');
            if (giftCard) {
                const bubble = giftCard.closest('.message-bubble');
                if (bubble) {
                    showGiftReceipt(parseInt(bubble.dataset.timestamp));
                }
            }
        
            const packetCard = e.target.closest('.red-packet-card');
            if (packetCard) {
                const messageBubble = packetCard.closest('.message-bubble');
                if (messageBubble && messageBubble.dataset.timestamp) {
                    const timestamp = parseInt(messageBubble.dataset.timestamp);
                    handlePacketClick(timestamp);
                }
            }
            
            const pollCard = e.target.closest('.poll-card');
            if (pollCard) {
                const timestamp = parseInt(pollCard.dataset.pollTimestamp);
                if (isNaN(timestamp)) return;
                
                const optionItem = e.target.closest('.poll-option-item');
                if (optionItem && !pollCard.classList.contains('closed')) {
                    handleUserVote(timestamp, optionItem.dataset.option);
                    return;
                }
                
                const actionBtn = e.target.closest('.poll-action-btn');
                if (actionBtn) {
                    if (pollCard.classList.contains('closed')) {
                        showPollResults(timestamp);
                    } else {
                        endPoll(timestamp);
                    }
                    return;
                }
        
                if (pollCard.classList.contains('closed')) {
                    showPollResults(timestamp);
                }
            }
        
    // 【【【这就是修复后的语音消息处理逻辑】】】
    const voiceBody = e.target.closest('.voice-message-body');
    if (voiceBody) {
        const bubble = voiceBody.closest('.message-bubble');
        if (!bubble) return;
        
        const spinner = voiceBody.querySelector('.loading-spinner');
        const transcriptEl = bubble.querySelector('.voice-transcript');

        if (bubble.dataset.state === 'loading') {
            return;
        }

        // 核心逻辑：判断当前状态并执行反向操作
        if (bubble.dataset.state === 'expanded') {
            // 如果已展开，则折叠
            transcriptEl.style.display = 'none';
            bubble.dataset.state = 'collapsed'; // 更新状态
        } 
        else {
            // 如果是折叠或初始状态，则展开
            bubble.dataset.state = 'loading';
            spinner.style.display = 'block';

            setTimeout(() => {
                if (document.body.contains(bubble)) {
                    const voiceText = bubble.dataset.voiceText || '(无法识别)';
                    transcriptEl.textContent = voiceText;
                    
                    spinner.style.display = 'none';
                    transcriptEl.style.display = 'block';
                    bubble.dataset.state = 'expanded'; // 更新状态
                }
            }, 1500);
        }
        return;
    }
        
            const placeholder = e.target.closest('.recalled-message-placeholder');
            if (placeholder) {
                const chat = state.chats[state.activeChatId];
                const wrapper = placeholder.closest('.message-wrapper');
                if (chat && wrapper) {
                    const timestamp = parseInt(wrapper.dataset.timestamp);
                    const recalledMsg = chat.history.find(m => m.timestamp === timestamp);
                    
                    if (recalledMsg && recalledMsg.recalledData) {
                        let originalContentText = '';
                        const recalled = recalledMsg.recalledData;
                        
                        if (recalled.originalType === 'text') {
                            originalContentText = `原文: "${recalled.originalContent}"`;
                        } else {
                            originalContentText = `撤回了一条[${recalled.originalType}]类型的消息`;
                        }
                        showCustomAlert('已撤回的消息', originalContentText);
                    }
                }
            }
        
            const linkCard = e.target.closest('.link-share-card');
            if (linkCard && linkCard.closest('.message-bubble.is-link-share')) {
                const timestamp = parseInt(linkCard.dataset.timestamp);
                openSharedHistoryViewer(timestamp);
            }
        
            const bubble = e.target.closest('.message-bubble');
            if (bubble && bubble.classList.contains('ai') && bubble.classList.contains('is-transfer') && bubble.dataset.status === 'pending') {
                const timestamp = parseInt(bubble.dataset.timestamp);
                if (!isNaN(timestamp)) {
                    showTransferActionModal(timestamp);
                }
            }
        });
        // ▲▲▲ 替换结束 ▲▲▲
                    
                    const chatSettingsModal = document.getElementById('chat-settings-modal');
                    const worldBookSelectBox = document.querySelector('.custom-multiselect .select-box');
                    const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
        // ▼▼▼ 【请用这个新版本】替换旧的 updateWorldBookSelectionDisplay 函数 ▼▼▼
        function updateWorldBookSelectionDisplay() {
            const checkedBoxes = worldBookCheckboxesContainer.querySelectorAll('input:checked');
            const displayText = document.querySelector('.selected-options-text');
            
            if (checkedBoxes.length === 0) {
                displayText.textContent = '-- 点击选择 --';
            } else if (checkedBoxes.length > 2) {
                displayText.textContent = `已选择 ${checkedBoxes.length} 本世界书`;
            } else {
                const displayItems = Array.from(checkedBoxes).map(cb => {
                    return cb.parentElement.textContent.trim();
                });
                displayText.textContent = displayItems.join(', ');
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲   
                    
                    worldBookSelectBox.addEventListener('click', (e) => { e.stopPropagation(); worldBookCheckboxesContainer.classList.toggle('visible'); worldBookSelectBox.classList.toggle('expanded'); });
                    document.getElementById('world-book-checkboxes-container').addEventListener('change', updateWorldBookSelectionDisplay);
                    window.addEventListener('click', (e) => { if (!document.querySelector('.custom-multiselect').contains(e.target)) { worldBookCheckboxesContainer.classList.remove('visible'); worldBookSelectBox.classList.remove('expanded'); } });
        // ▼▼▼ 【请用这个 V3.0 最终修复版】替换旧的 chat-settings-btn 事件监听器 ▼▼▼
        document.getElementById('chat-settings-btn').addEventListener('click', async () => {
            loadThemePresetsDropdown(); // <-- 新增这一行
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            const isGroup = chat.isGroup;
        
            // --- （这部分与之前相同，保持不变） ---
            const switchGreetingGroup = document.getElementById('switch-greeting-group');
            if (!isGroup && chat.settings.alternateGreetings && chat.settings.alternateGreetings.length > 0) {
                switchGreetingGroup.style.display = 'block';
            } else {
                switchGreetingGroup.style.display = 'none';
            }
            
            document.getElementById('chat-name-group').style.display = 'block';
            document.getElementById('my-persona-group').style.display = 'block';
            document.getElementById('my-avatar-group').style.display = 'block';
            document.getElementById('my-group-nickname-group').style.display = isGroup ? 'block' : 'none';
            document.getElementById('my-nickname-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('group-avatar-group').style.display = isGroup ? 'block' : 'none';
            document.getElementById('group-members-group').style.display = isGroup ? 'block' : 'none';
            document.getElementById('ai-persona-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('ai-avatar-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('assign-group-section').style.display = isGroup ? 'none' : 'block';
            document.getElementById('ai-original-name-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('ai-voice-id-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('offline-mode-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('ai-cooldown-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('group-cooldown-group').style.display = isGroup ? 'block' : 'none';
            document.getElementById('chat-name-input').value = chat.name;
            document.getElementById('my-persona').value = chat.settings.myPersona;
            document.getElementById('my-avatar-preview').src = chat.settings.myAvatar || (isGroup ? defaultMyGroupAvatar : defaultAvatar);
            document.getElementById('max-memory').value = chat.settings.maxMemory;
            document.getElementById('linked-memory-count').value = chat.settings.linkedMemoryCount || 10;
            const bgPreview = document.getElementById('bg-preview');
            const removeBgBtn = document.getElementById('remove-bg-btn');
            if (chat.settings.background) {
                bgPreview.src = chat.settings.background;
                bgPreview.style.display = 'block';
                removeBgBtn.style.display = 'inline-block';
            } else {
                bgPreview.style.display = 'none';
                removeBgBtn.style.display = 'none';
            }
            document.getElementById('lyrics-position-group').style.display = isGroup ? 'none' : 'block';
// 【核心新增】根据是否为群聊，显示或隐藏对应的后台活动开关
document.getElementById('single-char-background-activity-group').style.display = isGroup ? 'none' : 'block';
document.getElementById('group-background-activity-group').style.display = isGroup ? 'block' : 'none';

// (后续的赋值逻辑，请用下面这整块新代码完整替换)
// 【新增代码】读取时间感知设置
// 【新增代码】读取时间感知设置并控制时区选择器显隐
const timePerceptionToggle = document.getElementById('time-perception-toggle');
const timeZoneGroup = document.getElementById('time-zone-group');
timePerceptionToggle.checked = chat.settings.enableTimePerception;
timeZoneGroup.style.display = timePerceptionToggle.checked ? 'block' : 'none';

// 填充时区下拉列表
const timezoneSelect = document.getElementById('time-zone-select');
// Intl.supportedValuesOf('timeZone') 是浏览器内置的API，可以获取所有支持的时区
const timezones = Intl.supportedValuesOf('timeZone');
timezoneSelect.innerHTML = ''; // 清空旧选项
timezones.forEach(tz => {
    const option = document.createElement('option');
    option.value = tz;
    option.textContent = tz;
    timezoneSelect.appendChild(option);
});
// 设置当前选中的时区，如果没设置过，则默认为上海
timezoneSelect.value = chat.settings.timeZone || 'Asia/Shanghai';
if (isGroup) {
    // 【核心新增】读取并设置群聊开关的状态
    document.getElementById('group-background-activity-switch').checked = chat.settings.enableBackgroundActivity;
    document.getElementById('my-group-nickname-input').value = chat.settings.myNickname || '';
    document.getElementById('group-avatar-preview').src = chat.settings.groupAvatar || defaultGroupAvatar;
    document.getElementById('group-action-cooldown-input').value = chat.settings.actionCooldownMinutes || 10;

    // 【核心新增】在群聊设置中，隐藏单聊的后台活动开关
    document.getElementById('single-char-background-activity-group').style.display = 'none';
    renderGroupMemberSettings(chat.members);
} else {
    // 【核心新增】在单聊设置中，显示并设置开关的当前状态
    document.getElementById('single-char-background-activity-group').style.display = 'block';
    document.getElementById('char-background-activity-switch').checked = chat.settings.enableBackgroundActivity;

    // (其他单聊设置的读取逻辑保持不变)
    const offlineModeToggle = document.getElementById('offline-mode-toggle');
    const offlineModeOptions = document.getElementById('offline-mode-options');
    const offlineMinInput = document.getElementById('offline-min-length-input');
    const offlineMaxInput = document.getElementById('offline-max-length-input');
    offlineModeToggle.checked = chat.settings.isOfflineMode || false;
    offlineModeOptions.style.display = offlineModeToggle.checked ? 'block' : 'none';
    offlineMinInput.value = chat.settings.offlineMinLength || 100;
    offlineMaxInput.value = chat.settings.offlineMaxLength || 300;
await renderOfflinePresetSelector(chat);
    document.getElementById('ai-original-name-input').value = chat.originalName;
document.getElementById('ai-voice-id-input').value = chat.settings.minimaxVoiceId || '';
    document.getElementById('ai-persona').value = chat.settings.aiPersona;
    document.getElementById('ai-avatar-preview').src = chat.settings.aiAvatar || defaultAvatar;
    document.getElementById('my-nickname-input').value = chat.settings.myNickname || '我';
    document.getElementById('ai-action-cooldown-input').value = chat.settings.actionCooldownMinutes || 10;
    const select = document.getElementById('assign-group-select');
    select.innerHTML = '<option value="">未分组</option>';
    const groups = await db.qzoneGroups.toArray();
    groups.forEach(group => {
        const option = document.createElement('option');
        option.value = group.id;
        option.textContent = group.name;
        if (chat.groupId === group.id) option.selected = true;
        select.appendChild(option);
    });
    const lyricsPos = chat.settings.lyricsPosition || { vertical: 'top', horizontal: 'center', offset: 10 };
    document.getElementById('lyrics-vertical-pos').value = lyricsPos.vertical;
    document.getElementById('lyrics-horizontal-pos').value = lyricsPos.horizontal;
    document.getElementById('lyrics-offset-input').value = lyricsPos.offset;
}
// ▲▲▲ 替换结束 ▲▲▲
            
            // --- 【【【核心修复从这里开始】】】 ---
            const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
            worldBookCheckboxesContainer.innerHTML = ''; // 清空旧列表
        
            const [allCategories, allBooks] = await Promise.all([
                db.worldBookCategories.toArray(),
                db.worldBooks.toArray()
            ]);
        
            const linkedBookIds = new Set(chat.settings.linkedWorldBookIds || []);
        
            if (allBooks.length === 0) {
                worldBookCheckboxesContainer.innerHTML = '<p style="text-align:center; color: #8a8a8a;">还没有创建任何世界书</p>';
            } else {
                // 1. 先按分类渲染书籍
                allCategories.forEach(cat => {
                    const booksInCategory = allBooks.filter(book => book.categoryId === cat.id);
                    if (booksInCategory.length > 0) {
                        const categoryHeader = document.createElement('h4');
                        categoryHeader.textContent = cat.name; // 分类名作为标题
                        categoryHeader.style.cssText = 'margin: 10px 0 5px; color: #555; border-bottom: 1px solid #eee; padding-bottom: 3px;';
                        worldBookCheckboxesContainer.appendChild(categoryHeader);
        
                        booksInCategory.forEach(book => {
                            const isChecked = linkedBookIds.has(book.id);
                            const label = document.createElement('label');
                            // 统一使用 book_ 前缀
                            label.innerHTML = `<input type="checkbox" value="book_${book.id}" ${isChecked ? 'checked' : ''}> ${book.name}`;
                            worldBookCheckboxesContainer.appendChild(label);
                        });
                    }
                });
        
                // 2. 渲染未分类的书籍
                const uncategorizedBooks = allBooks.filter(book => !book.categoryId);
                if (uncategorizedBooks.length > 0) {
                    const bookHeader = document.createElement('h4');
                    bookHeader.textContent = '未分类';
                    bookHeader.style.cssText = 'margin: 15px 0 5px; color: #555; border-bottom: 1px solid #eee; padding-bottom: 3px;';
                    worldBookCheckboxesContainer.appendChild(bookHeader);
        
                    uncategorizedBooks.forEach(book => {
                        const isChecked = linkedBookIds.has(book.id);
                        const label = document.createElement('label');
                        label.innerHTML = `<input type="checkbox" value="book_${book.id}" ${isChecked ? 'checked' : ''}> ${book.name}`;
                        worldBookCheckboxesContainer.appendChild(label);
                    });
                }
            }
            // --- 【【【核心修复到这里结束】】】 ---
        
            updateWorldBookSelectionDisplay();

            const linkMemoryToggle = document.getElementById('link-memory-toggle'); const linkedMemorySelection = document.getElementById('linked-memory-selection'); const linkedChatsContainer = document.getElementById('linked-chats-checkboxes-container'); const linkedMemoryIds = chat.settings.linkedMemoryChatIds || []; linkMemoryToggle.checked = linkedMemoryIds.length > 0; linkedMemorySelection.style.display = linkMemoryToggle.checked ? 'block' : 'none'; linkedChatsContainer.innerHTML = ''; Object.values(state.chats).forEach(c => { if (c.id === chat.id) return; const isChecked = linkedMemoryIds.includes(c.id); const prefix = c.isGroup ? '[群聊]' : '[私聊]'; const label = document.createElement('label'); label.innerHTML = `<input type="checkbox" value="${c.id}" ${isChecked ? 'checked' : ''}> ${prefix} ${c.name}`; linkedChatsContainer.appendChild(label); }); function updateLinkedMemorySelectionDisplay() { const checkedBoxes = linkedChatsContainer.querySelectorAll('input:checked'); const displayText = linkedMemorySelection.querySelector('.selected-options-text'); if (checkedBoxes.length === 0) { displayText.textContent = '-- 点击选择 --'; } else if (checkedBoxes.length > 2) { displayText.textContent = `已选择 ${checkedBoxes.length} 项`; } else { displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join(', '); } } updateLinkedMemorySelectionDisplay(); linkMemoryToggle.addEventListener('change', () => { linkedMemorySelection.style.display = linkMemoryToggle.checked ? 'block' : 'none'; }); const linkedMemorySelectBox = linkedMemorySelection.querySelector('.select-box'); const newLinkedMemorySelectBox = linkedMemorySelectBox.cloneNode(true); linkedMemorySelectBox.parentNode.replaceChild(newLinkedMemorySelectBox, linkedMemorySelectBox); newLinkedMemorySelectBox.addEventListener('click', (e) => { e.stopPropagation(); linkedChatsContainer.classList.toggle('visible'); newLinkedMemorySelectBox.classList.toggle('expanded'); }); linkedChatsContainer.addEventListener('change', updateLinkedMemorySelectionDisplay);
            const themeRadio = document.querySelector(`input[name="theme-select"][value="${chat.settings.theme || 'default'}"]`); if (themeRadio) themeRadio.checked = true;
            const fontSizeSlider = document.getElementById('font-size-slider'); fontSizeSlider.value = chat.settings.fontSize || 13; document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
            const customCssInput = document.getElementById('custom-css-input'); customCssInput.value = chat.settings.customCss || '';
            updateSettingsPreview();
            document.getElementById('auto-memory-toggle').checked = chat.settings.enableAutoMemory || false;
            document.getElementById('auto-memory-interval').value = chat.settings.autoMemoryInterval || 20;
            showScreen('chat-settings-screen');
        });
        // ▲▲▲ 替换结束 ▲▲▲
                    
// ▼▼▼ 【V2.0 | 头像最终修复版】请用这个新版本替换旧的 renderGroupMemberSettings 函数 ▼▼▼
function renderGroupMemberSettings(members) { 
    const container = document.getElementById('group-members-settings'); 
    container.innerHTML = ''; 
    members.forEach(member => { 
        const div = document.createElement('div'); 
        div.className = 'member-editor'; 
        div.dataset.memberId = member.id; 
        
        // ★★★★★ 这就是【核心修复 ①】★★★★★
        // 优先使用成员自己独立的头像(member.avatar)，如果没有，再尝试去单聊配置里找，
        // 如果还没有，最后才用默认头像。这套逻辑能完美兼容所有类型的成员。
        const memberAvatar = member.avatar || (state.chats[member.id] ? state.chats[member.id].settings.aiAvatar : defaultGroupMemberAvatar);

        div.innerHTML = `<img src="${memberAvatar}" alt="${member.groupNickname}"><div class="member-name">${member.groupNickname}</div>`;
        div.addEventListener('click', () => openMemberEditor(member.id)); 
        container.appendChild(div); 
    }); 
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【V2.0 | 头像最终修复版】请用这个新版本替换旧的 saveMemberSettings 函数 ▼▼▼
document.getElementById('save-member-settings-btn').addEventListener('click', async () => {
    if (!editingMemberId) return; 
    const chat = state.chats[state.activeChatId]; 
    const member = chat.members.find(m => m.id === editingMemberId); 
    if (!member) return;

    const newNickname = document.getElementById('member-name-input').value.trim();
    if (!newNickname) {
        alert("群昵称不能为空！");
        return;
    }
    member.groupNickname = newNickname; 
    member.persona = document.getElementById('member-persona-input').value; 
    
    const newAvatarUrl = document.getElementById('member-avatar-preview').src;

    // ★★★★★ 这就是【核心修复 ②】 ★★★★★
    // 无论成员是“真角色”还是“纯NPC”，都【必须】将新头像URL直接保存在群聊的成员信息里。
    member.avatar = newAvatarUrl;

    // 同时，如果这个成员是一个“真角色”，我们依然更新他的主配置，保持数据同步。
    const characterProfile = state.chats[member.id];
    if (characterProfile) {
        characterProfile.settings.aiAvatar = newAvatarUrl;
        await db.chats.put(characterProfile);
    }
    
    // 将包含最新成员信息的【整个群聊对象】存回数据库，让NPC的头像得以永久保存。
    await db.chats.put(chat);
    
    // 刷新UI并关闭弹窗
    renderGroupMemberSettings(chat.members); 
    document.getElementById('member-settings-modal').classList.remove('visible'); 
    editingMemberId = null;
});
// ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 【请用这个新版本】替换旧的 openMemberEditor 函数 ▼▼▼
        function openMemberEditor(memberId) { 
            editingMemberId = memberId; 
            const chat = state.chats[state.activeChatId]; 
            const member = chat.members.find(m => m.id === memberId); 
            if (!member) return; // 安全检查
        
            document.getElementById('member-name-input').value = member.groupNickname; 
            document.getElementById('member-persona-input').value = member.persona; 
            
            // ★★★★★ 这就是【核心修复 ②】★★★★★
            // 使用与上面完全相同的逻辑来获取并显示正确的当前头像。
            const memberAvatar = member.avatar || (state.chats[member.id] ? state.chats[member.id].settings.aiAvatar : defaultGroupMemberAvatar);
            document.getElementById('member-avatar-preview').src = memberAvatar;
        
            document.getElementById('member-settings-modal').classList.add('visible'); 
        }
        // ▲▲▲ 替换结束 ▲▲▲
                    document.getElementById('cancel-member-settings-btn').addEventListener('click', () => { document.getElementById('member-settings-modal').classList.remove('visible'); editingMemberId = null; });
                    // ▼▼▼ 将其【完整替换为】下面这段修正后的代码 ▼▼▼
        // ▼▼▼ 【最终修复版】请用这整块代码，完整替换旧的 'save-member-settings-btn' 事件监听器 ▼▼▼
        document.getElementById('save-member-settings-btn').addEventListener('click', async () => {
            if (!editingMemberId) return; 
            const chat = state.chats[state.activeChatId]; 
            const member = chat.members.find(m => m.id === editingMemberId); 
            if (!member) return;
        
            const newNickname = document.getElementById('member-name-input').value.trim();
            if (!newNickname) {
                alert("群昵称不能为空！");
                return;
            }
            member.groupNickname = newNickname; 
            member.persona = document.getElementById('member-persona-input').value; 
            
            const newAvatarUrl = document.getElementById('member-avatar-preview').src;
        
            // ★★★★★ 这就是【核心修复】 ★★★★★
            // 无论成员是“真角色”还是“纯NPC”，都【必须】将新头像URL直接保存在群聊的成员信息里。
            member.avatar = newAvatarUrl;
        
            // 同时，如果这个成员是一个“真角色”，我们依然更新他的主配置，保持数据同步。
            const characterProfile = state.chats[member.id];
            if (characterProfile) {
                characterProfile.settings.aiAvatar = newAvatarUrl;
                await db.chats.put(characterProfile);
            }
            
            // 将包含最新成员信息的【整个群聊对象】存回数据库，让NPC的头像得以永久保存。
            await db.chats.put(chat);
            
            // 刷新UI并关闭弹窗
            renderGroupMemberSettings(chat.members); 
            document.getElementById('member-settings-modal').classList.remove('visible'); 
            editingMemberId = null;
        });
        // ▲▲▲ 替换结束 ▲▲▲
                    document.getElementById('reset-theme-btn').addEventListener('click', () => { document.getElementById('theme-default').checked = true; });
                   
        
        // ▼▼▼ 【请用这个新版本】替换旧的 save-chat-settings-btn 事件监听器 ▼▼▼
        document.getElementById('save-chat-settings-btn').addEventListener('click', async () => {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            
            // --- （这部分与之前相同，保持不变） ---
            const newName = document.getElementById('chat-name-input').value.trim();
            if (!newName) return alert('备注名/群名不能为空！');
            if (!chat.isGroup && newName !== chat.name) {
                if (!chat.nameHistory) chat.nameHistory = [];
                if (!chat.nameHistory.includes(chat.name)) chat.nameHistory.push(chat.name);
            }
            chat.name = newName;
            const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
            chat.settings.theme = selectedThemeRadio ? selectedThemeRadio.value : 'default';
            chat.settings.fontSize = parseInt(document.getElementById('font-size-slider').value);
            chat.settings.customCss = document.getElementById('custom-css-input').value.trim();
// 【新增代码】保存时间感知设置
chat.settings.enableTimePerception = document.getElementById('time-perception-toggle').checked;
chat.settings.timeZone = document.getElementById('time-zone-select').value;

            chat.settings.myPersona = document.getElementById('my-persona').value;
            chat.settings.myAvatar = document.getElementById('my-avatar-preview').src;
        
            // --- 【【【核心修改从这里开始】】】 ---
            const checkedBookItems = document.querySelectorAll('#world-book-checkboxes-container input[type="checkbox"]:checked');
            const newLinkedBookIds = [];
        
            checkedBookItems.forEach(cb => {
                const value = cb.value;
                // 我们只关心书籍的ID
                if (value.startsWith('book_')) {
                    newLinkedBookIds.push(value.replace('book_', ''));
                }
            });
            
            // 只保存单本书的ID
            chat.settings.linkedWorldBookIds = newLinkedBookIds;
            // 不再需要保存分类ID，将其从设置中移除以保持数据干净
            delete chat.settings.linkedWorldBookCategoryIds; 
            // --- 【【【核心修改到这里结束】】】 ---
        
// ▼▼▼ 请用这个【新版本】替换旧的 if/else 逻辑 ▼▼▼
if (chat.isGroup) {
    // 【核心新增】保存群聊的后台活动开关状态
    chat.settings.enableBackgroundActivity = document.getElementById('group-background-activity-switch').checked;
    chat.settings.myNickname = document.getElementById('my-group-nickname-input').value.trim();
    chat.settings.groupAvatar = document.getElementById('group-avatar-preview').src;
    chat.settings.actionCooldownMinutes = parseInt(document.getElementById('group-action-cooldown-input').value) || 10;
} else {
    // 【核心新增】保存单个角色的后台活动开关状态
    chat.settings.enableBackgroundActivity = document.getElementById('char-background-activity-switch').checked;

    // (其他单聊设置的保存逻辑保持不变)
    chat.settings.isOfflineMode = document.getElementById('offline-mode-toggle').checked;
    chat.settings.offlineMinLength = parseInt(document.getElementById('offline-min-length-input').value) || 100;
    chat.settings.offlineMaxLength = parseInt(document.getElementById('offline-max-length-input').value) || 300;
    chat.settings.offlinePresetId = document.getElementById('offline-preset-select').value || null;
    const newOriginalName = document.getElementById('ai-original-name-input').value.trim();
    if (!newOriginalName) return alert('对方本名不能为空！');
    chat.originalName = newOriginalName;
    chat.settings.aiPersona = document.getElementById('ai-persona').value;
chat.settings.minimaxVoiceId = document.getElementById('ai-voice-id-input').value.trim();
    chat.settings.aiAvatar = document.getElementById('ai-avatar-preview').src;
    chat.settings.myNickname = document.getElementById('my-nickname-input').value.trim() || '我';
    chat.settings.actionCooldownMinutes = parseInt(document.getElementById('ai-action-cooldown-input').value) || 10;
    chat.settings.lyricsPosition = {
        vertical: document.getElementById('lyrics-vertical-pos').value,
        horizontal: document.getElementById('lyrics-horizontal-pos').value,
        offset: parseInt(document.getElementById('lyrics-offset-input').value) || 10
    };
    const selectedGroupId = document.getElementById('assign-group-select').value;
    chat.groupId = selectedGroupId ? parseInt(selectedGroupId) : null;
}
// ▲▲▲ 替换结束 ▲▲▲
            chat.settings.maxMemory = parseInt(document.getElementById('max-memory').value) || 10;
            chat.settings.linkedMemoryCount = parseInt(document.getElementById('linked-memory-count').value) || 10;
            const linkMemoryToggleChecked = document.getElementById('link-memory-toggle').checked;
            if (linkMemoryToggleChecked) {
                const checkedChats = document.querySelectorAll('#linked-chats-checkboxes-container input:checked');
                chat.settings.linkedMemoryChatIds = Array.from(checkedChats).map(cb => cb.value);
            } else {
                chat.settings.linkedMemoryChatIds = [];
            }
            chat.settings.enableAutoMemory = document.getElementById('auto-memory-toggle').checked;
            chat.settings.autoMemoryInterval = parseInt(document.getElementById('auto-memory-interval').value) || 20;
            await db.chats.put(chat);
            if (!chat.isGroup) {
                await syncCharacterNameInGroups(chat);
                await syncCharacterAvatarInGroups(chat);
            }
            applyLyricsBarPosition(chat);
            applyScopedCss(chat.settings.customCss, '#chat-messages', 'custom-bubble-style');
            showScreen('chat-interface-screen');
            renderChatInterface(state.activeChatId);
            renderChatList();
        });
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 【这是最终的完整功能代码，请用它替换掉旧的】 ▼▼▼
        
        // 为聊天设置里的“更换头像框”按钮添加点击事件


// 为聊天设置里的“更换头像框”按钮添加点击事件
document.getElementById('chat-settings-screen').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-frame-btn')) {
        openFrameSelectorModal('chat');
    }
});
        
        // 为成员设置里的“更换头像框”按钮添加点击事件
        document.getElementById('member-settings-modal').addEventListener('click', (e) => {
            if (e.target.classList.contains('change-frame-btn')) { 
                openFrameSelectorModal('member');
            }
        });
        
        // --- 【新增】为头像框选择模态框的按钮和标签页绑定事件 ---
        const frameModal = document.getElementById('avatar-frame-modal');
        const aiFrameTab = document.getElementById('ai-frame-tab');
        const myFrameTab = document.getElementById('my-frame-tab');
        const aiFrameContent = document.getElementById('ai-frame-content');
        const myFrameContent = document.getElementById('my-frame-content');
        
        // “保存”按钮
        document.getElementById('save-frame-settings-btn').addEventListener('click', saveSelectedFrames);
        
        // “取消”按钮
        document.getElementById('cancel-frame-settings-btn').addEventListener('click', () => {
            frameModal.classList.remove('visible');
            editingFrameForMember = false; // 确保重置状态
        });
        
        // “对方的” 标签页
        aiFrameTab.addEventListener('click', () => {
            aiFrameTab.classList.add('active');
            myFrameTab.classList.remove('active');
            aiFrameContent.style.display = 'block';
            myFrameContent.style.display = 'none';
        });
        
        // “我的” 标签页
        myFrameTab.addEventListener('click', () => {
            myFrameTab.classList.add('active');
            aiFrameTab.classList.remove('active');
            myFrameContent.style.display = 'block';
            aiFrameContent.style.display = 'none';
        });
        
        // ▲▲▲ 替换结束 ▲▲▲
                    document.getElementById('clear-chat-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const confirmed = await showCustomConfirm('清空聊天记录', '此操作将永久删除此聊天的所有消息，无法恢复。确定要清空吗？', { confirmButtonClass: 'btn-danger' }); if (confirmed) { chat.history = []; await db.chats.put(chat); renderChatInterface(state.activeChatId); renderChatList(); chatSettingsModal.classList.remove('visible'); } });
                    
                    const setupFileUpload = (inputId, callback) => { document.getElementById(inputId).addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); callback(dataUrl); event.target.value = null; } }); };
                    setupFileUpload('ai-avatar-input', (base64) => document.getElementById('ai-avatar-preview').src = base64);
                    setupFileUpload('my-avatar-input', (base64) => document.getElementById('my-avatar-preview').src = base64);
                    setupFileUpload('group-avatar-input', (base64) => document.getElementById('group-avatar-preview').src = base64);
                    setupFileUpload('member-avatar-input', (base64) => document.getElementById('member-avatar-preview').src = base64);
                    setupFileUpload('bg-input', (base64) => { if(state.activeChatId) { state.chats[state.activeChatId].settings.background = base64; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = base64; bgPreview.style.display = 'block'; document.getElementById('remove-bg-btn').style.display = 'inline-block'; } });
                    setupFileUpload('preset-avatar-input', (base64) => document.getElementById('preset-avatar-preview').src = base64);
                    document.getElementById('remove-bg-btn').addEventListener('click', () => { if (state.activeChatId) { state.chats[state.activeChatId].settings.background = ''; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = ''; bgPreview.style.display = 'none'; document.getElementById('remove-bg-btn').style.display = 'none'; } });
        
                    const stickerPanel = document.getElementById('sticker-panel');
                    document.getElementById('open-sticker-panel-btn').addEventListener('click', () => { renderStickerPanel(); stickerPanel.classList.add('visible'); });
                    document.getElementById('close-sticker-panel-btn').addEventListener('click', () => stickerPanel.classList.remove('visible'));
                    // ▼▼▼ 【请用这整块代码】替换旧的 add-sticker-btn 事件监听器 ▼▼▼
        
        // 【核心新增】为“批量”按钮绑定新函数
        document.getElementById('add-sticker-batch-btn').addEventListener('click', openBatchStickerImportModal);
        
// ▼▼▼ 请用这个【已添加分类ID】的版本替换旧的事件监听器 ▼▼▼
        document.getElementById('add-sticker-url-btn').addEventListener('click', async () => {
            const url = await showCustomPrompt("添加表情(URL)", "请输入表情包的图片URL");
            if (!url || !url.trim().startsWith('http')) {
                if (url) alert("请输入有效的URL (以http开头)");
                return;
            }
            const name = await showCustomPrompt("命名表情", "请为这个表情命名 (例如：开心、疑惑)");
            if (name && name.trim()) {
                const newSticker = { 
                    id: 'sticker_' + Date.now(), 
                    url: url.trim(), 
                    name: name.trim(),
                    // 【核心修改】将表情归入当前分类
                    categoryId: (activeStickerCategoryId !== 'all' && activeStickerCategoryId !== 'uncategorized') ? activeStickerCategoryId : null
                };
                await db.userStickers.add(newSticker);
                state.userStickers.push(newSticker);
                renderStickerPanel();
            } else if (name !== null) {
                alert("表情名不能为空！");
            }
        });

        
        // ▲▲▲ 替换结束 ▲▲▲
                    document.getElementById('upload-sticker-btn').addEventListener('click', () => document.getElementById('sticker-upload-input').click());
                    document.getElementById('sticker-upload-input').addEventListener('change', async (event) => { 
            const file = event.target.files[0]; 
            if (!file) return; 
            const reader = new FileReader(); 
            reader.readAsDataURL(file); 
            reader.onload = async () => { 
                const base64Url = reader.result; 
                const name = await showCustomPrompt("命名表情", "请为这个表情命名 (例如：好耶、疑惑)"); 
                if (name && name.trim()) { 
                    const newSticker = { 
                        id: 'sticker_' + Date.now(), 
                        url: base64Url, 
                        name: name.trim(),
                        // 【核心修改】将表情归入当前分类
                        categoryId: (activeStickerCategoryId !== 'all' && activeStickerCategoryId !== 'uncategorized') ? activeStickerCategoryId : null
                    }; 
                    await db.userStickers.add(newSticker); 
                    state.userStickers.push(newSticker); 
                    renderStickerPanel(); 
                } else if (name !== null) alert("表情名不能为空！"); 
            }; 
            event.target.value = null; 
        });
        
                    document.getElementById('upload-image-btn').addEventListener('click', () => document.getElementById('image-upload-input').click());
                    document.getElementById('image-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file || !state.activeChatId) return; const reader = new FileReader(); reader.onload = async (e) => { const base64Url = e.target.result; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: [{ type: 'image_url', image_url: { url: base64Url } }], timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); }; reader.readAsDataURL(file); event.target.value = null; });
                    document.getElementById('voice-message-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const text = await showCustomPrompt("发送语音", "请输入你想说的内容："); if (text && text.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'voice_message', content: text.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });
                    document.getElementById('send-photo-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const description = await showCustomPrompt("发送照片", "请用文字描述您要发送的照片："); if (description && description.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'user_photo', content: description.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });
        
const waimaiModal = document.getElementById('waimai-request-modal');

// 绑定工具栏的“外卖”按钮，用于打开弹窗
document.getElementById('send-waimai-request-btn').addEventListener('click', () => {
    waimaiModal.classList.add('visible');
});

// 【核心修改1】为弹窗的半透明背景添加点击事件，实现点击外部关闭
waimaiModal.addEventListener('click', (e) => {
    // 只有当点击的是背景本身，而不是内容区域时，才关闭
    if (e.target === waimaiModal) {
        waimaiModal.classList.remove('visible');
    }
});

// 【核心修改2】为新的“为TA点外卖”按钮绑定我们新创建的函数
document.getElementById('waimai-order-for-ai-btn').addEventListener('click', sendWaimaiOrderForAI);

// 绑定“发起代付请求”按钮（这个逻辑保持不变）
document.getElementById('waimai-confirm-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    
    const productInfoInput = document.getElementById('waimai-product-info');
    const amountInput = document.getElementById('waimai-amount');
    
    const productInfo = productInfoInput.value.trim();
    const amount = parseFloat(amountInput.value);

    if (!productInfo || isNaN(amount) || amount <= 0) {
        alert('请填写有效的商品信息和金额！');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const now = Date.now();
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    const msg = {
        role: 'user',
        senderName: myNickname, 
        type: 'waimai_request',
        productInfo: productInfo,
        amount: amount,
        status: 'pending',
        countdownEndTime: now + 15 * 60 * 1000,
        timestamp: now
    };

    chat.history.push(msg);
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();

    productInfoInput.value = '';
    amountInput.value = '';
    waimaiModal.classList.remove('visible');
});       
                    document.getElementById('open-persona-library-btn').addEventListener('click', openPersonaLibrary);
                    document.getElementById('close-persona-library-btn').addEventListener('click', closePersonaLibrary);
                    document.getElementById('add-persona-preset-btn').addEventListener('click', openPersonaEditorForCreate);
                    document.getElementById('cancel-persona-editor-btn').addEventListener('click', closePersonaEditor);
                    document.getElementById('save-persona-preset-btn').addEventListener('click', savePersonaPreset);
                    document.getElementById('preset-action-edit').addEventListener('click', openPersonaEditorForEdit);
                    document.getElementById('preset-action-delete').addEventListener('click', deletePersonaPreset);
                    document.getElementById('preset-action-cancel').addEventListener('click', hidePresetActions);
                    
                    document.getElementById('selection-cancel-btn').addEventListener('click', exitSelectionMode);
        
        // ▼▼▼ 【这是最终的完整功能代码，请用它替换掉旧的】 ▼▼▼

        // 1. 为新的“删除(通知AI)”按钮绑定事件 (逻辑与旧版删除完全相同)
        document.getElementById('selection-soft-delete-btn').addEventListener('click', async () => {
            if (selectedMessages.size === 0) return;
            const confirmed = await showCustomConfirm('删除消息', `确定要删除选中的 ${selectedMessages.size} 条消息吗？这会通知AI这些消息已被删除。`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                const chat = state.chats[state.activeChatId];
                let deletedPollsInfo = [];
                for (const timestamp of selectedMessages) {
                    const msg = chat.history.find(m => m.timestamp === timestamp);
                    if (msg && msg.type === 'poll') {
                        deletedPollsInfo.push(`关于“${msg.question}”的投票(时间戳: ${msg.timestamp})`);
                    }
                }
                chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));
                let forgetReason = "一些之前的消息已被用户删除。";
                if (deletedPollsInfo.length > 0) {
                    forgetReason += ` 其中包括以下投票：${deletedPollsInfo.join('；')}。`;
                }
                forgetReason += " 你应该像它们从未存在过一样继续对话，并相应地调整你的记忆和行为，不要再提及这些被删除的内容。";
                const forgetInstruction = {
                    role: 'system',
                    content: `[系统提示：${forgetReason}]`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(forgetInstruction);
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);
                renderChatList();
            }
        });

        // 2. 为新增的“彻底删除”按钮绑定全新的、真正的删除逻辑
        document.getElementById('selection-erase-btn').addEventListener('click', async () => {
            if (selectedMessages.size === 0) return;
            const confirmed = await showCustomConfirm(
                '彻底删除消息', 
                `这将从历史记录中【永久抹除】这 ${selectedMessages.size} 条消息，AI将完全遗忘它们的存在。确定吗？`, 
                { confirmButtonClass: 'btn-danger', confirmText: '确认抹除' }
            );
            if (confirmed) {
                const chat = state.chats[state.activeChatId];
                
                // 核心逻辑：直接过滤掉被选中的消息，不添加任何系统提示
                chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));
                
                // 直接保存，AI的下一次请求将不会包含这些被删除的消息
                await db.chats.put(chat);
                
                // 刷新UI
                renderChatInterface(state.activeChatId);
                renderChatList();
            }
        });
        // ▲▲▲ 替换结束 ▲▲▲
        
                    const fontUrlInput = document.getElementById('font-url-input');
                    fontUrlInput.addEventListener('input', () => applyCustomFont(fontUrlInput.value.trim(), true));
                    document.getElementById('save-font-btn').addEventListener('click', async () => {
                        const newFontUrl = fontUrlInput.value.trim();
                        if (!newFontUrl) { alert("请输入有效的字体URL。"); return; }
                        applyCustomFont(newFontUrl, false);
                        state.globalSettings.fontUrl = newFontUrl;
                        await db.globalSettings.put(state.globalSettings);
                        alert('字体已保存并应用！');
                    });
                    document.getElementById('reset-font-btn').addEventListener('click', resetToDefaultFont);
        
                    document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => { item.addEventListener('click', () => switchToChatListView(item.dataset.view)); });
                    document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
                    document.getElementById('qzone-nickname').addEventListener('click', async () => { const newNickname = await showCustomPrompt("修改昵称", "请输入新的昵称", state.qzoneSettings.nickname); if (newNickname && newNickname.trim()) { state.qzoneSettings.nickname = newNickname.trim(); await saveQzoneSettings(); renderQzoneScreen(); } });
                    document.getElementById('qzone-avatar-container').addEventListener('click', () => document.getElementById('qzone-avatar-input').click());
                    document.getElementById('qzone-banner-container').addEventListener('click', () => document.getElementById('qzone-banner-input').click());
                    document.getElementById('qzone-avatar-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.avatar = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });
                    document.getElementById('qzone-banner-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.banner = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });
        
        // ▼▼▼ 【修正后】的“说说”按钮事件 ▼▼▼
        document.getElementById('create-shuoshuo-btn').addEventListener('click', async () => {
            // 1. 重置并获取模态框
            resetCreatePostModal();
            const modal = document.getElementById('create-post-modal');
            
            // 2. 设置为“说说”模式
            modal.dataset.mode = 'shuoshuo';
            
            // 3. 隐藏与图片/文字图相关的部分
            modal.querySelector('.post-mode-switcher').style.display = 'none';
            modal.querySelector('#image-mode-content').style.display = 'none';
            modal.querySelector('#text-image-mode-content').style.display = 'none';
            
            // 4. 修改主输入框的提示语，使其更符合“说说”的场景
            modal.querySelector('#post-public-text').placeholder = '分享新鲜事...';
            
            // 5. 准备并显示模态框
            const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
            visibilityGroupsContainer.innerHTML = '';
            const groups = await db.qzoneGroups.toArray();
            if (groups.length > 0) {
                groups.forEach(group => {
                    const label = document.createElement('label');
                    label.style.display = 'block';
                    label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
                    visibilityGroupsContainer.appendChild(label);
                });
            } else {
                visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">没有可用的分组</p>';
            }
            modal.classList.add('visible');
        });
        
        // ▼▼▼ 【修正后】的“动态”（图片）按钮事件 ▼▼▼
        document.getElementById('create-post-btn').addEventListener('click', async () => {
            // 1. 重置并获取模态框
            resetCreatePostModal();
            const modal = document.getElementById('create-post-modal');
            
            // 2. 设置为“复杂动态”模式
            modal.dataset.mode = 'complex';
            
        // 3. 确保与图片/文字图相关的部分是可见的
        modal.querySelector('.post-mode-switcher').style.display = 'flex';
        // 显式激活“上传图片”模式...
        modal.querySelector('#image-mode-content').classList.add('active');
        // ...同时确保“文字图”模式是隐藏的
        modal.querySelector('#text-image-mode-content').classList.remove('active');
            
            // 4. 恢复主输入框的默认提示语
            modal.querySelector('#post-public-text').placeholder = '分享新鲜事...（非必填的公开文字）';
        
            // 5. 准备并显示模态框（与“说说”按钮的逻辑相同）
            const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
            visibilityGroupsContainer.innerHTML = '';
            const groups = await db.qzoneGroups.toArray();
            if (groups.length > 0) {
                groups.forEach(group => {
                    const label = document.createElement('label');
                    label.style.display = 'block';
                    label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
                    visibilityGroupsContainer.appendChild(label);
                });
            } else {
                visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">没有可用的分组</p>';
            }
            modal.classList.add('visible');
        });
                    document.getElementById('open-album-btn').addEventListener('click', async () => { await renderAlbumList(); showScreen('album-screen'); });
                    document.getElementById('album-back-btn').addEventListener('click', () => { showScreen('chat-list-screen'); switchToChatListView('qzone-screen'); });
        
        // --- ↓↓↓ 从这里开始复制 ↓↓↓ ---
        
        document.getElementById('album-photos-back-btn').addEventListener('click', () => {
            state.activeAlbumId = null;
            showScreen('album-screen');
        });
        
        document.getElementById('album-upload-photo-btn').addEventListener('click', () => document.getElementById('album-photo-input').click());
        
        document.getElementById('album-photo-input').addEventListener('change', async (event) => {
            if (!state.activeAlbumId) return;
            const files = event.target.files;
            if (!files.length) return;
        
            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            
            for (const file of files) {
                const dataUrl = await new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.readAsDataURL(file);
                });
                await db.qzonePhotos.add({ albumId: state.activeAlbumId, url: dataUrl, createdAt: Date.now() });
            }
        
            const photoCount = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).count();
            const updateData = { photoCount };
            
            if (!album.photoCount || album.coverUrl.includes('placeholder')) {
                const firstPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                if(firstPhoto) updateData.coverUrl = firstPhoto.url;
            }
        
            await db.qzoneAlbums.update(state.activeAlbumId, updateData);
            await renderAlbumPhotosScreen();
            await renderAlbumList();
            
            event.target.value = null;
            alert('照片上传成功！');
        });
        
        // --- ↑↑↑ 复制到这里结束 ↑↑↑ ---
        
        // --- ↓↓↓ 从这里开始复制，完整替换掉旧的 photos-grid-page 监听器 ↓↓↓ ---
        
        document.getElementById('photos-grid-page').addEventListener('click', async (e) => {
            const deleteBtn = e.target.closest('.photo-delete-btn');
            const photoThumb = e.target.closest('.photo-thumb');
        
            if (deleteBtn) {
                e.stopPropagation(); // 阻止事件冒泡到图片上
                const photoId = parseInt(deleteBtn.dataset.photoId);
                const confirmed = await showCustomConfirm(
                    '删除照片',
                    '确定要删除这张照片吗？此操作不可恢复。',
                    { confirmButtonClass: 'btn-danger' }
                );
        
                if (confirmed) {
                    const deletedPhoto = await db.qzonePhotos.get(photoId);
                    if (!deletedPhoto) return;
                    
                    await db.qzonePhotos.delete(photoId);
        
                    const album = await db.qzoneAlbums.get(state.activeAlbumId);
                    const photoCount = (album.photoCount || 1) - 1;
                    const updateData = { photoCount };
                    
                    if (album.coverUrl === deletedPhoto.url) {
                        const nextPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                        updateData.coverUrl = nextPhoto ? nextPhoto.url : 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
                    }
                    
                    await db.qzoneAlbums.update(state.activeAlbumId, updateData);
                    await renderAlbumPhotosScreen();
                    await renderAlbumList();
                    alert('照片已删除。');
                }
            } 
            else if (photoThumb) {
                // 这就是恢复的图片点击放大功能！
                openPhotoViewer(photoThumb.src);
            }
        });
        
        // 恢复图片查看器的控制事件
        document.getElementById('photo-viewer-close-btn').addEventListener('click', closePhotoViewer);
        document.getElementById('photo-viewer-next-btn').addEventListener('click', showNextPhoto);
        document.getElementById('photo-viewer-prev-btn').addEventListener('click', showPrevPhoto);
        
        // 恢复键盘左右箭头和ESC键的功能
        document.addEventListener('keydown', (e) => {
            if (!photoViewerState.isOpen) return; 
        
            if (e.key === 'ArrowRight') {
                showNextPhoto();
            } else if (e.key === 'ArrowLeft') {
                showPrevPhoto();
            } else if (e.key === 'Escape') {
                closePhotoViewer();
            }
        });
        
        // --- ↑↑↑ 复制到这里结束 ↑↑↑ ---
                 
        document.getElementById('create-album-btn-page').addEventListener('click', async () => { const albumName = await showCustomPrompt("创建新相册", "请输入相册名称"); if (albumName && albumName.trim()) { const newAlbum = { name: albumName.trim(), coverUrl: 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png', photoCount: 0, createdAt: Date.now() }; await db.qzoneAlbums.add(newAlbum); await renderAlbumList(); alert(`相册 "${albumName}" 创建成功！`); } else if (albumName !== null) { alert("相册名称不能为空！"); } });
        
                    document.getElementById('cancel-create-post-btn').addEventListener('click', () => document.getElementById('create-post-modal').classList.remove('visible'));
                    document.getElementById('post-upload-local-btn').addEventListener('click', () => document.getElementById('post-local-image-input').click());
                    document.getElementById('post-local-image-input').addEventListener('change', (event) => { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { document.getElementById('post-image-preview').src = e.target.result; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; }; reader.readAsDataURL(file); } });
                    document.getElementById('post-use-url-btn').addEventListener('click', async () => { const url = await showCustomPrompt("输入图片URL", "请输入网络图片的链接", "", "url"); if (url) { document.getElementById('post-image-preview').src = url; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; } });
                    document.getElementById('post-remove-image-btn').addEventListener('click', () => resetCreatePostModal());
                    const imageModeBtn = document.getElementById('switch-to-image-mode');
                    const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
                    const imageModeContent = document.getElementById('image-mode-content');
                    const textImageModeContent = document.getElementById('text-image-mode-content');
                    imageModeBtn.addEventListener('click', () => { imageModeBtn.classList.add('active'); textImageModeBtn.classList.remove('active'); imageModeContent.classList.add('active'); textImageModeContent.classList.remove('active'); });
                    textImageModeBtn.addEventListener('click', () => { textImageModeBtn.classList.add('active'); imageModeBtn.classList.remove('active'); textImageModeContent.classList.add('active'); imageModeContent.classList.remove('active'); });
        
        // ▼▼▼ 【最终修正版】的“发布”按钮事件，已修复权限漏洞 ▼▼▼
        document.getElementById('confirm-create-post-btn').addEventListener('click', async () => {
            const modal = document.getElementById('create-post-modal');
            const mode = modal.dataset.mode;
            
            // --- 1. 获取通用的可见性设置 ---
            const visibilityMode = document.querySelector('input[name="visibility"]:checked').value;
            let visibleGroupIds = null;
            
            if (visibilityMode === 'include') {
                visibleGroupIds = Array.from(document.querySelectorAll('input[name="visibility_group"]:checked')).map(cb => parseInt(cb.value));
            }
        
            let newPost = {};
            const basePostData = {
                timestamp: Date.now(),
                authorId: 'user',
                // 【重要】在这里就把权限信息存好
                visibleGroupIds: visibleGroupIds,
            };
        
            // --- 2. 根据模式构建不同的 post 对象 ---
            if (mode === 'shuoshuo') {
                const content = document.getElementById('post-public-text').value.trim();
                if (!content) {
                    alert('说说内容不能为空哦！');
                    return;
                }
                newPost = {
                    ...basePostData,
                    type: 'shuoshuo',
                    content: content,
                };
        
            } else { // 处理 'complex' 模式 (图片/文字图)
                const publicText = document.getElementById('post-public-text').value.trim();
                const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');
        
                if (isImageModeActive) {
                    const imageUrl = document.getElementById('post-image-preview').src;
                    const imageDescription = document.getElementById('post-image-description').value.trim();
                    if (!imageUrl || !(imageUrl.startsWith('http') || imageUrl.startsWith('data:'))) {
                        alert('请先添加一张图片再发布动态哦！');
                        return;
                    }
                    if (!imageDescription) {
                        alert('请为你的图片添加一个简单的描述（必填，给AI看的）！');
                        return;
                    }
                    newPost = {
                        ...basePostData,
                        type: 'image_post',
                        publicText: publicText,
                        imageUrl: imageUrl,
                        imageDescription: imageDescription,
                    };
                } else { // 文字图模式
                    const hiddenText = document.getElementById('post-hidden-text').value.trim();
                    if (!hiddenText) {
                        alert('请输入文字图描述！');
                        return;
                    }
                    newPost = {
                        ...basePostData,
                        type: 'text_image',
                        publicText: publicText,
                        hiddenContent: hiddenText,
                    };
                }
            }
        
            // --- 3. 保存到数据库 ---
            const newPostId = await db.qzonePosts.add(newPost);
            let postSummary = newPost.content || newPost.publicText || newPost.imageDescription || newPost.hiddenContent || "（无文字内容）";
            postSummary = postSummary.substring(0, 50) + (postSummary.length > 50 ? '...' : '');
        
            // --- 4. 【核心修正】带有权限检查的通知循环 ---
            for (const chatId in state.chats) {
                const chat = state.chats[chatId];
                if (chat.isGroup) continue; // 跳过群聊
        
                let shouldNotify = false;
                const postVisibleGroups = newPost.visibleGroupIds;
        
                // 判断条件1：如果动态是公开的 (没有设置任何可见分组)
                if (!postVisibleGroups || postVisibleGroups.length === 0) {
                    shouldNotify = true;
                } 
                // 判断条件2：如果动态设置了部分可见，并且当前角色在可见分组内
                else if (chat.groupId && postVisibleGroups.includes(chat.groupId)) {
                    shouldNotify = true;
                }
        
                // 只有满足条件的角色才会被通知
                if (shouldNotify) {
        // ▼▼▼ 从这里开始替换 ▼▼▼
        const historyMessage = {
            role: 'system',
            content: `[系统提示：用户刚刚发布了一条动态(ID: ${newPostId})，内容摘要是：“${postSummary}”。请你【结合自己的角色设定、世界观和你们的最近聊天内容】，对这条动态发表一条自然的评论。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        // ▲▲▲ 到这里替换结束 ▲▲▲
                    chat.history.push(historyMessage);
                    await db.chats.put(chat);
                }
            }
            // --- 修正结束 ---
        
            await renderQzonePosts();
            modal.classList.remove('visible');
            alert('动态发布成功！');
        });
        
        // ▼▼▼ 请用这【一整块】包含所有滑动和点击事件的完整代码，替换掉旧的 postsList 事件监听器 ▼▼▼
        
        const postsList = document.getElementById('qzone-posts-list');
        let swipeState = { isDragging: false, startX: 0, startY: 0, currentX: 0, activeContainer: null, swipeDirection: null, isClick: true };
        
        function resetAllSwipes(exceptThisOne = null) {
            document.querySelectorAll('.qzone-post-container').forEach(container => {
                if (container !== exceptThisOne) {
                    container.querySelector('.qzone-post-item').classList.remove('swiped');
                }
            });
        }
        // ▼▼▼ 【最终修复方案】请用这个全新的、使用增量更新的函数，完整替换旧的 handlePostClick ▼▼▼
        /**
         * 【全新】处理动态区域内所有点击事件的统一入口
         */
        async function handlePostClick(e) {
            e.stopPropagation();
            const target = e.target;
        
            // --- 优先处理评论删除按钮的点击 ---
            const deleteBtn = target.closest('.comment-delete-btn');
            if (deleteBtn) {
                const postContainer = deleteBtn.closest('.qzone-post-container');
                const postId = parseInt(postContainer.dataset.postId);
                const commentIndex = parseInt(deleteBtn.dataset.commentIndex);
                if (isNaN(postId) || isNaN(commentIndex)) return;
        
                const post = qzonePostsCache.find(p => p.id === postId);
                if (!post || !post.comments || !post.comments[commentIndex]) return;
                
                const confirmed = await showCustomConfirm('删除评论', '确定要删除这条评论吗？', { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    post.comments.splice(commentIndex, 1);
                    await db.qzonePosts.update(postId, { comments: post.comments });
                    await updateSinglePostInDOM(postId); // 【性能优化】调用增量更新
                }
                
                return; // 处理完后必须退出
            }
            
            // --- 所有弹窗和非DOM更新的逻辑保持不变 ---
            const stickerBtn = target.closest('.comment-sticker-btn');
            if (stickerBtn) {
                const postContainer = stickerBtn.closest('.qzone-post-container');
                if (!postContainer) return;
                const postId = parseInt(postContainer.dataset.postId);
                if (qzoneStickerPanelState.isOpen && qzoneStickerPanelState.activePostId === postId) {
                    closeQzoneStickerPanel();
                } else {
                    openQzoneStickerPanel(postId, stickerBtn);
                }
                return; 
            }
            const commentItem = target.closest('.comment-item');
            if (commentItem) {
                const postId = parseInt(commentItem.dataset.postId);
                const commenterOriginalName = commentItem.dataset.commenterOriginalName;
                const commenterDisplayName = commentItem.dataset.commenterDisplayName;
        
                if (!commenterOriginalName || !commenterDisplayName || commenterOriginalName === state.qzoneSettings.nickname) {
                    clearQzoneReplyContext(commentItem.closest('.qzone-post-container'));
                    return;
                }
                currentQzoneReplyContext = { postId, replyToName: commenterOriginalName, replyToDisplayName: commenterDisplayName };
                const postContainer = commentItem.closest('.qzone-post-container');
                const commentInput = postContainer.querySelector('.comment-input');
                commentInput.placeholder = `回复 ${commenterDisplayName}:`;
                commentInput.focus();
                return; 
            }
            if (target.classList.contains('post-actions-btn')) {
                const container = target.closest('.qzone-post-container');
                if (container && container.dataset.postId) showPostActions(parseInt(container.dataset.postId));
                return;
            }
            if (target.tagName === 'IMG' && target.dataset.hiddenText) {
                showCustomAlert("图片内容", target.dataset.hiddenText.replace(/<br>/g, '\n'));
                return;
            }
        
            // --- 【核心性能优化】开始，处理所有会更新DOM的事件 ---
            const postContainer = target.closest('.qzone-post-container');
            if (!postContainer) return;
            const postId = parseInt(postContainer.dataset.postId);
            if (isNaN(postId)) return;
        
            if (target.closest('.qzone-post-delete-action')) {
                const confirmed = await showCustomConfirm('删除动态', '确定要永久删除这条动态吗？', { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    postContainer.style.transition = 'all 0.3s ease';
                    postContainer.style.transform = 'scale(0.8)';
                    postContainer.style.opacity = '0';
                    setTimeout(async () => {
                         await db.qzonePosts.delete(postId);
                         const notificationIdentifier = `(ID: ${postId})`;
                         for (const chatId in state.chats) {
                             const chat = state.chats[chatId];
                             const originalHistoryLength = chat.history.length;
                             chat.history = chat.history.filter(msg => !(msg.role === 'system' && msg.content.includes(notificationIdentifier)));
                             if (chat.history.length < originalHistoryLength) await db.chats.put(chat);
                         }
                         await renderQzonePosts(); // 删除需要全量重绘
                         alert('动态已删除。');
                    }, 300);
                }
                return;
            }
        
            const icon = target.closest('.action-icon');
            if (icon) {
                if (icon.classList.contains('repost')) { openRepostModal(postId); return; }
                if (icon.classList.contains('like')) {
                    const post = qzonePostsCache.find(p => p.id === postId);
                    if (!post) return;
                    if (!post.likes) post.likes = [];
                    const userOriginalName = state.qzoneSettings.nickname;
                    const userLikeIndex = post.likes.indexOf(userOriginalName);
                    if (userLikeIndex > -1) {
                        post.likes.splice(userLikeIndex, 1);
                    } else {
                        post.likes.push(userOriginalName);
                        icon.classList.add('animate-like');
                        icon.addEventListener('animationend', () => icon.classList.remove('animate-like'), { once: true });
                    }
                    await db.qzonePosts.update(postId, { likes: post.likes });
                    await updateSinglePostInDOM(postId); // 【性能优化】调用增量更新
                }
                if (icon.classList.contains('favorite')) {
                    const existingFavorite = await db.favorites.where({ type: 'qzone_post', 'content.id': postId }).first();
                    if (existingFavorite) {
                        await db.favorites.delete(existingFavorite.id);
                        await showCustomAlert('提示', '已取消收藏');
                    } else {
                        const postToSave = await db.qzonePosts.get(postId);
                        if (postToSave) {
                            await db.favorites.add({ type: 'qzone_post', content: postToSave, timestamp: Date.now() });
                            await showCustomAlert('提示', '收藏成功！');
                        }
                    }
                    await updateSinglePostInDOM(postId); // 【性能优化】调用增量更新
                }
                return;
            }
        
            const sendBtn = target.closest('.comment-send-btn');
            if (sendBtn) {
                const commentInput = postContainer.querySelector('.comment-input');
                const commentText = commentInput.value.trim();
                if (!commentText) return alert('评论内容不能为空哦！');
                
                const post = qzonePostsCache.find(p => p.id === postId);
                if (!post) return;
        
                if (!post.comments) post.comments = [];
                
                const newComment = {
                    commenterName: state.qzoneSettings.nickname,
                    text: commentText,
                    timestamp: Date.now(),
                    replyTo: (currentQzoneReplyContext && currentQzoneReplyContext.postId === postId) ? currentQzoneReplyContext.replyToName : null
                };
                
                post.comments.push(newComment);
                await db.qzonePosts.update(postId, { comments: post.comments });
                
                let postSummary = (post.publicText || post.content || '').substring(0, 30);
                const userNickname = state.qzoneSettings.nickname;
                const notifiedAiIds = new Set();
                if (post.authorId !== 'user') notifiedAiIds.add(post.authorId);
                if (newComment.replyTo && newComment.replyTo !== userNickname) {
                    const repliedToChat = Object.values(state.chats).find(c => c.originalName === newComment.replyTo);
                    if (repliedToChat) notifiedAiIds.add(repliedToChat.id);
                }
                for (const aiId of notifiedAiIds) {
                    const chat = state.chats[aiId];
                    if (chat && !chat.isGroup) {
                        const stickerMatch = state.userStickers.find(s => s.url === commentText);
                        let notificationText = stickerMatch ? `用户'${userNickname}'刚刚在你的动态“${postSummary}”下，发送了一个表情评论，意思是：“${stickerMatch.name}”。`
                            : newComment.replyTo ? `用户'${userNickname}'刚刚在你的动态“${postSummary}”下，回复了'${currentQzoneReplyContext.replyToDisplayName}'的评论，内容是：“${commentText}”。`
                            : `用户'${userNickname}'刚刚评论了你的动态“${postSummary}”，内容是：“${commentText}”。`;
                        const historyMessage = { 
                            role: 'system', 
                            content: `[系统提示：${notificationText}请你对此作出回应。]`, 
                            timestamp: Date.now(), 
                            isHidden: true 
                        };
                        chat.history.push(historyMessage);
                        await db.chats.put(chat);
                    }
                }
                
                commentInput.value = '';
                clearQzoneReplyContext(postContainer); 
                await updateSinglePostInDOM(postId); // 【性能优化】调用增量更新
                return;
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲
        
        
        // ▼▼▼ 【性能优化方案】请用这一整块全新的代码，替换所有旧的滑动处理函数和事件监听器 ▼▼▼
        
        // --- 1. 全新的、更智能的滑动开始函数 ---
        const handleSwipeStart = (e) => {
            const target = e.target;
            // 检查点击目标是否是交互区域，如果是，则不启动滑动
            if (target.closest('.post-footer, .post-feedback-icons, .post-actions-btn, .post-comments-container, .reposted-content-wrapper')) {
                return;
            }
            const targetContainer = e.target.closest('.qzone-post-container');
            if (!targetContainer) return;
        
            resetAllSwipes(targetContainer);
            swipeState.activeContainer = targetContainer;
            swipeState.isDragging = true;
            swipeState.isClick = true;
            swipeState.swipeDirection = null;
            swipeState.startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
            swipeState.startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
            swipeState.activeContainer.querySelector('.qzone-post-item').style.transition = 'none';
        
            // 【核心优化】只在滑动开始时，才动态绑定移动和结束的监听器
            document.addEventListener('mousemove', handleSwipeMove);
            document.addEventListener('mouseup', handleSwipeEnd);
            document.addEventListener('touchmove', handleSwipeMove, { passive: false });
            document.addEventListener('touchend', handleSwipeEnd);
        };
        
        // --- 2. 滑动移动函数（微调） ---
        const handleSwipeMove = (e) => {
            if (!swipeState.isDragging || !swipeState.activeContainer) return;
        
            const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
            const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
            const diffX = currentX - swipeState.startX;
            const diffY = currentY - swipeState.startY;
            
            if (swipeState.isClick && (Math.abs(diffX) > 5 || Math.abs(diffY) > 5)) {
                swipeState.isClick = false;
            }
        
            if (!swipeState.swipeDirection) {
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    swipeState.swipeDirection = 'horizontal';
                } else {
                    swipeState.swipeDirection = 'vertical';
                }
            }
            
            if (swipeState.swipeDirection === 'horizontal') {
                e.preventDefault(); // 只在确定是水平滑动时才阻止默认行为
                swipeState.currentX = currentX;
                let translation = Math.min(0, Math.max(-90, diffX)); // 限制滑动范围
                swipeState.activeContainer.querySelector('.qzone-post-item').style.transform = `translateX(${translation}px)`;
            }
        };
        
        // --- 3. 滑动结束函数（重构） ---
        const handleSwipeEnd = (e) => {
            // 【核心优化】无论如何，都在滑动结束后移除监听器
            document.removeEventListener('mousemove', handleSwipeMove);
            document.removeEventListener('mouseup', handleSwipeEnd);
            document.removeEventListener('touchmove', handleSwipeMove);
            document.removeEventListener('touchend', handleSwipeEnd);
        
            if (!swipeState.isDragging || !swipeState.activeContainer) return;
            
            const postItem = swipeState.activeContainer.querySelector('.qzone-post-item');
            postItem.style.transition = 'transform 0.3s ease';
        
            if (swipeState.swipeDirection === 'horizontal' && !swipeState.isClick) {
                const finalX = e.type.includes('touchend') ? e.changedTouches[0].pageX : e.pageX;
                const diffX = finalX - swipeState.startX;
                if (diffX < -40) { // 滑动超过40像素就触发
                    postItem.classList.add('swiped');
                } else {
                    postItem.classList.remove('swiped');
                }
            }
            
            postItem.style.transform = ''; // 恢复原位，让CSS class接管
            
            // 重置状态
            swipeState.isDragging = false;
            swipeState.activeContainer = null;
            swipeState.swipeDirection = null;
            swipeState.isClick = true;
        };
        
        // --- 4. 在 init() 函数中绑定事件 ---
        // postsList.addEventListener('click', handlePostClick); // 这行您应该已经有了
        // postsList.addEventListener('mousedown', handleSwipeStart); // 绑定鼠标按下
        // postsList.addEventListener('touchstart', handleSwipeStart, { passive: true }); // 绑定触摸开始
        
        // ▲▲▲ 替换结束 ▲▲▲
        
        
        
        // 【最终版】动态列表事件绑定
        postsList.addEventListener('click', handlePostClick);
        postsList.addEventListener('mousedown', handleSwipeStart);
        postsList.addEventListener('touchstart', handleSwipeStart, { passive: true }); // 使用 passive 提升滚动性能
        // --- 绑定所有点击事件 ---
        
        // ▼▼▼ 【全新】为动态列表添加“加载更多”的事件委托 ▼▼▼
        postsList.addEventListener('click', (e) => {
            // 检查被点击的是否是我们的“加载更多”按钮
            if (e.target && e.target.id === 'load-more-qzone-btn') {
                loadMoreQzonePosts();
            }
        });
        // ▲▲▲ 新增代码结束 ▲▲▲
        // 【全新】为长期记忆“精炼”按钮绑定事件
        document.getElementById('refine-memory-btn-header').addEventListener('click', () => {
            if(state.activeChatId) {
                summarizeExistingLongTermMemory(state.activeChatId);
            }
        });
                    // ▼▼▼ 【全新】API预设功能事件监听器 ▼▼▼
                    document.getElementById('api-preset-select').addEventListener('change', handlePresetSelectionChange);
                    document.getElementById('save-api-preset-btn').addEventListener('click', saveApiPreset);
                    document.getElementById('delete-api-preset-btn').addEventListener('click', deleteApiPreset);
                    // ▲▲▲ 新增结束 ▲▲▲
        // ▼▼▼ 在 init() 的事件监听器区域添加这行代码 ▼▼▼
        document.getElementById('add-world-book-entry-btn').addEventListener('click', () => {
            const container = document.getElementById('world-book-entries-container');
            // 如果之前有提示语，先清空
            if (container.querySelector('p')) {
                container.innerHTML = '';
            }
            const newBlock = createWorldBookEntryBlock(); // 创建一个空块
            container.appendChild(newBlock);
            newBlock.querySelector('.entry-content-textarea').focus(); // 自动聚焦到新块的内容区
        });
        // ▲▲▲ 新增事件绑定结束 ▲▲▲
                    // ▼▼▼ 在 init() 函数的事件监听器区域，粘贴下面这两行 ▼▼▼
        document.getElementById('switch-greeting-btn').addEventListener('click', handleSwitchGreeting);
        // ▼▼▼ 【全新】为心声历史列表添加“加载更多”的事件委托 ▼▼▼
        document.getElementById('thoughts-history-list').addEventListener('click', (e) => {
            if (e.target && e.target.id === 'load-more-thoughts-btn') {
                loadMoreThoughts();
            }
        });
        // ▲▲▲ 新增代码结束 ▲▲▲
        // 在 init() 的事件监听器区域添加
        
        // ▼▼▼ 【核心修改】将事件监听绑定到新的图标按钮上 ▼▼▼
        document.getElementById('profile-history-icon-btn').addEventListener('click', showThoughtsHistory);
        // ▲▲▲ 替换结束 ▲▲▲
        document.getElementById('history-back-btn').addEventListener('click', hideThoughtsHistory);
        document.getElementById('character-profile-modal').addEventListener('click', (e) => {
            // 如果点击的是深色背景本身，而不是内容区域，就关闭弹窗
            if (e.target.id === 'character-profile-modal') {
                e.target.classList.remove('visible');
            }
        });
        // ▼▼▼ 【全新】表情批量删除事件绑定 ▼▼▼
        document.getElementById('manage-stickers-btn').addEventListener('click', toggleStickerManagementMode);
        document.getElementById('delete-selected-stickers-btn').addEventListener('click', executeBatchDeleteStickers);
        // ▲▲▲ 新增结束 ▲▲▲
                    // 绑定动态页和收藏页的返回按钮
                    document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
                    document.getElementById('favorites-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
        
                    // ▲▲▲ 添加结束 ▲▲▲
        
                    // ▼▼▼ 在 init() 函数的事件监听器区域，检查并确保你有这段完整的代码 ▼▼▼
        
                    // 收藏页搜索功能
                    const searchInput = document.getElementById('favorites-search-input');
                    const searchClearBtn = document.getElementById('favorites-search-clear-btn');
        
                    searchInput.addEventListener('input', () => {
                        const searchTerm = searchInput.value.trim().toLowerCase();
                        
                        // 控制清除按钮的显示/隐藏
                        searchClearBtn.style.display = searchTerm ? 'block' : 'none';
        
                        if (!searchTerm) {
                            displayFilteredFavorites(allFavoriteItems); // 如果搜索框为空，显示所有
                            return;
                        }
        
                        // 筛选逻辑
                        const filteredItems = allFavoriteItems.filter(item => {
                            let contentToSearch = '';
                            let authorToSearch = '';
        
                            if (item.type === 'qzone_post') {
                                const post = item.content;
                                contentToSearch += (post.publicText || '') + ' ' + (post.content || '');
                                if (post.authorId === 'user') {
                                    authorToSearch = state.qzoneSettings.nickname;
                                } else if (state.chats[post.authorId]) {
                                    authorToSearch = state.chats[post.authorId].name;
                                }
                            } else if (item.type === 'chat_message') {
                                const msg = item.content;
                                if (typeof msg.content === 'string') {
                                    contentToSearch = msg.content;
                                }
                                const chat = state.chats[item.chatId];
                                if (chat) {
                                   if (msg.role === 'user') {
                                        authorToSearch = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                                   } else {
                                        authorToSearch = chat.isGroup ? msg.senderName : chat.name;
                                   }
                                }
                            }
                            
                            // 同时搜索内容和作者，并且不区分大小写
                            return contentToSearch.toLowerCase().includes(searchTerm) || 
                                   authorToSearch.toLowerCase().includes(searchTerm);
                        });
        
                        displayFilteredFavorites(filteredItems);
                    });
        
                    // 清除按钮的点击事件
                    searchClearBtn.addEventListener('click', () => {
                        searchInput.value = '';
                        searchClearBtn.style.display = 'none';
                        displayFilteredFavorites(allFavoriteItems);
                        searchInput.focus();
                    });
        
                    // ▲▲▲ 代码检查结束 ▲▲▲
        
                    // ▼▼▼ 新增/修改的事件监听器 ▼▼▼
                    
                    // 为聊天界面的批量收藏按钮绑定事件
                                // 为聊天界面的批量收藏按钮绑定事件 (已修正)
                    document.getElementById('selection-favorite-btn').addEventListener('click', async () => {
                        if (selectedMessages.size === 0) return;
                        const chat = state.chats[state.activeChatId];
                        if (!chat) return;
        
                        const favoritesToAdd = [];
                        const timestampsToFavorite = [...selectedMessages];
        
                        for (const timestamp of timestampsToFavorite) {
                            // 【核心修正1】使用新的、高效的索引进行查询
                            const existing = await db.favorites.where('originalTimestamp').equals(timestamp).first();
                            
                            if (!existing) {
                                const messageToSave = chat.history.find(msg => msg.timestamp === timestamp);
                                if (messageToSave) {
                                    favoritesToAdd.push({
                                        type: 'chat_message',
                                        content: messageToSave,
                                        chatId: state.activeChatId,
                                        timestamp: Date.now(), // 这是收藏操作发生的时间
                                        originalTimestamp: messageToSave.timestamp // 【核心修正2】保存原始消息的时间戳到新字段
                                    });
                                }
                            }
                        }
        
                        if (favoritesToAdd.length > 0) {
                            await db.favorites.bulkAdd(favoritesToAdd);
                            allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray(); // 更新全局收藏缓存
                            await showCustomAlert('收藏成功', `已成功收藏 ${favoritesToAdd.length} 条消息。`);
                        } else {
                            await showCustomAlert('提示', '选中的消息均已收藏过。');
                        }
                        
                        exitSelectionMode();
                    });
        
                    // 收藏页面的"编辑"按钮事件 (已修正)
                    const favoritesEditBtn = document.getElementById('favorites-edit-btn');
                    const favoritesView = document.getElementById('favorites-view');
                    const favoritesActionBar = document.getElementById('favorites-action-bar');
                    const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 获取主导航栏
                    const favoritesList = document.getElementById('favorites-list'); // 获取收藏列表
                    
                    favoritesEditBtn.addEventListener('click', () => {
                        isFavoritesSelectionMode = !isFavoritesSelectionMode;
                        favoritesView.classList.toggle('selection-mode', isFavoritesSelectionMode);
        
                        if (isFavoritesSelectionMode) {
                            // --- 进入编辑模式 ---
                            favoritesEditBtn.textContent = '完成';
                            favoritesActionBar.style.display = 'block'; // 显示删除操作栏
                            mainBottomNav.style.display = 'none'; // ▼ 新增：隐藏主导航栏
                            favoritesList.style.paddingBottom = '80px'; // ▼ 新增：给列表底部增加空间
                        } else {
                            // --- 退出编辑模式 ---
                            favoritesEditBtn.textContent = '编辑';
                            favoritesActionBar.style.display = 'none'; // 隐藏删除操作栏
                            mainBottomNav.style.display = 'flex';  // ▼ 新增：恢复主导航栏
                            favoritesList.style.paddingBottom = ''; // ▼ 新增：恢复列表默认padding
        
                            // 退出时清空所有选择
                            selectedFavorites.clear();
                            document.querySelectorAll('.favorite-item-card.selected').forEach(card => card.classList.remove('selected'));
                            document.getElementById('favorites-delete-selected-btn').textContent = `删除 (0)`;
                        }
                    });
        
        // ▼▼▼ 将它【完整替换】为下面这段修正后的代码 ▼▼▼
        // 收藏列表的点击选择事件 (事件委托)
        document.getElementById('favorites-list').addEventListener('click', (e) => {
            const target = e.target;
            const card = target.closest('.favorite-item-card');
        
            // 【新增】处理文字图点击，这段逻辑要放在最前面，保证任何模式下都生效
            if (target.tagName === 'IMG' && target.dataset.hiddenText) {
                const hiddenText = target.dataset.hiddenText;
                showCustomAlert("图片内容", hiddenText.replace(/<br>/g, '\n'));
                return; // 处理完就退出，不继续执行选择逻辑
            }
            
            // 如果不在选择模式，则不执行后续的选择操作
            if (!isFavoritesSelectionMode) return;
        
            // --- 以下是原有的选择逻辑，保持不变 ---
            if (!card) return;
        
            const favId = parseInt(card.dataset.favid);
            if (isNaN(favId)) return;
        
            // 切换选择状态
            if (selectedFavorites.has(favId)) {
                selectedFavorites.delete(favId);
                card.classList.remove('selected');
            } else {
                selectedFavorites.add(favId);
                card.classList.add('selected');
            }
            
            // 更新底部删除按钮的计数
            document.getElementById('favorites-delete-selected-btn').textContent = `删除 (${selectedFavorites.size})`;
        });
        
        // ▼▼▼ 将它【完整替换】为下面这段修正后的代码 ▼▼▼
        // 收藏页面批量删除按钮事件
        document.getElementById('favorites-delete-selected-btn').addEventListener('click', async () => {
            if (selectedFavorites.size === 0) return;
        
            const confirmed = await showCustomConfirm(
                '确认删除', 
                `确定要从收藏夹中移除这 ${selectedFavorites.size} 条内容吗？`, 
                { confirmButtonClass: 'btn-danger' }
            );
        
            if (confirmed) {
                const idsToDelete = [...selectedFavorites];
                await db.favorites.bulkDelete(idsToDelete);
                await showCustomAlert('删除成功', '选中的收藏已被移除。');
                
                // 【核心修正1】从前端缓存中也移除被删除的项
                allFavoriteItems = allFavoriteItems.filter(item => !idsToDelete.includes(item.id));
                
                // 【核心修正2】使用更新后的缓存，立即重新渲染列表
                displayFilteredFavorites(allFavoriteItems);
                
                // 最后，再退出编辑模式
                favoritesEditBtn.click(); // 模拟点击"完成"按钮来退出编辑模式
            }
        });
        
        // ▼▼▼ 在 init() 函数末尾添加 ▼▼▼
        if (state.globalSettings.enableBackgroundActivity) {
            startBackgroundSimulation();
            console.log("后台活动模拟已自动启动。");
        }
        // ▲▲▲ 添加结束 ▲▲▲
        
        // ▼▼▼ 【这是最终的正确代码】请粘贴这段代码到 init() 的事件监听器区域末尾 ▼▼▼
        
        // --- 统一处理所有影响预览的控件的事件 ---
        
        // 1. 监听主题选择
        document.querySelectorAll('input[name="theme-select"]').forEach(radio => {
            radio.addEventListener('change', updateSettingsPreview);
        });
        
        // 2. 监听字体大小滑块
        const fontSizeSlider = document.getElementById('font-size-slider');
        fontSizeSlider.addEventListener('input', () => {
            // a. 实时更新数值显示
            document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
            // b. 更新预览
            updateSettingsPreview();
        });
        
        // 3. 监听自定义CSS输入框
        const customCssInputForPreview = document.getElementById('custom-css-input');
        customCssInputForPreview.addEventListener('input', updateSettingsPreview);
        
        // 4. 监听重置按钮
        document.getElementById('reset-theme-btn').addEventListener('click', () => {
            document.getElementById('theme-default').checked = true;
            updateSettingsPreview();
        });
        
        document.getElementById('reset-custom-css-btn').addEventListener('click', () => {
            document.getElementById('custom-css-input').value = '';
            updateSettingsPreview();
        });
        
        // ▲▲▲ 粘贴结束 ▲▲▲
        // 【请确保这段代码在您的 init() 函数内】
        document.getElementById('lyrics-vertical-pos').addEventListener('change', updateSettingsPreview);
        document.getElementById('lyrics-horizontal-pos').addEventListener('change', updateSettingsPreview);
        document.getElementById('lyrics-offset-input').addEventListener('input', updateSettingsPreview);
        // ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
        document.querySelectorAll('input[name="visibility"]').forEach(radio => {
            radio.addEventListener('change', function() {
                const groupsContainer = document.getElementById('post-visibility-groups');
                if (this.value === 'include' || this.value === 'exclude') {
                    groupsContainer.style.display = 'block';
                } else {
                    groupsContainer.style.display = 'none';
                }
            });
        });
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
        
        // ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
        document.getElementById('manage-groups-btn').addEventListener('click', openGroupManager);
        document.getElementById('close-group-manager-btn').addEventListener('click', () => {
            document.getElementById('group-management-modal').classList.remove('visible');
            // 刷新聊天设置里的分组列表
            const chatSettingsBtn = document.getElementById('chat-settings-btn');
            if (document.getElementById('chat-settings-modal').classList.contains('visible')) {
               chatSettingsBtn.click(); // 再次点击以重新打开
            }
        });
        
        document.getElementById('add-new-group-btn').addEventListener('click', addNewGroup);
        document.getElementById('existing-groups-list').addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-group-btn')) {
                const groupId = parseInt(e.target.dataset.id);
                deleteGroup(groupId);
            }
        });
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
        
        // ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
        // 消息操作菜单的按钮事件
        document.getElementById('cancel-message-action-btn').addEventListener('click', hideMessageActions);
        // ▼▼▼ 【修正】使用新的编辑器入口 ▼▼▼
        document.getElementById('edit-message-btn').addEventListener('click', openAdvancedMessageEditor);
        // ▲▲▲ 替换结束 ▲▲▲
        document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);
        
        // ▼▼▼ 在这里添加新代码 ▼▼▼
        document.getElementById('recall-message-btn').addEventListener('click', handleRecallClick);
        // ▲▲▲ 添加结束 ▲▲▲
        
        // ▼▼▼ 请用这段【修正后】的代码替换旧的 select-message-btn 事件监听器 ▼▼▼
        document.getElementById('select-message-btn').addEventListener('click', () => {
            // 【核心修复】在关闭菜单前，先捕获时间戳
            const timestampToSelect = activeMessageTimestamp; 
            hideMessageActions();
            // 使用捕获到的值
            if (timestampToSelect) {
                enterSelectionMode(timestampToSelect);
            }
        });
        // ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 在 init() 的事件监听器区域添加 ▼▼▼
        
        // 监听聊天区域的点击，专门用于处理AI发来的转账
        document.getElementById('chat-messages').addEventListener('click', (e) => {
            // 1. 向上查找被点击的元素是否在一个消息气泡内
            const bubble = e.target.closest('.message-bubble');
            if (!bubble) return; // 如果不在，就退出
        
            // 2. 检查是否是AI的、待处理的转账消息
            if (bubble.classList.contains('ai') && 
                bubble.classList.contains('is-transfer') && 
                bubble.dataset.status === 'pending') {
                
                // 3. 只有满足所有条件，才显示操作菜单
                const timestamp = parseInt(bubble.dataset.timestamp);
                if (!isNaN(timestamp)) {
                    showTransferActionModal(timestamp);
                }
            }
        });
        
        // 绑定新转账操作模态框的按钮
        document.getElementById('transfer-action-accept').addEventListener('click', () => handleUserTransferResponse('accepted'));
        document.getElementById('transfer-action-decline').addEventListener('click', () => handleUserTransferResponse('declined'));
        document.getElementById('transfer-action-cancel').addEventListener('click', hideTransferActionModal);
        
        // ▲▲▲ 添加结束 ▲▲▲
        // ▼▼▼ 在 init() 函数的事件监听器区域末尾添加 ▼▼▼
        
        // 动态操作菜单的按钮事件
        document.getElementById('edit-post-btn').addEventListener('click', openPostEditor);
        document.getElementById('copy-post-btn').addEventListener('click', copyPostContent);
        document.getElementById('cancel-post-action-btn').addEventListener('click', hidePostActions);
        
        // ▲▲▲ 添加结束 ▲▲▲
        
        // ▼▼▼ 【新增】联系人选择器事件绑定 ▼▼▼
        document.getElementById('cancel-contact-picker-btn').addEventListener('click', () => {
            showScreen('chat-list-screen');
        });
        
        document.getElementById('contact-picker-list').addEventListener('click', (e) => {
            const item = e.target.closest('.contact-picker-item');
            if (!item) return;
        
            const contactId = item.dataset.contactId;
            item.classList.toggle('selected');
            
            if (selectedContacts.has(contactId)) {
                selectedContacts.delete(contactId);
            } else {
                selectedContacts.add(contactId);
            }
            updateContactPickerConfirmButton();
        });
        
        // ▼▼▼ 【新增】绑定“管理群成员”按钮事件 ▼▼▼
        document.getElementById('manage-members-btn').addEventListener('click', () => {
            // 在切换屏幕前，先隐藏当前的聊天设置弹窗
            //document.getElementById('chat-settings-modal').classList.remove('visible');
            // 然后再打开成员管理屏幕
            openMemberManagementScreen();
        });
        // ▲▲▲ 新增代码结束 ▲▲▲
        
        // ▼▼▼ 【最终完整版】群成员管理功能事件绑定 ▼▼▼
        document.getElementById('back-from-member-management').addEventListener('click', () => {
        
            showScreen('chat-interface-screen');    
            document.getElementById('chat-settings-btn').click();
        });
        // ▲▲▲ 替换结束 ▲▲▲
        
        document.getElementById('member-management-list').addEventListener('click', (e) => {
            // 【已恢复】移除成员的事件
            if (e.target.classList.contains('remove-member-btn')) {
                removeMemberFromGroup(e.target.dataset.memberId);
            }
        });
        
        document.getElementById('add-existing-contact-btn').addEventListener('click', async () => {
            // 【已恢复】从好友列表添加的事件
            // 【关键】为“完成”按钮绑定“拉人入群”的逻辑
            const confirmBtn = document.getElementById('confirm-contact-picker-btn');
            // 使用克隆节点方法清除旧的事件监听器，防止重复绑定
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            newConfirmBtn.addEventListener('click', handleAddMembersToGroup);
            
            await openContactPickerForAddMember();
        });
        
        document.getElementById('create-new-member-btn').addEventListener('click', createNewMemberInGroup);
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 【全新】视频通话功能事件监听器 ▼▼▼
        
        // 绑定单聊和群聊的发起按钮
        document.getElementById('video-call-btn').addEventListener('click', handleInitiateCall);
        document.getElementById('group-video-call-btn').addEventListener('click', handleInitiateCall);
        
        // 绑定“挂断”按钮
        document.getElementById('hang-up-btn').addEventListener('click', endVideoCall);
        
        // 绑定“取消呼叫”按钮
        document.getElementById('cancel-call-btn').addEventListener('click', () => {
            videoCallState.isAwaitingResponse = false;
            showScreen('chat-interface-screen');
        });
        
        // 【全新】绑定“加入通话”按钮
        document.getElementById('join-call-btn').addEventListener('click', handleUserJoinCall);
        
        // ▼▼▼ 用这个【已修复并激活旁观模式】的版本替换旧的 decline-call-btn 事件监听器 ▼▼▼
        // 绑定来电请求的“拒绝”按钮
        document.getElementById('decline-call-btn').addEventListener('click', async () => {
            hideIncomingCallModal();
            const chat = state.chats[videoCallState.activeChatId];
            if (!chat) return;
            
            // 【核心修正】在这里，我们将拒绝的逻辑与API调用连接起来
            if (videoCallState.isGroupCall) {
                videoCallState.isUserParticipating = false; // 标记用户为旁观者
                
                // 1. 创建一条隐藏消息，通知AI用户拒绝了
                const systemNote = {
                    role: 'system',
                    content: `[系统提示：用户拒绝了通话邀请，但你们可以自己开始。请你们各自决策是否加入。]`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(systemNote);
                await db.chats.put(chat);
                
                // 2. 【关键】触发AI响应，让它们自己决定要不要开始群聊
                // 这将会在后台处理，如果AI们决定开始，最终会调用 startVideoCall()
                await triggerAiResponse(); 
                
            } else { // 单聊拒绝逻辑保持不变
                const declineMessage = { role: 'user', content: '我拒绝了你的视频通话请求。', timestamp: Date.now() };
                chat.history.push(declineMessage);
                await db.chats.put(chat);
                
                // 回到聊天界面并显示拒绝消息
                showScreen('chat-interface-screen');
                appendMessage(declineMessage, chat);
                
                // 让AI对你的拒绝做出回应
                triggerAiResponse();
            }
            
            // 清理状态，以防万一
            videoCallState.isAwaitingResponse = false;
        });
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 用这个【已修复重复头像BUG】的版本替换旧的 accept-call-btn 事件监听器 ▼▼▼
        // 绑定来电请求的“接听”按钮
        document.getElementById('accept-call-btn').addEventListener('click', async () => {
            hideIncomingCallModal();
            
            videoCallState.initiator = 'ai';
            videoCallState.isUserParticipating = true;
            videoCallState.activeChatId = state.activeChatId;
            
            // 【核心修正】我们在这里不再手动添加用户到 participants 列表
            if (videoCallState.isGroupCall) {
                // 对于群聊，我们只把【发起通话的AI】加入参与者列表
                const chat = state.chats[videoCallState.activeChatId];
                const requester = chat.members.find(m => m.name === videoCallState.callRequester);
                if (requester) {
                    // 清空可能存在的旧数据，然后只添加发起者
                    videoCallState.participants = [requester];
                } else {
                    videoCallState.participants = []; // 如果找不到发起者，就清空
                }
            }
            
            // 无论单聊还是群聊，直接启动通话界面！
            startVideoCall();
        });
        // ▲▲▲ 替换结束 ▲▲▲
        
        
        // ▼▼▼ 请用这个【已增加用户高亮】的全新版本，完整替换旧的 user-speak-btn 事件监听器 ▼▼▼
        // 绑定用户在通话中发言的按钮
        document.getElementById('user-speak-btn').addEventListener('click', async () => {
            if (!videoCallState.isActive) return;
        
            // ★★★★★ 核心新增：在弹出输入框前，先找到并高亮用户头像 ★★★★★
            const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
            if (userAvatar) {
                userAvatar.classList.add('speaking');
            }
        
            const userInput = await showCustomPrompt('你说', '请输入你想说的话...');
            
            // ★★★★★ 核心新增：无论用户是否输入，只要关闭输入框就移除高亮 ★★★★★
            if (userAvatar) {
                userAvatar.classList.remove('speaking');
            }
        
            if (userInput && userInput.trim()) {
                triggerAiInCallAction(userInput.trim());
            }
        });
        // ▲▲▲ 替换结束 ▲▲▲
        
        // ▼▼▼ 【新增】回忆录相关事件绑定 ▼▼▼
        // 1. 将“回忆”页签和它的视图连接起来
        document.querySelector('.nav-item[data-view="memories-view"]').addEventListener('click', () => {
            // 在切换前，确保"收藏"页面的编辑模式已关闭
            if (isFavoritesSelectionMode) {
                document.getElementById('favorites-edit-btn').click(); 
            }
            switchToChatListView('memories-view');
            renderMemoriesScreen(); // 点击时渲染
        });
        
        // 2. 绑定回忆录界面的返回按钮
        document.getElementById('memories-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
        
        // ▲▲▲ 新增结束 ▲▲▲
        
        // ▼▼▼ 在 init() 函数的事件监听器区域找到这个按钮的监听器 ▼▼▼
        document.getElementById('confirm-create-countdown-btn').addEventListener('click', async () => {
            const title = document.getElementById('countdown-title-input').value.trim();
            const dateValue = document.getElementById('countdown-date-input').value;
            
            if (!title || !dateValue) {
                alert('请填写完整的约定标题和日期！');
                return;
            }
        
            const targetDate = new Date(dateValue);
            if (isNaN(targetDate) || targetDate <= new Date()) {
                alert('请输入一个有效的、未来的日期！');
                return;
            }
        
            // ▼▼▼ 将其【替换为】下面这段【新代码】▼▼▼
            const newCountdown = {
                authorId: 'user', // 【核心修复2】不再存 authorName，而是用 'user' 作为您的专属ID
                description: title,
                timestamp: Date.now(),
                type: 'countdown',
                targetDate: targetDate.getTime()
            };
            // ▲▲▲ 替换结束 ▲▲▲
            
            await db.memories.add(newCountdown);
            document.getElementById('create-countdown-modal').classList.remove('visible');
            renderMemoriesScreen();
        });
        
        // 【全新】拉黑功能事件绑定
        document.getElementById('block-chat-btn').addEventListener('click', async () => {
            if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;
        
            const chat = state.chats[state.activeChatId];
            const confirmed = await showCustomConfirm(
                '确认拉黑', 
                `确定要拉黑“${chat.name}”吗？拉黑后您将无法向其发送消息，直到您将Ta移出黑名单，或等待Ta重新申请好友。`,
                { confirmButtonClass: 'btn-danger' }
            );
        
            if (confirmed) {
                chat.relationship.status = 'blocked_by_user';
                chat.relationship.blockedTimestamp = Date.now();
        
                // ▼▼▼ 在这里添加下面的代码 ▼▼▼
                const hiddenMessage = {
                    role: 'system',
                    content: `[系统提示：你刚刚被用户拉黑了。在对方解除拉黑之前，你无法再主动发起对话，也无法回应。]`,
                    timestamp: Date.now() + 1,
                    isHidden: true
                };
                chat.history.push(hiddenMessage);
                // ▲▲▲ 添加结束 ▲▲▲
        
                await db.chats.put(chat);
                
                // 关闭设置弹窗，并刷新聊天界面
                document.getElementById('chat-settings-modal').classList.remove('visible');
                renderChatInterface(state.activeChatId);
                // 刷新聊天列表，可能会有UI变化
                renderChatList();
            }
        });
        
        document.getElementById('chat-lock-overlay').addEventListener('click', async (e) => {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            if (e.target.id === 'force-apply-check-btn') {
                alert("正在手动触发好友申请流程，请稍后...\n如果API调用成功，将弹出提示。如果失败，也会有错误提示。如果长时间无反应，说明AI可能决定暂时不申请。");
                await triggerAiFriendApplication(chat.id);
                renderChatInterface(chat.id); 
                return;
            }
        
            if (e.target.id === 'unblock-btn') {
                chat.relationship.status = 'friend';
                chat.relationship.blockedTimestamp = null;
        
                // ▼▼▼ 在这里添加下面的代码 ▼▼▼
                const hiddenMessage = {
                    role: 'system',
                    content: `[系统提示：用户刚刚解除了对你的拉黑。现在你们可以重新开始对话了。]`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(hiddenMessage);
                // ▲▲▲ 添加结束 ▲▲▲
        
                await db.chats.put(chat);
                renderChatInterface(chat.id);
                renderChatList();
                triggerAiResponse(); // 【可选但推荐】解除后让AI主动说点什么
            }
        else if (e.target.id === 'accept-friend-btn') {
                // 1. 核心修正：不再触发AI响应，避免逻辑混乱
                // triggerAiResponse(); // <-- 删除或注释掉这一行
        
                // 2. 直接更新关系状态
                chat.relationship.status = 'friend';
                chat.relationship.applicationReason = '';
        
                // 3. 新增：直接在前端生成一条对用户可见的系统消息，告知操作成功
                const systemMessage = {
                    role: 'system',
                    type: 'pat_message', // 复用居中样式
                    content: `你通过了“${chat.name}”的好友请求`,
                    timestamp: Date.now()
                };
                chat.history.push(systemMessage);
        
                // 4. 新增：模拟AI发来一条自然的欢迎消息，让交互更流畅
                const welcomeMessage = {
                    role: 'assistant',
                    senderName: chat.name,
                    content: '太好了！我们又可以聊天啦！',
                    timestamp: Date.now() + 1 // 时间戳+1确保在系统消息之后
                };
                chat.history.push(welcomeMessage);
        
                // 5. 一次性将所有更改保存到数据库
                await db.chats.put(chat);
        
                // 6. 刷新UI，显示最新的状态和消息
                renderChatInterface(chat.id);
                renderChatList();
            }
            else if (e.target.id === 'reject-friend-btn') {
                chat.relationship.status = 'blocked_by_user';
                chat.relationship.blockedTimestamp = Date.now();
                chat.relationship.applicationReason = '';
                await db.chats.put(chat);
                renderChatInterface(chat.id);
            }
            // 【新增】处理申请好友按钮的点击事件
            else if (e.target.id === 'apply-friend-btn') {
                const reason = await showCustomPrompt(
                    '发送好友申请', 
                    `请输入你想对“${chat.name}”说的申请理由：`,
                    "我们和好吧！"
                );
                // 只有当用户输入了内容并点击“确定”后才继续
                if (reason !== null) {
                    // 更新关系状态为“等待AI批准”
                    chat.relationship.status = 'pending_ai_approval';
                    chat.relationship.applicationReason = reason;
                    await db.chats.put(chat);
        
                    // 刷新UI，显示“等待通过”的界面
                    renderChatInterface(chat.id);
                    renderChatList();
                    
                    // 【关键】触发AI响应，让它去处理这个好友申请
                    triggerAiResponse();
                }
            }
        });
        
        // ▼▼▼ 【全新】红包功能事件绑定 ▼▼▼
        
        // 1. 将原有的转账按钮(￥)的点击事件，重定向到新的总入口函数
        document.getElementById('transfer-btn').addEventListener('click', handlePaymentButtonClick);
        
        // 2. 红包模态框内部的控制按钮
        document.getElementById('cancel-red-packet-btn').addEventListener('click', () => {
            document.getElementById('red-packet-modal').classList.remove('visible');
        });
        document.getElementById('send-group-packet-btn').addEventListener('click', sendGroupRedPacket);
        document.getElementById('send-direct-packet-btn').addEventListener('click', sendDirectRedPacket);
        
        // 3. 红包模态框的页签切换逻辑
        const rpTabGroup = document.getElementById('rp-tab-group');
        const rpTabDirect = document.getElementById('rp-tab-direct');
        const rpContentGroup = document.getElementById('rp-content-group');
        const rpContentDirect = document.getElementById('rp-content-direct');
        
        rpTabGroup.addEventListener('click', () => {
            rpTabGroup.classList.add('active');
            rpTabDirect.classList.remove('active');
            rpContentGroup.style.display = 'block';
            rpContentDirect.style.display = 'none';
        });
        rpTabDirect.addEventListener('click', () => {
            rpTabDirect.classList.add('active');
            rpTabGroup.classList.remove('active');
            rpContentDirect.style.display = 'block';
            rpContentGroup.style.display = 'none';
        });
        
        // 4. 实时更新红包金额显示
        document.getElementById('rp-group-amount').addEventListener('input', (e) => {
            const amount = parseFloat(e.target.value) || 0;
            document.getElementById('rp-group-total').textContent = `¥ ${amount.toFixed(2)}`;
        });
        document.getElementById('rp-direct-amount').addEventListener('input', (e) => {
            const amount = parseFloat(e.target.value) || 0;
            document.getElementById('rp-direct-total').textContent = `¥ ${amount.toFixed(2)}`;
        });
        
        // ▲▲▲ 新事件绑定结束 ▲▲▲
        
        // ▼▼▼ 【全新添加】使用事件委托处理红包点击，修复失效问题 ▼▼▼
        document.getElementById('chat-messages').addEventListener('click', (e) => {
            // 1. 找到被点击的红包卡片
            const packetCard = e.target.closest('.red-packet-card');
            if (!packetCard) return; // 如果点击的不是红包，就什么也不做
        
            // 2. 从红包卡片的父级.message-bubble获取时间戳
            const messageBubble = packetCard.closest('.message-bubble');
            if (!messageBubble || !messageBubble.dataset.timestamp) return;
        
            // 3. 调用我们现有的处理函数
            const timestamp = parseInt(messageBubble.dataset.timestamp);
            handlePacketClick(timestamp);
        });
        // ▲▲▲ 新增代码结束 ▲▲▲
        
        // ▼▼▼ 【全新】投票功能事件监听器 ▼▼▼
        // 在输入框工具栏添加按钮
        document.getElementById('send-poll-btn').addEventListener('click', openCreatePollModal);
        
        // 投票创建模态框的按钮
        document.getElementById('add-poll-option-btn').addEventListener('click', addPollOptionInput);
        document.getElementById('cancel-create-poll-btn').addEventListener('click', () => {
            document.getElementById('create-poll-modal').classList.remove('visible');
        });
        document.getElementById('confirm-create-poll-btn').addEventListener('click', sendPoll);
        
        // 使用事件委托处理投票卡片内的所有点击事件
        document.getElementById('chat-messages').addEventListener('click', (e) => {
            const pollCard = e.target.closest('.poll-card');
            if (!pollCard) return;
        
            const timestamp = parseInt(pollCard.dataset.pollTimestamp);
            if (isNaN(timestamp)) return;
            
            // 点击了选项
            const optionItem = e.target.closest('.poll-option-item');
            if (optionItem && !pollCard.classList.contains('closed')) {
                handleUserVote(timestamp, optionItem.dataset.option);
                return;
            }
            
            // 点击了动作按钮（结束投票/查看结果）
            const actionBtn = e.target.closest('.poll-action-btn');
            if (actionBtn) {
                if (pollCard.classList.contains('closed')) {
                    showPollResults(timestamp);
                } else {
                    endPoll(timestamp);
                }
                return;
            }
        
            // 如果是已结束的投票，点击卡片任何地方都可以查看结果
            if (pollCard.classList.contains('closed')) {
                showPollResults(timestamp);
            }
        });
        // ▲▲▲ 新事件监听器粘贴结束 ▲▲▲
        
          // ▼▼▼ 【全新】AI头像库功能事件绑定 ▼▼▼
        document.getElementById('manage-ai-avatar-library-btn').addEventListener('click', openAiAvatarLibraryModal);
        // ▼▼▼ 【全新】为批量导入按钮绑定事件 ▼▼▼
        // 绑定AI头像库的“批量”按钮
        document.getElementById('add-ai-avatar-batch-btn').addEventListener('click', () => openBatchImportModal('ai'));
        
        // 绑定群头像库的“批量”按钮
        document.getElementById('add-group-avatar-batch-btn').addEventListener('click', () => openBatchImportModal('group'));
        // ▲▲▲ 新增结束 ▲▲▲
        // ▼▼▼ 【请用这整块代码】替换旧的 add-ai-avatar-btn 事件监听器 ▼▼▼
        // 绑定“URL”按钮，调用我们刚刚重命名的函数
        document.getElementById('add-ai-avatar-url-btn').addEventListener('click', addAvatarToLibraryFromURL);
        
        // 【核心新增】绑定“上传”按钮，触发隐藏的文件选择器
        document.getElementById('add-ai-avatar-upload-btn').addEventListener('click', () => {
            document.getElementById('ai-avatar-upload-input').click();
        });
        
        // 【核心新增】为文件选择器绑定 change 事件，这是处理上传的核心入口
        document.getElementById('ai-avatar-upload-input').addEventListener('change', handleLocalAvatarUpload);
        // ▲▲▲ 替换结束 ▲▲▲
        document.getElementById('close-ai-avatar-library-btn').addEventListener('click', closeAiAvatarLibraryModal);
        // ▲▲▲ 新增结束 ▲▲▲
        // ▼▼▼ 【全新】群头像库功能事件绑定 ▼▼▼
        document.getElementById('manage-group-avatar-library-btn').addEventListener('click', openGroupAvatarLibraryModal);
        // ▼▼▼ 【请用这整块代码】替换旧的 add-group-avatar-btn 事件监听器 ▼▼▼
        
        // 绑定“URL”按钮，调用我们刚刚重命名的函数
        document.getElementById('add-group-avatar-url-btn').addEventListener('click', addAvatarToGroupLibraryFromURL);
        
        // 【核心新增】绑定“上传”按钮，触发隐藏的文件选择器
        document.getElementById('add-group-avatar-upload-btn').addEventListener('click', () => {
            document.getElementById('group-avatar-upload-input').click();
        });
        
        // 【核心新增】为文件选择器绑定 change 事件，这是处理上传的核心入口
        document.getElementById('group-avatar-upload-input').addEventListener('change', handleLocalGroupAvatarUpload);
        
        // ▲▲▲ 替换结束 ▲▲▲
        document.getElementById('close-group-avatar-library-btn').addEventListener('click', closeGroupAvatarLibraryModal);
        // ▲▲▲ 新增结束 ▲▲▲
        // ▼▼▼ 在 init() 的事件监听区域，粘贴这段【新代码】▼▼▼
// 为 EPhone 图标设置网格绑定事件委托
document.getElementById('icon-settings-grid').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-icon-btn')) {
        const item = e.target.closest('.icon-setting-item');
        const iconId = item.dataset.iconId;
        if (iconId) {
            handleIconChange(iconId, 'ephone', item);
        }
    }
});
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
        
        // ▼▼▼ 在 init() 函数的末尾，粘贴这段【全新的事件监听器】 ▼▼▼
        
            document.getElementById('chat-messages').addEventListener('click', (e) => {
                // 使用 .closest() 向上查找被点击的卡片
                const linkCard = e.target.closest('.link-share-card');
                if (linkCard) {
                    const timestamp = parseInt(linkCard.dataset.timestamp);
                    if (!isNaN(timestamp)) {
                        openBrowser(timestamp); // 调用我们的函数
                    }
                }
            });
        
            // 浏览器返回按钮的事件监听，确保它只绑定一次
            document.getElementById('browser-back-btn').addEventListener('click', () => {
                showScreen('chat-interface-screen');
            });
        
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
        // ▼▼▼ 请用这个【新代码块】替换旧的 qzoneStickerPanelState.panelEl.addEventListener ▼▼▼
        qzoneStickerPanelState.panelEl.addEventListener('click', async (e) => {
            const stickerItem = e.target.closest('.sticker-item');
            if (stickerItem && qzoneStickerPanelState.activePostId !== null) {
                // 从背景图片样式中提取URL
                const stickerUrl = stickerItem.style.backgroundImage.slice(5, -2);
                
                // 【核心修改】根据URL从全局表情状态中找到完整的表情对象
                const stickerObject = state.userStickers.find(s => s.url === stickerUrl);
        
                if (stickerObject) {
                    // 将完整的表情对象传递给处理函数
                    await sendQzoneStickerComment(qzoneStickerPanelState.activePostId, stickerObject);
                } else {
                    console.warn("在动态评论区点击了表情，但在表情库中未找到对象:", stickerUrl);
                }
            }
        });
        
        // ▲▲▲ 替换结束 ▲▲▲
        
        // 【全新】全局点击监听，用于关闭打开的表情面板
        document.addEventListener('click', (e) => {
            if (qzoneStickerPanelState.isOpen && 
                !qzoneStickerPanelState.panelEl.contains(e.target) && 
                !e.target.closest('.comment-sticker-btn')) {
                closeQzoneStickerPanel();
            }
        });
        // ▼▼▼ 在 init() 函数的末尾，粘贴这段【全新的事件监听器】 ▼▼▼
        
            // 1. 绑定输入框上方“分享链接”按钮的点击事件
            document.getElementById('share-link-btn').addEventListener('click', openShareLinkModal);
        
            // 2. 绑定模态框中“取消”按钮的点击事件
            document.getElementById('cancel-share-link-btn').addEventListener('click', () => {
                document.getElementById('share-link-modal').classList.remove('visible');
            });
        
            // 3. 绑定模态框中“分享”按钮的点击事件
            document.getElementById('confirm-share-link-btn').addEventListener('click', sendUserLinkShare);
        
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
        
        document.getElementById('theme-toggle-switch').addEventListener('change', toggleTheme);
        

        // ▼▼▼ 在 init() 的事件监听器区域添加这行代码 ▼▼▼
        document.getElementById('share-location-btn').addEventListener('click', sendLocationShare);
        // 在你的 init() 函数的事件监听器区域...
        

        // ▼▼▼ 用这段【新代码】替换旧的通话记录事件绑定 ▼▼▼
        
        document.getElementById('chat-list-title').addEventListener('click', renderCallHistoryScreen);
        
        // 2. 绑定通话记录页面的“返回”按钮
        document.getElementById('call-history-back-btn').addEventListener('click', () => {
            // 【核心修改】返回到聊天列表页面，而不是聊天界面
            showScreen('chat-list-screen');
        });
        
        // 3. 监听卡片点击的逻辑保持不变
        document.getElementById('call-history-list').addEventListener('click', (e) => {
            const card = e.target.closest('.call-record-card');
            if (card && card.dataset.recordId) {
                showCallTranscript(parseInt(card.dataset.recordId));
            }
        });
        
        // 4. 关闭详情弹窗的逻辑保持不变
document.getElementById('close-call-transcript-btn').addEventListener('click', () => {
    document.getElementById('call-transcript-modal').classList.remove('visible');
});
        
        // ▲▲▲ 替换结束 ▲▲▲
        

        
        document.getElementById('chat-header-status').addEventListener('click', handleEditStatusClick);
        
        // 在 init() 的事件监听器区域添加
        document.getElementById('selection-share-btn').addEventListener('click', () => {
            if (selectedMessages.size > 0) {
                openShareTargetPicker(); // 打开我们即将创建的目标选择器
            }
        });
        document.getElementById('selection-screenshot-btn').addEventListener('click', handleLongScreenshot);
        // 在 init() 的事件监听器区域添加
        document.getElementById('confirm-share-target-btn').addEventListener('click', async () => {
            const sourceChat = state.chats[state.activeChatId];
            const selectedTargetIds = Array.from(document.querySelectorAll('.share-target-checkbox:checked'))
                                           .map(cb => cb.dataset.chatId);
        
            if (selectedTargetIds.length === 0) {
                alert("请至少选择一个要分享的聊天。");
                return;
            }
        
            // 1. 打包聊天记录
            const sharedHistory = [];
            const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
            for (const timestamp of sortedTimestamps) {
                const msg = sourceChat.history.find(m => m.timestamp === timestamp);
                if (msg) {
                    sharedHistory.push(msg);
                }
            }
            
            // 2. 创建分享卡片消息对象
            const shareCardMessage = {
                role: 'user',
                senderName: sourceChat.isGroup ? (sourceChat.settings.myNickname || '我') : '我',
                type: 'share_card',
                timestamp: Date.now(),
                payload: {
                    sourceChatName: sourceChat.name,
                    title: `来自“${sourceChat.name}”的聊天记录`,
                    sharedHistory: sharedHistory
                }
            };
        
            // 3. 循环发送到所有目标聊天
            for (const targetId of selectedTargetIds) {
                const targetChat = state.chats[targetId];
                if (targetChat) {
                    targetChat.history.push(shareCardMessage);
                    await db.chats.put(targetChat);
                }
            }
            
            // 4. 收尾工作
            document.getElementById('share-target-modal').classList.remove('visible');
            exitSelectionMode(); // 退出多选模式
            await showCustomAlert("分享成功", `聊天记录已成功分享到 ${selectedTargetIds.length} 个会话中。`);
            renderChatList(); // 刷新列表，可能会有新消息提示
        });
        
        // 绑定取消按钮
        document.getElementById('cancel-share-target-btn').addEventListener('click', () => {
            document.getElementById('share-target-modal').classList.remove('visible');
        });
        
        // 在 init() 的事件监听器区域添加
        document.getElementById('chat-messages').addEventListener('click', (e) => {
            // ...你已有的其他点击事件逻辑...
        
            // 新增逻辑：处理分享卡片的点击
            const shareCard = e.target.closest('.link-share-card[data-timestamp]');
            if (shareCard && shareCard.closest('.message-bubble.is-link-share')) {
                const timestamp = parseInt(shareCard.dataset.timestamp);
                openSharedHistoryViewer(timestamp);
            }
        });
        
        // 绑定查看器的关闭按钮
        document.getElementById('close-shared-history-viewer-btn').addEventListener('click', () => {
            document.getElementById('shared-history-viewer-modal').classList.remove('visible');
        });
        
        // 创建新函数来处理渲染逻辑
        function openSharedHistoryViewer(timestamp) {
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestamp);
            if (!message || message.type !== 'share_card') return;
        
            const viewerModal = document.getElementById('shared-history-viewer-modal');
            const viewerTitle = document.getElementById('shared-history-viewer-title');
            const viewerContent = document.getElementById('shared-history-viewer-content');
        
            viewerTitle.textContent = message.payload.title;
            viewerContent.innerHTML = ''; // 清空旧内容
        
            // 【核心】复用 createMessageElement 来渲染每一条被分享的消息
            message.payload.sharedHistory.forEach(sharedMsg => {
                // 注意：这里我们传入的是 sourceChat 对象，以确保头像、昵称等正确
                const sourceChat = Object.values(state.chats).find(c => c.name === message.payload.sourceChatName) || chat;
                const bubbleEl = createMessageElement(sharedMsg, sourceChat);
                if (bubbleEl) {
                    viewerContent.appendChild(bubbleEl);
                }
            });
        
            viewerModal.classList.add('visible');
        }
        
        audioPlayer.addEventListener('timeupdate', updateMusicProgressBar);
        
        audioPlayer.addEventListener('pause', () => { 
            if(musicState.isActive) { 
                musicState.isPlaying = false; 
                updatePlayerUI(); 
            } 
        });
        audioPlayer.addEventListener('play', () => { 
            if(musicState.isActive) { 
                musicState.isPlaying = true; 
                updatePlayerUI(); 
            } 
        });
        
// ▼▼▼ 【最终修复版】请用这个全新的事件监听器，替换旧的 playlist-body 监听器 ▼▼▼

document.getElementById('playlist-body').addEventListener('click', async (e) => {
    const target = e.target;
    // 【【【核心新增逻辑就在这里！】】】
    // 点击“专辑”按钮
    const albumArtBtn = target.closest('.album-art-btn');
    if (albumArtBtn) {
        const index = parseInt(albumArtBtn.dataset.index);
        if (!isNaN(index)) {
            // 调用我们刚刚添加的新函数
            await handleChangeAlbumArt(index);
        }
        return; // 处理完后直接退出
    }
    // 点击“词”按钮
    const lyricsBtn = target.closest('.lyrics-btn');
    if (lyricsBtn) {
        const index = parseInt(lyricsBtn.dataset.index);
        if (isNaN(index)) return;

        // 【核心修复】我们现在只调用函数，不再需要处理它的返回值。
        // 因为所有必要的逻辑（包括保存）都已经在函数内部完成了。
        await handleManualLrcImport(index);

        return; // 处理完后直接退出
    }

    // 点击“删除”按钮 (这部分逻辑不变)
    const deleteBtn = target.closest('.delete-track-btn');
    if (deleteBtn) {
        const index = parseInt(deleteBtn.dataset.index);
        if (isNaN(index)) return;
        const track = musicState.playlist[index];
        const confirmed = await showCustomConfirm('删除歌曲', `确定要从播放列表中删除《${track.name}》吗？`);
        if (confirmed) {
            deleteTrack(index);
        }
        return;
    }

    // 点击歌曲信息区域 -> 播放歌曲 (这部分逻辑不变)
    const itemInfo = target.closest('.playlist-item-info');
    if (itemInfo) {
        const item = itemInfo.closest('.playlist-item');
        const index = Array.from(item.parentElement.children).indexOf(item);
        if (index > -1) {
            playSong(index);
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲
        
        document.querySelector('.progress-bar').addEventListener('click', (e) => {
            if (!audioPlayer.duration) return;
            const progressBar = e.currentTarget;
            const barWidth = progressBar.clientWidth;
            const clickX = e.offsetX;
            audioPlayer.currentTime = (clickX / barWidth) * audioPlayer.duration;
        });
        
        // ▼▼▼ 在 init() 函数的事件监听器区域，粘贴这段新代码 ▼▼▼
        
        // 使用事件委托来处理所有“已撤回消息”的点击事件
        document.getElementById('chat-messages').addEventListener('click', (e) => {
            // 检查被点击的元素或其父元素是否是“已撤回”提示
// ▼▼▼ 【这是最终修复版】请用这整块代码，完整替换旧的 .recalled-message-placeholder 点击事件逻辑 ▼▼▼
const placeholder = e.target.closest('.recalled-message-placeholder');
if (placeholder) {
    const chat = state.chats[state.activeChatId];
    const wrapper = placeholder.closest('.message-wrapper');
    if (chat && wrapper) {
        const timestamp = parseInt(wrapper.dataset.timestamp);
        const recalledMsg = chat.history.find(m => m.timestamp === timestamp);

        if (recalledMsg && recalledMsg.recalledData) {
            let originalContentText = '';
            const recalled = recalledMsg.recalledData;

            // --- 核心修复：在这里添加对更多消息类型的判断 ---
            switch (recalled.originalType) {
                case 'text':
                    originalContentText = `原文: "${recalled.originalContent}"`;
                    break;
                case 'user_photo':
                case 'ai_image':
                case 'text_image':
                    originalContentText = `[图片/文字图] 描述: "${recalled.originalContent}"`;
                    break;
                case 'voice_message':
                    originalContentText = `[语音] 内容: "${recalled.originalContent}"`;
                    break;
                case 'sticker':
                    // 对于表情，同时显示含义和图片URL
                    originalContentText = `[表情] 含义: "${recalled.originalMeaning || '(无)'}" \n URL: ${recalled.originalContent}`;
                    break;
                case 'transfer':
                    originalContentText = `一条[转账]消息已被撤回。`;
                    break;
                default:
                    // 对于其他未知类型，显示类型和原始内容
                    originalContentText = `撤回了一条[${recalled.originalType}]类型的消息。\n内容: ${JSON.stringify(recalled.originalContent)}`;
                    break;
            }
            // --- 修复结束 ---

            showCustomAlert('已撤回的消息', originalContentText);
        }
    }
}
});
        
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
        
        // ▼▼▼ 在 init() 的事件监听器区域，粘贴这段新代码 ▼▼▼
        document.getElementById('manage-world-book-categories-btn').addEventListener('click', openCategoryManager);
        document.getElementById('close-category-manager-btn').addEventListener('click', () => {
            document.getElementById('world-book-category-manager-modal').classList.remove('visible');
            renderWorldBookScreen(); // 关闭后刷新主列表
        });
        document.getElementById('add-new-category-btn').addEventListener('click', addNewCategory);
        document.getElementById('existing-categories-list').addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-group-btn')) {
                const categoryId = parseInt(e.target.dataset.id);
                deleteCategory(categoryId);
            }
        });
        // ▼▼▼ 在 init() 的事件监听器区域末尾，添加这部分代码 ▼▼▼
        document.getElementById('repost-cancel-btn').addEventListener('click', hideRepostModal);
        document.getElementById('repost-confirm-btn').addEventListener('click', handleConfirmRepost);
        // ▲▲▲ 添加结束 ▲▲▲

        // 在 init() 的事件监听器区域末尾
        // ...
        // 绑定消息操作菜单中的“引用”按钮
        document.getElementById('quote-message-btn').addEventListener('click', startReplyToMessage);
        
        // 绑定回复预览栏中的“取消”按钮
        document.getElementById('cancel-reply-btn').addEventListener('click', cancelReplyMode);
        // ...
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
        
                // ===================================================================
                // 5. 启动！
        // 在第 9660 行，showScreen('home-screen'); 的前面，粘贴下面的代码
        
            // ▼▼▼ 【请将这段全新的代码粘贴进去】 ▼▼▼
            
            // 使用事件委托，为动态评论区的@功能绑定事件
            document.getElementById('qzone-posts-list').addEventListener('input', (e) => {
                if (!e.target.matches('.comment-input')) return;
        
                const commentInput = e.target;
                const postContainer = commentInput.closest('.qzone-post-container');
                if (!postContainer) return;
                
                const popup = postContainer.querySelector('.at-mention-popup');
                const value = commentInput.value;
                const atMatch = value.match(/@([\p{L}\w]*)$/u);
        
                if (atMatch) {
                    const namesToMention = new Set();
                    const authorNickname = postContainer.querySelector('.post-nickname')?.textContent;
                    if (authorNickname) namesToMention.add(authorNickname);
                    postContainer.querySelectorAll('.commenter-name').forEach(nameEl => {
                        namesToMention.add(nameEl.textContent.replace(':', ''));
                    });
                    namesToMention.delete(state.qzoneSettings.nickname);
        
                    popup.innerHTML = '';
                    if (namesToMention.size > 0) {
                        const searchTerm = atMatch[1];
                        namesToMention.forEach(name => {
                            if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                                const item = document.createElement('div');
                                item.className = 'at-mention-item';
                                item.textContent = name;
                                item.addEventListener('mousedown', (evt) => {
                                    evt.preventDefault();
                                    const newText = value.substring(0, atMatch.index) + `@${name} `;
                                    commentInput.value = newText;
                                    popup.style.display = 'none';
                                    commentInput.focus();
                                });
                                popup.appendChild(item);
                            }
                        });
                        popup.style.display = popup.children.length > 0 ? 'block' : 'none';
                    } else {
                        popup.style.display = 'none';
                    }
                } else {
                    popup.style.display = 'none';
                }
            });
        
            document.getElementById('qzone-posts-list').addEventListener('focusout', (e) => {
                if (e.target.matches('.comment-input')) {
                    const postContainer = e.target.closest('.qzone-post-container');
                    if (postContainer) {
                        const popup = postContainer.querySelector('.at-mention-popup');
                        if (popup) {
                            setTimeout(() => { popup.style.display = 'none'; }, 200);
                        }
                    }
                }
            });
        
            // ▲▲▲ 【新代码粘贴结束】 ▲▲▲  
        // ▼▼▼ 把下面这段新代码完整粘贴到 showScreen('home-screen'); 的前面 ▼▼▼
        
        // 【全新】为【主聊天输入框】添加@功能
        const chatInputForMention = document.getElementById('chat-input');
        const chatMentionPopup = document.getElementById('chat-at-mention-popup');
        
        chatInputForMention.addEventListener('input', () => {
            // 1. 首先，检查当前是否在群聊中
            if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) {
                chatMentionPopup.style.display = 'none';
                return;
            }
            
            const chat = state.chats[state.activeChatId];
            const value = chatInputForMention.value;
            const atMatch = value.match(/@([\p{L}\w]*)$/u);
        
            if (atMatch) {
                // 2. 收集群成员名单 (排除自己)
                const myNickname = chat.settings.myNickname || '我';
                const namesToMention = chat.members
                    .map(member => member.groupNickname)
                    .filter(name => name !== myNickname);
        
                chatMentionPopup.innerHTML = '';
                if (namesToMention.length > 0) {
                    const searchTerm = atMatch[1];
                    // 3. 筛选并生成列表
                    namesToMention.forEach(name => {
                        if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                            const item = document.createElement('div');
                            item.className = 'at-mention-item';
                            item.textContent = name;
                            // 4. 绑定点击事件
                            item.addEventListener('mousedown', (e) => {
                                e.preventDefault();
                                const newText = value.substring(0, atMatch.index) + `@${name} `;
                                chatInputForMention.value = newText;
                                chatMentionPopup.style.display = 'none';
                                chatInputForMention.focus();
                            });
                            chatMentionPopup.appendChild(item);
                        }
                    });
                    // 5. 显示或隐藏弹窗
                    chatMentionPopup.style.display = chatMentionPopup.children.length > 0 ? 'block' : 'none';
                } else {
                    chatMentionPopup.style.display = 'none';
                }
            } else {
                chatMentionPopup.style.display = 'none';
            }
        });
        
        // 当输入框失去焦点时，隐藏弹窗
        chatInputForMention.addEventListener('blur', () => {
            setTimeout(() => { chatMentionPopup.style.display = 'none'; }, 200);
        });
        // ▲▲▲ 新代码粘贴到这里结束 ▲▲▲     
        // ▼▼▼ 【全新】新版群公告事件绑定 ▼▼▼
        document.getElementById('publish-to-announcement-btn').addEventListener('click', publishToAnnouncementBoard);
        document.getElementById('show-announcement-board-btn').addEventListener('click', showAnnouncementBoard);
        document.getElementById('close-announcement-board-btn').addEventListener('click', () => {
            document.getElementById('announcement-board-modal').classList.remove('visible');
        });
        // ▲▲▲ 新增结束 ▲▲▲  
        // ▼▼▼ 【全新】公告板内部事件委托与操作菜单事件绑定 ▼▼▼
        document.getElementById('announcement-board-content').addEventListener('click', (e) => {
            if (e.target.classList.contains('announcement-item-actions')) {
                const annoId = e.target.dataset.annoId;
                if (annoId) {
                    showAnnouncementActions(annoId);
                }
            }
        });
        
        document.getElementById('announcement-action-pin').addEventListener('click', handlePinAnnouncement);
        document.getElementById('announcement-action-delete').addEventListener('click', handleDeleteAnnouncement);
        document.getElementById('announcement-action-cancel').addEventListener('click', () => {
            document.getElementById('announcement-actions-modal').classList.remove('visible');
        });
        // ▲▲▲ 新增结束 ▲▲▲   
                    // ▼▼▼ 把新代码完整粘贴在这里 ▼▼▼
                    document.getElementById('reset-global-css-btn').addEventListener('click', () => {
                        document.getElementById('global-css-input').value = '';
                        // (可选) 如果希望点击重置后立刻看到效果，可以加上下面这行
                        // applyGlobalCss('');
                    });
        // ▼▼▼ 【最终修复版】请用这个全新的事件监听器，替换旧的长期记忆功能事件绑定 ▼▼▼
        // 聊天界面顶部新按钮 -> 打开全屏页面
        document.getElementById('open-memory-screen-btn').addEventListener('click', openLongTermMemoryScreen);
        
        // 长期记忆页面返回按钮 -> 返回聊天界面
        document.getElementById('memory-screen-back-btn').addEventListener('click', () => {
            showScreen('chat-interface-screen');
        });
        
        // 长期记忆页面顶部“+”按钮 -> 手动添加
        document.getElementById('add-manual-memory-btn-header').addEventListener('click', handleAddManualMemory);
        
        // 长期记忆页面顶部“总结”按钮 -> 手动总结
        document.getElementById('summarize-recent-btn-header').addEventListener('click', handleManualSummary);
        
        // 【【【核心修复就在这里！】】】
document.getElementById('memory-list-container').addEventListener('click', (e) => {
    const editBtn = e.target.closest('.edit-memory-btn');
    if (editBtn) {
        handleEditMemory(editBtn.dataset.authorId, parseInt(editBtn.dataset.memoryTimestamp));
        return;
    }
    const deleteBtn = e.target.closest('.delete-memory-btn');
    if (deleteBtn) {
        handleDeleteMemory(deleteBtn.dataset.authorId, parseInt(deleteBtn.dataset.memoryTimestamp));
        return;
    }
});
        // ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 【全新】五子棋功能事件监听器 ▼▼▼
        document.getElementById('gomoku-btn').addEventListener('click', toggleGomokuBoard);
        document.getElementById('close-gomoku-btn').addEventListener('click', closeGomokuBoard);
        
        const gomokuCanvas = document.getElementById('gomoku-board');
        gomokuCanvas.addEventListener('mousemove', handleBoardHover);
        gomokuCanvas.addEventListener('mouseout', () => renderGomokuBoard(state.activeChatId)); // Clear hover on exit
        gomokuCanvas.addEventListener('click', handleBoardClick);
        // ▲▲▲ 新增代码结束 ▲▲▲
        // ▼▼▼ 【这是修复代码】请将这段代码粘贴到 init() 函数的事件监听器区域末尾 ▼▼▼
        document.getElementById('add-countdown-btn').addEventListener('click', () => {
            // 清空输入框
            document.getElementById('countdown-title-input').value = '';
            document.getElementById('countdown-date-input').value = '';
            // 显示新建约定弹窗
            document.getElementById('create-countdown-modal').classList.add('visible');
        });
        
        // 为新建约定弹窗的“取消”按钮也绑定事件
        document.getElementById('cancel-create-countdown-btn').addEventListener('click', () => {
            document.getElementById('create-countdown-modal').classList.remove('visible');
        });
        // ▲▲▲ 修复代码粘贴结束 ▲▲▲
        
                    // ▼▼▼ 【全新】视频通话消息操作事件绑定 ▼▼▼
        document.getElementById('edit-call-message-btn').addEventListener('click', openCallMessageEditor);
        document.getElementById('delete-call-message-btn').addEventListener('click', deleteCallMessage);
        document.getElementById('cancel-call-message-action-btn').addEventListener('click', hideCallMessageActions);
        // ▲▲▲ 新增结束 ▲▲▲
        // ▼▼▼ 【全新】导演模式事件绑定 ▼▼▼
        document.getElementById('edit-last-response-btn').addEventListener('click', openAiResponseEditor);
        document.getElementById('cancel-ai-response-editor-btn').addEventListener('click', () => {
            document.getElementById('ai-response-editor-modal').classList.remove('visible');
        });
        document.getElementById('save-ai-response-editor-btn').addEventListener('click', saveEditedAiResponse);
        document.getElementById('add-ai-response-block-btn').addEventListener('click', () => {
            // 点击添加按钮时，创建一个空的、带模板的编辑块
            const container = document.getElementById('ai-response-editor-container');
            const newBlock = createAiResponseEditorBlock('{\n  "type": "text",\n  "content": "在这里输入新消息..."\n}');
            container.appendChild(newBlock);
            newBlock.querySelector('textarea').focus();
        });
        // ▲▲▲ 新增事件绑定结束 ▲▲▲
        // ▼▼▼ 【全新】“我的”头像库功能事件绑定 ▼▼▼
        document.getElementById('manage-my-avatar-library-btn').addEventListener('click', openMyAvatarLibraryModal);
        document.getElementById('close-my-avatar-library-btn').addEventListener('click', closeMyAvatarLibraryModal);
        document.getElementById('add-my-avatar-url-btn').addEventListener('click', addAvatarToMyLibraryFromURL);
        document.getElementById('add-my-avatar-upload-btn').addEventListener('click', () => {
            document.getElementById('my-avatar-upload-input').click();
        });
        document.getElementById('my-avatar-upload-input').addEventListener('change', handleLocalMyAvatarUpload);
        document.getElementById('add-my-avatar-batch-btn').addEventListener('click', async () => {
            const placeholderText = `请按照以下格式粘贴，一行一个：\n\n焦虑 2a9wte.jpeg\n大惊失色 or8qf4.png\n没有灵感 njwujh.jpeg`;
            const pastedText = await showCustomPrompt('批量导入头像', placeholderText, '', 'textarea');
            if (pastedText && pastedText.trim()) {
                await handleBatchImportForMyAvatar(pastedText);
            }
        });
        // ▲▲▲ 新增结束 ▲▲▲
        // ▼▼▼ 【全新】购物功能事件绑定 (V6.0 - 支持指定收礼人) ▼▼▼
        document.getElementById('open-shopping-btn').addEventListener('click', openShoppingScreen);
        document.getElementById('shopping-back-btn').addEventListener('click', () => showScreen('chat-interface-screen'));
        document.getElementById('go-to-cart-btn').addEventListener('click', openCartScreen);
        document.getElementById('cart-back-btn').addEventListener('click', openShoppingScreen);
        document.getElementById('checkout-btn').addEventListener('click', handleCheckout);
        document.getElementById('close-receipt-btn').addEventListener('click', () => {
            document.getElementById('gift-receipt-modal').classList.remove('visible');
        });
        
        // "管理"按钮
        document.getElementById('manage-products-btn').addEventListener('click', () => {
            isProductManagementMode = !isProductManagementMode;
            const btn = document.getElementById('manage-products-btn');
            btn.style.color = isProductManagementMode ? 'var(--accent-color)' : 'var(--text-primary)';
            if (!isProductManagementMode && document.querySelectorAll('#product-grid .product-item').length === 0) {
                openProductEditor(null);
            }
            renderShoppingProducts();
        });
        
        // “添加商品”按钮
        document.getElementById('add-new-product-btn').addEventListener('click', () => {
            if (isProductManagementMode) {
                openProductEditor(null);
            } else {
                alert("请先点击扳手图标进入管理模式，才能添加新商品。");
            }
        });
        
        // 商品列表事件委托
        document.getElementById('product-grid').addEventListener('click', async e => {
            const productItem = e.target.closest('.product-item');
            if (!productItem) return;
            const productId = parseInt(productItem.dataset.id);
        
            if (e.target.classList.contains('edit-product-btn')) {
                openProductEditor(productId);
            } else if (e.target.classList.contains('delete-product-btn')) {
                deleteProduct(productId);
            } else if (e.target.classList.contains('add-to-cart-btn')) {
                await addToCart(productId);
                await showCustomAlert('成功', '已成功加入购物车！');
            }
        });
        
        // 购物车列表事件委托
        document.getElementById('cart-items-list').addEventListener('click', e => {
            const target = e.target;
            if (target.classList.contains('decrease-qty-btn')) {
                updateCartItemQuantity(parseInt(target.dataset.id), -1);
            }
            if (target.classList.contains('increase-qty-btn')) {
                updateCartItemQuantity(parseInt(target.dataset.id), 1);
            }
            if (target.classList.contains('cart-item-checkbox')) {
                updateCartTotal();
            }
        });
        
        // 购物车清空按钮
        document.getElementById('clear-cart-btn').addEventListener('click', async () => {
            if (shoppingCart.length === 0) return;
            const confirmed = await showCustomConfirm('清空购物车', '确定要清空购物车中的所有商品吗？');
            if (confirmed) {
                shoppingCart = [];
                updateCartCount();
                renderCartItems();
            }
        });
        
        // 购物车全选
        document.getElementById('select-all-cart-items').addEventListener('change', function(e) {
            document.querySelectorAll('.cart-item-checkbox').forEach(cb => {
                cb.checked = e.target.checked;
            });
            updateCartTotal();
        });
        
        // 商品编辑器弹窗按钮
        document.getElementById('cancel-product-editor-btn').addEventListener('click', () => {
            document.getElementById('product-editor-modal').classList.remove('visible');
        });
        document.getElementById('save-product-btn').addEventListener('click', saveProduct);
        document.getElementById('product-image-input').addEventListener('change', e => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (re) => { document.getElementById('product-image-preview').src = re.target.result; };
                reader.readAsDataURL(file);
            }
        });
        
        // 聊天界面礼物卡片点击事件
        document.getElementById('chat-messages').addEventListener('click', e => {
            const giftCard = e.target.closest('.gift-card');
            if (giftCard) {
                const bubble = giftCard.closest('.message-bubble');
                if (bubble) {
                    showGiftReceipt(parseInt(bubble.dataset.timestamp));
                }
            }
        });
        
        // 【全新】礼物接收人选择弹窗的事件绑定
        document.getElementById('cancel-gift-recipient-btn').addEventListener('click', () => {
            document.getElementById('gift-recipient-modal').classList.remove('visible');
        });
        
        // ▼▼▼ 请用这个【已修复】的新事件监听器替换旧的 'confirm-gift-recipient-btn' 监听器 ▼▼▼
        document.getElementById('confirm-gift-recipient-btn').addEventListener('click', async () => {
            // 步骤 1: (保持不变) 获取选中的收礼人
            const selectedRecipients = Array.from(document.querySelectorAll('#gift-recipient-list .contact-picker-item.selected'))
                .map(item => item.dataset.recipientName);
            
            if (selectedRecipients.length === 0) {
                alert("请至少选择一位收礼人。");
                return;
            }
            
            // 步骤 2: 【【【核心修复】】】 在这里，重新从购物车获取一次选中的商品
            const selectedItems = shoppingCart.filter(item => 
                document.querySelector(`.cart-item-checkbox[data-id="${item.productId}"]:checked`)
            );
            
            // 步骤 3: (保持不变) 调用发送函数，此时两个参数都是正确的
            await sendGiftMessage(selectedItems, selectedRecipients);
            
            // 步骤 4: (保持不变) 关闭弹窗
            document.getElementById('gift-recipient-modal').classList.remove('visible');
        });
        // ▲▲▲ 替换结束 ▲▲▲
        
        document.getElementById('gift-recipient-list').addEventListener('click', (e) => {
            const item = e.target.closest('.contact-picker-item');
            if (item) {
                item.classList.toggle('selected');
            }
        });
        
        document.getElementById('select-all-recipients').addEventListener('change', function(e) {
            const isChecked = e.target.checked;
            document.querySelectorAll('#gift-recipient-list .contact-picker-item').forEach(item => {
                item.classList.toggle('selected', isChecked);
            });
        });
        // ▲▲▲ 新增事件绑定结束 ▲▲▲
        // ▼▼▼ 【全新】为重新生成按钮绑定事件 ▼▼▼
        document.getElementById('regenerate-btn').addEventListener('click', handleRegenerateResponse);
        document.getElementById('regenerate-call-btn').addEventListener('click', handleRegenerateCallResponse);
        // ▲▲▲ 新增事件绑定结束 ▲▲▲  
        // ▼▼▼ 【全新】为推进剧情按钮绑定事件 ▼▼▼
        document.getElementById('propel-btn').addEventListener('click', handlePropelAction);
        // 下面这行代码已被安全地注释掉，因为它对应的HTML按钮不存在
        // document.getElementById('propel-call-btn').addEventListener('click', handlePropelCallAction);
        // ▲▲▲ 新增事件绑定结束 ▲▲▲
// 在 init() 函数的事件监听器区域...

// 【全新】消息提示音设置事件
document.getElementById('test-sound-btn').addEventListener('click', () => {
    const player = document.getElementById('notification-sound-player');
    const url = document.getElementById('notification-sound-url-input').value.trim() || DEFAULT_NOTIFICATION_SOUND;
    player.src = url;
    player.play().catch(e => alert('播放失败，请检查URL是否正确或浏览器是否支持该格式。'));
});

document.getElementById('reset-sound-btn').addEventListener('click', () => {
    document.getElementById('notification-sound-url-input').value = '';
    alert('已重置为默认提示音，点击“保存所有外观设置”后生效。');
});
    // ▼▼▼ 【全新】为小组件编辑功能添加事件监听器 (使用事件委托) ▼▼▼
    document.getElementById('home-screen').addEventListener('click', (e) => {
        const target = e.target;
        // 检查点击的是否是可编辑的文字
        if (target.classList.contains('editable-text')) {
            handleEditText(target);
        }
        // 检查点击的是否是可编辑的图片
        if (target.classList.contains('editable-image')) {
            handleEditImage(target);
        }
    });
    // ▲▲▲ 新增事件监听器结束 ▲▲▲  
document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);    
// ▼▼▼ 【全新】为BGM搜索结果弹窗添加事件监听 ▼▼▼
document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
    document.getElementById('music-search-results-modal').classList.remove('visible');
});

// ▼▼▼ 【全新】BGM搜索结果弹窗事件绑定 (多选版) ▼▼▼
document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);

document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
    document.getElementById('music-search-results-modal').classList.remove('visible');
});

// "全选" 功能
document.getElementById('select-all-music-search').addEventListener('change', function(e) {
    document.querySelectorAll('#search-results-list .music-search-checkbox').forEach(cb => {
        cb.checked = e.target.checked;
    });
});

// 点击列表项切换选中状态
document.getElementById('search-results-list').addEventListener('click', (e) => {
    const item = e.target.closest('.search-result-item');
    if (item) {
        const checkbox = item.querySelector('.music-search-checkbox');
        if (checkbox) {
            // 如果点击的不是复选框本身，就手动切换它的状态
            if (e.target !== checkbox) {
                checkbox.checked = !checkbox.checked;
            }
        }
    }
});

// "添加选中" 按钮功能
document.getElementById('add-selected-music-btn').addEventListener('click', async () => {
    const selectedItems = document.querySelectorAll('.music-search-checkbox:checked');
    if (selectedItems.length === 0) {
        alert("请先选择要添加的歌曲。");
        return;
    }

    document.getElementById('music-search-results-modal').classList.remove('visible');
    await showCustomAlert("请稍候...", `正在批量添加 ${selectedItems.length} 首歌曲...`);

    const songDataList = Array.from(selectedItems).map(cb => JSON.parse(cb.closest('.search-result-item').dataset.songJson));
    
    let successCount = 0;
    let failedNames = [];

    // 使用 Promise.all 并行处理所有歌曲的详情获取
    const songDetailPromises = songDataList.map(songData => getPlayableSongDetails(songData));
    const fullSongObjects = await Promise.all(songDetailPromises);

    fullSongObjects.forEach((songObject, index) => {
        if (songObject) {
            musicState.playlist.push(songObject);
            successCount++;
        } else {
            failedNames.push(songDataList[index].name);
        }
    });

    if (successCount > 0) {
        await saveGlobalPlaylist();
        updatePlaylistUI();
        if (musicState.currentIndex === -1) {
            musicState.currentIndex = musicState.playlist.length - successCount;
            updatePlayerUI();
        }
    }

    let resultMessage = `添加完成！\n\n成功添加 ${successCount} 首歌曲。`;
    if (failedNames.length > 0) {
        resultMessage += `\n\n${failedNames.length} 首歌曲获取失败:\n- ${failedNames.join('\n- ')}`;
    }
    await showCustomAlert("操作结果", resultMessage);
});
// ▲▲▲ 新增事件绑定结束 ▲▲▲
// ▲▲▲ 新增事件绑定结束 ▲▲▲
// ▼▼▼ 【全新】为唱片/歌词容器绑定切换事件 ▼▼▼
document.getElementById('music-visual-container').addEventListener('click', () => {
    document.getElementById('music-visual-container').classList.toggle('lyrics-active');
});
// ▲▲▲ 新增事件结束 ▲▲▲

// ▼▼▼ 【全新】BGM搜索结果弹窗事件绑定 ▼▼▼
document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);
document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
    document.getElementById('music-search-results-modal').classList.remove('visible');
});

document.getElementById('search-results-list').addEventListener('click', (e) => {
    const item = e.target.closest('.search-result-item');
    if (item && item.dataset.songJson) {
        const songData = JSON.parse(item.dataset.songJson);
        handleSearchResultClick(songData);
    }
});
// ▲▲▲ 新增事件绑定结束 ▲▲▲

// ▼▼▼ 【全新】清理无效歌曲事件绑定 ▼▼▼
document.getElementById('cleanup-songs-btn').addEventListener('click', cleanupInvalidSongs);
document.getElementById('toggle-blur-btn').addEventListener('click', toggleBackgroundBlur);
 document.getElementById('toggle-fullscreen-btn').addEventListener('click', togglePlayerFullscreen);
document.getElementById('show-avatars-btn').addEventListener('click', toggleMusicPlayerAvatars);
// ▲▲▲ 新增事件绑定结束 ▲▲▲
// ▼▼▼ 【全新】为状态栏开关添加实时预览事件 ▼▼▼
document.getElementById('status-bar-toggle-switch').addEventListener('change', () => {
    // 每次点击开关时，也调用这个函数来实时切换 class
    state.globalSettings.showStatusBar = document.getElementById('status-bar-toggle-switch').checked;
    applyStatusBarVisibility();
});
// ▲▲▲ 新增事件结束 ▲▲▲
// 为“三点”按钮绑定新的入口函数
document.getElementById('qzone-more-actions-btn').addEventListener('click', openClearPostsSelectorModal);

// 为新模态框的按钮绑定事件
document.getElementById('cancel-clear-posts-btn').addEventListener('click', () => {
    document.getElementById('clear-posts-modal').classList.remove('visible');
});
document.getElementById('confirm-clear-posts-btn').addEventListener('click', handleConfirmClearPosts);

// 使用事件委托，为列表项添加勾选/取消勾选的点击逻辑
document.getElementById('clear-posts-list').addEventListener('click', (e) => {
    const item = e.target.closest('.clear-posts-item');
    if (item) {
        item.classList.toggle('selected');
    }
});
// ▼▼▼ 【全新】全局聊天背景事件绑定 ▼▼▼
document.getElementById('global-bg-input').addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (file) {
        const dataUrl = await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.readAsDataURL(file);
        });
        // 将上传的图片临时保存在 state 中，等待用户点击“保存”
        state.globalSettings.globalChatBackground = dataUrl;
        // 实时更新外观设置页面的预览
        renderWallpaperScreen();
    }
    event.target.value = null; // 清空以便下次选择
});

document.getElementById('remove-global-bg-btn').addEventListener('click', () => {
    // 移除背景并更新预览
    state.globalSettings.globalChatBackground = '';
    renderWallpaperScreen();
});

// ▼▼▼ 【重要】更新“保存所有外观设置”按钮的逻辑 ▼▼▼
document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {
    // 保存个人主页壁纸
    if (newWallpaperBase64) {
        state.globalSettings.wallpaper = newWallpaperBase64;
    }
    // 【核心修改】全局聊天背景已经在上传或移除时更新到 state 中了，
    // 所以这里我们只需要将包含所有最新设置的 globalSettings 对象完整地保存一次即可。
    
    state.globalSettings.globalCss = document.getElementById('global-css-input').value.trim();
    state.globalSettings.notificationSoundUrl = document.getElementById('notification-sound-url-input').value.trim();
    state.globalSettings.showStatusBar = document.getElementById('status-bar-toggle-switch').checked;
    
    // 一次性保存所有全局设置
    await db.globalSettings.put(state.globalSettings);
    
    // 应用所有更改
    applyGlobalWallpaper();
    newWallpaperBase64 = null;
    applyAppIcons();
    applyGlobalCss(state.globalSettings.globalCss);
    applyStatusBarVisibility();

    alert('外观设置已保存并应用！');
    showScreen('home-screen');
});
// ▲▲▲ 新增代码结束 ▲▲▲
        // ▼▼▼ 【全新】全局CSS预设功能事件监听器 ▼▼▼
        document.getElementById('css-preset-select').addEventListener('change', handleCssPresetSelectionChange);
        document.getElementById('save-css-preset-btn').addEventListener('click', saveCssPreset);
        document.getElementById('delete-css-preset-btn').addEventListener('click', deleteCssPreset);
        // ▲▲▲ 新增结束 ▲▲▲
        // ▼▼▼ 【全新】字体预设功能事件监听器 ▼▼▼
        document.getElementById('font-preset-select').addEventListener('change', handleFontPresetSelectionChange);
        document.getElementById('save-font-preset-btn').addEventListener('click', saveFontPreset);
        document.getElementById('delete-font-preset-btn').addEventListener('click', deleteFontPreset);
        // ▲▲▲ 新增结束 ▲▲▲
        // ▼▼▼ 【全新】气泡主题预设功能事件监听器 ▼▼▼
        document.getElementById('theme-preset-select').addEventListener('change', handleThemePresetSelectionChange);
        document.getElementById('save-theme-preset-btn').addEventListener('click', saveThemePreset);
        document.getElementById('delete-theme-preset-btn').addEventListener('click', deleteThemePreset);
        // ▲▲▲ 新增结束 ▲▲▲
        // ▼▼▼ 【全新】这是表情分类功能的【全部事件监听器】，请粘贴到 init() 函数中 ▼▼▼
        
        // 1. 绑定表情面板顶部的“分类”按钮，用于打开管理弹窗
        document.getElementById('manage-sticker-categories-btn').addEventListener('click', openStickerCategoryManager);

        // 2. 绑定分类管理弹窗的“完成”按钮
        document.getElementById('close-sticker-category-manager-btn').addEventListener('click', () => {
            document.getElementById('sticker-category-manager-modal').classList.remove('visible');
            renderStickerPanel(); // 关闭后刷新主面板的页签
        });

        // 3. 绑定“添加新分类”按钮
        document.getElementById('add-new-sticker-category-btn').addEventListener('click', addNewStickerCategory);

        // 4. 使用事件委托处理分类的删除
        document.getElementById('existing-sticker-categories-list').addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-group-btn')) {
                const categoryId = parseInt(e.target.dataset.id);
                deleteStickerCategory(categoryId);
            }
        });
        
        // 5. 使用事件委托处理表情面板的页签切换
        document.getElementById('sticker-category-tabs').addEventListener('click', (e) => {
            if (e.target.classList.contains('sticker-category-tab')) {
                const categoryId = e.target.dataset.categoryId;
                // 将字符串ID转换为数字，除非是 'all' 或 'uncategorized'
                const finalId = (categoryId !== 'all' && categoryId !== 'uncategorized') ? parseInt(categoryId) : categoryId;
                switchStickerCategory(finalId);
            }
        });

        // ▲▲▲ 新增事件绑定结束 ▲▲▲
        document.getElementById('select-all-stickers-checkbox').addEventListener('change', handleSelectAllStickers);
// ▼▼▼ 【全新】单个聊天导入导出事件绑定 ▼▼▼
document.getElementById('export-single-chat-btn').addEventListener('click', exportSingleChat);

document.getElementById('import-single-chat-btn').addEventListener('click', () => {
    document.getElementById('import-single-chat-input').click();
});

document.getElementById('import-single-chat-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        importSingleChat(file);
    }
    e.target.value = null; // 清空以便下次能选择同一个文件
});
// ▲▲▲ 新增代码结束 ▲▲▲
// ▼▼▼ 【全新】Cphone功能事件绑定 ▼▼▼
document.getElementById('add-char-memo-btn').addEventListener('click', () => openMemoEditor());
document.getElementById('add-char-diary-btn').addEventListener('click', () => openDiaryEditor());
document.getElementById('favorite-diary-btn').addEventListener('click', toggleDiaryFavorite);
// ▲▲▲ 新增事件绑定结束 ▲▲▲
        // “重新生成”按钮
// 新代码 (解决方案)
document.getElementById('regenerate-char-qq-btn').addEventListener('click', async () => {
    // 为了更好的用户体验，先弹出一个提示
    showCustomAlert("正在执行...", "正在生成新的模拟聊天记录，并同时让角色思考如何与你继续对话...");

    try {
        // 使用 Promise.all 可以让两个独立的API请求并发执行，效率更高
        await Promise.all([
            handleGenerateSimulatedQQ(),
            handleContinueRealConversationFromCPhone()
        ]);

        console.log("CPhone QQ模拟记录生成 和 主聊天推进 已同时完成。");

    } catch (error) {
        console.error("在同时执行两个函数时出错:", error);
        await showCustomAlert("操作失败", `在执行组合操作时遇到错误: ${error.message}`);
    }
});

        // 使用事件委托，处理模拟聊天【列表】的点击事件
        document.getElementById('char-chat-list').addEventListener('click', (e) => {
            const item = e.target.closest('.chat-list-item');
            if (item && item.dataset.conversationIndex) {
                const index = parseInt(item.dataset.conversationIndex);
                if (!isNaN(index)) {
                    // 【核心修改】现在调用新函数，打开全屏页面
                    openCharSimulatedConversation(index);
                }
            }
        });



        document.getElementById('back-to-char-qq-list-btn').addEventListener('click', () => {
            switchToCharScreen('char-qq-screen');
        });
// ▼▼▼ 【最终修复版】这是为CPhone镜像聊天窗口恢复“向上滚动加载”功能的代码 ▼▼▼

        // 1. 获取聊天记录的容器元素
        const charConversationMessages = document.getElementById('char-conversation-messages');

        // 2. 定义滚动事件的处理函数
        const cphoneScrollHandler = () => {
            // 3. 核心判断：只有当打开的对话是与用户的私聊时，才执行加载逻辑
            if (cphoneActiveConversationType !== 'private_user') {
                return; // 如果是NPC或群聊，则不执行任何操作
            }
            
            // 4. 检查是否滚动到顶部，并且当前没有正在加载
            if (charConversationMessages.scrollTop < 1 && !isLoadingMoreCphoneMessages) {
                const totalMessages = state.chats[activeCharacterId]?.history.length || 0;
                // 检查是否还有更多历史记录可供加载
                if (totalMessages > cphoneRenderedCount) {
                    // 调用加载函数
                    loadMoreMirroredMessages();
                }
            }
        };

        // 5. 将这个处理函数绑定到滚动事件上
        charConversationMessages.addEventListener('scroll', cphoneScrollHandler);

        // ▲▲▲ 修复代码粘贴结束 ▲▲▲
        // 【新增】为模拟对话页面的“发送”按钮绑定提示事件
        document.getElementById('char-simulated-send-btn').addEventListener('click', () => {
            alert("这是模拟对话，无法发送消息哦~");
        });

        // ▲▲▲ 新增事件绑定结束 ▲▲▲
        // 1. 为“重新生成”按钮绑定我们刚刚创建的核心函数
        document.getElementById('regenerate-char-album-btn').addEventListener('click', handleGenerateSimulatedAlbum);

        // 2. 使用事件委托，为整个相册网格添加点击事件
        document.getElementById('char-album-grid').addEventListener('click', (e) => {
            // 检查被点击的是否是一张照片
            const photoItem = e.target.closest('.char-photo-item');
            
            // 如果是，并且它身上存有我们之前放进去的“照片详情”
            if (photoItem && photoItem.dataset.description) {
                const description = photoItem.dataset.description;
                
                // 就用一个漂亮的弹窗把详情显示出来
                showCustomAlert("照片详情", description.replace(/\n/g, '<br>'));
            }
        });
        document.getElementById('regenerate-char-browser-btn').addEventListener('click', handleGenerateBrowserHistory);
        // 1. 将“重新生成”按钮与AI生成函数绑定
        document.getElementById('regenerate-char-taobao-btn').addEventListener('click', handleGenerateTaobaoHistory);
       
        
        // 3. 使用事件委托，为购买记录列表添加点击事件，用于显示“购买理由”
        document.getElementById('char-product-grid').addEventListener('click', (e) => {
            const item = e.target.closest('.char-product-item');
            if (item && item.dataset.reason) {
                const reason = item.dataset.reason;
                showCustomAlert("TA的想法...", reason.replace(/\n/g, '<br>'));
            }
        });
        
        // 4. 【核心】将 openCharWallet 函数暴露到全局，以便 onclick 可以调用
        window.openCharWallet = openCharWallet;
document.getElementById('regenerate-char-memo-btn').addEventListener('click', handleGenerateSimulatedMemos);
document.getElementById('char-memo-detail-back-btn').addEventListener('click', () => switchToCharScreen('char-memo-screen'));
// 在 init() 的事件监听器区域添加
document.getElementById('regenerate-char-diary-btn').addEventListener('click', handleGenerateSimulatedDiaries);
document.getElementById('add-char-diary-btn').addEventListener('click', handleWriteNewDiaryEntry);
document.getElementById('char-diary-detail-back-btn').addEventListener('click', () => switchToCharScreen('char-diary-screen'));
document.getElementById('regenerate-char-amap-btn').addEventListener('click', handleGenerateAmapHistory);
document.getElementById('regenerate-char-usage-btn').addEventListener('click', handleGenerateAppUsage);
        document.getElementById('regenerate-char-music-btn').addEventListener('click', handleGenerateSimulatedMusic);
        document.getElementById('close-char-music-player-btn').addEventListener('click', closeCharMusicPlayer);
document.getElementById('regenerate-douban-btn').addEventListener('click', handleGenerateDoubanPosts);
document.getElementById('regenerate-douban-btn').addEventListener('click', handleGenerateDoubanPosts);
document.getElementById('douban-detail-back-btn').addEventListener('click', () => showScreen('douban-screen'));
document.getElementById('douban-send-comment-btn').addEventListener('click', handleSendDoubanComment);
document.getElementById('douban-wait-reply-btn').addEventListener('click', handleDoubanWaitReply);
        // 1. 为CPhone的壁纸上传输入框绑定事件
        document.getElementById('cphone-wallpaper-upload-input').addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                const dataUrl = await new Promise((res) => {
                    const reader = new FileReader();
                    reader.onload = () => res(reader.result);
                    reader.readAsDataURL(file);
                });
                // 直接更新 state 中的值，等待用户点击“保存”
                state.globalSettings.cphoneWallpaper = dataUrl;
                // 实时刷新预览
                renderWallpaperScreen();
            }
        });
        
        // 2. 为CPhone的图标设置网格绑定事件委托
// 为 CPhone 图标设置网格绑定事件委托
document.getElementById('cphone-icon-settings-grid').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-icon-btn')) {
        const item = e.target.closest('.icon-setting-item');
        const iconId = item.dataset.iconId;
        if (iconId) {
            handleIconChange(iconId, 'cphone', item);
        }
    }
});
document.getElementById('import-appearance-btn').addEventListener('click', () => {
    document.getElementById('import-appearance-input').click();
});

document.getElementById('import-appearance-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        importAppearanceSettings(file);
    }
    e.target.value = null; 
});

// ▼▼▼ 【全新】这是记录应用关闭时间的核心代码，请粘贴进去 ▼▼▼
/**
 * 监听浏览器的可见性变化事件。
 * 当用户将PWA切换到后台或关闭浏览器标签页时，这个事件会被触发。
 */
document.addEventListener('visibilitychange', () => {
    // 如果页面变得不可见 (用户切换走了)
    if (document.visibilityState === 'hidden') {
        // 我们就在 localStorage 中存下当前的时间戳
        localStorage.setItem('ephoneLastActiveTimestamp', Date.now());
        console.log("应用已切换到后台，记录当前时间。");
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲
        document.getElementById('export-world-book-btn').addEventListener('click', exportWorldBooks);
        document.getElementById('import-world-book-btn').addEventListener('click', () => {
            document.getElementById('import-world-book-input').click();
        });
document.getElementById('import-world-book-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleWorldBookImport(file); // 【核心修改】现在调用新的智能处理器
            }
            e.target.value = null;
        });
        document.getElementById('enable-ai-drawing-switch').addEventListener('change', async (e) => {
            const isEnabled = e.target.checked;
            state.globalSettings.enableAiDrawing = isEnabled;
            await db.globalSettings.put(state.globalSettings);

            // 检查当前在哪个屏幕，并刷新它
            const activeScreen = document.querySelector('.screen.active');
            if (activeScreen) {
                switch (activeScreen.id) {
                    case 'chat-interface-screen':
                        renderChatInterface(state.activeChatId);
                        break;
                    case 'chat-list-screen':
                        // 刷新动态页
                        if(document.getElementById('qzone-screen').classList.contains('active')) renderQzonePosts();
                        // 刷新收藏页
                        if(document.getElementById('favorites-view').classList.contains('active')) renderFavoritesScreen();
                        break;
                    case 'douban-screen':
                        renderDoubanScreen();
                        break;
                    case 'douban-post-detail-screen':
                        openDoubanPostDetail(activeDoubanPostId);
                        break;
                    // Cphone内部的刷新
                    case 'character-phone-screen':
                        const activeCharScreen = document.querySelector('.char-screen.active');
                        if (activeCharScreen) {
                            switch(activeCharScreen.id) {
                                case 'char-album-screen': renderCharAlbum(); break;
                                case 'char-taobao-screen': renderCharTaobao(); break;
                                case 'char-browser-article-screen': 
                                    const char = state.chats[activeCharacterId];
                                    const history = char.simulatedBrowserHistory || [];
                                    const lastArticleIndex = history.length > 0 ? history.length - 1 : 0; // 简单示例，实际可能需要更精确的索引
                                    renderCharArticle(history[lastArticleIndex]);
                                    break;
                                case 'char-usage-screen': renderCharAppUsage(); break;
                                case 'char-qq-screen': renderCharSimulatedQQ(); break;
                                case 'char-qq-conversation-screen': 
                                    const convoIndex = document.querySelector('#char-chat-list .chat-list-item')?.dataset.conversationIndex || 0;
                                    openCharSimulatedConversation(parseInt(convoIndex));
                                    break;
                            }
                        }
                        break;
                }
            }
            showCustomAlert('设置已应用', `AI生图功能已${isEnabled ? '开启' : '关闭'}。`);
        });
// ▼▼▼ 【全新】聊天记录搜索功能事件绑定 ▼▼▼
document.getElementById('search-history-btn').addEventListener('click', openSearchHistoryScreen);
document.getElementById('search-history-back-btn').addEventListener('click', () => {
    showScreen('chat-settings-screen');
});
document.getElementById('execute-search-btn').addEventListener('click', handleSearchHistory);
document.getElementById('clear-search-btn').addEventListener('click', clearSearchFilters);
// ▲▲▲ 新增事件绑定结束 ▲▲▲
// ▼▼▼ 【全新】自定义头像框功能事件绑定 ▼▼▼

// 绑定弹窗头部的“上传”和“批量”按钮
document.getElementById('upload-custom-frame-btn').addEventListener('click', handleUploadFrame);
document.getElementById('batch-import-frames-btn').addEventListener('click', handleBatchUploadFrames);

// 使用事件委托，为整个弹窗内容区绑定点击事件，专门用于处理删除按钮
document.querySelector('#avatar-frame-modal .modal-body').addEventListener('click', (e) => {
    // 检查被点击的是否是删除按钮
    if (e.target.classList.contains('delete-btn')) {
        const frameId = parseInt(e.target.dataset.id);
        if (!isNaN(frameId)) {
            handleDeleteCustomFrame(frameId);
        }
    }
});

// ▲▲▲ 新增事件绑定结束 ▲▲▲
        // ▼▼▼ 【全新】这是主屏幕分页和“预设”App的【全部事件监听器】，请完整粘贴 ▼▼▼

        // 1. 初始化主屏幕分页功能
        setupHomeScreenPagination();

        // 2. 将“预设”App的全局调用函数暴露给 window，以便 onclick 可以找到它
        window.openPresetScreen = openPresetScreen;

        // 3. 绑定“预设”App内部的所有按钮事件
        document.getElementById('add-preset-btn').addEventListener('click', async () => {
            const name = await showCustomPrompt('创建新预设', '请输入预设名称');
            if (name && name.trim()) {
                const newPreset = { id: 'preset_' + Date.now(), name: name.trim(), content: [] };
                await db.presets.add(newPreset);
                await renderPresetScreen();
                openPresetEditor(newPreset.id);
            }
        });

        document.getElementById('manage-preset-categories-btn').addEventListener('click', openPresetCategoryManager);
        
        document.getElementById('add-preset-entry-btn').addEventListener('click', () => {
            const container = document.getElementById('preset-entries-container');
            if (container.querySelector('p')) {
                container.innerHTML = '';
            }
            const newBlock = createPresetEntryBlock();
            container.appendChild(newBlock);
            newBlock.querySelector('.entry-content-textarea').focus();
        });

// ▼▼▼ 【全新 | iOS 兼容版】请用这个新版本替换旧的 save-preset-btn 事件监听器 ▼▼▼
document.getElementById('save-preset-btn').addEventListener('click', async () => {
    if (!editingPresetId) return;
    const preset = await db.presets.get(editingPresetId);
    if (!preset) return;

    // (这部分保存数据的逻辑保持不变)
    const newName = document.getElementById('preset-name-input').value.trim();
    if (!newName) { alert('预设名称不能为空！'); return; }
    preset.name = newName;
    preset.categoryId = parseInt(document.getElementById('preset-category-select').value) || null;

    const entriesContainer = document.getElementById('preset-entries-container');
    const entryBlocks = entriesContainer.querySelectorAll('.message-editor-block');
    const newEntries = [];
    entryBlocks.forEach(block => {
        const content = block.querySelector('.entry-content-textarea').value.trim();
        if (content) {
            newEntries.push({
                comment: block.querySelector('.entry-comment-input').value.trim(),
                keys: (block.querySelector('.entry-keys-input').value.trim() || '').split(',').map(k => k.trim()).filter(Boolean),
                content: content,
                enabled: block.querySelector('.entry-enabled-switch').checked
            });
        }
    });
    preset.content = newEntries;

    // 1. 先将所有数据保存到数据库
    await db.presets.put(preset);
    editingPresetId = null;

    // 2. 【核心修复】先切换到目标屏幕
    showScreen('preset-screen');
    
    // 3. 【核心修复】然后再异步地、从容地渲染那个屏幕上的内容
    // 这就给了浏览器足够的时间来处理屏幕切换动画，避免了崩溃
    await renderPresetScreen();
});
// ▲▲▲ 替换结束 ▲▲▲

        // ▲▲▲ 新增事件绑定结束 ▲▲▲
        // ▼▼▼ 【全新】为“预设”App的导入功能绑定事件 ▼▼▼
        document.getElementById('import-preset-btn').addEventListener('click', () => {
            document.getElementById('import-preset-input').click();
        });

        document.getElementById('import-preset-input').addEventListener('change', handlePresetImport);
        // ▲▲▲ 新增事件绑定结束 ▲▲▲
document.getElementById('reset-button-order-btn').addEventListener('click', resetButtonOrder);
// ▼▼▼ 【全新V2.0 | 已修复】高级数据清理功能事件绑定 ▼▼▼
document.getElementById('clear-specific-data-btn').addEventListener('click', openDataClearWizard);

// 向导第一步的按钮
document.getElementById('cancel-clear-wizard-btn-step1').addEventListener('click', () => {
    document.getElementById('data-clear-wizard-modal').classList.remove('visible');
});
document.getElementById('go-to-clear-step2-btn').addEventListener('click', handleDataClearNext);

// 向导第二步的按钮
document.getElementById('back-to-clear-step1-btn').addEventListener('click', handleDataClearBack);
document.getElementById('cancel-clear-wizard-btn-step2').addEventListener('click', () => {
    document.getElementById('data-clear-wizard-modal').classList.remove('visible');
});
document.getElementById('confirm-final-clear-btn').addEventListener('click', handleConfirmDataClear);

// 【核心新增】使用事件委托处理两个列表的勾选/取消勾选 和 全选
document.getElementById('data-clear-wizard-modal').addEventListener('click', (e) => {
    const item = e.target.closest('.clear-posts-item');
    if (item) {
        // 阻止事件冒泡，避免触发下面的change事件
        e.stopPropagation();
        item.classList.toggle('selected');
    }
});
document.getElementById('data-clear-wizard-modal').addEventListener('change', (e) => {
    // 全选角色
    if (e.target.id === 'select-all-chars-for-clear') {
        const isChecked = e.target.checked;
        document.querySelectorAll('#data-clear-char-list .clear-posts-item').forEach(item => {
            item.classList.toggle('selected', isChecked);
        });
    } 
    // 全选数据类型
    else if (e.target.id === 'select-all-types-for-clear') {
        const isChecked = e.target.checked;
        document.querySelectorAll('#data-clear-type-list .clear-posts-item').forEach(item => {
            item.classList.toggle('selected', isChecked);
        });
    }
});
// ▲▲▲ 新增事件绑定结束 ▲▲▲
document.getElementById('compress-images-btn').addEventListener('click', compressAllLocalImages);
// ▼▼▼ 在 init() 的事件监听器区域，找到 #copy-message-btn 的监听器，在它后面粘贴新代码 ▼▼▼
document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);

// 【核心修改】为新按钮绑定新的功能函数
document.getElementById('copy-timestamp-btn').addEventListener('click', copyMessageTimestamp);
// ▲▲▲ 粘贴结束 ▲▲▲
document.getElementById('npc-list-back-btn').addEventListener('click', () => {
    // 当这个按钮被点击时，调用我们定义在“私密作用域”里的函数
    switchToChatListView('messages-view');
});

// 绑定NPC列表页顶部的“+”按钮
document.getElementById('add-npc-btn').addEventListener('click', () => openNpcEditor(null));

// 绑定NPC编辑器弹窗的“保存”和“取消”按钮
document.getElementById('save-npc-btn').addEventListener('click', saveNpc);
document.getElementById('cancel-npc-editor-btn').addEventListener('click', () => {
    document.getElementById('npc-editor-modal').classList.remove('visible');
});

// 绑定NPC头像上传
document.getElementById('npc-avatar-input').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            document.getElementById('npc-avatar-preview').src = e.target.result;
        };
        reader.readAsDataURL(file);
    }
});
document.getElementById('chat-lock-overlay').addEventListener('click', (e) => {
    // 检查点击的是否是“重Roll”按钮
    if (e.target.id === 'spectator-reroll-btn') {
        handleSpectatorReroll();
    }
    // 检查点击的是否是“剪辑”按钮
    else if (e.target.id === 'spectator-edit-btn') {
        // 直接复用现有的“导演剪辑室”打开函数
        openAiResponseEditor();
    }
    // (注意：主按钮 spectator-propel-btn 的事件已在 renderChatInterface 中直接绑定，这里无需处理)
});
addLongPressListener(document.getElementById('music-visual-container'), () => { if (musicState.currentIndex > -1) { handleChangeAlbumArt(musicState.currentIndex); } });
document.getElementById('douban-settings-btn').addEventListener('click', openDoubanSettingsModal);
document.getElementById('save-douban-settings-btn').addEventListener('click', saveDoubanSettings);
document.getElementById('cancel-douban-settings-btn').addEventListener('click', () => {
    document.getElementById('douban-settings-modal').classList.remove('visible');
});
// ▼▼▼ 【全新】为时区搜索框添加事件监听 ▼▼▼
document.getElementById('time-zone-search-input').addEventListener('input', (e) => {
    const searchTerm = e.target.value.toLowerCase();
    const selectEl = document.getElementById('time-zone-select');
    
    // 遍历下拉列表中的每一个选项
    for (const option of selectEl.options) {
        const optionText = option.textContent.toLowerCase();
        
        // 如果选项的文本内容包含了用户输入的搜索词，就显示它
        if (optionText.includes(searchTerm)) {
            option.style.display = ''; // 恢复显示
        } else {
            // 否则就隐藏它
            option.style.display = 'none';
        }
    }
});
// ▲▲▲ 新增JS代码结束 ▲▲▲
// ▼▼▼ 【全新】狼人杀游戏事件监听器 ▼▼▼
    
// 游戏小屋入口
// (这个已经在HTML的onclick里处理了, 但最好也在这里暴露一下函数)
window.openWerewolfLobby = openWerewolfLobby;

// 聊天工具栏入口
document.getElementById('werewolf-game-btn').addEventListener('click', () => openWerewolfLobby('group'));

// 大厅按钮
document.getElementById('cancel-werewolf-lobby-btn').addEventListener('click', () => {
    document.getElementById('werewolf-lobby-modal').classList.remove('visible');
});
document.getElementById('start-werewolf-game-btn').addEventListener('click', initializeWerewolfGame);

// 【全新】为新弹窗的取消/关闭按钮绑定事件
        document.getElementById('werewolf-role-confirm-btn').addEventListener('click', () => {
            document.getElementById('werewolf-role-modal').classList.remove('visible');
            executeNightPhase(); // 确认身份后，正式进入夜晚
        });
        
        document.getElementById('exit-werewolf-game-btn').addEventListener('click', async () => {
            const confirmed = await showCustomConfirm('退出游戏', '确定要退出当前这局狼人杀吗？游戏进度将不会被保存。', {confirmButtonClass: 'btn-danger'});
            if (confirmed) {
                werewolfGameState.isActive = false;
                // 根据游戏是从哪里发起的，返回到不同的界面
                showScreen(werewolfGameState.chatId ? 'chat-interface-screen' : 'home-screen');
            }
        });

        document.getElementById('werewolf-game-over-close-btn').addEventListener('click', () => {
            document.getElementById('werewolf-game-over-modal').classList.remove('visible');
            showScreen(werewolfGameState.chatId ? 'chat-list-screen' : 'home-screen');
        });

// ▲▲▲ 新增事件监听器结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域添加 ▼▼▼
document.getElementById('cancel-wolf-kill-btn').addEventListener('click', () => {
    document.getElementById('werewolf-kill-modal').classList.remove('visible');
});
// ▲▲▲ 新增代码结束 ▲▲▲

// ▼▼▼ 在 init() 函数的事件监听器区域添加 ▼▼▼
document.getElementById('cancel-werewolf-lobby-btn').addEventListener('click', () => {
    document.getElementById('werewolf-lobby-modal').classList.remove('visible');
});
// ▲▲▲ 新增代码结束 ▲▲▲
document.getElementById('werewolf-retry-btn').addEventListener('click', handleWerewolfRetry);
document.getElementById('manual-werewolf-summary-btn').addEventListener('click', handleManualWerewolfSummary);
document.getElementById('check-and-fix-data-btn').addEventListener('click', checkAndFixData);
// ▼▼▼ 【全新】这是为删除世界书功能添加的事件监听器 ▼▼▼
document.getElementById('delete-world-books-btn').addEventListener('click', openWorldBookDeletionModal);

// 为新弹窗的按钮和列表绑定事件
document.getElementById('cancel-delete-world-books-btn').addEventListener('click', () => {
    document.getElementById('delete-world-books-modal').classList.remove('visible');
});
document.getElementById('confirm-delete-world-books-btn').addEventListener('click', handleConfirmWorldBookDeletion);

document.getElementById('delete-world-books-modal').addEventListener('click', (e) => {
    // 处理列表项的勾选/取消勾选
    const item = e.target.closest('.clear-posts-item');
    if (item) {
        item.classList.toggle('selected');
    }
    // 处理“全选”复选框
    if (e.target.id === 'select-all-world-books-for-clear') {
        const isChecked = e.target.checked;
        document.querySelectorAll('#delete-world-books-list .clear-posts-item').forEach(el => {
            el.classList.toggle('selected', isChecked);
        });
    }
});
// ▲▲▲ 新增事件监听器结束 ▲▲▲
// ▼▼▼ 【全新】表情包搜索功能事件绑定 ▼▼▼
document.getElementById('sticker-search-input').addEventListener('input', () => {
    // 用户输入时，只需要重绘表情网格，不需要重绘顶部的页签
    renderStickerPanel(false); 
});

// 【修正】当切换分类时，清空搜索框并刷新
document.getElementById('sticker-category-tabs').addEventListener('click', (e) => {
    if (e.target.classList.contains('sticker-category-tab')) {
        const categoryId = e.target.dataset.categoryId;
        const finalId = (categoryId !== 'all' && categoryId !== 'uncategorized') ? parseInt(categoryId) : categoryId;
        
        // 清空搜索框的值
        document.getElementById('sticker-search-input').value = ''; 
        
        // 调用我们现有的切换函数
        switchStickerCategory(finalId);
    }
});
// ▲▲▲ 新增代码结束 ▲▲▲
// ▼▼▼ 【全新】无限滚动事件监听器 ▼▼▼

// --- 1. 聊天记录的滚动加载 ---
const chatMessagesContainer = document.getElementById('chat-messages');
chatMessagesContainer.addEventListener('scroll', () => {
    // 当滚动到顶部时触发
    if (chatMessagesContainer.scrollTop < 1 && !isLoadingMoreMessages) {
        const totalMessages = state.chats[state.activeChatId]?.history.length || 0;
        // 检查是否还有更多消息可供加载
        if (totalMessages > currentRenderedCount) {
             loadMoreMessages();
        }
    }
});

// --- 2. 心声历史的滚动加载 ---
const thoughtsHistoryList = document.getElementById('thoughts-history-list');
thoughtsHistoryList.addEventListener('scroll', () => {
    const { scrollTop, scrollHeight, clientHeight } = thoughtsHistoryList;
    // 当滚动到底部时触发
    if (scrollHeight - scrollTop <= clientHeight + 50 && !isLoadingMoreThoughts) { // 增加50px的缓冲距离
        const totalItems = state.chats[state.activeChatId]?.thoughtsHistory.length || 0;
        if (totalItems > thoughtsHistoryRenderCount) {
            loadMoreThoughts();
        }
    }
});

// --- 3. 好友动态的滚动加载 ---
const qzoneContent = document.querySelector('#qzone-screen .qzone-content');
qzoneContent.addEventListener('scroll', () => {
    const { scrollTop, scrollHeight, clientHeight } = qzoneContent;
    // 当滚动到底部时触发
    if (scrollHeight - scrollTop <= clientHeight + 100 && !isLoadingMorePosts) { // 增加100px的缓冲距离
        if (qzonePostsCache.length > qzonePostsRenderCount) {
            loadMoreQzonePosts();
        }
    }
});

// ▲▲▲ 新增事件监听器结束 ▲▲▲
// ▼▼▼ 【V2.0 | 全新】一起读书功能事件绑定 ▼▼▼
document.getElementById('read-together-btn').addEventListener('click', openReadingRoom);
const restoreBtn = document.getElementById('reading-restore-btn');
// 调用我们现有的拖动函数，将小球本身作为拖动目标和拖动把手
makeDraggable(restoreBtn, restoreBtn);
document.getElementById('close-reading-btn').addEventListener('click', closeReadingRoom);
document.getElementById('open-reading-library-btn').addEventListener('click', openBookLibrary);
document.getElementById('next-page-btn').addEventListener('click', showNextPage);
document.getElementById('prev-page-btn').addEventListener('click', showPrevPage);
document.getElementById('book-upload-input').addEventListener('change', handleBookFileUpload);

// 新增：为最小化和恢复按钮绑定事件
document.getElementById('minimize-reading-btn').addEventListener('click', minimizeReadingRoom);
document.getElementById('reading-restore-btn').addEventListener('click', restoreReadingRoom);

// 新增：初始化窗口的拖动功能
makeDraggable(document.getElementById('reading-window'), document.querySelector('#reading-window .reading-header'));
// ▲▲▲ 新增事件绑定结束 ▲▲▲
// ▼▼▼ 【全新】为读书功能的新按钮绑定事件 ▼▼▼
document.getElementById('open-reading-library-btn').addEventListener('click', openBookLibrary);
// ▼▼▼ 【全新】为书库弹窗的头部SVG按钮绑定事件 ▼▼▼
document.getElementById('close-reading-library-btn-header').addEventListener('click', () => {
    document.getElementById('reading-library-modal').classList.remove('visible');
});
document.getElementById('import-new-book-btn-header').addEventListener('click', importBook);
// ▲▲▲ 替换结束 ▲▲▲

// 使用事件委托处理书库列表中的点击事件
document.getElementById('reading-library-list').addEventListener('click', (e) => {
    const target = e.target;
    if (target.classList.contains('group-name')) { // 点击书名 -> 阅读
        const bookId = parseInt(target.dataset.bookId);
        loadBookFromLibrary(bookId);
    } else if (target.classList.contains('delete-group-btn')) { // 点击删除按钮
        const bookId = parseInt(target.dataset.bookId);
        deleteBookFromLibrary(bookId);
    }
});
// ▲▲▲ 新增事件绑定结束 ▲▲▲
document.getElementById('page-indicator').addEventListener('click', handlePageJump);
document.getElementById('reading-library-search-input').addEventListener('input', (e) => {
    // 当用户输入时，调用渲染函数并传入搜索词
    renderBookLibrary(e.target.value);
});
const debouncedUpdateReadingContext = debounce(updateReadingContextOnScroll, 300); // 停止滚动300毫秒后触发

// 2. 将这个新函数绑定到读书窗口内容区的滚动事件上
document.getElementById('reading-content').addEventListener('scroll', debouncedUpdateReadingContext);
document.getElementById('api-temperature-slider').addEventListener('input', (e) => {
    document.getElementById('api-temperature-value').textContent = e.target.value;
});
const chatListContainer = document.getElementById('messages-view');
chatListContainer.addEventListener('scroll', () => {
    const { scrollTop, scrollHeight, clientHeight } = chatListContainer;
    // 当滚动条距离底部小于 150px 时触发加载
    if (scrollHeight - scrollTop <= clientHeight + 150 && !isLoadingMoreChats) {
        loadMoreChats();
    }
});




    checkForUpdates();

                    showScreen('home-screen');
                }
        
                init();
            });
        
    </script>
    <div id="qzone-sticker-panel">
        <div id="qzone-sticker-grid"></div>
    </div>
    <!-- ▼▼▼ 【全新 V2.0 | 支持上传】请用这整块代码，完整替换旧的 avatar-frame-modal ▼▼▼ -->
    <div id="avatar-frame-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>选择头像框</span>
                <!-- 【核心新增】添加操作按钮 -->
                <div class="header-actions">
                    <button id="upload-custom-frame-btn" class="action-button">上传</button>
                    <button id="batch-import-frames-btn" class="action-button">批量</button>
                </div>
            </div>
            <div class="modal-body">
                <div class="frame-tabs">
                    <div id="ai-frame-tab" class="frame-tab active">对方的</div>
                    <div id="my-frame-tab" class="frame-tab">我的</div>
                </div>
                <div id="ai-frame-content" class="frame-content">
                    <div id="ai-frame-grid" class="frame-grid">
                    </div>
                </div>
                <div id="my-frame-content" class="frame-content" style="display: none;">
                    <div id="my-frame-grid" class="frame-grid">
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-frame-settings-btn">取消</button>
                <button class="save" id="save-frame-settings-btn">保存</button>
            </div>
        </div>
    </div>
    <!-- 【核心新增】用于本地上传的隐藏文件输入框 -->
    <input type="file" id="custom-frame-upload-input" accept="image/*" hidden>
    <!-- ▲▲▲ 替换结束 ▲▲▲ -->

<div id="character-profile-modal" class="modal">
    <div class="character-profile-content">
        <!-- 右上角的历史记录图标按钮 -->
        <button id="profile-history-icon-btn" title="查看历史心声">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
            </svg>
        </button>
        
        <!-- 主资料页 -->
        <div id="profile-main-content">
            <!-- （这里的内容结构与上次类似，但被包裹在了卡片内部） -->
            <div id="profile-timestamp" class="thought-header"></div>
            <div class="thought-content">
                <div class="voice">
                    <div class="label">
                        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                        心声
                    </div>
                    <p id="profile-heartfelt-voice" class="text"></p>
                </div>
                <div class="jottings">
                    <div class="label">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path></svg>
                        散记
                    </div>
                    <p id="profile-random-jottings" class="text"></p>
                </div>
            </div>
        </div>

        <!-- 历史记录页 (保持不变，但现在也在卡片内切换) -->
        <div id="profile-thoughts-history-view">
            <div class="profile-header">
                <span>心声记录</span>
                <button id="history-back-btn" title="返回">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>
                </button>
            </div>
            <div id="thoughts-history-list"></div>
        </div>
    </div>
</div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】“我的”头像库专用文件上传输入框 ▼▼▼ -->
    <input type="file" id="my-avatar-upload-input" accept="image/*" hidden>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】这是选择礼物接收人的弹窗，请粘贴到 body 底部 ▼▼▼ -->
    <div id="gift-recipient-modal" class="modal">
        <div class="modal-content" style="height: 70%;">
            <div class="modal-header">
                <span>选择收礼人</span>
                <label style="font-size: 14px; font-weight: normal; display: flex; align-items: center; gap: 5px;">
                    <input type="checkbox" id="select-all-recipients"> 全选 </label>
            </div>
            <div class="modal-body" id="gift-recipient-list" style="padding: 0;">
                <!-- 群成员列表将由JS动态生成在这里 -->
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-gift-recipient-btn">取消</button>
                <button class="save" id="confirm-gift-recipient-btn">确认送出</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这个【全新的 <audio> 标签】粘贴到 <body> 标签的最末尾，紧邻 </body> 之前 ▼▼▼ -->
<audio id="notification-sound-player" preload="auto"></audio>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新V2版】BGM搜索结果弹窗 (支持多选) ▼▼▼ -->
<div id="music-search-results-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>搜索结果</span>
            <!-- 核心修改1：添加“全选”复选框 -->
            <label style="font-size: 14px; font-weight: normal; display: flex; align-items: center; gap: 5px;">
                <input type="checkbox" id="select-all-music-search"> 全选
            </label>
        </div>
        <div class="modal-body" id="search-results-list" style="padding: 0;">
            <!-- 搜索结果将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <!-- 核心修改2：更新页脚按钮 -->
            <button class="cancel" id="cancel-music-search-btn">取消</button>
            <button class="save" id="add-selected-music-btn">添加选中</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是豆瓣设置的弹窗，请粘贴到 body 底部 ▼▼▼ -->
<div id="douban-settings-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>豆瓣设置</span>
        </div>
        <div class="modal-body">
            <div class="form-group douban-settings-item">
                <label for="douban-min-posts-input">
                    每次生成帖子数范围
                    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                        设置AI在豆瓣页面一次性生成帖子的最小和最大数量。
                    </p>
                </label>
                <div class="douban-settings-controls">
                    <input type="number" id="douban-min-posts-input" min="1" value="12">
                    <span>到</span>
                    <input type="number" id="douban-max-posts-input" min="1" value="20">
                    <span>篇</span>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-douban-settings-btn">取消</button>
            <button class="save" id="save-douban-settings-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<audio id="char-audio-player" preload="auto"></audio>
<!-- ▼▼▼ 【全新】豆瓣角色选择弹窗 ▼▼▼ -->
<div id="douban-cast-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>选择参与豆瓣的角色</span>
        </div>
        <div class="modal-body" id="douban-cast-list" style="padding: 0;">
            <!-- 角色列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-douban-cast-btn">取消</button>
            <button class="save" id="save-douban-cast-btn">保存并刷新</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是为“预设”功能新增的文件导入输入框 ▼▼▼ -->
<input type="file" id="import-preset-input" accept=".json" hidden>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是更新通知弹窗的HTML结构 ▼▼▼ -->
<div id="update-notice-modal">
    <div class="update-notice-content">
        <div class="update-notice-body" id="update-notice-body">
            <!-- 更新内容将由JS动态加载到这里 -->
        </div>
        <div class="update-notice-footer">
            <button id="update-notice-confirm-btn">我知道了</button>
            <button id="update-notice-dismiss-btn">不再提示</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<div id="delete-world-books-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>选择要删除的世界书</span>
            <label style="font-size: 14px; font-weight: normal; display: flex; align-items: center; gap: 5px;">
                <input type="checkbox" id="select-all-world-books-for-clear"> 全选
            </label>
        </div>
        <div class="modal-body" id="delete-world-books-list" style="padding: 0;">
            </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-delete-world-books-btn">取消</button>
            <button class="save btn-danger" id="confirm-delete-world-books-btn">确认删除</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 【全新】狼人杀夜晚刀人弹窗 ▼▼▼ -->
<div id="werewolf-kill-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header"><span>狼人请选择刀人对象</span></div>
        <div class="modal-body" id="werewolf-kill-selection-list" style="padding: 0;"></div>
        <div class="modal-footer">
             <button class="cancel" id="cancel-wolf-kill-btn">放弃</button>
             <button class="save btn-danger" id="confirm-wolf-kill-btn">确认刀人</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<div id="werewolf-lobby-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span>选择玩家开始狼人杀</span>
        </div>
        <div class="modal-body" id="werewolf-player-selection-list" style="padding: 0;">
            </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-werewolf-lobby-btn">取消</button>
            <button class="save" id="start-werewolf-game-btn">开始游戏</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新V2.0 | 交互修复版】请用这整块代码，完整替换旧的 werewolf-game-screen ▼▼▼ -->


<div id="werewolf-role-modal" class="modal">
    <div class="modal-content" style="width: 280px; height: auto; text-align: center; padding: 20px;">
        <h3 id="werewolf-role-title" style="margin-top: 0;">你的身份是</h3>
        <div id="werewolf-role-card" style="margin: 15px 0;">
            <!-- 【核心修复】在这里添加了缺失的 h2 和 p 标签 -->
            <h2 id="werewolf-role-name" style="margin: 0 0 10px 0;"></h2>
            <p id="werewolf-role-description" style="font-size: 14px; line-height: 1.6; color: #555; margin: 0;"></p>
        </div>
        <button id="werewolf-role-confirm-btn" class="form-button">我准备好了</button>
    </div>
</div>

<div id="werewolf-prophet-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header"><span>预言家请选择查验对象</span></div>
        <div class="modal-body" id="werewolf-prophet-selection-list" style="padding: 0;"></div>
        <div class="modal-footer">
             <button class="save" id="confirm-prophet-check-btn">确认查验</button>
        </div>
    </div>
</div>

<div id="werewolf-hunter-modal" class="modal">
     <div class="modal-content" style="height: 70%;">
        <div class="modal-header"><span>猎人请选择开枪对象</span></div>
        <div class="modal-body" id="werewolf-hunter-selection-list" style="padding: 0;"></div>
        <div class="modal-footer">
             <button class="save btn-danger" id="confirm-hunter-shot-btn">确认开枪</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】这是你缺失的“投票”弹窗，请粘贴到此处 ▼▼▼ -->
<div id="werewolf-vote-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header"><span>请投票放逐一名玩家</span></div>
        <div class="modal-body" id="werewolf-vote-selection-list" style="padding: 0;"></div>
        <div class="modal-footer">
             <button class="save" id="confirm-vote-btn">确认投票</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新V2.0】这是你缺失的所有狼人杀角色操作弹窗，请完整粘贴 ▼▼▼ -->

<!-- 1. 守卫选择弹窗 -->
<div id="werewolf-guard-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header"><span>守卫请选择今晚要守护的玩家</span></div>
        <div class="modal-body" id="werewolf-guard-selection-list" style="padding: 0;"></div>
        <div class="modal-footer">
             <button class="save" id="confirm-guard-selection-btn">确认守护</button>
        </div>
    </div>
</div>

<!-- 2. 女巫操作弹窗 (信息提示 + 毒人选择) -->
<div id="werewolf-witch-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header"><span id="witch-modal-title">女巫请睁眼</span></div>
        <div class="modal-body" id="werewolf-witch-selection-list" style="padding: 0;">
            </div>
        <div class="modal-footer">
             <button class="cancel" id="witch-do-nothing-btn">什么都不做</button>
             <button class="save btn-danger" id="confirm-witch-poison-btn" style="display: none;">确认用毒</button>
        </div>
    </div>
</div>


<!-- 3. 猎人开枪弹窗 (之前缺失) -->
<div id="werewolf-hunter-modal" class="modal">
     <div class="modal-content" style="height: 70%;">
        <div class="modal-header"><span>猎人请选择开枪对象</span></div>
        <div class="modal-body" id="werewolf-hunter-selection-list" style="padding: 0;"></div>
        <div class="modal-footer">
             <button class="save btn-danger" id="confirm-hunter-shot-btn">确认开枪</button>
        </div>
    </div>
</div>

<!-- 4. 投票弹窗 (之前缺失) -->
<div id="werewolf-vote-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header"><span>请投票放逐一名玩家</span></div>
        <div class="modal-body" id="werewolf-vote-selection-list" style="padding: 0;"></div>
        <div class="modal-footer">
             <button class="save" id="confirm-vote-btn">确认投票</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新V2.0 | 已添加身份公布】请用这整块代码，完整替换旧的 werewolf-game-over-modal ▼▼▼ -->
<div id="werewolf-game-over-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto; text-align: center; padding: 20px;">
        <h2 id="werewolf-game-over-title">游戏结束</h2>
        <p id="werewolf-game-over-reason" style="font-size: 16px; margin: 20px 0;"></p>
        
        <!-- 【【【核心新增：身份公布列表】】】 -->
        <div id="werewolf-role-reveal-list" style="max-height: 250px; overflow-y: auto; margin: 20px 0; border-top: 1px solid #444; padding-top: 10px;">
            <!-- 玩家身份将由JS动态生成在这里 -->
        </div>
        
        <button id="werewolf-game-over-close-btn" class="form-button">返回大厅</button>
      <button id="manual-werewolf-summary-btn" class="form-button form-button-secondary" style="margin-top: 10px;">手动总结记忆</button>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<div id="reading-library-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>我的书库</span>
            <div class="header-actions">
                <span class="action-btn" id="import-new-book-btn-header" title="导入新书">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                </span>
                <span class="action-btn" id="close-reading-library-btn-header" title="关闭">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </span>
            </div>
        </div>

        <div id="reading-library-search-container">
            <input type="search" id="reading-library-search-input" placeholder="搜索书名...">
        </div>

        <div class="modal-body" style="padding: 0; flex-grow: 1; overflow-y: auto;">
            <div id="reading-library-list">
                </div>
        </div>

        </div>
</div>
<!-- ▼▼▼ 【全新】这是用于iOS后台保活的静音播放器，请粘贴到 body 末尾 ▼▼▼ -->
<audio id="silent-audio-player" loop preload="auto" style="display:none;">
    <source src="https://phoebeboo.github.io/mewoooo/1-second-of-silence.mp3" type="audio/mpeg">
</audio>
<!-- ▲▲▲ 新增代码粘贴结束 ▲▲▲ -->
<audio id="tts-audio-player" style="display:none;"></audio>
</body>
</html>






































