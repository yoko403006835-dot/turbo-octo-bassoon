<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <!-- 启用 Web App 模式 -->
    <meta name="apple-mobile-web-app-capable" content="yes">

    <!-- Web App 在主屏幕上的标题 -->
    <meta name="apple-mobile-web-app-title" content="章鱼喷墨机">
    
    <!-- 
      设置顶部状态栏样式 (时间和电量)
      - 'default': 白色背景，黑色文字
      - 'black': 黑色背景，白色文字
      - 'black-translucent': 半透明黑色，内容会延伸到状态栏下方，最具沉浸感
    -->
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <!-- 
      (您已有的代码，用于设置主屏幕图标)
      确保这张图片是 180x180 像素或更高分辨率的方形图片，效果最好
    -->
    <link rel="apple-touch-icon" href="https://i.postimg.cc/nzP9sgxr/chan-125.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>章鱼喷墨机</title>
        <!-- ▼▼▼ 在这里粘贴新的代码 ▼▼▼ -->
    <link rel="manifest" href="manifest.json">
    <!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="apple-touch-icon" href="https://i.postimg.cc/nzP9sgxr/chan-125.png">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>

    <style>
        /* --- 全局与主题样式 --- */
        :root {
            --bg-color: #fce4ec;
            --primary-color: #ff80ab;
            --secondary-color: #f48fb1;
            --accent-color: #90caf9;
            --text-color: #444;
            --white-color: #fff;
            --border-radius: 18px;
            --phone-corner-radius: 0px;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --top-pinned-bg: #fff0f5;
            --online-status-color: #4CAF50;
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #fce4ec, #f8bbd0);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        .phone-screen {
            width: 100%;
            max-width: 420px;
            height: 100vh;
            max-height: 850px;
            background-color: var(--white-color);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border-radius: var(--phone-corner-radius);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .screen {
            display: none;
            flex-direction: column;
            width: 100%;
            height: 100%;
            animation: fadeIn 0.5s ease;
        }

        .screen.active {
            display: flex;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid #eee;
            flex-shrink: 0;
            position: relative;
            z-index: 10;
        }

        .app-header .back-btn,
        .app-header .action-btn {
            background: none;
            border: none;
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-color);
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #cancel-multi-select-btn {
            font-size: 14px !important;
            font-weight: 500 !important;
            color: var(--white-color) !important;
            background-color: var(--primary-color) !important;
            border-radius: 10px !important;
            padding: 5px 10px !important;
            width: auto !important;
            height: auto !important;
        }

        .app-header .action-btn-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .app-header .action-btn-group .action-btn {
            font-size: 16px;
            font-weight: 600;
            width: auto;
            padding: 6px 12px;
            border-radius: 10px;
        }

        .app-header .action-btn-group #create-group-btn {
            background-color: var(--primary-color);
            color: var(--white-color);
        }

        .app-header .action-btn-group #add-chat-btn {
            font-size: 28px;
            padding: 0;
            width: 40px;
            height: 40px;
            background-color: transparent;
            color: var(--primary-color);
            border-radius: 50%;
        }

        .app-header .action-btn img {
            width: 28px;
            height: 28px;
        }

        .app-header .title-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .app-header .title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-color);
            margin: 0;
        }

        .app-header .subtitle {
            font-size: 12px;
            color: #888;
            display: flex;
            align-items: center;
            margin-top: 2px;
        }

        .online-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--online-status-color);
            margin-right: 5px;
        }

        .app-header .placeholder {
            width: 40px;
        }

        #home-screen,
#home-screen-2 {
    justify-content: space-between;
    background-size: cover;
    background-position: center;
    transition: background-image 0.5s ease-in-out;
    padding: 50px 0;
}

        .time-widget {
            text-align: center;
            padding: 0 20px;
            color: var(--text-color);
        }

        .time-widget .time {
            font-size: 72px;
            font-weight: 600;
        }

        .time-widget .date {
            font-size: 18px;
            color: #666;
        }

        #home-screen.day-mode .time-widget,
        #home-screen.day-mode .time-widget .date,
        #home-screen.day-mode .app-icon .app-name {
            color: var(--white-color);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }

        .app-grid {
            width: 100%;
            padding: 20px 40px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            justify-content: center;
            align-content: center;
            margin-top: 30px;
        }

        #home-screen.day-mode .time-widget,
        #home-screen.day-mode .time-widget .date,
        #home-screen.day-mode .app-icon .app-name {
            color: var(--white-color);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }


        .app-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            text-decoration: none;
        }

        .icon-img {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            margin-bottom: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
            object-fit: cover;
        }

        .app-icon:hover .icon-img {
            transform: translateY(-5px);
        }

        .app-icon .app-name {
            font-size: 12px;
            color: var(--text-color);
            font-weight: 500;
        }

        .content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            position: relative;
        }

        .placeholder-text {
            text-align: center;
            color: #aaa;
            margin-top: 50px;
        }

        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 100;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal-window {
            background: var(--white-color);
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.15);
            width: 85%;
            max-width: 340px;
            animation: slideUp 0.4s ease-out;
        }

        .modal-window h3 {
            margin-top: 0;
            text-align: center;
            color: var(--primary-color);
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        #edit-group-member-modal,
        #create-member-for-group-modal {
            z-index: 102;
        }

        #edit-group-member-modal .avatar-preview,
        #create-member-for-group-modal .avatar-preview {
            width: 80px;
            height: 80px;
        }

        .context-menu {
            position: fixed;
            z-index: 1000;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            padding: 5px 0;
            animation: fadeIn 0.1s ease;
        }

        .context-menu-item {
            padding: 10px 20px;
            cursor: pointer;
        }

        .context-menu-item:hover {
            background-color: #f5f5f5;
        }

        .context-menu-item.danger {
            color: #e53935;
        }

        .action-sheet-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 200;
            display: none;
            align-items: flex-end;
            animation: fadeIn 0.3s ease;
        }

        .action-sheet-overlay.visible {
            display: flex;
        }

        .action-sheet {
            background: #f7f7f7;
            width: 100%;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            padding: 10px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            animation: slideUp 0.3s ease-out;
        }

        .action-sheet-button {
            width: 100%;
            background: white;
            border: none;
            padding: 15px;
            font-size: 16px;
            color: var(--primary-color);
            font-weight: 500;
            cursor: pointer;
            border-radius: 10px;
            margin-bottom: 8px;
        }

        .action-sheet-button.danger {
            color: #e53935;
        }

        .action-sheet-button:last-child {
            margin-bottom: 0;
        }

        #chat-list-screen .content,
        #world-book-screen .content {
            padding: 10px 0 0 0;
        }

        .list-container {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .list-item {
            display: flex;
            align-items: center;
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s ease;
            position: relative;
        }

        .list-item:hover {
            background-color: #fdf6f8;
        }

        .chat-item.pinned {
            background-color: var(--top-pinned-bg);
        }

        .chat-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin-right: 15px;
            object-fit: cover;
            flex-shrink: 0;
            background-color: #eee;
        }

        .group-avatar {
            border-radius: 10px;
        }

        .item-details {
            flex-grow: 1;
            overflow: hidden;
        }

        .item-details-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .item-name {
            font-weight: 600;
            color: var(--text-color);
            font-size: 16px;
        }

        .item-preview-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }

        .item-preview {
            font-size: 14px;
            color: #888;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-grow: 1;
        }

        .pin-badge {
            background-color: var(--primary-color);
            color: white;
            font-size: 10px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 5px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        #chat-room-screen {
            background-size: cover;
            background-position: center;
        }

        #chat-room-screen .content {
            display: flex;
            flex-direction: column;
            padding: 10px;
            padding-bottom: 10px;
            transition: padding-bottom 0.3s ease;
        }

        #chat-room-screen.multi-select-active .content {
            padding-bottom: 70px;
        }

        .message-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0 10px;
            scroll-behavior: smooth;
        }

        .message-wrapper {
            display: flex;
            margin-bottom: 12px;
            align-items: flex-start;
            transition: background-color 0.2s;
            flex-direction: column;
        }

        .message-wrapper.group-message {
            margin-bottom: 18px;
        }

        .message-wrapper.sent {
            align-items: flex-end;
        }

        .message-wrapper.received {
            align-items: flex-start;
        }

        .message-wrapper.system-notification {
            align-items: center;
        }

        .message-bubble-row {
            display: flex;
            width: 100%;
            align-items: flex-start;
        }

        .message-wrapper.sent .message-bubble-row {
            flex-direction: row-reverse;
        }

        .message-wrapper.multi-select-selected {
            background-color: rgba(144, 202, 249, 0.2);
            border-radius: var(--border-radius);
        }

        .message-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .group-nickname {
            position: absolute;
            top: -15px;
            font-size: 11px;
            color: #888;
            white-space: nowrap;
            width: 70px;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
        }

        .message-time {
            font-size: 9px;
            color: #aaa;
            margin-top: 3px;
        }

        .message-bubble {
            max-width: 260px;
            padding: 8px 12px;
            border-radius: var(--border-radius);
            word-wrap: break-word;
            line-height: 1.4;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            margin: 0 8px;
            cursor: pointer;
            font-size: 15px;
        }

        .message-bubble.sent {
            border-bottom-right-radius: 5px;
        }

        .message-bubble.received {
            border-bottom-left-radius: 5px;
        }

        .system-notification-bubble {
            background-color: rgba(200, 200, 200, 0.5);
            color: #666;
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 10px;
            text-align: center;
        }

        .image-bubble {
            max-width: 120px;
            border-radius: var(--border-radius);
            margin: 0 8px;
            padding: 4px;
            background-color: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }

        .image-bubble img {
            width: 100%;
            height: auto;
            display: block;
            border-radius: calc(var(--border-radius) - 4px);
        }

        .message-wrapper.sent .image-bubble {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .image-bubble {
            border-bottom-left-radius: 5px;
        }

        .voice-bubble {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            border-radius: var(--border-radius);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            margin: 0 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 90px;
            max-width: 200px;
        }

        .message-wrapper.sent .voice-bubble {
            border-bottom-right-radius: 5px;
            flex-direction: row-reverse;
        }

        .message-wrapper.received .voice-bubble {
            border-bottom-left-radius: 5px;
        }

        .voice-bubble .play-icon {
            width: 18px;
            height: 18px;
            flex-shrink: 0;
        }

        .voice-bubble .duration {
            font-size: 13px;
            margin: 0 8px;
            white-space: nowrap;
        }

        .message-wrapper.sent .play-icon {
            transform: scaleX(-1);
        }

        .voice-transcript {
            font-size: 14px;
            color: #555;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 8px 12px;
            margin-top: 5px;
            margin-left: 54px;
            margin-right: 54px;
            border-radius: 10px;
            line-height: 1.6;
            max-width: calc(100% - 108px);
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .voice-transcript.active {
            display: block;
        }

        .message-wrapper.sent .voice-transcript {
            align-self: flex-end;
            margin-right: 54px;
            margin-left: auto;
        }

        .message-wrapper.received .voice-transcript {
            align-self: flex-start;
            margin-left: 54px;
            margin-right: auto;
        }

        .pv-card {
            width: 230px;
            aspect-ratio: 1 / 1;
            background-color: #f0f0f0;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            position: relative;
            cursor: pointer;
            margin: 0 8px;
        }

        .message-wrapper.sent .pv-card {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .pv-card {
            border-bottom-left-radius: 5px;
        }

        .pv-card-image-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            transition: opacity 0.5s ease-in-out;
            z-index: 2;
        }

        .pv-card-image-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .pv-card-content {
            padding: 15px;
            height: 100%;
            overflow-y: auto;
            color: var(--text-color);
            line-height: 1.6;
            font-size: 15px;
            background-color: white;
            position: relative;
            z-index: 1;
        }

        .pv-card-footer {
            background: linear-gradient(to top, rgba(0, 0, 0, 0.6), transparent);
            color: white;
            padding: 20px 10px 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 3;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
        }

        .pv-card-footer.hidden {
            opacity: 0;
        }

        .pv-card-footer svg {
            width: 14px;
            height: 14px;
            fill: white;
            flex-shrink: 0;
        }

        .transfer-card {
            width: 240px;
            height: auto;
            border-radius: var(--border-radius);
            margin: 0 8px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            color: white;
        }

        .message-wrapper.sent .transfer-card {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .transfer-card {
            border-bottom-left-radius: 5px;
            cursor: pointer;
        }

        .transfer-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-size: cover;
            background-position: center;
            filter: blur(4px);
            transform: scale(1.1);
            z-index: 1;
        }

        .transfer-card.sent-transfer::before {
            background-image: url('https://i.postimg.cc/sxN893WF/IMG-20250712.png');
        }

        .transfer-card.received-transfer::before {
            background-image: url('https://i.postimg.cc/FzR8LY7g/IMG-20250712-170703.png');
        }

        .transfer-card .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.3);
            z-index: 2;
            transition: background-color 0.5s ease;
        }

        .transfer-card.received .overlay {
            background-color: rgba(255, 182, 193, 0.4);
        }

        .transfer-card.returned .overlay {
            background-color: rgba(100, 100, 100, 0.5);
        }

        .transfer-content {
            position: relative;
            z-index: 3;
            padding: 20px;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        .transfer-title {
            font-size: 14px;
            margin: 0 0 5px 0;
            opacity: 0.9;
        }

        .transfer-amount {
            font-size: 28px;
            font-weight: bold;
            margin: 0;
        }

        .transfer-remark {
            font-size: 14px;
            margin-top: 10px;
            opacity: 0.9;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .transfer-status {
            font-size: 12px;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            opacity: 0.8;
        }
        /* --- 拉黑功能新增样式 --- */
.block-indicator {
    color: #ef5350;
    font-size: 20px;
    font-weight: bold;
    display: none; /* 默认隐藏 */
    align-self: center; /* 垂直居中 */
    animation: fadeIn 0.3s;
}

/* --- 拉黑功能样式 (已修正) --- */
.block-indicator {
    color: #ef5350;
    font-size: 20px;
    font-weight: bold;
    display: none; /* 默认隐藏 */
    align-self: center; /* 垂直居中 */
    animation: fadeIn 0.3s;
}

/* 当用户(sent)的消息在被AI拉黑期间发送时，显示感叹号 */
.message-wrapper.user-was-blocked .block-indicator.sent {
    display: block; 
}

/* 当AI(received)的消息在被用户拉黑期间发送时，显示感叹号 */
.message-wrapper.ai-was-blocked .block-indicator.received {
    display: block; 
}

/* 感叹号位置调整 */
.message-wrapper.received .message-bubble-row .block-indicator.received {
    order: 3; (移除或注释掉此行) */
    margin-left: 8px; /* 将 margin-right 改为 margin-left */
}
.message-wrapper.sent .message-bubble-row .block-indicator.sent {
    order: 1; /* 新增：使用order属性改变其在flex容器中的视觉顺序 */
    margin-right: 8px; /* 修改：将间距应用到右侧，使其与气泡分开 */
}
/* --- 顶部“正在输入”状态的动画效果 --- */
@keyframes typing-pulse {
  0%, 100% {
    opacity: 0.6;
  }
  50% {
    opacity: 1;
  }
}

#chat-room-subtitle .typing-status {
  /* 应用呼吸灯一样的动画效果 */
  animation: typing-pulse 1.8s infinite ease-in-out;
}
/* --- 动态删除模式下的按钮样式调整 --- */
#moments-screen.is-delete-mode .app-header #moments-delete-btn {
    color: var(--primary-color);
    font-weight: 600;
}
#moments-screen.is-delete-mode .app-header #moments-delete-btn::before {
    content: "取消"; /* 将“删除”文字替换为“取消” */
}
#moments-screen.is-delete-mode .app-header #moments-delete-btn {
    font-size: 0; /* 隐藏原始的“删除”文字 */
}

/* 底部多选操作栏的样式 */
#moments-multi-select-bar {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(10px);
    padding: 10px 20px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
    border-top: 1px solid #eee;
    z-index: 200;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transform: translateY(100%);
    transition: transform 0.3s ease-out;
}
#moments-multi-select-bar.show {
    transform: translateY(0);
}
#moments-multi-select-bar button {
    padding: 8px 16px;
    border-radius: 10px;
    border: none;
    cursor: pointer;
    font-size: 14px;
}
#moments-multi-select-bar #moments-confirm-delete {
    background-color: #ef5350;
    color: white;
}
#moments-multi-select-bar #moments-cancel-delete {
    background-color: #e0e0e0;
    color: #333;
}
      
#diary-screen .content {
    padding: 10px;
}
.diary-entry {
    background-color: #fff8fa;
    border-radius: var(--border-radius);
    padding: 15px;
    margin-bottom: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    border-left: 4px solid var(--primary-color);
}
.diary-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 1px solid #f0f0f0;
}
.diary-date {
    font-size: 14px;
    font-weight: 600;
    color: var(--secondary-color);
}
.diary-actions button {
    background: none;
    border: none;
    cursor: pointer;
    padding: 5px;
    margin-left: 8px;
}
.diary-actions button svg {
    width: 20px;
    height: 20px;
    fill: #aaa;
    transition: fill 0.2s ease, transform 0.2s ease;
}
.diary-actions button:hover svg {
    fill: var(--primary-color);
    transform: scale(1.1);
}
.diary-actions button.favorited svg {
    fill: #fbc02d; /* 收藏后的金色 */
}
.diary-content {
    font-size: 15px;
    line-height: 1.7;
    color: var(--text-color);
    white-space: pre-wrap; /* 保留日记中的换行 */
    word-wrap: break-word;
}

        .gift-card {
            width: 230px;
            background-color: #fff;
            border: 2px solid #333;
            border-radius: var(--border-radius);
            box-shadow: 4px 4px 0px #ddd;
            padding: 10px;
            display: flex;
            align-items: center;
            cursor: pointer;
            margin: 0 8px;
            position: relative;
            overflow: hidden;
        }

        .message-wrapper.sent .gift-card {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .gift-card {
            border-bottom-left-radius: 5px;
        }

        .gift-card-icon {
            width: 50px;
            height: 50px;
            margin-right: 15px;
            flex-shrink: 0;
        }

        .gift-card-text {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            font-family: 'Comic Sans MS', 'Chalkduster', 'Handwriting', cursive;
        }

        .gift-card-description {
            font-size: 14px;
            color: #555;
            background-color: rgba(240, 240, 240, 0.9);
            padding: 8px 12px;
            margin-top: 5px;
            margin-left: 54px;
            margin-right: 54px;
            border-radius: 10px;
            line-height: 1.6;
            max-width: calc(100% - 108px);
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .gift-card-description.active {
            display: block;
        }

        .message-wrapper.sent .gift-card-description {
            align-self: flex-end;
            margin-right: 54px;
            margin-left: auto;
        }

        .message-wrapper.received .gift-card-description {
            align-self: flex-start;
            margin-left: 54px;
            margin-right: auto;
        }

        .gift-card-received-stamp {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 14px;
            font-weight: bold;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 2px 6px;
            transform: rotate(15deg);
            opacity: 0;
            transition: opacity 0.3s ease;
            font-family: 'Comic Sans MS', 'Chalkduster', 'Handwriting', cursive;
        }

        .gift-card.received .gift-card-received-stamp {
            opacity: 1;
        }
        .file-card {
            width: 240px;
            background-color: #fff;
            border: 1px solid #e0e0e0;
            border-radius: var(--border-radius);
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            margin: 0 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .message-wrapper.sent .file-card {
            border-bottom-right-radius: 5px;
        }
        .message-wrapper.received .file-card {
            border-bottom-left-radius: 5px;
        }
        .file-card-icon {
            width: 48px;
            height: 48px;
            flex-shrink: 0;
        }
        .file-card-info {
            overflow: hidden;
            flex-grow: 1;
        }
        .file-card-name {
            font-size: 15px;
            font-weight: 500;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin: 0 0 4px 0;
        }
        .file-card-size {
            font-size: 12px;
            color: #888;
            margin: 0;
        }
                .location-card {
            width: 250px;
            background-color: #fff;
            border: 1px solid #e0e0e0;
            border-radius: var(--border-radius);
            margin: 0 8px;
            overflow: hidden;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .message-wrapper.sent .location-card {
            border-bottom-right-radius: 5px;
        }
        .message-wrapper.received .location-card {
            border-bottom-left-radius: 5px;
        }
        .location-card-info {
            padding: 10px 12px;
            border-bottom: 1px solid #f0f0f0;
        }
        .location-main {
            font-size: 16px;
            color: #222;
            margin: 0 0 4px 0;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .location-detail {
            font-size: 12px;
            color: #888;
            margin: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .location-map {
            width: 100%;
            height: 140px;
            background-size: cover;
            background-position: center;
            background-image: url('https://i.postimg.cc/L8gYhF4Q/share-image-1755433372879-edit-155975507275678.jpg'); /* Placeholder map image */
        }
        .load-more-btn {
            background-color: #e0e0e0;
            color: #757575;
            border: none;
            padding: 8px 16px;
            margin: 10px auto;
            border-radius: 15px;
            cursor: pointer;
            display: block;
            font-size: 13px;
            font-weight: 500;
        }

        .load-more-btn:hover {
            background-color: #d1d1d1;
        }

        .typing-indicator {
            text-align: center;
            color: #aaa;
            font-style: italic;
            font-size: 14px;
            padding: 10px 0;
            display: none;
        }

        #sticker-bar {
    flex-shrink: 0;
    padding: 0 10px 5px;
    display: flex;
    align-items: center;
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(10px);
    overflow-x: auto; /* 新增：允许横向滚动 */
    /* 以下为可选代码，用于在某些浏览器上隐藏滚动条，但保留滚动功能 */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none;  /* IE 10+ */
}




/* --- 恢复图标栏的左右滑动功能 --- */
#sticker-bar {
    flex-shrink: 0;
    padding: 5px 10px; /* 左右留出一些边距 */
    display: flex;
    align-items: center;
    gap: 0px; /* 设置图标之间的固定间距 */
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(10px);

    /* 核心改动：允许X轴（横向）滚动 */
    overflow-x: auto; 
    overflow-y: hidden; /* 禁止垂直方向滚动 */

    /* 以下代码是为了在视觉上隐藏滚动条，但保留滚动功能，让界面更美观 */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none;  /* IE 10+ */
}

#sticker-bar::-webkit-scrollbar {
    display: none; /* Chrome, Safari, Opera */
}

#sticker-bar .sticker-bar-btn {
    padding: 5px; /* 减小按钮的内边距，让它本身更小 */
    margin: 0; /* 移除所有按钮可能存在的外边距 */
    background: none;
    border: none;
    cursor: pointer;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s ease;
}

#sticker-bar .sticker-bar-btn:hover {
    background-color: rgba(0, 0, 0, 0.05);
}

#sticker-bar .sticker-bar-btn svg {
    width: 24px;  /* 关键：适当缩小图标本身的大小以适应空间 */
    height: 24px;
    fill: #888; /* 确保所有图标都有一个统一的默认颜色 */
}

/* 如果特定按钮有额外样式，比如背景色，可以单独设置 */
#rollback-btn {
    /* 保持默认的背景，或者可以设置一个更亮的颜色 */
    background: rgba(0, 0, 0, 0.03); /* 稍微有点背景色，但保持间距 */
    border-radius: 50%; /* 保持圆形 */
}
#rollback-btn:hover {
    background-color: rgba(0, 0, 0, 0.1);
}

        .sticker-bar-btn {
            background: none;
            border: none;
            padding: 5px;
            cursor: pointer;
        }

        .sticker-bar-btn svg {
            width: 28px;
            height: 28px;
            fill: #888;
        }

        #sticker-modal {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 35%;
            max-height: 250px;
            background: #f7f7f7;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.1);
            z-index: 25;
            display: none;
            flex-direction: column;
        }

        #sticker-modal.visible {
            display: flex;
            animation: slideUp 0.3s ease-out;
        }

        #sticker-modal .header {
            padding: 10px 15px;
            font-weight: bold;
            color: var(--text-color);
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sticker-grid {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 15px;
        }

        .sticker-item {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }

        .sticker-item img {
            width: 60px;
            height: 60px;
            object-fit: contain;
        }

        .sticker-item span {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            text-align: center;
        }

        #add-sticker-modal .modal-window {
            max-width: 360px;
        }

        #sticker-preview {
            width: 100px;
            height: 100px;
            border: 2px dashed #ddd;
            border-radius: 10px;
            margin: 0 auto 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #aaa;
            background-color: #f9f9f9;
        }

        #sticker-preview img {
            max-width: 100%;
            max-height: 100%;
        }

        .chat-input-wrapper {
            flex-shrink: 0;
        }

        .message-input-area {
            display: flex;
            align-items: center;
            padding: 10px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            border-top: 1px solid #eee;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            flex-shrink: 0;
            gap: 10px;
            border-bottom-left-radius: var(--phone-corner-radius);
            border-bottom-right-radius: var(--phone-corner-radius);
            overflow: hidden;
        }

        .message-input-area input {
            flex-grow: 1;
            border: none;
            padding: 12px;
            border-radius: 18px;
            background-color: #f0f0f0;
        }

        .message-input-area input:focus {
            outline: none;
        }

        .message-input-area .icon-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .message-input-area .icon-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .message-input-area .icon-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .message-input-area .icon-btn.send-btn {
            font-size: 18px;
        }

        #multi-select-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            border-top: 1px solid #eee;
            z-index: 20;
            border-bottom-left-radius: var(--phone-corner-radius);
            border-bottom-right-radius: var(--phone-corner-radius);
            animation: slideUp 0.3s ease-out;
        }

        #multi-select-bar.visible {
            display: flex;
        }

        .settings-sidebar {
            position: absolute;
            top: 0;
            right: -100%;
            width: 80%;
            height: 100%;
            background: #fff;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.1);
            transition: right 0.4s ease-in-out;
            z-index: 101;
            display: flex;
            flex-direction: column;
        }

        .settings-sidebar.open {
            right: 0;
        }

        .settings-sidebar .header {
            padding: 15px;
            border-bottom: 1px solid #eee;
            font-weight: bold;
            text-align: center;
            color: var(--primary-color);
        }

        .settings-sidebar .content {
            padding: 20px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .settings-sidebar .form-group textarea {
            height: 100px;
            resize: vertical;
        }

        .settings-sidebar .avatar-setting {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .settings-sidebar .avatar-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--primary-color);
            cursor: pointer;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--secondary-color);
            font-weight: 600;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #fce4ec;
            border-radius: 10px;
            background-color: #fff;
            transition: border-color 0.3s;
            font-family: var(--font-family);
            font-size: 14px;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .form-group.radio-group {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .form-group.radio-group label {
            margin-bottom: 0;
        }

        .btn {
            width: 100%;
            padding: 15px;
            border-radius: 10px;
            border: none;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-align: center;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: var(--white-color);
        }

        .btn-primary:hover {
            background-color: var(--secondary-color);
            box-shadow: 0 4px 15px rgba(255, 128, 171, 0.5);
        }

        label.btn-primary {
            color: var(--white-color) !important;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 14px;
            width: auto;
        }

        .btn-secondary {
            background-color: var(--accent-color);
            color: var(--white-color);
            margin-bottom: 15px;
        }

        .btn-secondary:hover {
            background-color: #64b5f6;
            box-shadow: 0 4px 15px rgba(144, 202, 249, 0.5);
        }

        .btn-neutral {
            background-color: #bdbdbd;
            color: var(--white-color);
        }

        .btn-neutral:hover {
            background-color: #9e9e9e;
        }

        .btn-danger {
            background-color: #ef5350;
            color: white;
        }

        .btn .spinner {
            display: none;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-top-color: var(--white-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .btn.loading .spinner {
            display: block;
        }

        .btn.loading .btn-text {
            display: none;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

         .wallpaper-preview {
            width: 100%;
            aspect-ratio: 9 / 16;
            max-height: 200px; /* 修改：将最大高度从 400px 缩小到 300px */
            border-radius: var(--border-radius);
            margin-bottom: 15px; /* 修改：将底部间距从 25px 缩小到 15px */
            background-size: cover;
            background-position: center;
            border: 3px dashed var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--secondary-color);
            font-style: italic;
            background-color: #fff8fa;
        }

        .toast {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 15px;
            font-size: 14px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
            z-index: 1000;
        }

        .toast.show {
            opacity: 1;
            visibility: visible;
        }

        #world-book-selection-modal,
        #invite-member-modal,
        #group-recipient-selection-modal {
            z-index: 102;
        }

        #world-book-selection-modal .modal-window,
        #invite-member-modal .modal-window,
        #group-recipient-selection-modal .modal-window {
            width: 90%;
            max-width: 380px;
        }

        #world-book-selection-list,
        #invite-member-selection-list,
        #group-recipient-selection-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 40vh;
            overflow-y: auto;
        }

        .world-book-select-item,
        .invite-member-select-item,
        .group-recipient-select-item {
            display: flex;
            align-items: center;
            padding: 12px 5px;
            border-bottom: 1px solid #f0f0f0;
        }

        .world-book-select-item:last-child,
        .invite-member-select-item:last-child,
        .group-recipient-select-item:last-child {
            border-bottom: none;
        }

        .world-book-select-item input[type="checkbox"],
        .invite-member-select-item input[type="checkbox"],
        .group-recipient-select-item input[type="checkbox"] {
            margin-right: 15px;
            width: 20px;
            height: 20px;
        }

        .world-book-select-item label,
        .invite-member-select-item label,
        .group-recipient-select-item label {
            font-weight: 500;
            color: var(--text-color);
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .invite-member-select-item img,
        .group-recipient-select-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }

        /* --- Group Chat Specific Styles --- */
        .member-selection-list {
            list-style: none;
            padding: 0;
            margin: 15px 0;
            max-height: 40vh;
            overflow-y: auto;
        }

        .member-selection-item {
            display: flex;
            align-items: center;
            padding: 10px 5px;
            border-bottom: 1px solid #f0f0f0;
        }

        .member-selection-item:last-child {
            border-bottom: none;
        }

        .member-selection-item input[type="checkbox"] {
            margin-right: 15px;
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }

        .member-selection-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
        }

        .member-selection-item label {
            font-weight: 500;
            color: var(--text-color);
        }

        #group-settings-sidebar .group-avatar-setting {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        #group-settings-sidebar .group-avatar-preview {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            object-fit: cover;
            border: 2px solid var(--primary-color);
            cursor: pointer;
        }

        #group-settings-sidebar .group-members-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }

        #group-settings-sidebar .group-member,
        #group-settings-sidebar .add-member-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }

        #group-settings-sidebar .group-member img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 5px;
            border: 2px solid #eee;
        }

        #group-settings-sidebar .add-member-btn .add-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px dashed #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ccc;
            margin-bottom: 5px;
            transition: all 0.2s ease;
        }

        #group-settings-sidebar .add-member-btn:hover .add-icon {
            color: var(--primary-color);
            border-color: var(--primary-color);
        }

        #group-settings-sidebar .group-member span,
        #group-settings-sidebar .add-member-btn span {
            font-size: 12px;
            text-align: center;
            color: var(--text-color);
        }

        #customize-screen .icon-custom-item {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #f0f0f0;
        }

        #customize-screen .icon-custom-item:last-child {
            border-bottom: none;
        }

        #customize-screen .icon-preview {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            object-fit: cover;
            flex-shrink: 0;
        }

        #customize-screen .icon-details {
            flex-grow: 1;
        }

        #customize-screen .icon-details p {
            margin: 0 0 8px 0;
            font-weight: 600;
        }

        #customize-screen .icon-details input {
            width: calc(100% - 70px);
        }

        #customize-screen .reset-icon-btn {
            background: #e0e0e0;
            color: #555;
            border: none;
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 10px;
        }

        /* --- Tutorial Screen Styles --- */
        .tutorial-item {
            margin-bottom: 15px;
            border: 1px solid #fce4ec;
            border-radius: 12px;
            overflow: hidden;
            background-color: #fff8fa;
        }

        .tutorial-header {
            padding: 12px 18px;
            font-weight: 600;
            color: var(--secondary-color);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tutorial-header::after {
            content: '▼';
            font-size: 12px;
            transition: transform 0.3s ease;
        }

        .tutorial-item.open .tutorial-header::after {
            transform: rotate(180deg);
        }

        .tutorial-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, padding 0.5s ease;
            padding: 0 10px;
        }

        .tutorial-item.open .tutorial-content {
            padding: 10px 10px;
            /* A large value to ensure it expands to fit the content */
            max-height: 5000px;
        }

        .tutorial-content img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            display: block;
        }
     /* --- Voice Call Styles --- */
.sticker-bar-btn#voice-call-btn {
    display: none; /* Initially hidden, shown only in private chats */
}

#voice-call-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    z-index: 300;
    display: none;
    flex-direction: column;
    /* 修改: 不再垂直居中，改为从顶部开始排列元素 */

    align-items: center;
    color: white;
    text-align: center;
    padding: 20px;
    animation: fadeIn 0.3s ease;
}

#voice-call-overlay.visible {
    display: flex;
}

.call-avatar-large {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 20px;
    border: 4px solid rgba(255, 255, 255, 0.5);
    /* 修改: 增加顶部外边距，让头像不会紧贴屏幕顶部 */
    margin-top: 40px; 
    flex-shrink: 0; /* 防止在flex布局中被压缩 */
}

.call-name {
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 10px;
    flex-shrink: 0;
}

.call-status {
    font-size: 16px;
    color: #ccc;
    min-height: 24px;
    flex-shrink: 0;
}

/* 来电/去电时的按钮组样式保持不变 */
.call-button-group {
    position: absolute;
    bottom: 80px;
    left: 0;
    width: 100%;
    display: flex;
    justify-content: space-around;
    align-items: center;
}
.call-button {
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
    background: none;
    border: none;
    color: white;
}
.call-button .icon-wrapper {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 10px;
}
.call-button svg {
    width: 36px;
    height: 36px;
    fill: white;
}
.call-button.decline .icon-wrapper {
    background-color: #ef5350;
}
.call-button.accept .icon-wrapper {
    background-color: #4CAF50;
}

/* --- 通话中界面的核心修改 --- */
/* 【请用下面这段修正后的代码替换上面的代码】 */
#active-call-view {
    display: none;
    flex-direction: column;
    width: 100%;
    flex: 1; /* 修正：使用flex: 1简写属性，确保容器能强力占据所有可用垂直空间 */
    min-height: 0; /* 保留：这是一个重要的Flexbox布局技巧，防止内部聊天框溢出 */
}

/* 隐藏之前版本添加的、现在不需要的顶部固定header */
#active-call-header {
    display: none !important;
}

/* 文字聊天面板（图片中橙色框区域） */
#call-transcript-area {
    flex-grow: 1; /* 占据 #active-call-view 内的所有可用垂直空间 */
    overflow-y: auto; /* 当内容超出时，允许滚动 */
    padding: 10px;
    margin-top: 15px; /* 与顶部的状态计时器保持一定间距 */
    margin-bottom: 15px; /* 与下方的挂断按钮保持一定间距 */
    font-size: 15px;
    line-height: 1.7;
    -webkit-overflow-scrolling: touch; /* 优化在移动设备上的滚动体验 */
    text-align: left; /* 聊天内容左对齐，更易于阅读 */
}
.call-transcript-line {
    margin-bottom: 12px;
}
.call-transcript-line .action {
    color: #aaa;
    font-style: italic;
}
.call-transcript-line .dialog {
    color: #fff;
}

/* 底部操作区（挂断按钮和输入框） */
#hangup-button-container {
    position: static; /* 移除绝对定位，使其成为flex布局的一部分 */
    padding: 10px 0;
    flex-shrink: 0; /* 防止被压缩 */
}
#call-input-area {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    width: 100%;
    flex-shrink: 0;
}
#call-input {
    flex-grow: 1;
    border: none;
    padding: 12px;
    border-radius: 18px;
    background-color: rgba(255, 255, 255, 0.2);
    color: white;
}
#call-input::placeholder {
    color: #ccc;
}
#send-call-message-btn {
    background: var(--primary-color);
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    cursor: pointer;
    color: white;
    font-size: 18px;
    flex-shrink: 0;
}

/* --- 音乐播放器弹窗样式 --- */
#music-player-modal .modal-window {
    width: 90%;
    max-width: 360px;
    padding: 0; /* 移除内边距，方便自定义布局 */
    overflow: hidden;
    background: #fafafa;
}
.music-player-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    border-bottom: 1px solid #eee;
}
.music-player-header .song-title {
    font-size: 16px;
    font-weight: 600;
    margin: 0;
}
.music-player-header .share-btn {
    width: 24px; height: 24px; fill: #888;
}
.music-player-body {
    padding: 25px 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
}
.music-album-art {
    width: 180px;
    height: 180px;
    border-radius: 15px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    margin-bottom: 25px;
}
.music-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 25px;
    margin-top: 20px;
}
.music-controls button {
    background: none;
    border: none;
    cursor: pointer;
}
.music-controls .play-btn svg {
    width: 60px; height: 60px;
}
.music-controls .side-btn svg {
    width: 32px; height: 32px;
}
.music-extra-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    padding: 15px 25px;
}
.music-extra-controls button {
     background: none; border: none; cursor: pointer;
}
.music-extra-controls svg {
    width: 26px; height: 26px; fill: #555;
}
.lyrics-panel-placeholder {
    height: 60px; /* 歌词面板占位 */
    width: 100%;
    background: #f0f0f0;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #aaa;
    margin-top: 15px;
}
/* --- 歌词面板样式 (新添加) --- */
.lyrics-panel {
    width: 100%;
    height: 60px; /* 固定高度 */
    margin-top: 15px;
    overflow: hidden; /* 隐藏容器外部的内容 */
    text-align: center;
    position: relative;
    -webkit-mask-image: linear-gradient(to bottom, 
        transparent 0%, 
        black 25%, 
        black 75%, 
        transparent 100%
    );
    mask-image: linear-gradient(to bottom, 
        transparent 0%, 
        black 25%, 
        black 75%, 
        transparent 100%
    );
}
.lyrics-panel-inner {
    transition: transform 0.5s ease-out; /* 平滑滚动效果 */
}
.lyric-line {
    margin: 0;
    padding: 4px 0;
    font-size: 15px;
    color: #888;
    line-height: 1.5;
    transition: all 0.3s ease;
}
.lyric-line.active {
    color: var(--primary-color);
    font-weight: 600;
    font-size: 16px;
    transform: scale(1.05);
}
/* --- 音乐分享卡片样式 --- */
.music-card {
    width: 240px;
    background-color: #fff;
    border-radius: var(--border-radius);
    padding: 12px;
    display: flex;
    align-items: center;
    gap: 12px;
    cursor: pointer;
    margin: 0 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    border: 1px solid #eee;
}
.message-wrapper.sent .music-card {
    border-bottom-right-radius: 5px;
}
.message-wrapper.received .music-card {
    border-bottom-left-radius: 5px;
}
.music-card-icon {
    width: 48px;
    height: 48px;
    flex-shrink: 0;
    border-radius: 8px;
    object-fit: cover;
}
.music-card-info {
    overflow: hidden;
    flex-grow: 1;
}
.music-card-title {
    font-size: 15px;
    font-weight: 500;
    color: #333;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin: 0 0 4px 0;
}
.music-card-artist {
    font-size: 12px;
    color: #888;
    margin: 0;
}
/* === 可缩放变量（作用域：仅聊天室屏幕） === */
#chat-room-screen {
  --bubble-scale: 1;
  --bubble-font-base: 15px;
}
#chat-room-screen .message-area {
  font-size: calc(var(--bubble-font-base) * var(--bubble-scale));
}
#chat-room-screen .message-bubble {
  font-size: 1em !important;
  padding: 0.533em 0.8em !important;
  max-width: calc(260px * var(--bubble-scale)) !important;
}
#chat-room-screen .system-notification-bubble {
  font-size: 0.8em !important;
  padding: 0.4em 0.67em !important;
}
#chat-room-screen .voice-bubble {
  font-size: 1em !important;
  padding: 0.533em 0.8em !important;
  min-width: calc(90px * var(--bubble-scale)) !important;
  max-width: calc(200px * var(--bubble-scale)) !important;
}
#chat-room-screen .voice-bubble .duration { font-size: 0.87em !important; }
#chat-room-screen .image-bubble { max-width: calc(120px * var(--bubble-scale)) !important; }
#chat-room-screen .pv-card { width: calc(230px * var(--bubble-scale)) !important; font-size: 1em !important; }
#chat-room-screen .transfer-card { width: calc(240px * var(--bubble-scale)) !important; font-size: 1em !important; }
#chat-room-screen .gift-card { width: calc(230px * var(--bubble-scale)) !important; font-size: 1em !important; }
#chat-room-screen .gift-card-description,
#chat-room-screen .voice-transcript {
  font-size: 0.93em !important;
  line-height: 1.6;
}
#chat-room-screen .message-bubble,
#chat-room-screen .voice-bubble,
#chat-room-screen .pv-card,
#chat-room-screen .transfer-card,
#chat-room-screen .gift-card {
  border-radius: calc(var(--border-radius) * var(--bubble-scale)) !important;
}

/* DEBUG FIXES: ensure active screen uses flex and phone-screen is positioned */
.phone-screen { position: relative !important; }
.screen { display: none !important; }
.screen.active { display: flex !important; }
.modal-overlay { position: absolute !important; }


/* --- moment image description card (injected) --- */
.moment-image-desc-card {
  background: linear-gradient(135deg, rgba(238, 156, 167, 0.3), rgba(255, 221, 225, 0.3)); /* 半透明粉色渐变背景 */
  border-radius: 10px;
  padding: 12px 14px;
  margin-top: 6px;
  color: #fff;
  position: relative;
  overflow: hidden;
  box-shadow: 0 6px 18px rgba(0,0,0,0.06);
  /* min-height: 86px; */
  display: flex;
  align-items: center;
  cursor: pointer;
  backdrop-filter: blur(10px); /* 关键：毛玻璃模糊效果 */
  -webkit-backdrop-filter: blur(10px); /* 兼容 Safari */
  border: 1px solid rgba(255, 255, 255, 0.3); /* 增加玻璃质感边框 */
}


/* === 覆盖：仅改变卡片外框与配色（保留原文件卡片形状/布局/标题） === */
.moment-image-desc-card {
  /* 不改 width/height/border-radius/padding 等布局属性，保障原样式形状不变 */
  border: 6px solid #ffffff;
  box-shadow: 0 6px 20px rgba(10, 10, 20, 0.06);
  background: transparent !important;
}

/* 内层浅灰面板（只在存在内层类时覆盖背景色） */
.moment-image-desc-card .inner {
  background: #eef0f3 !important;
}

/* 将参考图中“标题色”应用到图片描述文字上：#66676b */
.moment-image-desc-card .desc-content,
  .moment-image-desc-card .description,
  .moment-image-desc-card .image-desc {
  color: #66676b !important;
}

/* 小屏微调（不改变布局） */
@media (max-width: 420px) {
  .moment-image-desc-card { box-shadow: 0 4px 14px rgba(10,10,20,0.05); }
}

/*
.moment-image-desc-card::before {
  content: '';
  position: absolute;
  inset: -12px;
  background: inherit;
  filter: blur(10px);
  transform: scale(1.08);
  z-index: 1;
  opacity: 0.95;
}
*/
.moment-image-desc-card .desc-content {
  position: relative;
  z-index: 2;
  font-style: italic;
  text-shadow: 0 1px 3px rgba(0,0,0,0.45);
  line-height: 1.4;
  font-size: 13px;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  /* -webkit-line-clamp: 4; */
  overflow: hidden;
  word-break: break-word;
  /* max-height: calc(1.4em * 4); */
}
@media (max-width: 420px) {
  .moment-image-desc-card { padding: 9px; /* min-height: 72px; */ }
  .moment-image-desc-card .desc-content { /* -webkit-line-clamp: 3; */ }
}/* --- 钱包功能新增样式 --- */
.wallet-balance-card {
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
    color: white;
    padding: 25px;
    border-radius: var(--border-radius);
    text-align: center;
    margin-bottom: 30px;
    box-shadow: 0 8px 25px rgba(255, 128, 171, 0.3);
}
.wallet-balance-label {
    margin: 0 0 10px 0;
    font-size: 16px;
    opacity: 0.9;
}
.wallet-balance-amount {
    margin: 0;
    font-size: 42px;
    font-weight: 600;
}
.wallet-actions-list {
    background-color: #fff;
    border-radius: var(--border-radius);
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    overflow: hidden;
}
.wallet-action-item {
    padding: 18px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 16px;
    cursor: pointer;
    border-bottom: 1px solid #f0f0f0;
}
.wallet-action-item:last-child {
    border-bottom: none;
}
.wallet-action-item:hover {
    background-color: #fdf6f8;
}

/* 交易明细样式 */
.transaction-item {
    display: flex;
    justify-content: space-between;
    padding: 12px 5px;
    border-bottom: 1px solid #f0f0f0;
}
.transaction-details {
    display: flex;
    flex-direction: column;
}
.transaction-description {
    font-weight: 500;
    color: #333;
}
.transaction-timestamp {
    font-size: 12px;
    color: #999;
    margin-top: 4px;
}
.transaction-amount {
    font-weight: bold;
    font-size: 16px;
}
.transaction-amount.expense {
    color: #333;
}
.transaction-amount.income {
    color: #4CAF50; /* 收入用绿色表示 */
}
/* --- HTML小剧场显示高度自适应修复 --- */
.ai-generated-theater {
    width: auto;         /* 宽度由内容决定，但不能超过父容器 */
    max-width: 100%;      /* 保持最大宽度限制 */
    height: auto;        /* 关键：高度自动适应内部内容 */
    min-height: 20px;    /* 设置一个最小高度，避免空内容时塌陷 */
    display: inline-block; /* 改为行内块元素，使其能更好地包裹内容 */
    overflow: visible;   /* 允许内部的绝对定位或阴影元素稍微溢出 */
    box-sizing: border-box;
}

/* 确保AI生成的内部元素也能正常显示 */
.ai-generated-theater > * {
    max-width: 100%;
    box-sizing: border-box;
}
/* 确保小剧场在发送方和接收方位置正确 */
.message-wrapper.sent .ai-generated-theater {
    align-self: flex-end;
}
.message-wrapper.received .ai-generated-theater {
    align-self: flex-start;
}
/* --- AI空间对话气泡样式修复与美化 (AI Space Bubble Fix & Styling) --- */

/* 核心：为“对方”的消息（received）定义样式 */
#ai-message-area .message-wrapper.received .message-bubble {
    /* 1. 强制为对方消息添加一个默认的灰色气泡背景，解决“没有气泡”的问题 */
    background-color: #f0f0f0;
    color: #333;

    /* 2. 将气泡设置为椭圆形，并移除尖角 */
    border-radius: 20px; /* 您可以调整这个值来改变椭圆的圆润程度 */
}

/* 确保主视角AI自己发送的消息（sent）也有默认的粉色气泡（以防万一） */
#ai-message-area .message-wrapper.sent .message-bubble {
    background-color: var(--primary-color);
    color: white;
    border-radius: 20px;
    border-bottom-right-radius: 5px; /* 依然可以保留自己消息的尖角，如果想去掉也改成20px即可 */
}

/* 对于HTML小剧场等特殊内容，确保它们在AI空间也能正常显示 */
#ai-message-area .ai-generated-theater {
    max-width: 90%;
    margin: 0 8px;
}
/* --- 群头衔定位修正代码 --- */

/* 用于包裹头衔和昵称的容器 */
.group-message-header {
    display: flex;
    align-items: center;
    margin-bottom: 4px; /* 头衔与气泡的垂直间距 */
    padding: 0; /* 移除固定的左右内边距，以便灵活对齐 */
    position: absolute; /* 使用绝对定位进行精确定位 */
    top: 0;
    width: calc(100% - 44px); /* 限制宽度，避免溢出 */
}

/* AI消息 (对方): 头衔/昵称显示在头像右侧，气泡上方 */
.message-wrapper.received .group-message-header {
    justify-content: flex-start; /* 内容靠左 */
    left: 44px; /* 距离左侧 = 头像宽度(36px) + 间距(8px) */
}

/* 用户消息 (自己): 头衔/昵称显示在头像左侧，气泡上方 */
.message-wrapper.sent .group-message-header {
    justify-content: flex-end; /* 内容靠右 */
    right: 44px; /* 距离右侧 = 头像宽度(36px) + 间距(8px) */
}

/* 消息气泡行需要向下移动，为头衔留出空间 */
.group-message .message-bubble-row {
    margin-top: 18px; /* 留出足够的垂直空间 */
}

/* 群成员昵称的样式 */
.group-sender-name {
    font-size: 12px;
    color: #888;
}

/* 群头衔徽章的样式 */
.group-title-badge {
    display: inline-block;
    padding: 2px 6px;
    font-size: 9px;
    font-weight: bold;
    border-radius: 4px;
    color: #fff;
    background: linear-gradient(135deg, #6e8efb, #a777e3); /* 默认颜色 */
    vertical-align: middle;
    margin-right: 4px; /* 徽章和昵称之间的间距 */
}

/* 用户消息中，头衔在昵称右侧，需要调整间距 */
.message-wrapper.sent .group-title-badge {
    margin-right: 0;   /* 移除右边距 */
    margin-left: 4px;  /* 增加左边距 */
}

/* 确保旧的样式被正确覆盖 */
.group-nickname {
    position: static;
    width: auto;
    text-align: left;
    overflow: visible;
    text-overflow: clip;
}

/* 不同等级头衔的颜色 (保持不变) */
.group-title-badge.lv26 { background: linear-gradient(135deg, #ffaf7b, #ff8c5a); color: #fff; }
.group-title-badge.lv12 { background: linear-gradient(135deg, #d4a4f2, #b57be5); color: #fff; }
.group-title-badge.lv11 { background: linear-gradient(135deg, #ffc0cb, #ff9eaf); color: #c72c48; }
.group-title-badge.lv10 { background: linear-gradient(135deg, #cfd9df, #e2ebf0); color: #5d707f; }
 /* --- 世界书分类功能样式 --- */
.world-book-category {
    margin-bottom: 10px;
    border-radius: var(--border-radius);
    background-color: #fff8fa;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    overflow: hidden;
}
.category-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    cursor: pointer;
    background-color: #fff;
    border-bottom: 1px solid #f0f0f0;
}
.category-header:hover {
    background-color: #fdf6f8;
}
.category-name {
    font-weight: 600;
    font-size: 16px;
    color: var(--secondary-color);
}
.category-toggle-icon {
    transition: transform 0.3s ease;
    font-weight: bold;
    color: var(--secondary-color);
}
.world-book-category.collapsed .category-toggle-icon {
    transform: rotate(-90deg);
}
.category-book-list {
    list-style: none;
    margin: 0;
    padding: 0;
    transition: max-height 0.5s ease-in-out, padding 0.5s ease;
    max-height: 5000px; /* A large value to ensure it can contain many items */
    overflow: hidden;
}
.world-book-category.collapsed .category-book-list {
    max-height: 0;
}
/* 分类下的世界书条目样式微调 */
.category-book-list .list-item {
    border-top: 1px solid #f0f0f0;
    border-bottom: none;
}

 /* --- 新增：头像框功能样式 --- */

/* 用于包裹头像和头像框的容器 */
.avatar-container, .avatar-container-setting {
    position: relative;
    display: inline-block;
    flex-shrink: 0;
    /* 确保容器大小与内部头像一致 */
    line-height: 0; 
}
.avatar-container-setting {
    width: 60px;
    height: 60px;
}
.message-info .avatar-container {
    width: 36px;
    height: 36px;
}

/* 设置面板中的“星星”按钮 */
.avatar-frame-btn {
    padding: 5px 10px !important;
    font-size: 16px !important;
    line-height: 1 !important;
    min-width: auto !important;
    align-self: center; /* 垂直居中对齐 */
}
/* 头像框图片样式 (尺寸已调整) */
.avatar-frame {
    position: absolute;
    /* 核心修改：通过负边距将其放大并重新居中 */
    width: 125%;      /* 将宽度设为头像的1.25倍 */
    height: 125%;     /* 将高度设为头像的1.25倍 */
    top: -16.5%;      /* 向上移动多出高度的一半 */
    left: -12.5%;     /* 向左移动多出宽度的一半 */
    
    pointer-events: none; /* 允许点击穿透到下面的头像 */
    z-index: 2;
}
/* 调整设置项的间距以容纳按钮 */
.avatar-setting {
    gap: 8px; 
}

/* 头像框选择面板样式 */
#avatar-frame-modal .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}
#avatar-frame-modal h3 {
    margin: 0;
}
#avatar-frame-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 15px;
    max-height: 50vh;
    overflow-y: auto;
    padding: 10px;
    background-color: #f9f9f9;
    border-radius: 8px;
    min-height: 100px;
}
.frame-item {
    position: relative;
    width: 80px;
    height: 80px;
    cursor: pointer;
    border: 3px solid transparent;
    border-radius: 12px;
    transition: all 0.2s ease-in-out;
    padding: 2px;
}
.frame-item.selected {
    border-color: var(--primary-color);
    transform: scale(1.05);
}
.frame-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 8px;
}
.frame-item .delete-frame-btn {
    position: absolute;
    top: -8px;
    right: -8px;
    width: 22px;
    height: 22px;
    background: #ef5350;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 14px;
    line-height: 22px;
    text-align: center;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.2s;
    z-index: 5;
}
.frame-item:hover .delete-frame-btn {
    opacity: 1;
}
#avatar-frame-modal .modal-footer {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 20px;
}

/* --- 商城购物流程 & 购物车样式 --- */
.purchase-flow-modal {
    padding: 15px;
}
.close-purchase-modal-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    background: none;
    border: none;
    font-size: 24px;
    color: #999;
    cursor: pointer;
}
.purchase-product-info {
    display: flex;
    align-items: flex-end;
    gap: 15px;
    padding-bottom: 15px;
    border-bottom: 1px solid #f0f0f0;
}
.purchase-product-info img {
    width: 80px;
    height: 80px;
    border-radius: 8px;
    object-fit: cover;
}
.purchase-product-info p {
    color: #e53935;
    font-size: 20px;
    font-weight: bold;
    margin: 0 0 5px 0;
}
.purchase-product-info h4 {
    font-size: 16px;
    margin: 0;
}
.purchase-section {
    padding: 15px 0;
}
.purchase-section h5 {
    margin: 0 0 10px 0;
    font-size: 14px;
    color: #555;
}
#recipient-selection-list {
    max-height: 25vh;
    overflow-y: auto;
}
#recipient-selection-list .list-item {
    padding: 10px 5px;
}
.style-options {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
}
.style-option-btn {
    padding: 8px 15px;
    border: 1px solid #ddd;
    background-color: #f5f5f5;
    color: #333;
    border-radius: 15px;
    cursor: pointer;
}
.style-option-btn.active {
    border-color: var(--primary-color);
    background-color: #fff0f5;
    color: var(--primary-color);
}
.quantity-section {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.quantity-selector {
    display: flex;
    align-items: center;
}
.quantity-selector .quantity-btn {
    width: 28px;
    height: 28px;
    border: 1px solid #ddd;
    background-color: #f5f5f5;
    font-size: 18px;
    cursor: pointer;
}
.quantity-selector input {
    width: 50px;
    height: 28px;
    text-align: center;
    border: 1px solid #ddd;
    border-left: none;
    border-right: none;
}

/* 购物车商品项样式 */
.cart-item {
    background-color: #fff;
    border-radius: 12px;
    padding: 15px;
    margin-bottom: 10px;
    display: flex;
    gap: 15px;
}
.cart-item-image {
    width: 90px;
    height: 90px;
    border-radius: 8px;
    object-fit: cover;
    flex-shrink: 0;
}
.cart-item-details {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}
.cart-item-title {
    font-size: 14px;
    margin: 0 0 8px 0;
}
.cart-item-price {
    font-size: 16px;
    font-weight: bold;
    color: #e53935;
    margin-top: auto;
}
.cart-item-actions {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    justify-content: space-between;
}
.cart-item-actions .to-pay-btn {
    padding: 6px 12px;
    font-size: 13px;
    background-color: #e53935;
    color: white;
}
.cart-payment-countdown {
    font-size: 12px;
    color: #e53935;
}

/* 发送到聊天中的商品名片样式 */
.product-delivery-card {
    width: 240px;
    background-color: #fff;
    border-radius: var(--border-radius);
    padding: 12px;
    display: flex;
    align-items: center;
    gap: 12px;
    margin: 0 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    border: 1px solid #eee;
}
.message-wrapper.sent .product-delivery-card {
    border-bottom-right-radius: 5px;
}
.product-delivery-card-icon {
    width: 48px;
    height: 48px;
    flex-shrink: 0;
    border-radius: 8px;
    object-fit: cover;
}
.product-delivery-card-info {
    overflow: hidden;
    flex-grow: 1;
}
.product-delivery-card-title {
    font-size: 15px;
    font-weight: 500;
    color: #333;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin: 0 0 4px 0;
}
.delivery-countdown-display {
    font-size: 12px;
    color: #e53935;
    font-weight: bold;
    margin: 0;
}
/* --- 商品详情页底部操作栏修复 --- */
#product-detail-screen {
    display: flex;
    flex-direction: column;
}

#product-detail-screen .content {
    flex-grow: 1;
    padding-bottom: 80px; /* 为底部操作栏留出足够空间 */
}

.detail-footer-nav {
    position: absolute; /* 改为绝对定位 */
    bottom: 0;
    left: 0;
    width: 100%;
    z-index: 10;
    height: auto; /* 高度自适应 */
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-top: 1px solid #eee;
    padding: 8px;
    display: flex;
    gap: 8px;
}

.detail-footer-nav .action-btn {
    flex: 1;
    border: none;
    border-radius: 20px;
    font-size: 14px; /* 适当减小字体 */
    font-weight: 600;
    cursor: pointer;
    padding: 12px 5px; /* 调整内边距 */
    background-color: #ffcdd2;
    color: var(--primary-color);
}
.detail-footer-nav .action-btn.primary {
    background-color: var(--primary-color);
    color: white;
}

/* 收藏按钮激活样式 */
.detail-footer-nav .action-btn.liked {
    background-color: #fff0f5;
    color: var(--primary-color);
    border: 1px solid var(--primary-color);
}
/* --- 新增：AI空间功能样式 --- */
#ai-space-photos-album-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 5px;
    padding: 5px;
}
.ai-photo-item {
    aspect-ratio: 1 / 1;
    background-color: #e9e9e9;
    border-radius: 8px;
    padding: 10px;
    font-size: 13px;
    color: #555;
    line-height: 1.5;
    overflow: hidden;
    cursor: pointer;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 5; /* 最多显示5行文字 */
}
.ai-transaction-item .item-details {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}
.ai-transaction-amount {
    font-weight: bold;
}
.ai-transaction-amount.expense {
    color: #d32f2f;
}
.ai-transaction-amount.income {
    color: #388e3c;
}
/* --- 新版购物车样式 --- */

#cart-item-list-container {
    padding-bottom: 120px !important; /* 为底部结算栏和导航栏留出空间 */
}

.cart-store-group {
    background-color: #fff;
    border-radius: 12px;
    margin: 0 10px 10px;
    padding: 10px;
}

.cart-store-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding-bottom: 10px;
    border-bottom: 1px solid #f5f5f5;
    font-size: 14px;
    font-weight: bold;
}

.cart-item {
    padding: 15px 0 15px 10px;
    display: flex;
    gap: 10px;
    align-items: center;
    border-bottom: 1px solid #f5f5f5;
}
.cart-store-group .cart-item:last-child {
    border-bottom: none;
}

/* 选择框样式 */
.cart-item-selector {
    width: 22px;
    height: 22px;
    border: 2px solid #ccc;
    border-radius: 50%;
    background-color: #fff;
    cursor: pointer;
    flex-shrink: 0;
    position: relative;
    transition: all 0.2s ease;
}

/* 选中时的样式 */
.cart-item.selected .cart-item-selector,
.select-all-container.selected .cart-item-selector {
    background-color: var(--primary-color);
    border-color: var(--primary-color);
}
.cart-item.selected .cart-item-selector::after,
.select-all-container.selected .cart-item-selector::after {
    content: '✓';
    color: white;
    font-size: 14px;
    font-weight: bold;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.cart-item-image {
    width: 80px;
    height: 80px;
}
.cart-item-details .cart-item-price {
    margin-top: 8px; /* 价格和标题拉开距离 */
}
.cart-item-actions {
    margin-left: auto; /* 将支付按钮推到最右侧 */
}

/* 底部结算栏 */
.cart-checkout-bar {
    position: absolute;
    bottom: 60px; /* 在主导航之上 */
    left: 0;
    right: 0;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    padding: 10px 15px;
    border-top: 1px solid #eee;
    display: flex;
    justify-content: space-between;
    align-items: center;
    z-index: 150;
}
.select-all-container {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
}
.checkout-info {
    display: flex;
    align-items: center;
    gap: 10px;
}
#cart-total-price {
    font-size: 16px;
    font-weight: bold;
    color: #e53935;
}
#cart-checkout-btn {
    padding: 8px 18px;
    border-radius: 18px;
}
#cart-delete-selected-btn {
    border-radius: 18px;
}

/* 管理模式切换 */
#mall-cart-screen.manage-mode #cart-checkout-btn,
#mall-cart-screen.manage-mode #cart-total-price {
    display: none;
}
#mall-cart-screen:not(.manage-mode) #cart-delete-selected-btn {
    display: none;
}


/* --- 【最终自适应方案 V2 - 修正版】--- */

:root {
    /* 定义一个全局的状态栏高度变量，方便统一调整 */
    --status-bar-height: 33px;
}

/* 
 * 1. 强制所有页面容器从屏幕最顶端(top:0)开始，并移除自身的顶部内边距。
 *    这是最关键的一步，用于覆盖掉“自动补丁”中错误的 top 偏移。
*/
.screen {
    top: 0 !important;
    padding-top: 0 !important;
    box-sizing: border-box !important;
}

/* 
 * 2. 为带标准标题栏的页面（包括聊天页）拉伸毛玻璃背景。
 *    原理：将状态栏空间作为内边距加到 header 内部，让其背景向上延伸。
*/
.app-header {
    padding-top: max(var(--status-bar-height), env(safe-area-inset-top)) !important;
    height: auto;
}

/* 
 * 3. 为主屏幕页面适配，让壁纸延伸。
 *    原理：将状态栏空间作为内边距加到页面本身，把内容推下去。
*/
#home-screen,
#home-screen-2 {
    padding-top: max(var(--status-bar-height), env(safe-area-inset-top)) !important;
    box-sizing: border-box !important;
}
/* --- 【商城专属】强制添加浅灰色毛玻璃状态栏 --- */

/* 
 * 1. 使用 ::before 伪元素，在商城页面的最顶部创建一个新的视觉层。
 *    这就像在页面顶部贴了一块半透明的玻璃。
*/
#mall-screen::before {
    content: ''; /* 伪元素必须有 content 属性才能显示 */
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    /* 高度会自动适配普通手机和iPhone刘海屏 */
    height: max(var(--status-bar-height, 44px), env(safe-area-inset-top));
    
    /* 设置为您想要的浅灰色毛玻璃效果 */
    background-color: rgba(220, 220, 220, 0.7);
    -webkit-backdrop-filter: blur(10px);
    backdrop-filter: blur(10px);
    
    /* 确保它在最顶层，能覆盖在原有的白色搜索栏之上 */
    z-index: 11; 
}

/* 
 * 2. 将商城原有的白色搜索栏(.mall-header)整体向下推移一个状态栏的高度。
*/
#mall-screen .mall-header {
    top: max(var(--status-bar-height, 44px), env(safe-area-inset-top));
}

/* 
 * 3. 将商城的内容区(.content)也向下推移，为“状态栏 + 搜索栏”同时留出空间。
*/
#mall-screen .content {
    /* 60px是搜索栏的高度, 再加上状态栏的高度 */
    padding-top: calc(60px + max(var(--status-bar-height, 44px), env(safe-area-inset-top))) !important;
}

/* --- 【最终方案】防止页面滑动偏移与溢出 --- */

/* 
 * 1. 针对 body 和 html (根源修复)
 *    - overflow-x: hidden;  禁止所有横向滚动。这是最关键的一步，能消除因内容溢出导致的滑动。
 *    - overscroll-behavior-x: none;  禁止“滑动到边缘时触发导航”的默认浏览器行为（如后退/前进）。
*/
html, body {
    overflow-x: hidden;
    overscroll-behavior-x: none;
}

/* 
 * 2. 针对 .phone-screen 容器 (加固措施)
 *    再次确保作为主容器的 .phone-screen 本身不会产生任何横向滚动。
*/
.phone-screen {
    overflow-x: hidden;
}

/* 
 * 3. 针对所有 .screen 页面 (保险措施)
 *    为每个独立的页面也加上这个规则，确保即使某个页面内部有宽度超出的元素，
 *    也不会导致整个页面容器被撑开。
*/
.screen {
    overflow-x: hidden;
}

    </style>
    <!-- === moments 固定在 phone-screen 内的修复样式 (自动插入补丁) === -->
<style>
/* --- 【最终修正 v4.0】Dock栏绝对固定在底部 & 内容区独立滚动 --- */

/* 
 * 1. 关键：将第一页(#home-screen)设为相对定位，并使其成为一个Flexbox容器。
 *    - position: relative; 为Dock栏创建定位上下文。
 *    - display: flex; flex-direction: column; 方便我们定义内部滚动区域。
*/
#home-screen {
    position: relative !important;
    display: flex !important;
    flex-direction: column !important;
    padding: 0 !important; /* 移除所有内边距，交由内部元素处理 */
    overflow: hidden !important; /* 隐藏所有溢出，防止页面过长 */
}

/*
 * 2. 关键：定义一个在Dock栏之上的、可独立滚动的内容区域。
 *    我们将所有原属于 #home-screen 的子元素都包裹在这个新区域里。
*/
#home-screen-content {
    flex-grow: 1;           /* 占据所有可用的垂直空间 */
    overflow-y: auto;       /* 当内容超出时，只滚动这个区域 */
    min-height: 0;          /* Flexbox布局的关键技巧，防止内容撑破容器 */
    padding: 50px 20px 120px 20px; /* 上、左右、下 的内边距。底部留出比Dock栏更高的空间 */
}

/* 
 * 3. Dock栏使用绝对定位，强制“粘”在 #home-screen 的最底部。
*/
.dock {
    position: absolute;
    bottom: 10px;
    left: 20px;
    right: 20px;
    
    /* 其他所有样式保持不变，确保美观和居中 */
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 15px;
    padding: 10px;
    background-color: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(10px);
    border-radius: var(--border-radius);
    z-index: 100;

    /* 清理所有不再需要的属性 */
    margin: 0;
    transform: none;
    width: auto;
}

/* 
 * 4. Dock栏内的图标缩放逻辑保持不变，确保能自动适配。
*/
.dock .app-icon {
    flex-shrink: 1;
    flex-grow: 0;
    flex-basis: 60px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-decoration: none;
}
.dock .app-icon .icon-img {
    max-width: 100%;
    height: auto;
    flex-shrink: 0;
}
/* 确保 phone-screen 做为裁切容器 */
.phone-screen {
  position: relative !important;
  overflow: hidden !important; /* 防止子元素跑出可视区 */
}

/* 把所有 screen 统一做绝对铺满，这样切换只影响可见性，不会改变布局流 */
.screen {
  position: absolute !important;
  top: max(var(--status-bar-height), env(safe-area-inset-top)); /* 从状态栏下方开始 */
  right: 0;
  bottom: 0;
  left: 0;
  height: auto !important; /* 高度自动填充剩余空间 */
  display: none !important;
  flex-direction: column;
  -webkit-overflow-scrolling: touch;
}

/* 激活的 screen 可见 */
.screen.active {
  display: flex !important;
}

/* 确保 screen 中的主内容区单独可滚动（不会把整个 screen 推出） */
/* --- 修复：聊天输入框因布局问题无法点击的补丁 (最终版) --- */
#chat-room-screen .content {
    flex-grow: 1;           /* 保持：让其填充可用空间 */
    overflow-y: auto;       /* 保持：内容超出时可滚动 */
    height: auto;           /* 新增/确认：高度由flexbox决定，不是固定的100% */
    min-height: 0;          /* 关键修复：防止内部内容撑破flex容器 */
    display: flex;          /* 确保内部元素也使用flex布局 */
    flex-direction: column; /* 垂直排列消息 */
    padding: 10px;          /* 保持原有的内边距 */
    padding-bottom: 10px;   /* 保持原有的内边距 */
}

/* 为动态页面的底部导航栏预留空间 */
#moments-screen .content {
    padding-bottom: 88px !important;
}

/* 防止 moments 页面被某些 transform/translate 推出视窗（保底） */
#moments-screen {
  transform: none !important;
  will-change: auto !important;
}

/* --- 调整右上角按钮组的间距 --- */
.app-header .action-btn-group {
    gap: 2px; /* 将按钮间的默认间距从 10px 减小到 4px */
}
/* --- 将回忆图标移动到标题栏最右侧 --- */
.app-header .action-btn-group #ai-memories-btn {
    order: 99;
}
/* --- 新的音乐播放器小部件样式（唱片机） --- */
.record-player-widget {
    /*
     * ===============================================
     * == 在这里自定义您的图片 URL ==
     * ===============================================
     * --record-sleeve-image: 替换为您想要的方形“唱片封套”图片。
     * --record-label-image:  替换为您想要的圆形“唱片标签”图片。
    */
    --record-sleeve-image: url('https://i.postimg.cc/KzC3q4w3/image.png'); /* 示例：带猫爪的半透明封面 */
    --record-label-image: url('https://i.postimg.cc/nzP9sgxr/chan-125.png');  /* 示例：动漫头像 */

    /* 使用变量控制整体大小 */
    --music-widget-scale: 1.3;
    
    position: relative;
    width: calc(130px * var(--music-widget-scale));
    height: calc(130px * var(--music-widget-scale));
    margin: 20px auto 15px auto;
    cursor: pointer;
}

.record-player-widget .record-sleeve {
    position: absolute;
    top: 50%;
    left: 0;
    transform: translateY(-50%);
    width: 100%;
    height: 100%;
    background-image: var(--record-sleeve-image);
    background-size: cover;
    background-position: center;
    background-color: rgba(255, 255, 255, 0.7); /* 图片加载失败时的底色 */
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.record-player-widget .vinyl-record {
    position: absolute;
    top: 50%;
    right: -20%; /* 让唱片从右侧伸出 */
    transform: translateY(-50%);
    width: 100%;
    height: 100%;
    background-color: #1a1a1a; /* 黑胶唱片的颜色 */
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    transition: transform 0.4s ease;
}

.record-player-widget:hover .vinyl-record {
    transform: translateY(-50%) translateX(8px); /* 鼠标悬浮时唱片向右移动 */
}

.record-player-widget .record-label {
    width: 70%;
    height: 70%;
    background-image: var(--record-label-image);
    background-size: cover;
    background-position: center;
    background-color: #fff; /* 图片加载失败时的底色 */
    border-radius: 50%;
    border: 2px solid #333; /* 标签周围的深色环 */
}
/* --- 购物车管理模式切换样式 --- */

/* 当进入管理模式时，隐藏“合计”和“去结算”按钮 */
#mall-cart-screen.manage-mode .checkout-info {
    display: none;
}

/* 当进入管理模式时，显示“删除”按钮 */
#mall-cart-screen.manage-mode #cart-delete-selected-btn {
    display: inline-flex; /* 或者 block, flex 等，根据您的按钮样式 */
    border-radius: 18px; /* 保持样式统一 */
}
/* --- 新增：支付确认页面样式 --- */
.payment-section {
    background-color: #fff;
    border-radius: 12px;
    padding: 15px;
    margin-bottom: 10px;
}
.address-section {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 14px;
    cursor: pointer;
}
.address-section .recipient { font-size: 16px; margin: 0 0 5px; }
.address-section .address { color: #666; margin: 0; }
.payment-item-card {
    display: flex;
    gap: 10px;
    padding: 10px 0;
    border-bottom: 1px solid #f5f5f5;
}
.payment-item-card:last-child { border-bottom: none; }
.payment-item-card img { width: 70px; height: 70px; border-radius: 8px; }
.payment-item-card .item-info { flex-grow: 1; }
.payment-item-card .item-name { font-size: 14px; margin: 0; }
.payment-item-card .item-price { font-size: 14px; font-weight: bold; margin-top: 8px; }
.payment-methods .method-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 12px 0;
    cursor: pointer;
}
.payment-methods .method-item.selected::after {
    content: '✓';
    color: var(--primary-color);
    font-size: 20px;
    margin-left: auto;
}
.payment-methods .method-item img { width: 24px; height: 24px; }
.payment-footer {
    position: absolute;
    bottom: 0; left: 0; right: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 20px;
    background: #fff;
    border-top: 1px solid #eee;
}
.payment-footer .total-price { color: #e53935; font-size: 18px; font-weight: bold; }
#confirm-final-payment-btn { padding: 10px 30px; border-radius: 20px; }

/* --- 新增：代付请求卡片样式 --- */
.payment-request-card {
    width: 240px;
    border-radius: var(--border-radius);
    margin: 0 8px;
    background: linear-gradient(135deg, #FFC107, #FF9800);
    color: white;
    padding: 15px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}
.payment-request-title { font-size: 14px; opacity: 0.9; }
.payment-request-amount { font-size: 32px; font-weight: bold; margin: 5px 0; }
.payment-request-desc { font-size: 13px; margin-bottom: 15px; }
.payment-request-actions { display: flex; gap: 10px; margin-top: 10px; }
.payment-request-actions button { flex: 1; border-radius: 8px; padding: 8px; }
.payment-request-status { font-weight: bold; text-align: center; margin-top: 10px; }

/* --- 新增：物流界面样式 --- */
.logistics-item {
    background-color: #fff;
    border-radius: 12px;
    padding: 15px;
    margin-bottom: 10px;
}
.logistics-header { display: flex; justify-content: space-between; font-size: 14px; margin-bottom: 10px; }
.logistics-status { color: var(--primary-color); font-weight: bold; }
.logistics-body { display: flex; gap: 10px; align-items: center; }
.logistics-body img { width: 80px; height: 80px; border-radius: 8px; }
.logistics-info .item-name { font-weight: 500; }
.logistics-info .eta { font-size: 12px; color: #888; margin-top: 5px; }
/* --- 新增：自定义商品功能样式 --- */
.special-product-fields {
    display: none; /* 默认隐藏 */
    border-left: 3px solid var(--primary-color);
    padding-left: 15px;
    margin-top: 15px;
}
.special-product-fields.visible {
    display: block; /* 当被勾选时显示 */
}
/* --- 心灵羁绊 - 愿望清单样式 --- */
#bond-wishlist-container .list-item {
    display: block; /* 覆盖默认的flex布局 */
    padding: 15px;
}
.wish-item {
    display: flex;
    align-items: center;
    gap: 15px;
}
.wish-checkbox {
    width: 24px;
    height: 24px;
    flex-shrink: 0;
    accent-color: var(--primary-color);
}
.wish-item .item-details {
    transition: opacity 0.3s ease;
}
.wish-item.completed .item-name {
    text-decoration: line-through;
    color: #aaa;
}
.wish-item.completed .item-details {
    opacity: 0.6;
}
/* --- 心灵羁绊 - 拍立得照片文字溢出修复 --- */
.bond-photo-back {
    overflow-y: auto; /* 核心修复：当内容超出时，允许垂直滚动 */
    justify-content: flex-start;
    align-items: flex-start;
    text-align: left;
    padding: 12px; 
}
/* --- 心灵羁绊 - 交换日记样式 --- */
#diary-exchange-list-container {
    padding: 10px;
}
.diary-exchange-pair {
    background-color: #fff;
    border-radius: 16px;
    margin-bottom: 15px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.06);
    overflow: hidden;
}
.diary-exchange-entry {
    padding: 15px;
}
.entry-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 10px;
}
.entry-header img {
    width: 24px;
    height: 24px;
    border-radius: 50%;
}
.entry-header .author-name {
    font-weight: bold;
    color: var(--secondary-color);
}
.entry-content {
    font-size: 15px;
    line-height: 1.7;
    white-space: pre-wrap;
    padding-left: 32px; /* 对齐头像下的内容 */
}
.entry-image {
    width: calc(100% - 32px);
    margin-left: 32px;
    margin-top: 10px;
    border-radius: 8px;
    object-fit: cover;
}
.ai-reply {
    background-color: #fff8fa;
    border-top: 1px dashed #fce4ec;
}
/* --- 心灵羁绊 - 交换日记 V2.0 样式 --- */
#diary-exchange-list-container {
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 20px; /* 增加日记本之间的间距 */
}

.diary-book {
    perspective: 1200px;
    height: 220px; /* 设定日记本的高度 */
}

.diary-book-inner {
    position: relative;
    width: 100%;
    height: 100%;
    transform-style: preserve-3d;
    transition: transform 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55);
    cursor: pointer;
}

.diary-book.is-flipped .diary-book-inner {
    transform: rotateY(180deg);
}

.diary-book-cover,
.diary-book-back {
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
    border-radius: 12px;
    box-shadow: 0 6px 20px rgba(0,0,0,0.1);
    background-size: cover;
    background-position: center;
    overflow: hidden;
}

.diary-book-cover {
    background-color: #fce4ec; /* 默认封面颜色 */
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding: 15px;
    color: white;
    text-shadow: 0 1px 3px rgba(0,0,0,0.3);
}
.cover-date {
    font-size: 12px;
    font-weight: bold;
    align-self: flex-start;
}
.cover-title {
    font-size: 18px;
    font-weight: 600;
    text-align: center;
}
.cover-authors {
    font-size: 13px;
    align-self: flex-end;
}

.diary-book-back {
    transform: rotateY(180deg);
    background-color: #fff8fa;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    color: var(--secondary-color);
    padding: 20px;
    text-align: center;
}

/* 弹窗查看器样式 */
#diary-viewer-content .diary-exchange-entry {
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 1px dashed #eee;
}
#diary-viewer-content .diary-exchange-entry:last-child {
    border-bottom: none;
    margin-bottom: 0;
}
</style>


<!-- === /patch === -->

<style>
/* z-index and stacking safety to ensure bottom nav and modals stay on top */
.screen { z-index: 0 !important; }
.screen.active { z-index: 1 !important; }
.bottom-nav { z-index: 200 !important; } /* ensure bottom nav overlays feed */
.modal-overlay, .action-sheet-overlay, .context-menu { z-index: 300 !important; }
#moments-screen { z-index: 0 !important; } /* keep moments below nav/modals by default */
/* --- 新代码开始 --- */

/* --- 恢复：论坛页面顶部导航栏遮挡内容 --- */
#forum-screen .content,
#forum-thread-screen .content {
    padding-top: 0; /* 修正：移除顶内边距，因为我们将让内部元素自己定位 */
}
.home-profile-header {
    width: calc(100% - 40px); /* 左右留20px边距 */
    margin: 0 auto; /* 居中 */
    position: relative;
    background-color: var(--white-color);
    border-radius: 18px; /* 统一的圆角 */
    box-shadow: 0 6px 20px rgba(0,0,0,0.07); /* 统一的阴影 */
    overflow: visible; /* 允许头像溢出 */
}
/* --- 新增：论坛列表独立滚动区域 --- */
#thread-list-container,
#thread-content-container {
    position: absolute;
    top: 55px;      /* 从标题栏（约55px高）的下方开始 */
    bottom: 68px;   /* 在底部导航栏（约68px高）的上方结束 */
    left: 0;
    right: 0;
    overflow-y: auto; /* 允许这个区域自己垂直滚动 */
    padding: 10px;    /* 为内容增加一些内边距，避免贴边 */
}
/* --- 新增结束 --- */
.home-hero {
    height: 160px;
    background-color: #f0f0f0;
    background-size: cover;
    background-position: center;
    border-radius: 18px 18px 0 0; /* 只给顶部设置圆角 */
}

.home-avatar-wrap {
    position: absolute;
    top: 160px; /* 定位在背景图的下边缘 */
    left: 50%;
    transform: translate(-50%, -50%); /* 精确居中 */
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: 4px solid var(--white-color);
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    overflow: hidden;
    z-index: 5;
}

#home-profile-avatar {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
}

.home-info-card {
    padding: 50px 20px 20px; /* 顶部留出头像空间，底部缩小间距 */
    text-align: center;
}

.home-profile-name {
    font-size: 20px;
    font-weight: 600;
    margin: 0 0 5px 0;
}

.home-profile-signature {
    font-size: 14px;
    color: #888;
    margin: 0;
}

#home-screen .main-content-area {
    margin-top: -5px; /* 确保与卡片底部有10px间距 */
}
/* === 样式结束 === */
/* START: 主屏幕翻页样式 */
#home-container {
    padding: 0;
    justify-content: flex-start;
    overflow: hidden;
}
.home-page-wrapper {
    width: 200%;
    height: 100%;
    display: flex;
    transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
}
.home-page {
    width: 50%;
    height: 100%;
    flex-shrink: 0;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
}
.home-page-indicator {
    position: absolute;
    bottom: 80px; /* 根据你的dock栏高度微调 */
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 8px;
    z-index: 20;
}
.home-page-indicator .dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: rgba(0, 0, 0, 0.2);
    transition: background-color 0.3s;
}
.home-page-indicator .dot.active {
    background-color: var(--primary-color);
}
#home-screen.day-mode ~ .home-page-indicator .dot {
    background-color: rgba(255, 255, 255, 0.4);
}
#home-screen.day-mode ~ .home-page-indicator .dot.active {
    background-color: #fff;
}
/* END: 主屏幕翻页样式 */

/* START: 渲染器应用样式 */
.renderer-layout {
    display: flex;
    height: 100%;
    padding: 0;
}
.renderer-sidebar {
    width: 120px;
    flex-shrink: 0;
    background-color: #fff8fa;
    border-right: 1px solid #fce4ec;
    overflow-y: auto;
}
.renderer-sidebar .list-item {
    padding: 15px 10px;
    border-bottom-color: #fce4ec;
    text-align: center;
}
.renderer-sidebar .list-item.active {
    background-color: var(--primary-color);
    color: white;
}
.renderer-main {
    flex-grow: 1;
    overflow-y: auto;
    padding: 10px;
}
.renderer-main .list-item {
    display: block;
    padding: 12px 15px;
}
.rule-name {
    font-weight: 600;
}
.rule-regex {
    font-size: 13px;
    color: #888;
    margin-top: 4px;
    font-family: monospace;
}
.char-binding-list {
    max-height: 150px;
    overflow-y: auto;
    border: 1px solid #eee;
    padding: 10px;
    border-radius: 8px;
    background-color: #f9f9f9;
}
.char-binding-item {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
}
/* END: 渲染器应用样式 */
/* START: 渲染器弹窗补充样式 */
.regex-flags-container {
    display: flex;
    gap: 15px;
    margin-top: 8px;
    font-size: 13px;
}
.regex-flags-container label, .scope-options label {
    display: flex;
    align-items: center;
    gap: 5px;
}
.renderer-options-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
}
/* END: 渲染器弹窗补充样式 */
/* START: 渲染器面板尺寸、字号与滚动优化 */

/* 1. 限制弹窗最大高度，并启用flex布局以便内容滚动 */
#edit-renderer-rule-modal .modal-window {
    max-height: 85vh; /* 限制最大高度为视窗的85% */
    display: flex;
    flex-direction: column;
}

/* 2. 让表单内容区域可滚动 */
#edit-renderer-rule-form {
    overflow-y: auto;   /* 核心：当内容超出时，此区域出现垂直滚动条 */
    flex-grow: 1;       /* 占据所有可用垂直空间 */
    padding: 5px 15px 5px 5px; /* 微调内边距，为滚动条留出空间 */
    margin-right: -10px;     /* 负外边距让滚动条更贴近边缘，视觉效果更好 */
}

/* 3. 缩小所有UI元素的字号和间距，使其更紧凑 */
#edit-renderer-rule-modal h3 {
    font-size: 18px;    /* 缩小标题字号 */
    margin-bottom: 15px;
    flex-shrink: 0;   /* 防止标题在flex布局中被压缩 */
}

#edit-renderer-rule-modal .form-group {
    margin-bottom: 12px; /* 减小表单项之间的垂直间距 */
}

#edit-renderer-rule-modal .form-group label {
    font-size: 14px;    /* 缩小标签文字大小 */
    color: var(--primary-color); /* 将标签颜色统一为主题粉色 */
    margin-bottom: 6px;
}

#edit-renderer-rule-modal .form-group input[type="text"],
#edit-renderer-rule-modal .form-group textarea {
    font-size: 14px;    /* 缩小输入框/文本域的字体大小 */
    padding: 10px;      /* 减小输入框的内边距 */
}

/* 4. 缩小各种选项复选框的文字大小 */
.regex-flags-container,
.scope-options,
.char-binding-item label {
    font-size: 14px;
}

/* 5. 调整绑定角色列表的样式 */
.char-binding-list {
    padding: 8px;
}

/* 6. 调整保存按钮的样式 */
#edit-renderer-rule-form .btn-primary {
    margin-top: 10px;
}

/* END: 渲染器面板优化 */
/* --- 撤回消息功能新增样式 --- */

/* 1. 这是被撤回后，消息占位符的样式 */
.recalled-message-placeholder {
    background-color: rgba(200, 200, 200, 0.5);
    color: #666;
    font-size: 12px;
    padding: 4px 10px;
    border-radius: 10px;
    text-align: center;
}

/* 2. 这是消息消失时的动画效果 */
@keyframes recall-animation {
  from {
    opacity: 1;
    transform: scale(1);
  }
  to {
    opacity: 0;
    transform: scale(0.8);
  }
}

.recalled-animation {
  animation: recall-animation 0.3s ease-out forwards;
}
/* --- 微信输入栏布局 & 功能面板样式 --- */

/* 1. 布局切换核心规则 */
/* 默认情况下，隐藏微信布局和功能面板 */
#wechat-input-area,
.function-panel {
    display: none;
}
/* 当 .wechat-layout-active 应用时，显示微信布局，隐藏旧布局 */
.phone-screen.wechat-layout-active #message-input-default,
.phone-screen.wechat-layout-active #sticker-bar {
    display: none !important;
}
.phone-screen.wechat-layout-active #wechat-input-area {
    display: flex !important;
}
/* 为新输入栏调整聊天内容区的底部间距 */
.phone-screen.wechat-layout-active #chat-room-screen .content {
    padding-bottom: 0px !important;
}

/* 2. 微信风格输入栏样式 */
#wechat-input-area {
    gap: 10px;
    align-items: center;
}
#wechat-message-input {
    flex-grow: 1;
    border: none;
    padding: 12px;
    border-radius: 18px;
    background-color: #f0f0f0;
}
#wechat-message-input:focus {
    outline: none;
}

/* 3. 功能面板样式 */
.function-panel {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: #f7f7f7;
    border-top: 1px solid #ddd;
    padding: 20px;
    padding-bottom: calc(20px + env(safe-area-inset-bottom));
    box-sizing: border-box;
    z-index: 25;
    transform: translateY(100%);
    transition: transform 0.3s ease-out;
}
.function-panel.visible {
    display: block; /* 先设为block才能有动画 */
    transform: translateY(0);
}

/* 4. 面板内部功能网格样式 */
.function-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 20px;
}
.function-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    font-size: 12px;
    color: #666;
}
.function-item .icon-bg {
    width: 60px;
    height: 60px;
    background-color: #fff;
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
.function-item .icon-bg svg {
    width: 28px;
    height: 28px;
    fill: #555;
}
/* === 日记功能扩展样式 === */

/* “我的日记”条目样式 */
.user-diary-entry {
    background-color: #f0f4f8; /* 使用淡蓝色背景以区分AI日记 */
    border-left-color: #64b5f6; /* 左侧边框也用蓝色 */
}

/* AI评论区样式 */
.ai-comment-section {
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px dashed #d0d8e0;
}
.ai-comment-entry {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}
.ai-comment-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}
.ai-comment-bubble {
    background-color: #fff;
    border-radius: 10px;
    padding: 10px 12px;
    font-size: 14px;
    color: #555;
    flex-grow: 1;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
.ai-comment-header {
    font-weight: bold;
    color: var(--secondary-color);
    margin-bottom: 5px;
}

/* AI日记翻页按钮 */
.diary-pagination {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 20px;
}
.diary-pagination button {
    padding: 6px 14px;
    font-size: 14px;
}
.diary-pagination .page-indicator {
    font-size: 14px;
    color: #888;
}

/* 修复之前所有页面的白屏问题 */
#diary-screen .content,
#user-diary-screen .content,
#favorites-diary-screen .content,
#memories-screen .content,
#memory-detail-screen .content,
#api-settings-screen .content,
#world-book-screen .content,
#renderer-screen .content,
#wallet-screen .content,
#wallet-settings-screen .content,
#customize-screen .content,
#tutorial-screen .content {
    flex-grow: 1;
    overflow-y: auto;
    height: auto;
    min-height: 0;
    padding-bottom: 80px; /* 为底部导航栏预留空间 */
}
/* === 日记功能扩展与修复样式 === */

/* 1. 使日记条目本身成为一个可交互的块 */
.diary-entry {
    display: block;
}

/* 2. 将日记头部用作折叠/展开的触发器 */
.diary-header {
    cursor: pointer;
}

/* 3. 日记内容和AI评论区默认隐藏，通过 <details> 标签控制 */
.diary-entry > .diary-content,
.diary-entry > .ai-comment-section {
    display: none;
    padding-top: 10px;
}
.diary-entry[open] > .diary-content,
.diary-entry[open] > .ai-comment-section {
    display: block; /* 当 <details> 元素被打开时显示 */
}

/* 4. AI评论区样式 */
.ai-comment-section {
    margin-top: 15px;
    padding-top: 15px;
    border-top: 1px dashed #e0c8d1;
}
.ai-comment-header { /* “AI的悄悄话” 标题 */
    font-weight: bold;
    color: var(--secondary-color);
    margin-bottom: 10px;
    cursor: pointer; /* 让它看起来可以点击 */
}
.ai-comment-entry {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}
.ai-comment-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}
.ai-comment-bubble {
    background-color: #fff;
    border-radius: 10px;
    padding: 10px 12px;
    font-size: 14px;
    color: #555;
    flex-grow: 1;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    white-space: pre-wrap; /* 保留评论中的换行 */
}

/* 5. AI日记翻页按钮 */
.diary-pagination {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 20px;
}
.diary-pagination button {
    padding: 6px 14px;
    font-size: 14px;
}
.diary-pagination .page-indicator {
    font-size: 14px;
    color: #888;
}

/* 6. 统一的白屏修复 (覆盖之前的所有修复) */
.screen .content {
    flex-grow: 1;
    overflow-y: auto;
    height: auto;
    min-height: 0;
    padding-bottom: 80px; /* 为底部导航栏预留空间 */
}
/* --- AI轨迹/心声按钮激活样式 --- */
#ai-trajectory-btn.active-heart-sound svg {
    color: #007BFF !important; /* 切换为蓝色 */
    transform: scale(1.1); /* 轻微放大以示区别 */
    transition: color 0.3s ease, transform 0.3s ease;
}
    /* 隐藏主页的翻页指示圆点 */
    .home-page-indicator {
        display: none !important;
    }

/* 商城功能整体样式 */
#mall-screen .content {
    padding: 60px 10px 80px 10px; /* 顶部为搜索栏留空，底部为导航栏留空 */
    background-color: #f5f5f5;
}

.mall-header {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 10px;
    background-color: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(10px);
    border-bottom: 1px solid #eee;
    z-index: 10;
}

.search-bar-container {
    flex-grow: 1;
    display: flex;
    align-items: center;
    background-color: #f5f5f5;
    border-radius: 18px;
    padding: 0 12px;
}

.search-bar-container .search-icon {
    width: 20px;
    height: 20px;
    fill: #999;
    margin-right: 8px;
}

.search-bar-container input {
    width: 100%;
    border: none;
    background: transparent;
    height: 36px;
    font-size: 14px;
}
.search-bar-container input:focus {
    outline: none;
}

.mall-categories {
    display: flex;
    justify-content: space-around;
    padding: 15px 5px;
    background-color: #fff;
    border-radius: 12px;
    margin-bottom: 10px;
}

.product-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
}

.product-card {
    background-color: #fff;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    display: flex;
    flex-direction: column;
}

.product-card .product-image {
    width: 100%;
    aspect-ratio: 1 / 1;
    object-fit: cover;
}

.product-card .product-info {
    padding: 10px;
    display: flex;
    flex-direction: column;
    flex-grow: 1;
}

.product-card .product-title {
    font-size: 14px;
    color: #333;
    line-height: 1.4;
    margin: 0 0 5px 0;
    /* 多行文字省略号 */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
    overflow: hidden;
    text-overflow: ellipsis;
    height: 39.2px; /* 14px * 1.4 * 2 lines */
}

.product-card .product-tags {
    margin-bottom: 8px;
}

.product-card .product-tags .tag {
    background-color: #fff0f5;
    color: var(--primary-color);
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 4px;
    margin-right: 5px;
}

.product-card .product-price-row {
    margin-top: auto; /* 将价格推到底部 */
    display: flex;
    align-items: baseline;
    justify-content: space-between;
}

.product-card .product-price {
    font-size: 18px;
    font-weight: bold;
    color: #e53935;
}

.product-card .product-price::before {
    content: '¥';
    font-size: 12px;
    margin-right: 2px;
}

.product-card .product-sales {
    font-size: 12px;
    color: #999;
}

/* 商城底部导航样式 */
.mall-bottom-nav {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 60px;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-top: 1px solid #eee;
    display: flex;
    justify-content: space-around;
    align-items: center;
    z-index: 200;
}

.mall-bottom-nav .nav-item {
    background: none;
    border: none;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 4px;
    color: #888;
}

.mall-bottom-nav .nav-item svg {
    width: 24px;
    height: 24px;
    fill: currentColor;
}

.mall-bottom-nav .nav-item span {
    font-size: 10px;
}

.mall-bottom-nav .nav-item.active {
    color: var(--primary-color);
}

/* 商品详情页面样式 */
#product-detail-screen .content {
    background-color: #f5f5f5;
}

.product-detail-card {
    background-color: #fff;
    border-radius: 12px;
    margin-bottom: 10px;
}

.detail-product-image {
    width: 100%;
    aspect-ratio: 1 / 1;
    object-fit: cover;
    border-top-left-radius: 12px;
    border-top-right-radius: 12px;
}

.detail-product-info {
    padding: 15px;
}

.detail-price-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.detail-product-price {
    font-size: 24px;
    font-weight: bold;
    color: #e53935;
}

.detail-stats {
    font-size: 14px;
    color: #888;
    display: flex;
    gap: 15px;
}

.detail-product-title {
    font-size: 18px;
    font-weight: 600;
    color: #333;
    margin: 0 0 10px 0;
}

.detail-product-description {
    font-size: 14px;
    color: #666;
    line-height: 1.6;
    margin: 0;
}

.detail-store-info {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 15px;
    border-top: 1px solid #f5f5f5;
    border-bottom: 10px solid #f5f5f5;
}

.detail-store-info .store-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%;
}

.comment-section {
    padding: 15px;
}

.comment-section h3 {
    margin: 0 0 15px 0;
    font-size: 16px;
}

#comment-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.comment-item {
    padding: 15px 0;
    border-bottom: 1px solid #f5f5f5;
}
.comment-item:last-child {
    border-bottom: none;
}

.comment-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 10px;
}

.comment-avatar {
    width: 30px;
    height: 30px;
    border-radius: 50%;
}

.comment-author {
    font-weight: 500;
    font-size: 14px;
}

.comment-text {
    font-size: 14px;
    line-height: 1.7;
    margin-bottom: 10px;
}

.seller-reply {
    background-color: #fff8e1;
    border-radius: 8px;
    padding: 10px;
    font-size: 13px;
    margin-top: 10px;
}

.seller-reply::before {
    content: '商家回复：';
    font-weight: bold;
    color: #f57f17;
}

.detail-footer-nav {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 60px;
    background: #fff;
    border-top: 1px solid #eee;
    display: flex;
    padding: 8px;
    gap: 8px;
    z-index: 10;
}

.detail-footer-nav .action-btn {
    flex: 1;
    border: none;
    border-radius: 20px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    background-color: #ffcdd2;
    color: var(--primary-color);
}
.detail-footer-nav .action-btn.primary {
    background-color: var(--primary-color);
    color: white;
}
/* --- 商城购物流程 & 购物车样式 --- */
.purchase-flow-modal {
    padding: 15px;
}
.close-purchase-modal-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    background: none;
    border: none;
    font-size: 24px;
    color: #999;
    cursor: pointer;
}
.purchase-product-info {
    display: flex;
    align-items: flex-end;
    gap: 15px;
    padding-bottom: 15px;
    border-bottom: 1px solid #f0f0f0;
}
.purchase-product-info img {
    width: 80px;
    height: 80px;
    border-radius: 8px;
    object-fit: cover;
}
.purchase-product-info p {
    color: #e53935;
    font-size: 20px;
    font-weight: bold;
    margin: 0 0 5px 0;
}
.purchase-product-info h4 {
    font-size: 16px;
    margin: 0;
}
.purchase-section {
    padding: 15px 0;
}
.purchase-section h5 {
    margin: 0 0 10px 0;
    font-size: 14px;
    color: #555;
}
#recipient-selection-list {
    max-height: 25vh;
    overflow-y: auto;
}
#recipient-selection-list .list-item {
    padding: 10px 5px;
}
.style-options {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
}
.style-option-btn {
    padding: 8px 15px;
    border: 1px solid #ddd;
    background-color: #f5f5f5;
    color: #333;
    border-radius: 15px;
    cursor: pointer;
}
.style-option-btn.active {
    border-color: var(--primary-color);
    background-color: #fff0f5;
    color: var(--primary-color);
}
.quantity-section {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.quantity-selector {
    display: flex;
    align-items: center;
}
.quantity-selector .quantity-btn {
    width: 28px;
    height: 28px;
    border: 1px solid #ddd;
    background-color: #f5f5f5;
    font-size: 18px;
    cursor: pointer;
}
.quantity-selector input {
    width: 50px;
    height: 28px;
    text-align: center;
    border: 1px solid #ddd;
    border-left: none;
    border-right: none;
}

/* 购物车商品项样式 */
.cart-item {
    background-color: #fff;
    border-radius: 12px;
    padding: 15px;
    margin-bottom: 10px;
    display: flex;
    gap: 15px;
}
.cart-item-image {
    width: 90px;
    height: 90px;
    border-radius: 8px;
    object-fit: cover;
    flex-shrink: 0;
}
.cart-item-details {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}
.cart-item-title {
    font-size: 14px;
    margin: 0 0 8px 0;
}
.cart-item-price {
    font-size: 16px;
    font-weight: bold;
    color: #e53935;
    margin-top: auto;
}
.cart-item-actions {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    justify-content: space-between;
}
.cart-item-actions .to-pay-btn {
    padding: 6px 12px;
    font-size: 13px;
    background-color: #e53935;
    color: white;
}
.cart-payment-countdown {
    font-size: 12px;
    color: #e53935;
}

/* 发送到聊天中的商品名片样式 */
.product-delivery-card {
    width: 240px;
    background-color: #fff;
    border-radius: var(--border-radius);
    padding: 12px;
    display: flex;
    align-items: center;
    gap: 12px;
    margin: 0 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    border: 1px solid #eee;
}
.message-wrapper.sent .product-delivery-card {
    border-bottom-right-radius: 5px;
}
.product-delivery-card-icon {
    width: 48px;
    height: 48px;
    flex-shrink: 0;
    border-radius: 8px;
    object-fit: cover;
}
.product-delivery-card-info {
    overflow: hidden;
    flex-grow: 1;
}
.product-delivery-card-title {
    font-size: 15px;
    font-weight: 500;
    color: #333;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin: 0 0 4px 0;
}
.delivery-countdown-display {
    font-size: 12px;
    color: #e53935;
    font-weight: bold;
    margin: 0;
}
/* --- 商城刷新与加载更多样式 --- */
#refresh-mall-btn svg.rotating {
    animation: spin 1s linear infinite;
}
@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.load-more-indicator {
    display: none; /* 默认隐藏 */
    text-align: center;
    padding: 15px;
    color: #888;
    font-size: 14px;
}
.load-more-indicator.loading {
    display: block; /* 加载时显示 */
}

/* --- 个人主页扩展样式 --- */
.profile-header {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    background-color: #fff;
    margin: -20px -10px 10px -10px; /* 顶部和左右贴边，底部留出间距 */
}

.profile-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    object-fit: cover;
    border: 3px solid #fff;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    margin-bottom: 15px;
}

.profile-username {
    font-size: 20px;
    font-weight: 600;
    color: #333;
    margin: 0;
}

.profile-section {
    background-color: #fff;
    border-radius: 12px;
    padding: 15px;
    margin-bottom: 10px;
}

.profile-section .section-title {
    font-size: 16px;
    font-weight: 600;
    color: #333;
    margin: 0 0 15px 0;
    padding-bottom: 10px;
    border-bottom: 1px solid #f5f5f5;
}/* --- 新增：支付确认页面样式 --- */
.recipient-selector-section, .delivery-time-section {
    padding-bottom: 10px;
}
.recipient-selector-section h5, .delivery-time-section h5 {
    margin: 0 0 10px;
    font-size: 14px;
    color: #555;
}
.payment-methods .method-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 12px 0;
    cursor: pointer;
    font-weight: 500;
}
.payment-methods .method-item.selected::after {
    content: '✓';
    color: var(--primary-color);
    font-size: 20px;
    font-weight: bold;
    margin-left: auto;
}
.payment-methods .method-item img { width: 24px; height: 24px; }
.payment-footer {
    position: absolute;
    bottom: 0; left: 0; right: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 20px;
    background: #fff;
    border-top: 1px solid #eee;
    z-index: 10;
}
.payment-footer .total-price { color: #e53935; font-size: 18px; font-weight: bold; }
#confirm-final-payment-btn { padding: 10px 30px; border-radius: 20px; }

/* --- 新增：代付请求卡片样式 --- */
.payment-request-card {
    width: 240px;
    border-radius: var(--border-radius);
    margin: 0 8px;
    background: linear-gradient(135deg, #FFC107, #FF9800);
    color: white;
    padding: 15px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}
.payment-request-title { font-size: 14px; opacity: 0.9; }
.payment-request-amount { font-size: 32px; font-weight: bold; margin: 5px 0; }
.payment-request-desc { font-size: 13px; margin-bottom: 15px; max-height: 40px; overflow: hidden; }
.payment-request-actions { display: flex; gap: 10px; margin-top: 10px; }
.payment-request-actions button { flex: 1; border-radius: 8px; padding: 8px; }
.payment-request-status { font-weight: bold; text-align: center; margin-top: 10px; }

/* --- 新增：物流界面样式 --- */
.logistics-item {
    background-color: #fff;
    border-radius: 12px;
    padding: 15px;
    margin-bottom: 10px;
}
.logistics-header { display: flex; justify-content: space-between; font-size: 14px; margin-bottom: 10px; }
.logistics-status { color: var(--primary-color); font-weight: bold; }
.logistics-body { display: flex; gap: 10px; align-items: center; }
.logistics-body img { width: 80px; height: 80px; border-radius: 8px; object-fit: cover; }
.logistics-info .item-name { font-weight: 500; }
.logistics-info .eta { font-size: 12px; color: #888; margin-top: 5px; }
.logistics-info .recipient-info { font-size: 12px; color: #888; margin-top: 5px; }
/* =========================================== */
/* START: 心灵羁绊 App V3.0 样式 (粉色主题) */
/* =========================================== */

#soul-bond-screen .app-header {
    background-color: #fff8fa; /* 恢复为淡粉色标题栏 */
    border-bottom: none;
}

#soul-bond-screen .content {
    background-size: cover;
    background-position: center;
    transition: background-image 0.5s ease-in-out;
    background-color: #fff8fa; /* 统一为淡粉色背景 */
    padding: 15px;
    display: flex;
    flex-direction: column;
}

/* 顶部照片滚动区域 (保持不变) */
.bond-photo-scroll-container {
    flex-shrink: 0;
    overflow-x: auto;
    padding-bottom: 20px;
    /* 隐藏滚动条 */
    scrollbar-width: none;
    -ms-overflow-style: none;
}
.bond-photo-scroll-container::-webkit-scrollbar {
    display: none;
}
.bond-photo-scroll {
    display: flex;
    gap: 15px;
    padding: 10px;
}

/* 拍立得卡片翻转效果 (保持不变) */
.bond-photo-item {
    flex-shrink: 0;
    width: 110px;
    height: 130px;
    perspective: 1000px;
    cursor: pointer;
}
.bond-photo-inner {
    position: relative;
    width: 100%;
    height: 100%;
    transition: transform 0.6s;
    transform-style: preserve-3d;
}
.bond-photo-item.is-flipped .bond-photo-inner {
    transform: rotateY(180deg);
}
.bond-photo-front, .bond-photo-back {
    position: absolute;
    width: 100%;
    height: 100%;
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
    background-color: white;
    padding: 8px;
    border-radius: 4px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}
.bond-photo-front img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}
.bond-photo-back {
    transform: rotateY(180deg);
    font-size: 13px;
    color: #666;
    font-family: 'Comic Sans MS', 'Chalkduster', cursive;
    text-align: center;
    padding: 15px;
}
.bond-photo-front::before {
    content: '';
    position: absolute;
    top: -5px;
    left: 50%;
    transform: translateX(-50%);
    width: 40px;
    height: 15px;
    background-color: rgba(255, 222, 233, 0.8); /* 淡粉色胶带 */
    border-radius: 2px;
}

/* --- 核心修改：恢复旧版大卡片样式 --- */
.bond-main-card {
    background: rgba(255, 255, 255, 0.75);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 24px;
    padding: 20px;
    text-align: center;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    animation: fadeIn 0.8s ease;
    margin: 15px 0; /* 上下边距 */
}
.bond-anniversary p { margin: 0; font-size: 14px; color: var(--secondary-color); }
.bond-anniversary h2 { font-size: 56px; margin: 5px 0; color: var(--primary-color); font-weight: 700; }
.bond-anniversary span { font-size: 14px; color: var(--secondary-color); }
.bond-avatars { display: flex; justify-content: center; align-items: center; gap: 20px; margin: 25px 0; }
.bond-avatar-container { display: flex; flex-direction: column; align-items: center; gap: 8px; }
.bond-avatar-container img { width: 70px; height: 70px; border-radius: 50%; object-fit: cover; border: 3px solid white; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
.bond-avatar-container span { font-weight: 600; color: var(--text-color); }
.bond-heart { width: 30px; height: 30px; fill: var(--primary-color); animation: heart-pulse 1.5s infinite ease-in-out; }
@keyframes heart-pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }
.bond-days-counter { font-size: 16px; color: #555; }
.bond-days-counter strong { color: var(--primary-color); font-weight: 700; }
/* --- 旧版样式恢复结束 --- */

.bond-section-title {
    text-align: center;
    color: var(--secondary-color);
    margin: 20px 0 15px;
    font-weight: 600;
}

/* 底部功能导航栏 (颜色修改) */
.bond-bottom-nav {
    position: absolute;
    bottom: 15px;
    left: 15px;
    right: 15px;
    background-color: var(--primary-color); /* 主题粉色 */
    border-radius: 24px;
    box-shadow: 0 6px 20px rgba(255, 128, 171, 0.3);
    display: flex;
    justify-content: space-around;
    align-items: center;
    padding: 10px 0;
    z-index: 100;
}
.bond-nav-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 8px;
}
.bond-nav-btn svg {
    width: 28px;
    height: 28px;
    fill: white; /* 图标改为白色 */
}

/* 移除不再使用的元素的样式 */
.bond-profile-section, .bond-tabs, .bond-post-moment-btn {
    display: none !important;
}
/* =========================================== */
/* END: 心灵羁绊 App 样式 */
/* =========================================== */

/* --- 心灵羁绊 - 愿望清单样式 --- */
#bond-wishlist-container .list-item {
    display: block; /* 覆盖默认的flex布局 */
    padding: 15px;
}
.wish-item {
    display: flex;
    align-items: center;
    gap: 15px;
}
.wish-checkbox {
    width: 24px;
    height: 24px;
    flex-shrink: 0;
    accent-color: var(--primary-color);
}
.wish-item .item-details {
    transition: opacity 0.3s ease;
}
.wish-item.completed .item-name {
    text-decoration: line-through;
    color: #aaa;
}
.wish-item.completed .item-details {
    opacity: 0.6;
}
</style>
<!-- === /zindex-patch === -->
<style>
        /* --- 全屏强制适配样式 --- */
        body {
            /* 移除body原有的居中和渐变背景，让phone-screen完全接管 */
            display: block;
            background: #fce4ec; /* 设置一个基础底色，防止闪烁 */
            padding: 0;
            min-height: 0;
        }

        .phone-screen {
            /* 覆盖原有的尺寸和位置限制 */
            max-width: none !important;
            max-height: none !important;
            width: 100vw !important;
            height: 100vh !important;
            
            /* 移除模拟手机的视觉效果 */
            border-radius: 0 !important;
            box-shadow: none !important;
            
            /* 如果之前不是从左上角定位，则强制定位 */
            position: absolute;
            top: 0;
            left: 0;
        }
        /* --- iPhone 全屏与安全区域适配 --- */
.phone-screen {
    /* 使用苹果官方提供的安全区域变量来增加内边距 */
    /* 这可以防止内容被顶部的刘海/灵动岛和底部的Home指示器遮挡 */
    padding-bottom: env(safe-area-inset-bottom);
}

/* 专门为聊天输入框和底部操作栏适配底部安全区 */
/* 您的代码中已经有了这些，这里是再次确认和加强 */
.message-input-area, 
#multi-select-bar,
.function-panel,
.mall-bottom-nav,
.cart-checkout-bar {
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
}

/* 如果有其他绝对定位在底部的元素，也需要类似处理 */
.bottom-nav {
    bottom: env(safe-area-inset-bottom);
}
    </style>
</head>

<body>
<div class="phone-screen">
	<!-- 在 <div class="phone-screen"> 之后添加 -->
<div id="global-notification-banner" class="notification-banner">
    <img id="notification-avatar" src="" alt="avatar">
    <div id="notification-text"></div>
    <button id="notification-close-btn">&times;</button>
</div>
  <!-- START: 改造主屏幕以支持翻页 -->
<div id="home-container" class="screen active">
    <div class="home-page-wrapper">
        <!-- 这是原来的主页，现在是第一页 -->
        <div id="home-screen" class="home-page active"></div>
        <!-- 这是新增的第二页 -->
        <div id="home-screen-2" class="home-page"></div>
    </div>
    <div class="home-page-indicator">
        <span class="dot active" data-index="0"></span>
        <span class="dot" data-index="1"></span>
    </div>
</div>
<!-- END: 改造主屏幕 -->
    <div id="chat-list-screen" class="screen">
        <header class="app-header">
            <button class="back-btn" data-target="home-container">‹</button>
            <div class="title-container">
                <h1 class="title">聊天</h1>
            </div>
            <div class="action-btn-group">
            <div class="action-btn-group">
        <button class="action-btn" id="import-card-btn" title="导入角色卡">
        <svg viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px;">
            <path d="M9,16V10H5L12,3L19,10H15V16H9M5,20V18H19V20H5Z" />
        </svg>
    </button>
        <button class="action-btn" id="create-group-btn">群聊</button>
        <button class="action-btn" id="add-chat-btn">+</button>
    </div>
        </header>
        <main class="content">
            <ul class="list-container" id="chat-list-container"></ul>
            <div class="placeholder-text" id="no-chats-placeholder" style="display: none;">
                <p>还没有聊天对象哦~</p>
                <p>点击右上角的“+”创建一个吧！</p>
            </div>
        </main>
    </div>
    <div id="chat-room-screen" class="screen">
  <!-- ▼▼▼ 用这个全新的header替换掉旧的header ▼▼▼ -->
<header class="app-header" id="chat-room-header-default">
    <button class="back-btn" data-target="chat-list-screen">‹</button>
    <div class="title-container">
        <h1 class="title" id="chat-room-title">...</h1>
        <div class="subtitle" id="chat-room-subtitle">
            <div class="online-indicator"></div>
            <span id="chat-room-status-text">在线</span>
        </div>
    </div>
    
    <!-- 新增的截图选择操作栏 (保持不变) -->
    <div id="screenshot-select-bar" style="display: none; position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.8); backdrop-filter: blur(5px); padding: 10px 20px; z-index: 100; justify-content: space-between; align-items: center; color: white;">
        <button id="cancel-screenshot-select" class="btn btn-neutral btn-small">取消</button>
        <span id="screenshot-select-count">已选择 0 条</span>
        <button id="confirm-screenshot-select" class="btn btn-primary btn-small">生成截图</button>
    </div>

    <!-- 修正后的右侧按钮组 -->
    <div class="action-btn-group">
        <button class="action-btn" id="ai-trajectory-btn">
            <svg viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px; color:var(--primary-color);">
                <path d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z"></path>
            </svg>
        </button>
        <button class="action-btn" id="chat-settings-btn"><img src="https://i.postimg.cc/nhwP4pQy/chan-73.png" alt="设置"></button>
    </div>
</header>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
        <header class="app-header" id="chat-room-header-select" style="display: none;">
            <button class="action-btn" id="cancel-multi-select-btn">取消</button>
            <div class="title-container">
                <h1 class="title" id="multi-select-title">选择消息</h1>
            </div>
            <div class="placeholder"></div>
        </header>
        <main class="content">
            <div class="message-area" id="message-area"></div>
            <div class="typing-indicator" id="typing-indicator"></div>
        </main>
        
        <div class="chat-input-wrapper">
        	<!-- 找到 <div class="chat-input-wrapper"> 在其内部最前面添加 -->
<div id="quote-reply-bar" style="padding: 8px 12px; background-color: rgba(240, 240, 240, 0.9); border-top: 1px solid #eee; display: none; align-items: center; gap: 8px; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);">
    <div id="quoted-message-preview" style="flex-grow: 1; font-size: 13px; color: #666; border-left: 3px solid var(--primary-color); padding-left: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></div>
    <button id="cancel-quote-reply-btn" style="background: none; border: none; font-size: 20px; color: #888; cursor: pointer; padding: 0 5px;">&times;</button>
</div>
          
<div id="sticker-bar">
    <button class="sticker-bar-btn" id="rollback-btn" title="撤回并重写">
        <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M12.5,8C9.85,8 7.45,9 5.6,10.6L2,7V16H11L7.38,12.38C8.77,11.22 10.54,10.5 12.5,10.5C16.04,10.5 19.05,12.81 20.1,16L22.47,15.22C21.08,11.03 17.15,8 12.5,8Z"></path>
        </svg>
    </button><!-- ... 紧跟在 id="rollback-btn" 的 </button> 之后 ... -->
<button class="sticker-bar-btn" id="continue-writing-btn" title="续写">
    <svg viewBox="0 0 24 24" fill="currentColor">
        <path d="M6,10A2,2 0 0,1 8,12A2,2 0 0,1 6,14A2,2 0 0,1 4,12A2,2 0 0,1 6,10M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M18,10A2,2 0 0,1 20,12A2,2 0 0,1 18,14A2,2 0 0,1 16,12A2,2 0 0,1 18,10Z"></path>
    </svg>
</button>
<!-- ... 后面是 id="sticker-toggle-btn" ... -->
    <button class="sticker-bar-btn" id="sticker-toggle-btn">
        <svg viewBox="0 0 24 24">
            <path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"></path>
        </svg>
    </button>
    <button class="sticker-bar-btn" id="photo-video-btn">
        <svg viewBox="0 0 24 24"><path d="M4,4H7L9,2H15L17,4H20A2,2 0 0,1 22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6A2,2 0 0,1 4,4M12,7A5,5 0 0,0 7,12A5,5 0 0,0 12,17A5,5 0 0,0 17,12A5,5 0 0,0 12,7M12,9A3,3 0 0,1 15,12A3,3 0 0,1 12,15A3,3 0 0,1 9,12A3,3 0 0,1 12,9Z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="image-recognition-btn">
        <svg viewBox="0 0 24 24"><path d="M21.58,16.09L19.66,18L18.24,16.58L21,13.83C21.39,13.44 22,13.44 22.39,13.83L23.17,14.61C23.56,15 23.56,15.64 23.17,16.03L21.58,17.62M20.13,12.25L18.71,13.66L20.41,15.36L21.83,13.94L20.13,12.25M5.93,19H5C3.9,19 3,18.1 3,17V5C3,3.9 3.9,3 5,3H19C20.1,3 21,3.9 21,5V11.08L19,13.08V5H5V17H5.93L13.5,9.43L16.29,12.21L12.08,16.42L5.93,19Z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="voice-message-btn">
        <svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="voice-call-btn">
        <svg viewBox="0 0 24 24"><path d="M6.62,10.79C8.06,13.62 10.38,15.94 13.21,17.38L15.41,15.18C15.69,14.9 16.08,14.82 16.43,14.93C17.55,15.3 18.75,15.5 20,15.5A1,1 0 0,1 21,16.5V20A1,1 0 0,1 20,21A17,17 0 0,1 3,4A1,1 0 0,1 4,3H7.5A1,1 0 0,1 8.5,4C8.5,5.25 8.7,6.45 9.07,7.57C9.18,7.92 9.1,8.31 8.82,8.59L6.62,10.79Z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="wallet-btn">
        <svg viewBox="0 0 24 24"><path d="M20 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V6C22 4.9 21.1 4 20 4ZM20 18H4V8H20V18ZM4 6H20V6H4Z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="gift-btn">
        <svg viewBox="0 0 24 24"><path d="M20,8L12,13L4,8V6H20M20,4H4A2,2 0 0,0 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6A2,2 0 0,0 20,4M12.5,18C12.5,17.29 12.17,16.65 11.64,16.27C12.17,15.89 12.5,15.26 12.5,14.55C12.5,13.6 11.83,12.79 11,12.58V12H13V10H11V8H13V6H11V5C11,4.45 10.55,4 10,4H8C7.45,4 7,4.45 7,5V6H9V8H7V10H9V12H7V12.58C6.17,12.79 5.5,13.6 5.5,14.55C5.5,15.26 5.83,15.89 6.36,16.27C5.83,16.65 5.5,17.29 5.5,18H12.5Z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="diary-btn" style="display: none;">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3M14 17H7V15H14V17M17 13H7V11H17V13M17 9H7V7H17V9Z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="time-skip-btn">
        <svg viewBox="0 0 24 24"><path d="M4 5v14l7-7-7-7zm9 0v14l7-7-7-7z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="file-btn">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="location-btn">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12C20,15.08 18.05,17.78 15.42,19.23L12,14.5L8.58,19.23C5.95,17.78 4,15.08 4,12A8,8 0 0,1 12,4M12,6.5A5.5,5.5 0 0,0 6.5,12A5.5,5.5 0 0,0 12,17.5A5.5,5.5 0 0,0 17.5,12A5.5,5.5 0 0,0 12,6.5Z"></path></svg>
    </button>
    <button class="sticker-bar-btn" id="ai-memories-btn">
        <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M20,2H8A2,2 0 0,0 6,4V16A2,2 0 0,0 8,18H20A2,2 0 0,0 22,16V4A2,2 0 0,0 20,2M20,16H8V4H20M4,6H2V20A2,2 0 0,0 4,22H18V20H4M12,6L11.2,6.8L9,9L10.2,10.2L11,9.4V14H13V9.4L13.8,10.2L15,9L12.8,6.8L12,6Z"></path>
        </svg>
    </button>
</div>
    <!-- ▼▼▼ 将新的微信输入栏粘贴到这里 ▼▼▼ -->
<div class="message-input-area" id="wechat-input-area" style="display: none;">
    <button id="plus-btn" class="icon-btn" style="background-color: transparent; color: #555;">
        <svg viewBox="0 0 24 24" fill="currentColor" style="width: 28px; height: 28px;"><path d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z"></path></svg>
    </button>
    <input type="text" id="wechat-message-input" placeholder="输入消息..."autocomplete="off">
    <div class="wechat-send-btn-group" style="display: flex; gap: 8px;">
        <button id="wechat-send-message-btn" class="icon-btn send-btn">➤</button>
        <button id="wechat-get-reply-btn" class="icon-btn">
            <svg viewBox="0 0 24 24"><path d="M12,2A10,10 0 1,0 22,12A10,10 0 0,0 12,2M12,20A8,8 0 1,1 20,12A8,8 0 0,1 12,20M16.24,7.76C15.07,6.58 13.53,6 12,6V12L7.76,16.24C10.1,18.58 13.9,18.58 16.24,16.24C18.58,13.9 18.58,10.1 16.24,7.76Z"></path></svg>
        </button>
    </div>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->  
	<!-- “+”号展开的功能面板 -->
    <div id="function-panel" class="function-panel">
        <div class="function-grid">
            <div class="function-item" data-action="sticker"><div class="icon-bg"><svg viewBox="0 0 24 24"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"></path></svg></div><span>表情</span></div>
            <div class="function-item" data-action="photo-video"><div class="icon-bg"><svg viewBox="0 0 24 24"><path d="M4,4H7L9,2H15L17,4H20A2,2 0 0,1 22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6A2,2 0 0,1 4,4M12,7A5,5 0 0,0 7,12A5,5 0 0,0 12,17A5,5 0 0,0 17,12A5,5 0 0,0 12,7M12,9A3,3 0 0,1 15,12A3,3 0 0,1 12,15A3,3 0 0,1 9,12A3,3 0 0,1 12,9Z"></path></svg></div><span>照片</span></div>
            <div class="function-item" data-action="image-recognition"><div class="icon-bg"><svg viewBox="0 0 24 24"><path d="M21.58,16.09L19.66,18L18.24,16.58L21,13.83C21.39,13.44 22,13.44 22.39,13.83L23.17,14.61C23.56,15 23.56,15.64 23.17,16.03L21.58,17.62M20.13,12.25L18.71,13.66L20.41,15.36L21.83,13.94L20.13,12.25M5.93,19H5C3.9,19 3,18.1 3,17V5C3,3.9 3.9,3 5,3H19C20.1,3 21,3.9 21,5V11.08L19,13.08V5H5V17H5.93L13.5,9.43L16.29,12.21L12.08,16.42L5.93,19Z"></path></svg></div><span>识图</span></div>
            <div class="function-item" data-action="voice-message"><div class="icon-bg"><svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"></path></svg></div><span>语音</span></div>
            <div class="function-item" data-action="voice-call"><div class="icon-bg"><svg viewBox="0 0 24 24"><path d="M6.62,10.79C8.06,13.62 10.38,15.94 13.21,17.38L15.41,15.18C15.69,14.9 16.08,14.82 16.43,14.93C17.55,15.3 18.75,15.5 20,15.5A1,1 0 0,1 21,16.5V20A1,1 0 0,1 20,21A17,17 0 0,1 3,4A1,1 0 0,1 4,3H7.5A1,1 0 0,1 8.5,4C8.5,5.25 8.7,6.45 9.07,7.57C9.18,7.92 9.1,8.31 8.82,8.59L6.62,10.79Z"></path></svg></div><span>通话</span></div>
            <div class="function-item" data-action="wallet"><div class="icon-bg"><svg viewBox="0 0 24 24"><path d="M20 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V6C22 4.9 21.1 4 20 4ZM20 18H4V8H20V18ZM4 6H20V6H4Z"></path></svg></div><span>钱包</span></div>
            <div class="function-item" data-action="gift"><div class="icon-bg"><svg viewBox="0 0 24 24"><path d="M20,8L12,13L4,8V6H20M20,4H4A2,2 0 0,0 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6A2,2 0 0,0 20,4M12.5,18C12.5,17.29 12.17,16.65 11.64,16.27C12.17,15.89 12.5,15.26 12.5,14.55C12.5,13.6 11.83,12.79 11,12.58V12H13V10H11V8H13V6H11V5C11,4.45 10.55,4 10,4H8C7.45,4 7,4.45 7,5V6H9V8H7V10H9V12H7V12.58C6.17,12.79 5.5,13.6 5.5,14.55C5.5,15.26 5.83,15.89 6.36,16.27C5.83,16.65 5.5,17.29 5.5,18H12.5Z"></path></svg></div><span>礼物</span></div>
            <div class="function-item" data-action="time-skip"><div class="icon-bg"><svg viewBox="0 0 24 24"><path d="M4 5v14l7-7-7-7zm9 0v14l7-7-7-7z"></path></svg></div><span>跳时</span></div>
            <div class="function-item" data-action="file"><div class="icon-bg"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"></path></svg></div><span>文件</span></div>
            <div class="function-item" data-action="location"><div class="icon-bg"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12C20,15.08 18.05,17.78 15.42,19.23L12,14.5L8.58,19.23C5.95,17.78 4,15.08 4,12A8,8 0 0,1 12,4M12,6.5A5.5,5.5 0 0,0 6.5,12A5.5,5.5 0 0,0 12,17.5A5.5,5.5 0 0,0 17.5,12A5.5,5.5 0 0,0 12,6.5Z"></path></svg></div><span>位置</span></div>
            <div class="function-item" data-action="rollback"><div class="icon-bg"><svg viewBox="0 0 24 24"><path d="M12.5,8C9.85,8 7.45,9 5.6,10.6L2,7V16H11L7.38,12.38C8.77,11.22 10.54,10.5 12.5,10.5C16.04,10.5 19.05,12.81 20.1,16L22.47,15.22C21.08,11.03 17.15,8 12.5,8Z"></path></svg></div><span>重Roll</span></div>
    <div class="function-item" data-action="continue-writing"><div class="icon-bg"><svg viewBox="0 0 24 24"><path d="M6,10A2,2 0 0,1 8,12A2,2 0 0,1 6,14A2,2 0 0,1 4,12A2,2 0 0,1 6,10M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M18,10A2,2 0 0,1 20,12A2,2 0 0,1 18,14A2,2 0 0,1 16,12A2,2 0 0,1 18,10Z"></path></svg></div><span>续写</span></div>
    <div class="function-item" data-action="memories"><div class="icon-bg"><svg viewBox="0 0 24 24"><path d="M20,2H8A2,2 0 0,0 6,4V16A2,2 0 0,0 8,18H20A2,2 0 0,0 22,16V4A2,2 0 0,0 20,2M20,16H8V4H20M4,6H2V20A2,2 0 0,0 4,22H18V20H4M12,6L11.2,6.8L9,9L10.2,10.2L11,9.4V14H13V9.4L13.8,10.2L15,9L12.8,6.8L12,6Z"></path></svg></div><span>回忆</span></div>
    
    <div class="function-item" data-action="diary"><div class="icon-bg"><svg viewBox="0 0 24 24"><path d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3M14 17H7V15H14V17M17 13H7V11H17V13M17 9H7V7H17V9Z"></path></svg></div><span>日记</span></div>
</div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
        
<!-- ▲▲▲ 粘贴到这里结束 ▲▲▲ -->
            <div class="message-input-area" id="message-input-default">
                <input type="text" id="message-input" placeholder="输入消息..."autocomplete="off">
                <button id="send-message-btn" class="icon-btn send-btn">➤</button>
                <button id="get-reply-btn" class="icon-btn">
                    <svg viewBox="0 0 24 24">
                        <path d="M12,2A10,10 0 1,0 22,12A10,10 0 0,0 12,2M12,20A8,8 0 1,1 20,12A8,8 0 0,1 12,20M16.24,7.76C15.07,6.58 13.53,6 12,6V12L7.76,16.24C10.1,18.58 13.9,18.58 16.24,16.24C18.58,13.9 18.58,10.1 16.24,7.76Z"/>
                    </svg>
                </button>
            </div>
            <div class="message-input-area" id="message-edit-bar" style="display: none;">
                <input type="text" id="message-edit-input">
                <button id="save-edit-btn" class="icon-btn send-btn">✓</button>
                <button id="cancel-edit-btn" class="icon-btn" style="background-color: #aaa;">✗</button>
            </div>
        </div>
        <div id="multi-select-bar"><span id="select-count">已选择 0 项</span>
            <button class="btn btn-danger" id="delete-selected-btn" style="width: auto; padding: 8px 16px;">删除已选
            </button>
        </div>
        <div id="sticker-modal">
            <div class="header"><span>我的表情</span><button class="btn btn-secondary btn-small" id="batch-add-sticker-btn">批量添加</button>
                <button class="btn btn-primary btn-small" id="add-new-sticker-btn">添加新表情</button>       
           </div>
            <div class="sticker-grid" id="sticker-grid-container"></div>
        </div>
    </div>
    <div id="world-book-screen" class="screen">
        <header class="app-header">
            <button class="back-btn" data-target="home-container">‹</button>
            <div class="title-container">
                <h1 class="title">世界书</h1>
            </div>
      <div class="action-btn-group">
      	<button class="action-btn" id="import-world-book-btn">✦</button> 
    <button class="action-btn" id="add-world-book-category-btn">分类</button>
    <button class="action-btn" id="add-world-book-btn">+</button>
</div>
        </header>
        <main class="content">
            <ul class="list-container" id="world-book-list-container"></ul>
            <div class="placeholder-text" id="no-world-books-placeholder" style="display: none;">
                <p>你的世界一片混沌...</p>
                <p>点击右上角的“+”创造第一个设定吧！</p>
            </div>
        </main>
    </div>
    <div id="edit-world-book-screen" class="screen">
        <header class="app-header">
            <button class="back-btn" data-target="world-book-screen">‹</button>
            <div class="title-container">
                <h1 class="title" id="edit-world-book-title">创建/编辑条目</h1>
            </div>
            <div class="placeholder"></div>
        </header>
        <main class="content">
            <form id="edit-world-book-form">
                <input type="hidden" id="world-book-id">
                <div class="form-group">
                    <label for="world-book-name">条目名称</label>
                    <input type="text" id="world-book-name" placeholder="例如：世界观背景、魔法体系" required>
                </div>
                <div class="form-group">
    <label for="world-book-category-select">所属分类</label>
    <select id="world-book-category-select">
        <!-- Options will be populated by JS -->
    </select>
</div>
<!-- ▼▼▼ START: 新增功能字段 ▼▼▼ -->
        <div class="form-group">
            <label for="world-book-keywords">触发关键词 (逗号分隔)</label>
            <input type="text" id="world-book-keywords" placeholder="例如: 戒指,婚戒,ring">
        </div>
        <div style="display: flex; gap: 20px; margin-bottom: 20px;">
            <div class="form-group" style="display: flex; align-items: center; gap: 8px; margin-bottom: 0;">
                <label for="world-book-always-active" style="margin-bottom: 0;">始终启用</label>
                <input type="checkbox" id="world-book-always-active" style="width: auto; height: 20px;">
            </div>
            <div class="form-group" style="display: flex; align-items: center; gap: 8px; margin-bottom: 0;">
                <label for="world-book-case-sensitive" style="margin-bottom: 0;">区分大小写</label>
                <input type="checkbox" id="world-book-case-sensitive" style="width: auto; height: 20px;">
            </div>
        </div>
        <!-- ▲▲▲ END: 新增功能字段 ▲▲▲ -->
                <div class="form-group">
                    <label for="world-book-content">条目内容</label>
                    <textarea id="world-book-content" rows="8" placeholder="详细描述此项设定..." required></textarea>
                </div>
                <div class="form-group">
                    <label>注入位置</label>
                    <div class="form-group radio-group">
                        <label><input type="radio" name="world-book-position" value="before" checked> 前</label>
                        <label><input type="radio" name="world-book-position" value="after"> 后</label>
                    </div>
                </div>
                <button type="submit" class="btn btn-primary">保存条目</button>
            </form>
        </main>
    </div>
    <div id="api-settings-screen" class="screen"></div>
<!-- 在 id="api-settings-screen" 的 </div> 之后添加以下代码 -->
<!-- START: 新增渲染器应用界面 -->
<div id="renderer-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="home-container">‹</button>
        <div class="title-container">
            <h1 class="title">渲染器</h1>
        </div>
        <div class="action-btn-group">
        	<div class="action-btn-group">
    <button class="action-btn" id="import-renderer-rules-btn">导入</button> <!-- 新增的按钮 -->
            <button class="action-btn" id="add-renderer-category-btn">分类</button>
            <button class="action-btn" id="add-renderer-rule-btn">+</button>
        </div>
    </header>
    <main class="content renderer-layout">
        <div class="renderer-sidebar">
            <ul class="list-container" id="renderer-category-list"></ul>
        </div>
        <div class="renderer-main">
            <ul class="list-container" id="renderer-rule-list"></ul>
            <div class="placeholder-text" id="no-renderer-rules-placeholder" style="display: none;">
                <p>该分类下没有规则</p>
                <p>点击右上角的“+”创建一条吧！</p>
            </div>
        </div>
    </main>
</div>
<!-- END: 新增渲染器应用界面 -->
<div id="diary-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="chat-room-screen">‹</button>
        <div class="title-container">
            <h1 class="title">日记</h1>
        </div>
        <button class="action-btn" id="generate-diary-manually-btn">
             <svg viewBox="0 0 24 24" fill="currentColor" style="width: 24px; height: 24px;">
                <path d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" />
            </svg>
        </button>
    </header>
    <main class="content">
        <ul class="list-container" id="diary-list-container"></ul>
        <div class="placeholder-text" id="no-diaries-placeholder" style="display: none;">
            <p>还没有日记哦~</p>
            <p>多聊聊天，让Ta记录下你们的故事吧！</p>
        </div>
    </main>
</div>
<div id="memories-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="chat-room-screen">‹</button>
        <div class="title-container">
            <h1 class="title">回忆</h1>
        </div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
        <ul class="list-container" id="memories-list-container"></ul>
        <div class="placeholder-text" id="no-memories-placeholder" style="display: none;">
            <p>还没有专属回忆哦~</p>
            <p>和Ta多聊聊天，创造一些难忘的瞬间吧！</p>
        </div>
    </main>
</div>

<div id="memory-detail-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="memories-screen">‹</button>
        <div class="title-container">
            <h1 class="title">回忆详情</h1>
        </div>
        <div class="placeholder"></div>
    </header>
    <main class="content" id="memory-detail-content">
        </main>
</div>


    <div id="wallpaper-screen" class="screen"></div>
    <div id="font-settings-screen" class="screen"></div>
    <div id="customize-screen" class="screen"></div>
    <div id="tutorial-screen" class="screen"></div>
  <div id="forum-screen" class="screen">
  <header class="app-header">
        <button class="back-btn" data-target="chat-list-screen">‹</button>
        <div class="title-container">
            <div class="forum-header" id="forum-header">
                <h1 id="forum-board-title-header">生活闲聊</h1>
                <svg class="dropdown-arrow" viewBox="0 0 24 24"><path d="M7,10L12,15L17,10H7Z"></path></svg>
            </div>
        </div>
        
        <div class="action-btn-group">
            <button class="action-btn" id="refresh-board-btn">
                 <svg viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px;"><path d="M17.65,6.35C16.2,4.9, 14.21,4, 12,4A8,8, 0, 0,0, 4,12A8,8, 0, 0,0, 12,20C15.73,20, 18.84,17.45, 19.73,14H17.65C16.83,16.33, 14.61,18, 12,18A6,6, 0, 0,1, 6,12A6,6, 0, 0,1, 12,6C13.66,6, 15.14,6.69, 16.22,7.78L13,11H20V4L17.65,6.35Z"></path></svg>
            </button>
            <button class="action-btn" id="open-forum-config-btn">
                <svg viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px;">
                    <path d="M12,8A4,4 0 0,1 16,12A4,4 0 0,1 12,16A4,4 0 0,1 8,12A4,4 0 0,1 12,8M12,10A2,2 0 0,0 10,12A2,2 0 0,0 12,14A2,2 0 0,0 14,12A2,2 0 0,0 12,10M10,22C9.75,22 9.54,21.82 9.5,21.58L9.13,18.93C8.5,18.68 7.96,18.34 7.44,17.94L4.95,18.95C4.73,19.03 4.46,18.95 4.34,18.73L2.34,15.27C2.21,15.05 2.27,14.78 2.45,14.63L4.6,13.05C4.54,12.72 4.5,12.37 4.5,12C4.5,11.63 4.54,11.28 4.6,10.95L2.45,9.37C2.27,9.22 2.21,8.95 2.34,8.73L4.34,5.27C4.46,5.05 4.73,4.96 4.95,5.05L7.44,6.06C7.96,5.66 8.5,5.32 9.13,5.07L9.5,2.42C9.54,2.18 9.75,2 10,2H14C14.25,2 14.46,2.18 14.5,2.42L14.87,5.07C15.5,5.32 16.04,5.66 16.56,6.06L19.05,5.05C19.27,4.96 19.54,5.05 19.66,5.27L21.66,8.73C21.79,8.95 21.73,9.22 21.55,9.37L19.4,10.95C19.46,11.28 19.5,11.63 19.5,12C19.5,12.37 19.46,12.72 19.4,13.05L21.55,14.63C21.73,14.78 21.79,15.05 21.66,15.27L19.66,18.73C19.54,18.95 19.27,19.04 19.05,18.95L16.56,17.94C16.04,18.34 15.5,18.68 14.87,18.93L14.5,21.58C14.46,21.82 14.25,22 14,22H10Z" />
                </svg>
            </button>
        </div>
    </header>
    <main class="content">
        <div class="forum-dropdown-menu" id="forum-dropdown-menu"></div>
        <div class="thread-list-container" id="thread-list-container">
            </div>
     
    </main>
</div>

<div id="forum-thread-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="forum-screen">‹</button>
        <div class="title-container"><h1 class="title" id="thread-detail-title">帖子详情</h1></div>
        <button class="action-btn" id="share-thread-btn">
            <svg viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px;"><path d="M18,16.08C17.24,16.08, 16.56,16.38, 16.04,16.85L8.91,12.7C8.96,12.47, 9,12.24, 9,12C9,11.76, 8.96,11.53, 8.91,11.3L16.04,7.15C16.56,7.62, 17.24,7.92, 18,7.92A3,3, 0, 0,0, 18,2A3,3, 0, 0,0, 15,5C15,5.24, 15.04,5.47, 15.09,5.7L7.96,9.85C7.44,9.38, 6.76,9.08, 6,9.08A3,3, 0, 0,0, 6,15C6.76,15, 7.44,14.72, 7.96,14.25L15.09,18.3C15.04,18.53, 15,18.76, 15,19A3,3, 0, 0,0, 18,22A3,3, 0, 0,0, 21,19C21,17.42, 19.66,16.08, 18,16.08Z"></path></svg>
        </button>
    </header>
    <main class="content" id="thread-content-container">
        </main>
</div>
<!-- 自定义组件编辑器弹窗 -->
<div id="customize-widget-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>自定义组件</h3>
        <form id="customize-widget-form">
            <input type="hidden" id="editing-widget-id">
            <div class="form-group">
                <label for="widget-text-input">显示文字</label>
                <input type="text" id="widget-text-input" placeholder="输入要显示的文字" required>
            </div>
            <div class="form-group">
                <label for="widget-image-url-input">图片 URL</label>
                <input type="url" id="widget-image-url-input" placeholder="粘贴图片URL">
            </div>
            <p style="text-align:center; color:#888; margin: -10px 0 15px;">或</p>
            <input type="file" id="widget-image-upload" accept="image/*" style="display:none;">
            <label for="widget-image-upload" class="btn btn-secondary" style="width:100%; margin-bottom: 20px;">从本地上传</label>
            <button type="submit" class="btn btn-primary">保存</button>
        </form>
    </div>
</div>
<div id="new-post-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>发布新帖</h3>
        <form id="new-post-form">
            <div class="form-group">
                <label for="post-title-input">帖子标题</label>
                <input type="text" id="post-title-input" required>
            </div>
            <div class="form-group">
                <label for="post-content-input">帖子内容</label>
                <textarea id="post-content-input" rows="6" required></textarea>
            </div>
            <div class="form-group" style="display: flex; align-items: center; justify-content: space-between; margin-top: 15px;">
                <label for="post-anonymous-checkbox" style="margin-bottom: 0;">匿名发布</label>
                <input type="checkbox" id="post-anonymous-checkbox" style="width: auto; height: 20px;">
            </div>
            <button type="submit" class="btn btn-primary" style="margin-top: 20px;">发布</button>
        </form>
    </div>
</div>
    <div id="toast-notification" class="toast"></div>
    <input type="file" id="image-upload-input" accept="image/*" style="display:none;">
    <div id="add-char-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>创建新角色</h3>
            <form id="add-char-form">
                <div class="form-group">
                    <label for="char-real-name">角色姓名</label><input type="text" id="char-real-name"
                                                                       placeholder="角色的真实姓名" required>
                </div>
                <div class="form-group">
                    <label for="char-remark-name">角色备注 (昵称)</label><input type="text" id="char-remark-name"
                                                                                placeholder="你对Ta的称呼" required>
                </div>
                <div class="form-group">
                    <label for="my-name-for-char">我的姓名</label><input type="text" id="my-name-for-char"
                                                                         placeholder="你希望Ta如何称呼你" required>
                </div>
                <button type="submit" class="btn btn-primary">创建</button>
            </form>
        </div>
    </div>
    <div id="add-sticker-modal" class="modal-overlay">
        <div class="modal-window">
            <h3 id="add-sticker-modal-title">添加新表情</h3>
            <form id="add-sticker-form"><input type="hidden" id="sticker-edit-id">
                <div id="sticker-preview"><span>预览</span></div>
                <div class="form-group"><label for="sticker-name">表情名称</label><input type="text" id="sticker-name"
                                                                                         placeholder="如：开心" required>
                </div>
                <div class="form-group"><label for="sticker-url-input">表情URL</label><input type="url"
                                                                                             id="sticker-url-input"
                                                                                             placeholder="粘贴图片URL">
                </div>
                <p style="text-align:center; color:#888; margin: -10px 0 15px;">或</p><input type="file"
                                                                                             id="sticker-file-upload"
                                                                                             accept="image/*"
                                                                                             style="display:none;"><label
                        for="sticker-file-upload" class="btn btn-secondary" style="width:100%; margin-bottom: 20px;">从本地上传</label>
                <button type="submit" class="btn btn-primary">保存</button>
            </form>
        </div>
    </div>
    <div id="sticker-actionsheet" class="action-sheet-overlay">
        <div class="action-sheet">
            <button class="action-sheet-button" id="edit-sticker-btn">编辑</button>
            <button class="action-sheet-button danger" id="delete-sticker-btn">删除</button>
        </div>
    </div>
    <div id="send-voice-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>发送语音消息</h3>
            <form id="send-voice-form">
                <div class="form-group">
                    <label for="voice-text-input">输入语音文字</label>
                    <textarea id="voice-text-input" placeholder="在这里输入你想说的话..." required rows="4"></textarea>
                </div>
                <div class="form-group" style="text-align:center; color:#888; font-size: 14px;">
                    预计时长: <span id="voice-duration-preview">0"</span>
                </div>
                <button type="submit" class="btn btn-primary">发送</button>
            </form>
        </div>
    </div>
    <div id="send-pv-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>分享照片/视频</h3>
            <form id="send-pv-form">
                <div class="form-group">
                    <label for="pv-text-input">输入描述</label>
                    <textarea id="pv-text-input" placeholder="在这里描述你的照片或视频内容..." required
                              rows="4"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">发送</button>
            </form>
        </div>
    </div>
    <div id="send-transfer-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>转账</h3>
            <form id="send-transfer-form">
                <div class="form-group">
                    <label for="transfer-amount-input">金额 (元)</label>
                    <input type="number" id="transfer-amount-input" placeholder="0.00" required step="0.01" min="0.01">
                </div>
                <div class="form-group">
                    <label for="transfer-remark-input">备注</label>
                    <input type="text" id="transfer-remark-input" placeholder="（选填）">
                </div>
                <button type="submit" class="btn btn-primary">发送</button>
            </form>
        </div>
    </div>
        <div id="send-gift-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>送出礼物</h3>
            <form id="send-gift-form">
                <!-- ▼▼▼ 新增的价格输入框 ▼▼▼ -->
                <div class="form-group">
                    <label for="gift-amount-input">礼物价格 (元)</label>
                    <input type="number" id="gift-amount-input" placeholder="0.00" required step="0.01" min="0.01">
                </div>
                <!-- ▲▲▲ 新增结束 ▲▲▲ -->
                <div class="form-group">
                    <label for="gift-description-input">礼物描述</label>
                    <textarea id="gift-description-input" placeholder="告诉Ta你送了什么特别的东西..." required rows="4"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">发送</button>
            </form>
        </div>
    </div>
    <!-- NEW: Time Skip Modal -->
    <div id="time-skip-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>记录今天发生的事</h3>
            <form id="time-skip-form">
                <div class="form-group">
                    <label for="time-skip-input">事件描述 (该消息AI可见，会作为上下文)</label>
                    <textarea id="time-skip-input" placeholder="例如：我们一起去山顶看了日落，然后吃了烧烤。" required
                              rows="4"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">发送</button>
            </form>
        </div>
    </div>
    <!-- NEW: Send File Modal -->
<div id="send-file-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>发送文件</h3>
        <form id="send-file-form">
            <div class="form-group">
                <label for="file-name-input">文件名</label>
                <input type="text" id="file-name-input" placeholder="例如：会议纪要.txt" required>
            </div>
            <div class="form-group">
                <label for="file-content-input">文件内容</label>
                <textarea id="file-content-input" placeholder="在此输入或粘贴文件内容..." required rows="6"></textarea>
            </div>
            <button type="submit" class="btn btn-primary">发送</button>
        </form>
    </div>
</div>
<!-- NEW: Display File Modal -->
<div id="display-file-modal" class="modal-overlay">
    <div class="modal-window">
        <h3 id="display-file-name" style="word-wrap: break-word;">文件名</h3>
        <div class="form-group" style="max-height: 60vh; overflow-y: auto; background-color: #f5f5f5; padding: 10px; border-radius: 8px;">
            <pre id="display-file-content" style="white-space: pre-wrap; word-wrap: break-word; font-size: 14px; color: #333;"></pre>
        </div>
        <button id="close-file-display-btn" class="btn btn-primary" style="margin-top: 20px;">关闭</button>
    </div>
</div>
<!-- NEW: Send Location Modal -->
<div id="send-location-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>发送位置</h3>
        <form id="send-location-form">
            <div class="form-group">
                <label for="location-main-input">主要位置</label>
                <input type="text" id="location-main-input" placeholder="例如：市中心购物广场" required>
            </div>
            <div class="form-group">
                <label for="location-detail-input">详细位置</label>
                <textarea id="location-detail-input" placeholder="例如：xx省xx市xx区人民路123号" required rows="3"></textarea>
            </div>
            <button type="submit" class="btn btn-primary">发送</button>
        </form>
    </div>
</div>
<!-- NEW: Display Location Modal -->
<div id="display-location-modal" class="modal-overlay">
    <div class="modal-window" style="padding: 0; overflow: hidden;">
        <div id="display-location-map" style="width: 100%; height: 200px; background-size: cover; background-position: center;"></div>
        <div style="padding: 20px;">
            <h3 id="display-location-main" style="margin-top: 0; color: #333;"></h3>
            <p id="display-location-detail" style="color: #666; margin-bottom: 20px;"></p>
            <button id="close-location-display-btn" class="btn btn-primary">关闭</button>
        </div>
    </div>
</div>
<!-- NEW: Voice Call Modal -->
<div id="voice-call-overlay">
    <!-- Common Info -->
    <img src="" alt="Avatar" class="call-avatar-large" id="call-avatar">
    <h2 class="call-name" id="call-name">...</h2>
    <p class="call-status" id="call-status">正在呼叫...</p>

    <!-- Ringing/Incoming View -->
    <div id="ringing-view">
        <div class="call-button-group" id="incoming-buttons" style="display: none;">
            <button class="call-button decline" id="decline-call-btn">
                <div class="icon-wrapper"><svg viewBox="0 0 24 24"><path d="M12,9C10.4,9 9,10.4 9,12S10.4,15 12,15 15,13.6 15,12 13.6,9 12,9M12,17.25C9.24,17.25 6.75,15.17 6.75,12.5C6.75,11.05 7.42,9.73 8.5,8.81L15.19,15.5C14.27,16.58 12.95,17.25 12,17.25M17.25,12C17.25,14.76 15.17,17.25 12.5,17.25C11.05,17.25 9.73,16.58 8.81,15.5L15.5,8.81C16.58,9.73 17.25,11.05 17.25,12M4.44,3L3,4.44L8.06,9.5C7.36,10.23 6.84,11.08 6.5,12H4.13C4.5,14.75 6.13,17.13 8.5,18.5V22H15.5V18.5C16.92,17.81 18.1,16.81 18.91,15.56L20.56,17.22L21.94,15.84L4.44,3Z" /></svg></div>
                <span>拒接</span>
            </button>
            <button class="call-button accept" id="accept-call-btn">
                <div class="icon-wrapper"><svg viewBox="0 0 24 24"><path d="M6.62,10.79C8.06,13.62 10.38,15.94 13.21,17.38L15.41,15.18C15.69,14.9 16.08,14.82 16.43,14.93C17.55,15.3 18.75,15.5 20,15.5A1,1 0 0,1 21,16.5V20A1,1 0 0,1 20,21A17,17 0 0,1 3,4A1,1 0 0,1 4,3H7.5A1,1 0 0,1 8.5,4C8.5,5.25 8.7,6.45 9.07,7.57C9.18,7.92 9.1,8.31 8.82,8.59L6.62,10.79Z" /></svg></div>
                <span>接听</span>
            </button>
        </div>
        <div class="call-button-group" id="outgoing-buttons" style="display: none;">
            <button class="call-button decline" id="cancel-call-btn">
                 <div class="icon-wrapper"><svg viewBox="0 0 24 24"><path d="M12,9C10.4,9 9,10.4 9,12S10.4,15 12,15 15,13.6 15,12 13.6,9 12,9M12,17.25C9.24,17.25 6.75,15.17 6.75,12.5C6.75,11.05 7.42,9.73 8.5,8.81L15.19,15.5C14.27,16.58 12.95,17.25 12,17.25M17.25,12C17.25,14.76 15.17,17.25 12.5,17.25C11.05,17.25 9.73,16.58 8.81,15.5L15.5,8.81C16.58,9.73 17.25,11.05 17.25,12M4.44,3L3,4.44L8.06,9.5C7.36,10.23 6.84,11.08 6.5,12H4.13C4.5,14.75 6.13,17.13 8.5,18.5V22H15.5V18.5C16.92,17.81 18.1,16.81 18.91,15.56L20.56,17.22L21.94,15.84L4.44,3Z" /></svg></div>
                <span>取消</span>
            </button>
        </div>
    </div>

    <!-- Active Call View -->
    <!-- 在 id="voice-call-overlay" 内部 -->
<div id="active-call-view">
    <!-- 新增：固定的顶部信息面板 -->
    <div id="active-call-header">
        <img src="" alt="Avatar" class="call-avatar-large" id="active-call-header-avatar">
        <h2 class="call-name" id="active-call-header-name">...</h2>
        <p class="call-status" id="active-call-header-status">通话中</p>
    </div>
    
    <div id="call-transcript-area"></div>
    
        <div class="call-button-group" id="hangup-button-container">
         <button class="call-button decline" id="hangup-call-btn">
            <div class="icon-wrapper"><svg viewBox="0 0 24 24"><path d="M12,9C10.4,9 9,10.4 9,12S10.4,15 12,15 15,13.6 15,12 13.6,9 12,9M12,17.25C9.24,17.25 6.75,15.17 6.75,12.5C6.75,11.05 7.42,9.73 8.5,8.81L15.19,15.5C14.27,16.58 12.95,17.25 12,17.25M17.25,12C17.25,14.76 15.17,17.25 12.5,17.25C11.05,17.25 9.73,16.58 8.81,15.5L15.5,8.81C16.58,9.73 17.25,11.05 17.25,12M4.44,3L3,4.44L8.06,9.5C7.36,10.23 6.84,11.08 6.5,12H4.13C4.5,14.75 6.13,17.13 8.5,18.5V22H15.5V18.5C16.92,17.81 18.1,16.81 18.91,15.56L20.56,17.22L21.94,15.84L4.44,3Z" /></svg></div>
            <span>挂断</span>
        </button>
    </div>
    <div id="call-input-area">
        <input type="text" id="call-input" placeholder="输入文字...">
        <button id="send-call-message-btn">➤</button>
    </div>
  </div>
</div>
    <!-- NEW: Group Recipient Selection Modal -->
    <div id="group-recipient-selection-modal" class="modal-overlay">
        <div class="modal-window">
            <h3 id="group-recipient-selection-title">选择收件人</h3>
            <ul id="group-recipient-selection-list"></ul>
            <button class="btn btn-primary" id="confirm-group-recipient-btn" style="margin-top: 20px;">确认</button>
        </div>
    </div>
    <div id="receive-transfer-actionsheet" class="action-sheet-overlay">
        <div class="action-sheet">
            <button class="action-sheet-button" id="accept-transfer-btn">接收</button>
            <button class="action-sheet-button danger" id="return-transfer-btn">退回</button>
        </div>
    </div>
    <!-- Private Chat Settings -->
    <div id="chat-settings-sidebar" class="settings-sidebar">
        <div class="header">聊天设置</div>
        <div class="content">
            <form id="chat-settings-form">
                             <div class="avatar-setting">
    <div class="avatar-container-setting" id="char-avatar-container-setting">
        <img src="" alt="角色头像" id="setting-char-avatar-preview" class="avatar-preview">
        <!-- 头像框将动态添加在这里 -->
    </div>
    <button type="button" class="btn btn-small btn-primary avatar-frame-btn" data-target="private-ai">🌟</button>
    <input type="file" id="setting-char-avatar-upload" accept="image/*" style="display:none;">
    <label for="setting-char-avatar-upload" class="btn btn-primary" style="flex-grow:1;">更换角色头像</label>
</div>
                <div class="form-group"><label for="setting-char-remark">角色备注 (昵称)</label><input type="text"
                                                                                                       id="setting-char-remark">
                </div>
                <div class="form-group"><label for="setting-char-persona">角色人设</label><textarea
                        id="setting-char-persona" placeholder="详细描述角色的性格、背景、说话风格等。"></textarea></div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
           <div class="avatar-setting">
    <div class="avatar-container-setting" id="my-avatar-container-setting">
        <img src="" alt="我的头像" id="setting-my-avatar-preview" class="avatar-preview">
        <!-- 头像框将动态添加在这里 -->
    </div>
    <button type="button" class="btn btn-small btn-secondary avatar-frame-btn" data-target="private-user">🌟</button>
    <input type="file" id="setting-my-avatar-upload" accept="image/*" style="display:none;">
    <label for="setting-my-avatar-upload" class="btn btn-secondary" style="flex-grow:1;">更换我的头像</label>
</div>
                <div class="form-group"><label for="setting-my-name">我的姓名</label><input type="text"
                                                                                            id="setting-my-name"></div>
                <div class="form-group"><label for="setting-my-persona">我的人设</label><textarea
                        id="setting-my-persona" placeholder="描述你希望在对话中扮演的形象。"></textarea>


<!-- 管理 Modal（样式与气泡预设管理一致） -->
<div id="mypersona-presets-modal" class="modal-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.35);justify-content:center;align-items:center;z-index:9999;">
  <div class="modal-window" style="max-width:520px;background:var(--panel-bg,#fff);padding:14px;border-radius:10px;box-shadow:0 12px 36px rgba(10,10,20,0.12);">
    <h3 style="margin:0 0 10px 0;font-size:16px;">管理我的人设预设</h3>
    <div id="mypersona-presets-list" style="max-height:340px; overflow:auto; margin-bottom:12px;"></div>
    <div style="display:flex;gap:8px;justify-content:flex-end;">
      <button type="button" id="mypersona-close-modal" class="btn btn-primary" style="padding:8px 12px;border-radius:8px;">关闭</button>
    </div>
  </div>
</div>
<!-- === /我的人设预设控制 === -->
</div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <button type="button" class="btn btn-secondary" id="link-world-book-btn">关联世界书</button>
                </div>
                <div class="form-group"><label for="setting-theme-color">主题颜色 (对方/我方)</label><select
                        id="setting-theme-color"></select></div>

                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <label for="setting-use-custom-css" style="margin-bottom:0;">自定义气泡样式</label>
                        <input type="checkbox" id="setting-use-custom-css" style="width: auto;">
                    </div>
                    <div id="private-bubble-css-preview" class="bubble-css-preview"
                         style="background: #fff; border: 1px solid #eee; border-radius: 10px; padding: 15px; margin-bottom: 10px; display: flex; flex-direction: column; gap: 10px;">
                    </div>
                    <textarea id="setting-custom-bubble-css" rows="6"
                              placeholder="在此输入CSS代码...&#10;例如：&#10;.message-bubble.sent { background-color: #A5D6A7; }&#10;.message-bubble.received { background-color: #E1E1E1; }"
                              disabled></textarea>


<!-- === 气泡预设控制（由 ChatGPT 插入） === -->
<!-- 插入位置：自定义气泡样式 textarea 之后（已美化外观） -->
<div class="panel panel-sm" style="padding:12px;border-radius:10px;border:1px solid var(--border-color,#e8e8ef);background:var(--panel-bg,#fff);box-shadow:var(--panel-shadow,0 4px 12px rgba(20,20,30,0.04));margin:10px 0;">
  <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;">
    <label for="bubble-preset-select" style="width:88px;color:var(--muted,#667);font-size:13px;">气泡预设</label>
    <select id="bubble-preset-select" style="flex:1;padding:8px 10px;border-radius:8px;border:1px solid var(--input-border,#e6e6ea);background:var(--input-bg,#fff);font-size:14px;">
      <option value="">— 选择预设 —</option>
    </select>
    <button type="button" id="apply-preset-btn" class="btn btn-primary" style="margin-left:8px;padding:7px 10px;border-radius:8px;">应用</button>
  </div>

  <div style="display:flex;gap:8px;align-items:center;margin-bottom:10px;">
    <label style="width:88px;color:var(--muted,#667);font-size:13px;">外观操作</label>
    <button type="button" id="save-preset-btn" class="btn" style="padding:7px 10px;border-radius:8px;">另存为预设</button>
    <button type="button" id="manage-presets-btn" class="btn" style="padding:7px 10px;border-radius:8px;">管理</button>
  </div>

  
</div>

<!-- 管理预设 modal（样式微调） -->
<div id="bubble-presets-modal" class="modal-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.35);justify-content:center;align-items:center;z-index:9999;">
  <div class="modal-window" style="max-width:520px;background:var(--panel-bg,#fff);padding:14px;border-radius:10px;box-shadow:0 12px 36px rgba(10,10,20,0.12);">
    <h3 style="margin:0 0 10px 0;font-size:16px;">管理气泡预设</h3>
    <div id="bubble-presets-list" style="max-height:340px; overflow:auto; margin-bottom:12px;"></div>
    <div style="display:flex;gap:8px;justify-content:flex-end;">
      <button type="button" id="close-presets-modal" class="btn btn-primary" style="padding:8px 12px;border-radius:8px;">关闭</button>
    </div>
  </div>
</div>
<!-- === /气泡预设控制（由 ChatGPT 插入） === -->


                    <button type="button" class="btn btn-neutral" id="reset-custom-bubble-css-btn"
                            style="margin-top: 10px; width: auto; padding: 5px 15px; font-size: 14px;">恢复默认
                    </button>
                </div>
<hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
<div class="form-group" style="display: flex; align-items: center; justify-content: space-between;">
    <label for="setting-offline-mode" style="margin-bottom: 0;">开启线下模式 (仅此角色)</label>
    <input type="checkbox" id="setting-offline-mode" style="width: auto; height: 20px;">
</div>
                <div class="form-group"><label for="setting-max-memory">最大记忆轮数</label><input type="number"
                                                                                                   id="setting-max-memory"
                                                                                                   value="10" min="1">
                </div>
               <!-- === 修改为回忆记录按钮 开始 === -->
<div class="form-group">
    <button type="button" class="btn btn-secondary" id="show-memory-summary-btn">查看回忆记录</button>
</div>
<!-- === 修改为回忆记录按钮 结束 === --> 
	<hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
<!-- AI Proactive Chat Settings for Private Chat -->
<div class="form-group">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <label for="private-ai-proactive-chat-toggle" style="margin-bottom:0;">开启AI后台回复</label>
        <input type="checkbox" id="private-ai-proactive-chat-toggle" style="width: auto;">
    </div>
    <div id="private-ai-proactive-options" style="display: none;">
        <label for="private-ai-proactive-chat-delay">无回复超过 (分钟)</label>
        <input type="number" id="private-ai-proactive-chat-delay" min="1" placeholder="例如：30">
        <label for="private-ai-proactive-chat-interval" style="margin-top: 10px;">AI后台回复间隔时间 (分钟)</label>
        <input type="number" id="private-ai-proactive-chat-interval" min="1" placeholder="例如：60">
    </div>
</div>
<!-- START: 共享表情包功能开关 -->
<div class="form-group" style="display: flex; align-items: center; justify-content: space-between; border-top: 1px solid #eee; padding-top: 20px;">
    <label for="setting-share-stickers" style="margin-bottom: 0;">共享表情包</label>
    <input type="checkbox" id="setting-share-stickers" style="width: auto; height: 20px;">
</div>
<!-- END: 共享表情包功能开关 -->
                <div class="form-group"><label for="setting-chat-bg-upload" class="btn btn-primary">更换聊天背景</label><input
                        type="file" id="setting-chat-bg-upload" accept="image/*" style="display:none;"></div>
                <button type="submit" class="btn btn-primary">保存设置</button>
            </form><hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
            	<div class="form-group">
            <button type="button" class="btn btn-secondary" id="search-history-btn">搜索聊天记录</button>
        </div>
<button type="button" class="btn btn-danger" id="block-user-btn">拉黑</button>
            <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
            <button type="button" class="btn btn-danger" id="clear-chat-history-btn">清空聊天记录</button>
        </div>
    </div>
    <div id="world-book-selection-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>选择要关联的世界书</h3>
            <ul id="world-book-selection-list"></ul>
            <button class="btn btn-primary" id="save-world-book-selection-btn" style="margin-top: 20px;">确认</button>
        </div>
    </div>
    <!-- Group Chat Creation Modal -->
    <div id="create-group-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>创建群聊</h3>
            <form id="create-group-form">
                <div class="form-group">
                    <label>选择群成员</label>
                    <ul id="member-selection-list" class="member-selection-list"></ul>
                </div>
                <div class="form-group">
                    <label for="group-name-input">群聊名称</label>
                    <input type="text" id="group-name-input" placeholder="给你的群聊起个名字吧" required>
                </div>
                <button type="submit" class="btn btn-primary">创建群聊</button>
            </form>
        </div>
    </div>
    <!-- Group Chat Settings -->
    <div id="group-settings-sidebar" class="settings-sidebar">
        <div class="header">群聊设置</div>
        <div class="content">
            <form id="group-settings-form">
                <div class="group-avatar-setting">
                    <img src="" alt="群头像" id="setting-group-avatar-preview" class="group-avatar-preview">
                    <input type="file" id="setting-group-avatar-upload" accept="image/*" style="display:none;">
                    <label for="setting-group-avatar-upload" class="btn btn-primary"
                           style="flex-grow:1;">更换群头像</label>
                </div>
                <div class="form-group">
                    <label for="setting-group-name">群名 (AI也可见)</label>
                    <input type="text" id="setting-group-name">
                </div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                             <div class="avatar-setting">
    <div class="avatar-container-setting" id="group-my-avatar-container-setting">
        <img src="" alt="我的头像" id="setting-group-my-avatar-preview" class="avatar-preview">
        <!-- 头像框将动态添加在这里 -->
    </div>
    <button type="button" class="btn btn-small btn-secondary avatar-frame-btn" data-target="group-user">🌟</button>
    <input type="file" id="setting-group-my-avatar-upload" accept="image/*" style="display:none;">
    <label for="setting-group-my-avatar-upload" class="btn btn-secondary" style="flex-grow:1;">更换我的头像</label>
</div>
                <div class="form-group">
                    <label for="setting-group-my-nickname">我的群昵称</label>
                    <input type="text" id="setting-group-my-nickname">
                </div>
                <div class="form-group">
                    <label for="setting-group-my-persona">我的人设</label>
                    <textarea id="setting-group-my-persona" placeholder="描述你希望在此群聊中扮演的形象。"></textarea>
                </div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <label>群成员</label>
                    <div class="group-members-list" id="group-members-list-container"></div>
                </div>
                
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group"><!-- ... 在 id="group-members-list-container" 的 div 之后 ... -->
<div class="form-group">
    <button type="button" class="btn btn-secondary" id="set-group-title-btn">设置群头衔</button>
</div>
<hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
<!-- ... 后面是 id="link-group-world-book-btn" 所在的 div ... -->
                    <button type="button" class="btn btn-secondary" id="link-group-world-book-btn">关联世界书</button>
                </div>
                <div class="form-group"><label for="setting-group-theme-color">主题颜色 (对方/我方)</label><select
                        id="setting-group-theme-color"></select></div>

                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <label for="setting-group-use-custom-css" style="margin-bottom:0;">自定义气泡样式</label>
                        <input type="checkbox" id="setting-group-use-custom-css" style="width: auto;">
                    </div>
                    <div id="group-bubble-css-preview" class="bubble-css-preview"
                         style="background: #fff; border: 1px solid #eee; border-radius: 10px; padding: 15px; margin-bottom: 10px; display: flex; flex-direction: column; gap: 10px;">
                    </div>
                    <textarea id="setting-group-custom-bubble-css" rows="6"
                              placeholder="在此输入CSS代码...&#10;例如：&#10;.message-bubble.sent { background-color: #A5D6A7; }&#10;.message-bubble.received { background-color: #E1E1E1; }"
                              disabled></textarea>
                    <button type="button" class="btn btn-neutral" id="reset-group-custom-bubble-css-btn"
                            style="margin-top: 10px; width: auto; padding: 5px 15px; font-size: 14px;">恢复默认
                    </button>
                </div>

                <div class="form-group"><label for="setting-group-max-memory">最大记忆轮数</label><input type="number"
                                                                                                         id="setting-group-max-memory"
                                                                                                         value="10"
                                                                                                         min="1"></div>
               
<!-- === 修改为回忆记录按钮 开始 === -->
<div class="form-group">
    <button type="button" class="btn btn-secondary" id="show-group-memory-summary-btn">查看回忆记录</button>
</div>
<!-- === 修改为回忆记录按钮 结束 === -->
 <div class="form-group"><label for="setting-group-chat-bg-upload"
                                               class="btn btn-primary">更换聊天背景</label><input type="file"
                                                                                                  id="setting-group-chat-bg-upload"
                                                                                                  accept="image/*"
                                                                                                  style="display:none;">
                </div>
                <div class="form-group">
<label for="bubble-scale-range">气泡 + 字体大小</label>
<div style="display:flex;align-items:center;gap:10px;">
<input id="bubble-scale-range" max="1.6" min="0.8" step="0.05" style="flex:1;" type="range" value="1"/>
<span id="bubble-scale-value" style="width:56px;text-align:right;">100%</span>
</div>
<div style="margin-top:8px; color:#888; font-size:12px;">
    提示：该滑块仅影响聊天区气泡及其文字，不改变输入栏/标题栏大小。
  </div>
</div>
<hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
<!-- AI Proactive Chat Settings for Group Chat -->
<div class="form-group">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <label for="group-ai-proactive-chat-toggle" style="margin-bottom:0;">开启AI后台回复</label>
        <input type="checkbox" id="group-ai-proactive-chat-toggle" style="width: auto;">
    </div>
<div id="group-ai-proactive-options" style="display: none;">
        <label for="group-ai-proactive-chat-delay">无回复超过 (分钟)</label>
        <input type="number" id="group-ai-proactive-chat-delay" min="1" placeholder="例如：30">
        <label for="group-ai-proactive-chat-interval" style="margin-top: 10px;">AI后台回复间隔时间 (分钟)</label>
        <input type="number" id="group-ai-proactive-chat-interval" min="1" placeholder="例如：60">
    </div>
</div>
<hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"/>
                <button type="submit" class="btn btn-primary">保存设置</button>
                 </form>
            <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
            	<div class="form-group">
            <button type="button" class="btn btn-secondary" id="search-group-history-btn">搜索聊天记录</button>
        </div>
            <button type="button" class="btn btn-danger" id="clear-group-chat-history-btn">清空聊天记录</button>
        </div>
    </div>
    <!-- Group Member Edit Modal -->
    <div id="edit-group-member-modal" class="modal-overlay">
        <div class="modal-window">
            <h3 id="edit-group-member-title">编辑群成员</h3>
            <form id="edit-group-member-form">
                <input type="hidden" id="editing-member-id">
                             <div class="avatar-setting" style="justify-content: center;">
    <div class="avatar-container-setting" id="group-member-avatar-container-setting">
        <img src="" alt="成员头像" id="edit-member-avatar-preview" class="avatar-preview" style="cursor: pointer;">
        <!-- 头像框将动态添加在这里 -->
    </div>
    <button type="button" class="btn btn-small btn-primary avatar-frame-btn" data-target="group-member">🌟</button>
    <input type="file" id="edit-member-avatar-upload" accept="image/*" style="display:none;">
</div>
                <div class="form-group">
                    <label for="edit-member-group-nickname">群昵称</label>
                    <input type="text" id="edit-member-group-nickname" required>
                </div>
                <div class="form-group">
                    <label for="edit-member-real-name">真名</label>
                    <input type="text" id="edit-member-real-name" required>
                </div>
                <div class="form-group">
                    <label for="edit-member-persona">人设</label>
                    <textarea id="edit-member-persona" placeholder="详细描述角色的性格、背景等。"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">保存</button>
            </form>
        </div>
    </div>
    <!-- Add Member to Group Action Sheet -->
    <div id="add-member-actionsheet" class="action-sheet-overlay">
        <div class="action-sheet">
            <button class="action-sheet-button" id="invite-existing-member-btn">邀请现有角色</button>
            <button class="action-sheet-button" id="create-new-member-btn">创建新角色入群</button>
        </div>
    </div>
    <!-- Invite Existing Member Modal -->
    <div id="invite-member-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>邀请成员加入群聊</h3>
            <ul id="invite-member-selection-list"></ul>
            <button class="btn btn-primary" id="confirm-invite-btn" style="margin-top: 20px;">确认邀请</button>
        </div>
    </div>
    <!-- 在这里插入音乐播放器弹窗 -->
<div id="music-player-modal" class="modal-overlay">
    <div class="modal-window">
        <div class="music-player-header">
            <h3 class="song-title">歌曲名</h3>
            <svg class="share-btn" viewBox="0 0 24 24"><path d="M18,16.08C17.24,16.08 16.56,16.38 16.04,16.85L8.91,12.7C8.96,12.47 9,12.24 9,12C9,11.76 8.96,11.53 8.91,11.3L16.04,7.15C16.56,7.62 17.24,7.92 18,7.92C19.66,7.92 21,6.58 21,5C21,3.42 19.66,2 18,2C16.34,2 15,3.42 15,5C15,5.24 15.04,5.47 15.09,5.7L7.96,9.85C7.44,9.38 6.76,9.08 6,9.08C4.34,9.08 3,10.42 3,12C3,13.58 4.34,14.92 6,14.92C6.76,14.92 7.44,14.62 7.96,14.15L15.09,18.3C15.04,18.53 15,18.76 15,19C15,20.58 16.34,22 18,22C19.66,22 21,20.58 21,19C21,17.42 19.66,16.08 18,16.08Z"/></svg>
        </div>
        <!-- 在 id="music-player-modal" 内找到 .music-player-body -->
<div class="music-player-body">
    <img src="https://i.postimg.cc/nzP9sgxr/chan-125.png" alt="专辑封面" class="music-album-art">
    <!-- ▼▼▼ 修改下面这一行 ▼▼▼ -->
    <div id="lyrics-panel" class="lyrics-panel">
        <p class="lyric-line">暂无歌词</p>
    </div>
    <!-- ▲▲▲ 修改结束 ▲▲▲ -->
    <div class="music-controls">
        <button class="side-btn" title="上一首"><svg viewBox="0 0 24 24"><path d="M6,18V6H8V18H6M9.5,12L18,6V18L9.5,12Z"/></svg></button>
        <button class="play-btn" title="播放/暂停"><svg viewBox="0 0 24 24"><path d="M8,5.14V19.14L19,12.14L8,5.14Z"/></svg></button>
        <button class="side-btn" title="下一首"><svg viewBox="0 0 24 24"><path d="M16,18H18V6H16V18M4,18V6L13,12L4,18Z"/></svg></button>
    </div>
</div>
        <div class="music-extra-controls">
            <button title="循环模式"><svg viewBox="0 0 24 24"><path d="M17,17H7V14L3,18L7,22V19H19V13H17M7,7H17V10L21,6L17,2V5H5V11H7V7Z"/></svg></button>
            <button title="歌曲列表"><svg viewBox="0 0 24 24"><path d="M3,13H15V11H3M3,6V8H21V6M3,18H9V16H3V18Z"/></svg></button>
        </div>
    </div>
</div>
<!-- NEW: Add Category Modal -->
<div id="add-category-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>创建新分类</h3>
        <form id="add-category-form">
            <div class="form-group">
                <label for="category-name-input">分类名称</label>
                <input type="text" id="category-name-input" placeholder="例如：主要角色、地点设定" required>
            </div>
            <button type="submit" class="btn btn-primary">创建</button>
        </form>
    </div>
</div>

<!-- === 新增：头像框选择面板 === -->
<div id="avatar-frame-modal" class="modal-overlay">
    <div class="modal-window">
        <div class="modal-header">
            <h3>选择头像框</h3>
            <button id="add-avatar-frame-btn" class="btn btn-primary btn-small">+</button>
        </div>
        <div id="avatar-frame-grid">
            <!-- 头像框将由JS动态渲染于此 -->
        </div>
        <div class="modal-footer">
            <button id="remove-avatar-frame-btn" class="btn btn-danger">移除头像框</button>
            <button id="apply-avatar-frame-btn" class="btn btn-primary">应用</button>
            <button id="cancel-avatar-frame-btn" class="btn btn-neutral">取消</button>
        </div>
    </div>
</div>
<!-- =============================================================== -->
<!-- START: 新增音乐功能HTML (粘贴到 </body> 标签前) -->
<!-- =============================================================== -->

<!-- 音乐播放列表面板 -->
<div id="music-playlist-panel" class="action-sheet-overlay">
    <div class="action-sheet" style="height: 60%; display: flex; flex-direction: column;">
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; border-bottom: 1px solid #eee; flex-shrink: 0;">
            <h3 style="margin: 0; font-size: 16px;">播放列表</h3>
            <button id="open-add-song-modal-btn" class="btn btn-primary btn-small" style="font-size: 24px; padding: 0; width: 32px; height: 32px; border-radius: 50%;">+</button>
        </div>
        <ul id="playlist-container" class="list-container" style="flex-grow: 1; overflow-y: auto; padding: 5px;">
            <!-- 歌曲列表将由JS动态生成 -->
        </ul>
    </div>
</div>

<!-- 添加歌曲弹窗 -->
<div id="add-song-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>添加新歌曲</h3>
        <form id="add-song-form">
            <div class="form-group">
                <label for="song-url-input">歌曲URL (Catbox MP3)</label>
                <input type="url" id="song-url-input" placeholder="https://files.catbox.moe/..." required>
            </div>
            <div class="form-group">
                <label for="song-name-input">歌曲名称</label>
                <input type="text" id="song-name-input" placeholder="歌曲的名称" required>
            </div>
             <div class="form-group">
                <label for="song-artist-input">艺术家</label>
                <input type="text" id="song-artist-input" placeholder="演唱者/艺术家" required>
            </div>
            <div class="form-group">
                <label for="song-album-art-input">专辑封面URL (选填)</label>
                <input type="url" id="song-album-art-input" placeholder="https://...">
            </div>
            <div class="form-group">
                <label for="song-lyrics-input">歌词内容 (选填)</label>
                <textarea id="song-lyrics-input" rows="5" placeholder="在此处粘贴 .lrc 文件内容..."></textarea>
            </div>
            <button type="submit" class="btn btn-primary">添加</button>
        </form>
    </div>
</div>

<!-- 分享音乐弹窗 -->
<div id="share-music-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>分享音乐给...</h3>
        <ul id="share-music-selection-list" class="list-container" style="max-height: 40vh; overflow-y: auto;">
            <!-- 聊天对象列表将由JS动态生成 -->
        </ul>
        <button id="confirm-music-share-btn" class="btn btn-primary" style="margin-top: 20px;">确认分享</button>
    </div>
</div>

<!-- 全局音频播放器 -->
<audio id="global-audio-player"></audio>

<!-- 用于上传LRC文件的隐藏输入框 -->
<input type="file" id="lrc-upload-input" accept=".lrc" style="display: none;">
<!-- 音乐播放器弹窗结束 -->
    <!-- Create New Member for Group Modal -->
    <div id="create-member-for-group-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>创建新角色并加入群聊</h3>
            <form id="create-member-for-group-form">
                <div class="avatar-setting" style="justify-content: center;">
                    <img src="https://i.postimg.cc/Y96LPskq/o-o-2.jpg" alt="新成员头像"
                         id="create-group-member-avatar-preview" class="avatar-preview" style="cursor: pointer;">
                    <input type="file" id="create-group-member-avatar-upload" accept="image/*" style="display:none;">
                </div>
                <div class="form-group">
                    <label for="create-group-member-nickname">群昵称</label>
                    <input type="text" id="create-group-member-nickname" required>
                </div>
                <div class="form-group">
                    <label for="create-group-member-realname">真名</label>
                    <input type="text" id="create-group-member-realname" required>
                </div>
                <div class="form-group">
                    <label for="create-group-member-persona">人设</label>
                    <textarea id="create-group-member-persona" placeholder="详细描述角色的性格、背景等。"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">创建并加入</button>
            </form>
        </div>
    </div>
<!-- =============================================================== -->
<!-- START: 新增钱包功能HTML (粘贴到 </body> 标签前) -->
<!-- =============================================================== -->
<!-- START: 新增聊天记录搜索弹窗 -->
<div id="search-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>搜索当前聊天记录</h3>
        <form id="search-modal-form">
            <div class="form-group">
                <input type="search" id="search-modal-input" class="form-group" placeholder="输入关键词..." required>
            </div>
            <button type="submit" class="btn btn-primary">搜索</button>
        </form>
    </div>
</div>
<!-- END: 新增聊天记录搜索弹窗 -->
<!-- 1. 钱包主界面 Screen -->
<div id="wallet-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="home-container">‹</button>
        <div class="title-container">
            <h1 class="title">我的钱包</h1>
        </div>
       <div class="action-btn-group">
    <button class="action-btn" id="wallet-settings-btn">设置</button>
</div>
    </header>
    <main class="content" style="padding: 20px; background-color: #f9f9f9;">
        <div class="wallet-balance-card">
            <p class="wallet-balance-label">零花钱余额 (元)</p>
            <p class="wallet-balance-amount" id="wallet-balance-display">0.00</p>
        </div>
        <div class="wallet-actions-list">
            <div class="wallet-action-item" id="show-transactions-btn">
                <span>零花钱明细</span>
                <span>›</span>
            </div>
        </div>
    </main>
</div>
<!-- START: 新增聊天记录搜索结果页面 -->
<div id="search-results-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="chat-room-screen">‹</button>
        <div class="title-container">
            <h1 class="title">搜索结果</h1>
        </div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
        <ul class="list-container" id="search-results-list">
            <!-- 搜索结果将由JS动态生成 -->
        </ul>
        <div class="placeholder-text" id="no-search-results-placeholder" style="display: none;">
            <p>未找到相关聊天记录</p>
        </div>
    </main>
</div>
<!-- END: 新增聊天记录搜索结果页面 -->
<!-- 2. 钱包设置界面 Screen -->
<div id="wallet-settings-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="wallet-screen">‹</button>
        <div class="title-container">
            <h1 class="title">支付设置</h1>
        </div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
        <form id="wallet-settings-form">
    <div class="form-group">
    <label for="wallet-balance-input">设置零花钱余额</label>
    <input type="number" id="wallet-balance-input" placeholder="0.00" step="0.01" min="0">
</div>

<div class="form-group toggle-group">
    <label for="wallet-password-enabled-toggle" style="margin-bottom:0;">启用支付密码</label>
    <label class="toggle-switch">
        <input type="checkbox" id="wallet-password-enabled-toggle">
        <span class="slider"></span>
    </label>
</div>
<div class="form-group">
    <label for="wallet-password-input">设置/修改支付密码 (6位数字)</label>
    <input type="password" id="wallet-password-input" pattern="\d{6}" maxlength="6" inputmode="numeric">
</div>
            <button type="submit" class="btn btn-primary">保存设置</button>
        </form>
    </main>
</div>

<!-- 3. 零花钱明细弹窗 Modal -->
<div id="transaction-details-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>零花钱明细</h3>
        <ul id="transaction-list-container" class="list-container" style="max-height: 60vh; overflow-y: auto;">
            <!-- 明细将由JS动态生成 -->
        </ul>
        <button class="btn btn-primary" id="close-transactions-btn" style="margin-top: 20px;">关闭</button>
    </div>
</div>

<!-- 4. 支付密码输入弹窗 Modal -->
<div id="payment-password-modal" class="modal-overlay">
    <div class="modal-window">
        <h3 id="payment-prompt-title">请输入支付密码</h3>
        <p id="payment-prompt-description" style="text-align:center; color:#666;"></p>
        <div class="form-group">
            <input type="password" id="payment-password-input" pattern="\d{6}" maxlength="6" inputmode="numeric" style="text-align:center; font-size: 20px; letter-spacing: 1em;">
        </div>
        <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button class="btn btn-neutral" id="cancel-payment-btn" style="flex: 1;">取消</button>
            <button class="btn btn-primary" id="confirm-payment-btn" style="flex: 1;">确认</button>
        </div>
    </div>
</div>

<!-- =============================================================== -->
<!-- END: 新增钱包功能HTML -->
<!-- =============================================================== -->
<!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<!-- AI POV: Character Selection Screen -->
<div id="ai-character-select-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="home-container">‹</button>
        <div class="title-container">
            <h1 class="title">选择AI视角</h1>
        </div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
        <ul class="list-container" id="ai-character-select-list"></ul>
        <div class="placeholder-text" id="no-ai-chars-placeholder" style="display: none;">
            <p>还没有创建任何AI角色哦~</p>
        </div>
    </main>
</div>

<!-- AI POV: AI's Chat List Screen -->
<div id="ai-chat-list-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="ai-character-select-screen">‹</button>
        <div class="title-container">
            <h1 class="title" id="ai-chat-list-title">的聊天列表</h1>
        </div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
        <ul class="list-container" id="ai-chat-list-container"></ul>
         <div class="placeholder-text" id="no-ai-chats-placeholder" style="display: none;">
            <p>Ta还没有和别人聊过天哦~</p>
        </div>
    </main>
</div>

<!-- AI POV: AI's Conversation View Screen -->
<div id="ai-chat-view-screen" class="screen">
   <header class="app-header">
    <button class="back-btn" data-target="ai-chat-list-screen">‹</button>
    <div class="title-container">
        <h1 class="title" id="ai-chat-view-title">与...的对话</h1>
    </div>
    <div class="placeholder"></div>
   </header>
    <main class="content">
        <div class="message-area" id="ai-message-area"></div>
    </main>
    <!-- 这个屏幕是只读的，所以没有输入框 -->
</div>
<!-- ▲▲▲ 新代码粘贴到这里结束 ▲▲▲ -->
<!-- === Modal 结束 === -->
<div id="voice-call-overlay">
    <img src="" alt="Avatar" class="call-avatar-large" id="call-avatar">
    <h2 class="call-name" id="call-name">...</h2>
    <p class="call-status" id="call-status">正在呼叫...</p>

    <div id="ringing-view">
        <div class="call-button-group" id="incoming-buttons" style="display: none;">
            <button class="call-button decline" id="decline-call-btn">
                <div class="icon-wrapper"><svg viewBox="0 0 24 24"><path d="M12,9C10.4,9 9,10.4 9,12S10.4,15 12,15 15,13.6 15,12 13.6,9 12,9M12,17.25C9.24,17.25 6.75,15.17 6.75,12.5C6.75,11.05 7.42,9.73 8.5,8.81L15.19,15.5C14.27,16.58 12.95,17.25 12,17.25M17.25,12C17.25,14.76 15.17,17.25 12.5,17.25C11.05,17.25 9.73,16.58 8.81,15.5L15.5,8.81C16.58,9.73 17.25,11.05 17.25,12M4.44,3L3,4.44L8.06,9.5C7.36,10.23 6.84,11.08 6.5,12H4.13C4.5,14.75 6.13,17.13 8.5,18.5V22H15.5V18.5C16.92,17.81 18.1,16.81 18.91,15.56L20.56,17.22L21.94,15.84L4.44,3Z" /></svg></div>
                <span>拒接</span>
            </button>
            <button class="call-button accept" id="accept-call-btn">
                <div class="icon-wrapper"><svg viewBox="0 0 24 24"><path d="M6.62,10.79C8.06,13.62 10.38,15.94 13.21,17.38L15.41,15.18C15.69,14.9 16.08,14.82 16.43,14.93C17.55,15.3 18.75,15.5 20,15.5A1,1 0 0,1 21,16.5V20A1,1 0 0,1 20,21A17,17 0 0,1 3,4A1,1 0 0,1 4,3H7.5A1,1 0 0,1 8.5,4C8.5,5.25 8.7,6.45 9.07,7.57C9.18,7.92 9.1,8.31 8.82,8.59L6.62,10.79Z" /></svg></div>
                <span>接听</span>
            </button>
        </div>
        <div class="call-button-group" id="outgoing-buttons" style="display: none;">
            <button class="call-button decline" id="cancel-call-btn">
                 <div class="icon-wrapper"><svg viewBox="0 0 24 24"><path d="M12,9C10.4,9 9,10.4 9,12S10.4,15 12,15 15,13.6 15,12 13.6,9 12,9M12,17.25C9.24,17.25 6.75,15.17 6.75,12.5C6.75,11.05 7.42,9.73 8.5,8.81L15.19,15.5C14.27,16.58 12.95,17.25 12,17.25M17.25,12C17.25,14.76 15.17,17.25 12.5,17.25C11.05,17.25 9.73,16.58 8.81,15.5L15.5,8.81C16.58,9.73 17.25,11.05 17.25,12M4.44,3L3,4.44L8.06,9.5C7.36,10.23 6.84,11.08 6.5,12H4.13C4.5,14.75 6.13,17.13 8.5,18.5V22H15.5V18.5C16.92,17.81 18.1,16.81 18.91,15.56L20.56,17.22L21.94,15.84L4.44,3Z" /></svg></div>
                <span>取消</span>
            </button>
        </div>
    </div>

 <div id="call-transcript-area"></div>
    <div class="call-button-group" id="hangup-button-container">
        <button class="call-button decline" id="hangup-call-btn">
            </button>
    </div>
    <div id="call-input-area">
        <input type="text" id="call-input" placeholder="输入文字...">
        <button id="send-call-message-btn">➤</button>
    </div>
</div>
</div>
  
</div>
<input type="file" id="import-data-input" accept=".ee" style="display: none;">	
<script>
 
    const URLBlacklist = []

    async function compressImage(file, options = {}) {
            const {
                quality = 0.8, maxWidth = 800, maxHeight = 800
            } = options;

            // --- 新增：处理GIF动图 ---
            // 如果文件是GIF，则不经过canvas压缩，直接返回原始文件数据以保留动画
            if (file.type === 'image/gif') {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            }

            // --- 对其他静态图片（如PNG, JPG）进行压缩 ---
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onerror = reject;
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onerror = reject;
                    img.onload = () => {
                        let width = img.width;
                        let height = img.height;

                        if (width > height) {
                            if (width > maxWidth) {
                                height = Math.round(height * (maxWidth / width));
                                width = maxWidth;
                            }
                        } else {
                            if (height > maxHeight) {
                                width = Math.round(width * (maxHeight / height));
                                height = maxHeight;
                            }
                        }

                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');

                        // 对于有透明背景的PNG图片，先填充一个白色背景
                        // 这样可以防止透明区域在转换成JPEG时变黑
                        if (file.type === 'image/png') {
                            ctx.fillStyle = '#FFFFFF'; // 白色背景
                            ctx.fillRect(0, 0, width, height);
                        }

                        ctx.drawImage(img, 0, 0, width, height);

                        // --- 关键修正：将输出格式改为 'image/jpeg' ---
                        // JPEG格式可以显著减小文件大小，避免浏览器处理超大Base64字符串时崩溃
                        const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                        resolve(compressedDataUrl);
                    };
                };
            });
        }
    // gemini如果是多个密钥, 那么随机获取一个
    function getRandomValue(str) {
        // 检查字符串是否包含逗号
        if (str.includes(',')) {
            // 用逗号分隔字符串并移除多余空格
            const arr = str.split(',').map(item => item.trim());
            // 生成随机索引 (0 到 arr.length-1)
            const randomIndex = Math.floor(Math.random() * arr.length);
            // 返回随机元素
            return arr[randomIndex];
        }
        // 没有逗号则直接返回原字符串
        return str;
    }
    const toastElement = document.getElementById('toast-notification');
const showToast = (message) => {
            toastElement.textContent = message;
            toastElement.classList.add('show');
            setTimeout(() => toastElement.classList.remove('show'), 3000);
        };
        const pad = (num) => num.toString().padStart(2, '0');
        async function callAiApi(messages) {
    const { provider, url, key, model } = db.apiSettings;
    if (!url || !key || !model) {
        throw new Error('API设置不完整');
    }

    let endpoint = url;
    let headers = { 'Content-Type': 'application/json' };
    let requestBody;

    // 根据不同的服务商构建请求
    if (provider === 'gemini') {
        endpoint = `${url}/v1beta/models/${model}:generateContent?key=${getRandomValue(key)}`;
        requestBody = {
            contents: messages,
            generationConfig: {}
        };
    } else { // OpenAI, DeepSeek, Claude, NewAPI 等兼容格式
        endpoint = `${url}/v1/chat/completions`;
        headers['Authorization'] = `Bearer ${getRandomValue(key)}`;
        requestBody = {
            model,
            messages,
            stream: false // 论坛功能需要非流式输出
        };
    }

    const response = await fetch(endpoint, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
        const errorText = await response.text();
        console.error("API Error Response:", errorText);
        // 如果返回的是HTML错误页面，给出更清晰的提示
        if (errorText.trim().startsWith('<')) {
            throw new Error(`API返回了一个错误页面(HTML)，而不是JSON数据。`);
        }
        throw new Error(`AI服务请求失败: ${response.status} ${errorText}`);
    }

    const data = await response.json();

    // 根据不同服务商解析最终的文本内容
    if (provider === 'gemini') {
        if (data.candidates && data.candidates[0].content && data.candidates[0].content.parts) {
            return data.candidates[0].content.parts[0].text;
        }
   } else { // OpenAI, DeepSeek, Claude, NewAPI 等兼容格式
    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
        // 确保 choices 数组不是空的
        return data.choices[0].message.content;
    } else {
        // 如果 choices 数组是空的, 抛出一个更明确的错误
        const finishReason = data.choices && data.choices.length > 0 ? data.choices[0].finish_reason : 'unknown';
        if (finishReason === 'content_filter') {
            throw new Error("内容触发了API的安全审核被拦截。");
        }
        throw new Error("API返回了空结果，请检查模型或提示词。");
    }
}
    
    // 如果上面的路径都找不到，抛出错误
    throw new Error('未能从API响应中解析出有效的文本内容。');
}
// ▲▲▲ 替换结束 ▲▲▲
    document.addEventListener('DOMContentLoaded', () => {
    

        // --- Initial HTML Injection ---
        // (请找到文件中的旧 'api-settings-screen'.innerHTML 代码，并用下面的代码完整替换它)



// START: 修正动态生成屏幕的返回按钮 (完整替换)
document.getElementById('api-settings-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-container">‹</button><div class="title-container"><h1 class="title">API 设置</h1></div><div class="placeholder"></div></header><main class="content"><form id="api-form"><div class="form-group"><label for="api-provider">API 服务商</label><select id="api-provider" name="provider"><option value="newapi">NewAPI (自定义)</option><option value="deepseek">DeepSeek</option><option value="claude">Claude</option><option value="gemini">Gemini</option></select>
<div class="api-presets-embedded" style="margin-top:12px;">
<div id="api-presets-control" style="margin:12px 0;padding:12px;border-radius:8px;border:1px solid var(--border-color, #eee);background:var(--panel-bg, #fff);box-shadow:var(--panel-shadow, none);">
  <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
    <label style="min-width:86px;color:var(--muted,#666);">API 预设：</label>
    <select id="api-preset-select" style="flex:1;padding:8px;border-radius:6px;border:1px solid #ddd;">
      <option value="">— 选择 API 预设 —</option>
    </select>
    <button id="api-apply-preset" class="btn btn-primary" style="margin-left:8px;padding:6px 10px;">应用</button>
  </div>
  <div style="display:flex;gap:8px;align-items:center;">
    <button id="api-save-preset" class="btn" style="padding:6px 10px;">另存为预设</button>
    <button id="api-manage-presets" class="btn" style="padding:6px 10px;">管理</button>
    <div style="flex:1"></div>
    <button id="api-import-presets" class="btn" style="padding:6px 10px;">导入</button>
    <button id="api-export-presets" class="btn" style="padding:6px 10px;">导出</button>
  </div>
</div>

<div id="api-presets-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.35);z-index:9999;align-items:center;justify-content:center;">
  <div style="width:640px;max-width:94%;background:var(--panel-bg,#fff);padding:16px;border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,0.12);">
    <h3 style="margin:0 0 12px 0;">API 预设管理</h3>
    <div id="api-presets-list" style="max-height:360px;overflow:auto;border:1px solid #f0f0f0;padding:8px;border-radius:6px;"></div>
    <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end;">
      <button id="api-close-modal" class="btn btn-primary">关闭</button>
    </div>
  </div>
</div>
</div>
</div><div class="form-group"><label for="api-url">API 地址（后缀不用添加/v1）</label><input type="url" id="api-url" name="url" placeholder="选择服务商可自动填写" required></div><div class="form-group"><label for="api-key">密钥 (Key)</label><input type="password" id="api-key" name="key" placeholder="请输入你的API密钥" required></div><button type="button" class="btn btn-secondary" id="fetch-models-btn"><span class="btn-text">点击拉取模型</span><div class="spinner"></div></button><div class="form-group"><label for="api-model">选择模型</label><select id="api-model" name="model" required><option value="">请先拉取模型列表</option></select></div>
<div class="form-group" style="border-top: 1px solid #eee; padding-top: 20px; margin-top: 20px;">
    <label for="ai-block-duration">AI自动解封时间 (分钟)</label>
    <input type="number" id="ai-block-duration" min="0" placeholder="0 或留空表示永不自动解封">
</div>
<div class="form-group" style="display: flex; align-items: center; justify-content: space-between; margin-top: 20px; border-top: 1px solid #eee; padding-top: 20px;">
    <label for="force-html-theater" style="margin-bottom: 0;">生成HTML小剧场</label>
    <input type="checkbox" id="force-html-theater" style="width: auto; height: 20px;">
</div>
<div class="form-group" style="display: flex; align-items: center; justify-content: space-between; margin-top: 20px;">
    <label for="ai-auto-post-moment" style="margin-bottom: 0;">AI自动发布动态</label>
    <input type="checkbox" id="ai-auto-post-moment" style="width: auto; height: 20px;">
</div>
<button type="submit" class="btn btn-primary" id="save-btn"><span class="btn-text">保 存</span><div class="spinner"></div></button>
</form></main>`;

document.getElementById('wallpaper-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-container">‹</button><div class="title-container"><h1 class="title">更换壁纸</h1></div><div class="placeholder"></div></header><main class="content"><div class="wallpaper-preview" id="wallpaper-preview"><span>当前壁纸预览</span></div><input type="file" id="wallpaper-upload" accept="image/*" style="display: none;"><label for="wallpaper-upload" class="btn btn-primary">从相册选择新壁纸</label></main>`;
// --- 新代码开始 ---
document.getElementById('font-settings-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-container">‹</button><div class="title-container"><h1 class="title">字体设置</h1></div><div class="placeholder"></div></header><main class="content">
    
    <div id="font-presets-control" style="margin:15px 0; padding:15px; border-radius:12px; border:1px solid #fce4ec; background:#fff8fa;">
      <div style="display:flex; align-items:center; gap:8px; margin-bottom:12px;">
        <label style="color:var(--secondary-color); font-weight:600;">字体预设</label>
        <select id="font-preset-select" style="flex:1; padding:8px; border-radius:8px; border:1px solid #fce4ec;"></select>
      </div>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button id="font-apply-preset" class="btn btn-primary btn-small">应用</button>
        <button id="font-save-preset" class="btn btn-secondary btn-small">另存</button>
        <button id="font-manage-presets" class="btn btn-neutral btn-small">管理</button>
      </div>
    </div>
    <form id="font-settings-form">
        <div class="form-group">
            <label for="font-url">字体链接 (ttf, woff, woff2)</label>
            <input type="url" id="font-url" placeholder="https://.../font.ttf" required>
        </div>
        <p style="font-size:12px; color:#888; text-align:center;">示例: https://lf3-static.bytednsdoc.com/obj/eden-cn/jplptk/ljhwZthlaukjlkulzlp/portal/fonts/HarmonyOS_Sans_SC_Regular.woff2</p>
        <button type="submit" class="btn btn-primary">应用字体</button>
        <button type="button" class="btn btn-neutral" id="restore-default-font-btn" style="margin-top: 15px;">恢复默认字体</button>
    </form>
</main>`;
// --- 新代码结束 ---
document.getElementById('customize-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-container">‹</button><div class="title-container"><h1 class="title">主屏幕自定义</h1></div><div class="placeholder"></div></header><main class="content"><form id="customize-form"></form></main>`;
document.getElementById('tutorial-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-container">‹</button><div class="title-container"><h1 class="title">教程</h1></div><div class="placeholder"></div></header><main class="content" id="tutorial-content-area"></main>`;
// END: 修正动态生成屏幕的返回按钮
        

        // --- Global Variables and Constants ---
        const colorThemes = {
            'white_pink': {
                name: '白/粉',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(255,204,204,0.9)', text: '#A56767'}
            },
            'white_blue': {
                name: '白/蓝',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(173,216,230,0.9)', text: '#4A6F8A'}
            },
            'white_yellow': {
                name: '白/黄',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(249,237,105,0.9)', text: '#8B7E4B'}
            },
            'white_green': {
                name: '白/绿',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(188,238,188,0.9)', text: '#4F784F'}
            },
            'white_purple': {
                name: '白/紫',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(185,190,240,0.9)', text: '#6C5B7B'}
            },
            'black_red': {
                name: '黑/红',
                received: {bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0'},
                sent: {bg: 'rgb(226,62,87,0.9)', text: '#fff'}
            },
            'black_green': {
                name: '黑/绿',
                received: {bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0'},
                sent: {bg: 'rgba(119,221,119,0.9)', text: '#2E5C2E'}
            },
            'black_white': {
                name: '黑/白',
                received: {bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0'},
                sent: {bg: 'rgba(245,245,245,0.9)', text: '#333'}
            },
            'white_black': {
                name: '白/黑',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(50,50,50,0.85)', text: '#F5F5F5'}
            },
            'yellow_purple': {
                name: '黄/紫',
                received: {bg: 'rgba(255,250,205,0.9)', text: '#8B7E4B'},
                sent: {bg: 'rgba(185,190,240,0.9)', text: '#6C5B7B'}
            },
            'pink_blue': {
                name: '粉/蓝',
                received: {bg: 'rgba(255,231,240,0.9)', text: '#7C6770'},
                sent: {bg: 'rgba(173,216,230,0.9)', text: '#4A6F8A'}
            },
        };
const defaultIcons = {
            'chat-list-screen': {name: '404', url: 'https://i.postimg.cc/VvQB8dQT/chan-143.png'},
            'api-settings-screen': {name: 'api', url: 'https://i.postimg.cc/50FqT8GL/chan-125.png'},
            'wallpaper-screen': {name: '壁纸', url: 'https://i.postimg.cc/3wqFttL3/chan-90.png'},
            'world-book-screen': {name: '世界书', url: 'https://i.postimg.cc/prCWkrKT/chan-74.png'},
            'customize-screen': {name: '自定义', url: 'https://i.postimg.cc/vZVdC7gt/chan-133.png'},
            'font-settings-screen': {name: '字体', url: 'https://i.postimg.cc/FzVtC0x4/chan-21.png'},
            'tutorial-screen': {name: '教程', url: 'https://i.postimg.cc/6QgNzCFf/chan-118.png'},
            'ai-character-select-screen': {name: 'AI手机', url: 'https://i.postimg.cc/9Q8B2X3D/chan-101.png'},
            'renderer-screen': {name: '渲染器', url: 'https://i.postimg.cc/zX7d2b2S/image.png'},
            'mall-screen': {name: '商城', url: 'https://i.postimg.cc/PqYkx23B/shop-icon.png'},
            'soul-bond-app-icon': {name: '心灵羁绊', url: 'https://i.postimg.cc/P5pQd2Xp/image.png'},
            'day-mode-btn': {name: '', url: 'https://i.postimg.cc/Jz0tYqnT/chan-145.png'},
            'night-mode-btn': {name: '', url: 'https://i.postimg.cc/htYvkdQK/chan-146.png'},
            'record-label': { name: '唱片标签 (圆形)', url: 'https://i.postimg.cc/nzP9sgxr/chan-125.png' },
            'record-sleeve': { name: '唱片封套 (方形)', url: 'https://i.postimg.cc/KzC3q4w3/image.png' },
            'decorative-component': { name: '装饰组件 (方形)', url: '' },
   // --- 新增：AI手机内部App图标 ---
            'ai-space-404': { name: '404', icon: 'https://i.postimg.cc/VvQB8dQT/chan-143.png' },
            'ai-space-browser': { name: '浏览器', icon: 'https://i.postimg.cc/Pq5YQJk8/safari.png' },
            'ai-space-photos': { name: '照片', icon: 'https://i.postimg.cc/d1sQRp2z/photos.png' },
            'ai-space-wallet': { name: '钱包', icon: 'https://i.postimg.cc/mkZ1hN3r/wallet.png' },
            'ai-space-shopping': { name: '购物', icon: 'https://i.postimg.cc/PqYkx23B/shop-icon.png' },
            'ai-space-memo': { name: '备忘录', icon: 'https://i.postimg.cc/TY4J1j2L/notes.png' },
            'ai-space-signal': { name: '心动讯号', icon: 'https://i.postimg.cc/tJ0g1C0m/heart.png' },
            'ai-space-music': { name: '音乐', icon: 'https://i.postimg.cc/d10J4VzR/image.png' },
            'ai-space-phone': { name: '电话', icon: 'https://i.postimg.cc/W35G2FzW/phone.png' },
        };

        let db = {
            characters: [],
            groups: [],
            apiSettings: {},
            wallpaper: 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg',
            wallpaper2: 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg', // 新增：第二页壁纸
            myStickers: [],
            homeScreenMode: 'night',
            worldBooks: [],
            fontUrl: '',
            customIcons: {},
            customWidgets: [], // <-- 添加这一行
            playlist: [], // <-- 新增
            musicPlayerSettings: { // <-- 新增
                volume: 0.8,
                playbackMode: 'sequential', 
                },
                renderers: [],
        rendererCategories: []
        };
        let currentQuotedMessageId = null, currentChatId = null, currentChatType = null, isGenerating = false, longPressTimer = null;
        inputElement = null;
        let isInScreenshotMode = false;
let selectedMessagesForScreenshot = new Set();
let notificationQueue = [];
let isNotificationShowing = false;
            isInMultiSelectMode = false, editingMessageId = null, currentPage = 1, currentTransferMessageId = null,
            currentEditingWorldBookId = null, currentStickerActionTarget = null,
            currentGroupAction = {type: null, recipients: []};
            let isFavoriteProcessing = false; // 用于防止收藏按钮被双击
// ▲▲▲ 添加结束 ▲▲▲
            let audioPlayer = null;
        let currentSongIndex = -1;
        let isPlaying = false;
        let sharedWithChatIds = new Set();
        let shuffleOrder = [];
        let parsedLyrics = [];
        let currentLyricIndex = -1;
        let isAiCalling = false; // 新增：标记是否是AI发起的呼叫
            let isVoiceCallActive = false, voiceCallTranscript = [], voiceCallStartTime = null, callTimerInterval = null, currentCallTargetId = null;
let isCallRinging = false; // <-- 新增变量，标记是否处于正在响铃状态
let callInitiationTimeout = null; // <-- 新增变量，用于存放呼叫超时计时器
        let selectedMessageIds = new Set();
        const MESSAGES_PER_PAGE = 50;

        // --- DOM Element Cache ---
        const screens = document.querySelectorAll('.screen'),
            toastElement = document.getElementById('toast-notification'),
            homeScreen = document.getElementById('home-screen'),
            chatListContainer = document.getElementById('chat-list-container'),
            noChatsPlaceholder = document.getElementById('no-chats-placeholder'),
            addChatBtn = document.getElementById('add-chat-btn'),
            addCharModal = document.getElementById('add-char-modal'),
            addCharForm = document.getElementById('add-char-form'),
            chatRoomScreen = document.getElementById('chat-room-screen'),
            chatRoomHeaderDefault = document.getElementById('chat-room-header-default'),
            chatRoomHeaderSelect = document.getElementById('chat-room-header-select'),
            cancelMultiSelectBtn = document.getElementById('cancel-multi-select-btn'),
            multiSelectTitle = document.getElementById('multi-select-title'),
            chatRoomTitle = document.getElementById('chat-room-title'),
            chatRoomStatusText = document.getElementById('chat-room-status-text'),
            messageArea = document.getElementById('message-area'),
            messageInputDefault = document.getElementById('message-input-default'),
            messageInput = document.getElementById('message-input'),
            sendMessageBtn = document.getElementById('send-message-btn'),
            getReplyBtn = document.getElementById('get-reply-btn'),
            typingIndicator = document.getElementById('typing-indicator'),
            chatSettingsBtn = document.getElementById('chat-settings-btn'),
            settingsSidebar = document.getElementById('chat-settings-sidebar'),
            settingsForm = document.getElementById('chat-settings-form'),
            messageEditBar = document.getElementById('message-edit-bar'),
            messageEditInput = document.getElementById('message-edit-input'),
            saveEditBtn = document.getElementById('save-edit-btn'),
            cancelEditBtn = document.getElementById('cancel-edit-btn'),
            multiSelectBar = document.getElementById('multi-select-bar'),
            selectCount = document.getElementById('select-count'),
            deleteSelectedBtn = document.getElementById('delete-selected-btn');
        const stickerToggleBtn = document.getElementById('sticker-toggle-btn'),
            stickerModal = document.getElementById('sticker-modal'),
            stickerGridContainer = document.getElementById('sticker-grid-container'),
            addNewStickerBtn = document.getElementById('add-new-sticker-btn'),
            addStickerModal = document.getElementById('add-sticker-modal'),
            addStickerModalTitle = document.getElementById('add-sticker-modal-title'),
            addStickerForm = document.getElementById('add-sticker-form'),
            stickerEditIdInput = document.getElementById('sticker-edit-id'),
            stickerPreview = document.getElementById('sticker-preview'),
            stickerNameInput = document.getElementById('sticker-name'),
            stickerUrlInput = document.getElementById('sticker-url-input'),
            stickerFileUpload = document.getElementById('sticker-file-upload');
            const searchResultsScreen = document.getElementById('search-results-screen'),
            searchResultsList = document.getElementById('search-results-list'),
            noResultsPlaceholder = document.getElementById('no-search-results-placeholder'),
            // ▼▼▼ 新增以下变量 ▼▼▼
            searchModal = document.getElementById('search-modal'),
            searchModalForm = document.getElementById('search-modal-form'),
            searchModalInput = document.getElementById('search-modal-input');
            const voiceCallBtn = document.getElementById('voice-call-btn');
const voiceCallOverlay = document.getElementById('voice-call-overlay');
const callAvatar = document.getElementById('call-avatar');
const callName = document.getElementById('call-name');
const callStatus = document.getElementById('call-status');
const ringingView = document.getElementById('ringing-view');
const incomingButtons = document.getElementById('incoming-buttons');
const outgoingButtons = document.getElementById('outgoing-buttons');
const activeCallView = document.getElementById('active-call-view');
const callTranscriptArea = document.getElementById('call-transcript-area');
const hangupCallBtn = document.getElementById('hangup-call-btn');
const callInput = document.getElementById('call-input');
const sendCallMessageBtn = document.getElementById('send-call-message-btn');
const declineCallBtn = document.getElementById('decline-call-btn');
const acceptCallBtn = document.getElementById('accept-call-btn');
const cancelCallBtn = document.getElementById('cancel-call-btn');
        const stickerActionSheet = document.getElementById('sticker-actionsheet'),
            editStickerBtn = document.getElementById('edit-sticker-btn'),
            deleteStickerBtn = document.getElementById('delete-sticker-btn');
        const voiceMessageBtn = document.getElementById('voice-message-btn'),
            sendVoiceModal = document.getElementById('send-voice-modal'),
            sendVoiceForm = document.getElementById('send-voice-form'),
            voiceTextInput = document.getElementById('voice-text-input'),
            voiceDurationPreview = document.getElementById('voice-duration-preview');
        const photoVideoBtn = document.getElementById('photo-video-btn'),
            sendPvModal = document.getElementById('send-pv-modal'),
            sendPvForm = document.getElementById('send-pv-form'),
            pvTextInput = document.getElementById('pv-text-input');
        const imageRecognitionBtn = document.getElementById('image-recognition-btn'),
            imageUploadInput = document.getElementById('image-upload-input');
        const walletBtn = document.getElementById('wallet-btn'),
            sendTransferModal = document.getElementById('send-transfer-modal'),
            sendTransferForm = document.getElementById('send-transfer-form'),
            transferAmountInput = document.getElementById('transfer-amount-input'),
            transferRemarkInput = document.getElementById('transfer-remark-input');
        const receiveTransferActionSheet = document.getElementById('receive-transfer-actionsheet'),
            acceptTransferBtn = document.getElementById('accept-transfer-btn'),
            returnTransferBtn = document.getElementById('return-transfer-btn');
        const giftBtn = document.getElementById('gift-btn'), sendGiftModal = document.getElementById('send-gift-modal'),
            sendGiftForm = document.getElementById('send-gift-form'),
            giftDescriptionInput = document.getElementById('gift-description-input');
        const timeSkipBtn = document.getElementById('time-skip-btn'),
            timeSkipModal = document.getElementById('time-skip-modal'),
            timeSkipForm = document.getElementById('time-skip-form'),
            timeSkipInput = document.getElementById('time-skip-input');
        const clearChatHistoryBtn = document.getElementById('clear-chat-history-btn');
        const worldBookListContainer = document.getElementById('world-book-list-container'),
            noWorldBooksPlaceholder = document.getElementById('no-world-books-placeholder'),
            addWorldBookBtn = document.getElementById('add-world-book-btn'),
            editWorldBookScreen = document.getElementById('edit-world-book-screen'),
            editWorldBookForm = document.getElementById('edit-world-book-form'),
            worldBookIdInput = document.getElementById('world-book-id'),
            worldBookNameInput = document.getElementById('world-book-name'),
            worldBookContentInput = document.getElementById('world-book-content');
        const linkWorldBookBtn = document.getElementById('link-world-book-btn'),
            worldBookSelectionModal = document.getElementById('world-book-selection-modal'),
            worldBookSelectionList = document.getElementById('world-book-selection-list'),
            saveWorldBookSelectionBtn = document.getElementById('save-world-book-selection-btn');
        const fontSettingsForm = document.getElementById('font-settings-form'),
            fontUrlInput = document.getElementById('font-url'),
            restoreDefaultFontBtn = document.getElementById('restore-default-font-btn');
        const createGroupBtn = document.getElementById('create-group-btn'),
            createGroupModal = document.getElementById('create-group-modal'),
            createGroupForm = document.getElementById('create-group-form'),
            memberSelectionList = document.getElementById('member-selection-list'),
            groupNameInput = document.getElementById('group-name-input'),
            groupSettingsSidebar = document.getElementById('group-settings-sidebar'),
            groupSettingsForm = document.getElementById('group-settings-form'),
            groupMembersListContainer = document.getElementById('group-members-list-container'),
            editGroupMemberModal = document.getElementById('edit-group-member-modal'),
            editGroupMemberForm = document.getElementById('edit-group-member-form');
        const addMemberActionSheet = document.getElementById('add-member-actionsheet'),
            inviteExistingMemberBtn = document.getElementById('invite-existing-member-btn'),
            createNewMemberBtn = document.getElementById('create-new-member-btn'),
            inviteMemberModal = document.getElementById('invite-member-modal'),
            inviteMemberSelectionList = document.getElementById('invite-member-selection-list'),
            confirmInviteBtn = document.getElementById('confirm-invite-btn'),
            createMemberForGroupModal = document.getElementById('create-member-for-group-modal'),
            createMemberForGroupForm = document.getElementById('create-member-for-group-form');
        const customizeForm = document.getElementById('customize-form'),
            tutorialContentArea = document.getElementById('tutorial-content-area');
        const groupRecipientSelectionModal = document.getElementById('group-recipient-selection-modal'),
            groupRecipientSelectionList = document.getElementById('group-recipient-selection-list'),
            confirmGroupRecipientBtn = document.getElementById('confirm-group-recipient-btn'),
            groupRecipientSelectionTitle = document.getElementById('group-recipient-selection-title');
        const linkGroupWorldBookBtn = document.getElementById('link-group-world-book-btn');
// --- NEW: File System Elements ---
const fileBtn = document.getElementById('file-btn'),
      sendFileModal = document.getElementById('send-file-modal'),
      sendFileForm = document.getElementById('send-file-form'),
      fileNameInput = document.getElementById('file-name-input'),
      fileContentInput = document.getElementById('file-content-input');
 // --- NEW: Location System Elements ---
const locationBtn = document.getElementById('location-btn'),
      sendLocationModal = document.getElementById('send-location-modal'),
      sendLocationForm = document.getElementById('send-location-form'),
      locationMainInput = document.getElementById('location-main-input'),
      locationDetailInput = document.getElementById('location-detail-input'),
      displayLocationModal = document.getElementById('display-location-modal'),
      displayLocationMap = document.getElementById('display-location-map'),
      displayLocationMain = document.getElementById('display-location-main'),
      displayLocationDetail = document.getElementById('display-location-detail'),
      closeLocationDisplayBtn = document.getElementById('close-location-display-btn');
        // --- Utility and Core Functions ---
        // --- 优化的数据存储系统 ---
        class OptimizedDataStorage {
            constructor() {
                // 创建数据库
                this.db = new Dexie('章鱼喷墨机DB_V2');

                // 定义数据库结构
                this.db.version(1).stores({
                    // 基础数据存储
                    storage: 'key, value, timestamp',
                    // 消息分块存储
                    messageChunks: 'id, chatId, chatType, chunkIndex, messages, timestamp',
                    // 元数据存储
                    metadata: 'key, value, timestamp'
                });

                // LRU缓存配置
                this.cache = new Map();
                this.maxCacheSize = 50; // 最大缓存50个数据块
                this.chunkSize = 100; // 每个数据块100条消息

                // 性能监控
                this.performanceMetrics = {
                    cacheHits: 0,
                    cacheMisses: 0,
                    operationTimes: [],
                    memoryUsage: 0
                };
            }



            // LRU缓存管理
            updateCache(key, value) {
                if (this.cache.has(key)) {
                    this.cache.delete(key);
                }
                this.cache.set(key, value);

                if (this.cache.size > this.maxCacheSize) {
                    const firstKey = this.cache.keys().next().value;
                    this.cache.delete(firstKey);
                }

                // 更新内存使用量估算
                this.performanceMetrics.memoryUsage = JSON.stringify([...this.cache.values()]).length;
            }

            // 从缓存获取数据
            getFromCache(key) {
                if (this.cache.has(key)) {
                    const value = this.cache.get(key);
                    // 移到最后（最近使用）
                    this.cache.delete(key);
                    this.cache.set(key, value);
                    this.performanceMetrics.cacheHits++;
                    return value;
                }
                this.performanceMetrics.cacheMisses++;
                return null;
            }

            // 保存基础数据（非消息数据）
            async saveData(key, data) {
                const startTime = Date.now();
                try {
                    const item = {
                        key: key,
                        value: JSON.stringify(data),
                        timestamp: Date.now()
                    };

                    await this.db.storage.put(item);
                    this.updateCache(key, data);
                    console.log(`数据已保存: ${key}`);
                    return true;
                } catch (error) {
                    console.error('保存数据失败:', error);
                    return false;
                }
            }

            // 获取基础数据
            async getData(key) {
                const startTime = Date.now();
                try {
                    // 先检查缓存
                    const cached = this.getFromCache(key);
                    if (cached !== null) {
                        return cached;
                    }

                    const item = await this.db.storage.get(key);
                    if (item) {
                        const data = JSON.parse(item.value);
                        this.updateCache(key, data);
                        return data;
                    } else {
                        console.log(`未找到数据: ${key}`);
                        return null;
                    }
                } catch (error) {
                    console.error('获取数据失败:', error);
                    return null;
                }
            }

            // 保存聊天消息（分块存储）
            async saveChatMessages(chatId, chatType, messages) {
                const startTime = Date.now();
                try {
                    // 清除该聊天的所有现有分块
                    await this.db.messageChunks.where('chatId').equals(chatId).and(chunk => chunk.chatType === chatType).delete();

                    // 将消息分块存储
                    const chunks = [];
                    for (let i = 0; i < messages.length; i += this.chunkSize) {
                        const chunkMessages = messages.slice(i, i + this.chunkSize);
                        const chunkId = `${chatId}_${chatType}_${Math.floor(i / this.chunkSize)}`;

                        chunks.push({
                            id: chunkId,
                            chatId: chatId,
                            chatType: chatType,
                            chunkIndex: Math.floor(i / this.chunkSize),
                            messages: chunkMessages,
                            timestamp: Date.now()
                        });
                    }

                    if (chunks.length > 0) {
                        await this.db.messageChunks.bulkPut(chunks);
                    }

                    // 更新缓存
                    const cacheKey = `messages_${chatId}_${chatType}`;
                    this.updateCache(cacheKey, messages);

                    console.log(`消息已分块保存: ${chatId} (${chunks.length}个分块)`);
                    return true;
                } catch (error) {
                    console.error('保存消息失败:', error);
                    return false;
                }
            }

            // 获取聊天消息（按需加载）
            async getChatMessages(chatId, chatType, limit = null, offset = 0) {
                const startTime = Date.now();
                try {
                    const cacheKey = `messages_${chatId}_${chatType}`;

                    // 如果没有限制，先检查缓存
                    if (!limit) {
                        const cached = this.getFromCache(cacheKey);
                        if (cached !== null) {
                            return cached;
                        }
                    }

                    // 从数据库获取分块
                    const chunks = await this.db.messageChunks
                        .where('chatId').equals(chatId)
                        .and(chunk => chunk.chatType === chatType)
                        .sortBy('chunkIndex');

                    if (chunks.length === 0) {
                        return [];
                    }

                    // 合并所有消息
                    let allMessages = [];
                    chunks.forEach(chunk => {
                        allMessages = allMessages.concat(chunk.messages);
                    });

                    // 如果没有限制，更新缓存
                    if (!limit) {
                        this.updateCache(cacheKey, allMessages);
                    }

                    // 应用分页
                    if (limit) {
                        const result = allMessages.slice(offset, offset + limit);
                        return result;
                    }

                    return allMessages;
                } catch (error) {
                    console.error('获取消息失败:', error);
                    return [];
                }
            }

            // 添加单条消息（增量更新）
            async addMessage(chatId, chatType, message) {
                const startTime = Date.now();
                try {
                    // Find the last chunk for this chat
                    const lastChunk = await this.db.messageChunks
                        .where({ chatId: chatId, chatType: chatType })
                        .last();

                    if (lastChunk && lastChunk.messages.length < this.chunkSize) {
                        // Last chunk has space, update it
                        lastChunk.messages.push(message);
                        await this.db.messageChunks.put(lastChunk);
                    } else {
                        // No last chunk or it's full, create a new one
                        const newChunkIndex = lastChunk ? lastChunk.chunkIndex + 1 : 0;
                        const newChunkId = `${chatId}_${chatType}_${newChunkIndex}`;
                        const newChunk = {
                            id: newChunkId,
                            chatId: chatId,
                            chatType: chatType,
                            chunkIndex: newChunkIndex,
                            messages: [message],
                            timestamp: Date.now()
                        };
                        await this.db.messageChunks.put(newChunk);
                    }

                    // Invalidate the full history cache for this chat
                    const cacheKey = `messages_${chatId}_${chatType}`;
                    if (this.cache.has(cacheKey)) {
                        this.cache.delete(cacheKey);
                    }
                    
                    console.log(`消息已增量添加: ${chatId}`);
                    return true;
                } catch (error) {
                    console.error('增量添加消息失败:', error);
                    return false;
                }
            }

            // 删除消息
            async deleteMessage(chatId, chatType, messageId) {
                const startTime = Date.now();
                try {
                    const chunks = await this.db.messageChunks
                        .where({ chatId: chatId, chatType: chatType })
                        .toArray();

                    for (const chunk of chunks) {
                        const messageIndex = chunk.messages.findIndex(msg => msg.id === messageId);
                        if (messageIndex !== -1) {
                            chunk.messages.splice(messageIndex, 1);
                            if (chunk.messages.length > 0) {
                                await this.db.messageChunks.put(chunk);
                            } else {
                                // Delete the chunk if it's empty
                                await this.db.messageChunks.delete(chunk.id);
                            }
                            
                            // Invalidate cache
                            const cacheKey = `messages_${chatId}_${chatType}`;
                            if (this.cache.has(cacheKey)) {
                                this.cache.delete(cacheKey);
                            }
                            console.log(`消息已删除: ${messageId}`);
                            return true;
                        }
                    }
                    console.warn(`删除失败: 未找到消息 ${messageId}`);
                    return false;
                } catch (error) {
                    console.error('删除消息失败:', error);
                    return false;
                }
            }

            // 更新消息
            async updateMessage(chatId, chatType, messageId, updatedMessage) {
                const startTime = Date.now();
                try {
                    const chunks = await this.db.messageChunks
                        .where({ chatId: chatId, chatType: chatType })
                        .toArray();

                    for (const chunk of chunks) {
                        const messageIndex = chunk.messages.findIndex(msg => msg.id === messageId);
                        if (messageIndex !== -1) {
                            // Merge updates into the existing message object
                            chunk.messages[messageIndex] = { ...chunk.messages[messageIndex], ...updatedMessage };
                            await this.db.messageChunks.put(chunk);
                            
                            // Invalidate cache
                            const cacheKey = `messages_${chatId}_${chatType}`;
                            if (this.cache.has(cacheKey)) {
                                this.cache.delete(cacheKey);
                            }
                            console.log(`消息已更新: ${messageId}`);
                            return true;
                        }
                    }
                    console.warn(`更新失败: 未找到消息 ${messageId}`);
                    return false;
                } catch (error) {
                    console.error('更新消息失败:', error);
                    return false;
                }
            }

            // 清空聊天记录
            async clearChatMessages(chatId, chatType) {
                const startTime = Date.now();
                try {
                    await this.db.messageChunks.where('chatId').equals(chatId).and(chunk => chunk.chatType === chatType).delete();

                    // 清除缓存
                    const cacheKey = `messages_${chatId}_${chatType}`;
                    this.cache.delete(cacheKey);


                    return true;
                } catch (error) {
                    console.error('清空消息失败:', error);

                    return false;
                }
            }

            // 删除数据
            async removeData(key) {
                const startTime = Date.now();
                try {
                    await this.db.storage.delete(key);
                    this.cache.delete(key);
                    console.log(`数据已删除: ${key}`);

                    return true;
                } catch (error) {
                    console.error('删除数据失败:', error);

                    return false;
                }
            }

            // 清空所有数据
            async clearAll() {
                const startTime = Date.now();
                try {
                    await this.db.storage.clear();
                    await this.db.messageChunks.clear();
                    await this.db.metadata.clear();
                    this.cache.clear();
                    console.log('所有数据已清空');

                    return true;
                } catch (error) {
                    console.error('清空数据失败:', error);

                    return false;
                }
            }

            // 获取所有存储的键
            async getAllKeys() {
                try {
                    const storageItems = await this.db.storage.toArray();
                    return storageItems.map(item => item.key);
                } catch (error) {
                    console.error('获取所有键失败:', error);
                    return [];
                }
            }

            // 获取存储信息
            async getStorageInfo() {
                const startTime = Date.now();
                try {
                    const [storageItems, messageChunks] = await Promise.all([
                        this.db.storage.toArray(),
                        this.db.messageChunks.toArray()
                    ]);

                    const storageSize = storageItems.reduce((sum, item) => sum + item.value.length, 0);
                    const messageSize = messageChunks.reduce((sum, chunk) => sum + JSON.stringify(chunk.messages).length, 0);
                    const totalSize = storageSize + messageSize;

                    const info = {
                        itemCount: storageItems.length,
                        chunkCount: messageChunks.length,
                        totalSize: totalSize,
                        storageSize: storageSize,
                        messageSize: messageSize,
                        cacheSize: this.cache.size,
                        items: storageItems.map(item => ({
                            key: item.key,
                            size: item.value.length,
                            timestamp: new Date(item.timestamp).toLocaleString()
                        }))
                    };

                    // 更新显示
                    this.updateStorageDisplay(info);

                    return info;
                } catch (error) {
                    console.error('获取存储信息失败:', error);

                    return null;
                }
            }

            // 更新存储信息显示
            updateStorageDisplay(info) {
                const monitor = document.getElementById('performance-monitor');
                if (!monitor) return;

                document.getElementById('storage-size').textContent = `${(info.totalSize / 1024).toFixed(1)} KB`;
                document.getElementById('chunk-count').textContent = info.chunkCount.toString();

                // 设置存储大小颜色指示器
                const sizeElement = document.getElementById('storage-size');
                const sizeKB = info.totalSize / 1024;
                if (sizeKB < 1000) sizeElement.className = 'metric-value good';
                else if (sizeKB < 5000) sizeElement.className = 'metric-value warning';
                else sizeElement.className = 'metric-value error';
            }

            // 数据迁移方法（从旧版本迁移）
            async migrateFromOldStorage() {
                const startTime = Date.now();
                let oldDb = null;
                let migrationSuccess = false;

                try {
                    // 尝试从旧数据库获取数据
                    oldDb = new Dexie('章鱼喷墨机DB');
                    oldDb.version(1).stores({
                        storage: 'key, value, timestamp'
                    });

                    // 检查旧数据库是否存在数据
                    const oldData = await oldDb.storage.get('章鱼喷墨机');
                    if (oldData) {
                        console.log('检测到旧数据库，开始迁移...');
                        const data = JSON.parse(oldData.value);

                        // 迁移基础数据
                        const { characters, groups, ...baseData } = data;
                        await this.saveData('章鱼喷墨机', baseData);

                        let migratedCharacters = 0;
                        let migratedGroups = 0;

                        // 迁移角色消息
                        if (characters) {
                            for (const char of characters) {
                                if (char.history && char.history.length > 0) {
                                    await this.saveChatMessages(char.id, 'private', char.history);
                                }
                                // 保存角色信息（不包含history）
                                const { history, ...charData } = char;
                                charData.history = []; // 保持兼容性
                                await this.saveData(`character_${char.id}`, charData);
                                migratedCharacters++;
                            }
                        }

                        // 迁移群组消息
                        if (groups) {
                            for (const group of groups) {
                                if (group.history && group.history.length > 0) {
                                    await this.saveChatMessages(group.id, 'group', group.history);
                                }
                                // 保存群组信息（不包含history）
                                const { history, ...groupData } = group;
                                groupData.history = []; // 保持兼容性
                                await this.saveData(`group_${group.id}`, groupData);
                                migratedGroups++;
                            }
                        }

                        migrationSuccess = true;
                        console.log(`数据迁移完成: ${migratedCharacters}个角色, ${migratedGroups}个群组`);

                        // 迁移成功后立即删除旧数据库
                        try {
                            console.log('开始删除旧数据库...');

                            // 关闭数据库连接
                            if (oldDb.isOpen()) {
                                oldDb.close();
                            }

                            // 删除整个数据库
                            await oldDb.delete();
                            console.log('旧数据库删除成功');

                            // 验证删除是否成功
                            const deletedDb = new Dexie('章鱼喷墨机DB');
                            try {
                                deletedDb.version(1).stores({
                                    storage: 'key, value, timestamp'
                                });
                                const testData = await deletedDb.storage.get('章鱼喷墨机');
                                if (!testData) {
                                    console.log('旧数据库删除验证成功');
                                } else {
                                    console.warn('旧数据库可能未完全删除');
                                }
                                deletedDb.close();
                            } catch (verifyError) {
                                // 如果无法访问，说明删除成功
                                console.log('旧数据库删除验证成功（数据库不存在）');
                            }

                        } catch (deleteError) {
                            console.error('删除旧数据库失败，但不影响主要功能:', deleteError);
                            // 尝试清空数据而不是删除数据库
                            try {
                                if (!oldDb.isOpen()) {
                                    await oldDb.open();
                                }
                                await oldDb.storage.clear();
                                console.log('已清空旧数据库内容');
                                oldDb.close();
                            } catch (clearError) {
                                console.error('清空旧数据库也失败:', clearError);
                            }
                        }

                        return true;
                    } else {
                        console.log('未发现旧数据库数据');
                        // 即使没有数据，也尝试删除可能存在的空数据库
                        try {
                            if (oldDb.isOpen()) {
                                oldDb.close();
                            }
                            await oldDb.delete();
                            console.log('已删除空的旧数据库');
                        } catch (deleteError) {
                            // 删除失败可能是因为数据库不存在，这是正常的
                            console.log('旧数据库不存在或已删除');
                        }
                        return false;
                    }


                    return false;
                } catch (error) {
                    console.error('数据迁移失败:', error);

                    // 即使迁移失败，也尝试清理旧数据库连接
                    if (oldDb) {
                        try {
                            if (oldDb.isOpen()) {
                                oldDb.close();
                                console.log('已关闭旧数据库连接');
                            }
                        } catch (closeError) {
                            console.error('关闭旧数据库连接失败:', closeError);
                        }
                    }

                    return false;
                } finally {
                    // 确保在任何情况下都记录迁移耗时
                    const duration = Date.now() - startTime;
                    console.log(`数据迁移操作完成，耗时: ${duration}ms, 成功: ${migrationSuccess}`);
                }
            }
        }

        const dataStorage = new OptimizedDataStorage();

        // 兼容性适配器 - 保持原有API接口
        const saveData = async (data) => {
            const dbData = data ? data : db;

            // 修改：分离出所有需要独立保存的重要数据
            const { 
                characters, 
                groups, 
                worldBooks, 
                apiSettings,
                customIcons,
                wallpaper,
                wallpaper2,
                aiSpaceWallpaper,
                homeProfile,
                // ... 你未来可能增加的其他顶层复杂数据
                ...baseData // 剩余的简单数据
            } = dbData;

            // 保存剩余的基础数据
            await dataStorage.saveData('章鱼喷墨机', baseData);

            // 新增：为每一项重要数据创建独立的保存通道
            if (worldBooks) await dataStorage.saveData('worldBooks_data', worldBooks);
            if (apiSettings) await dataStorage.saveData('apiSettings_data', apiSettings);
            if (customIcons) await dataStorage.saveData('customIcons_data', customIcons);
            if (wallpaper) await dataStorage.saveData('wallpaper_data', wallpaper);
            if (wallpaper2) await dataStorage.saveData('wallpaper2_data', wallpaper2);
            if (aiSpaceWallpaper) await dataStorage.saveData('aiSpaceWallpaper_data', aiSpaceWallpaper);
            if (homeProfile) await dataStorage.saveData('homeProfile_data', homeProfile);


            // 分别保存角色和群组数据（包含消息）
            if (characters) {
                for (const char of characters) {
                    // 保存消息到分块存储
                    if (char.history && char.history.length > 0) {
                        await dataStorage.saveChatMessages(char.id, 'private', char.history);
                    }
                    // 保存角色基础信息（不包含history）
                    const { history, ...charData } = char;
                    charData.history = []; // 保持兼容性
                    await dataStorage.saveData(`character_${char.id}`, charData);
                }
            }

            if (groups) {
                for (const group of groups) {
                    // 保存消息到分块存储
                    if (group.history && group.history.length > 0) {
                        await dataStorage.saveChatMessages(group.id, 'group', group.history);
                    }
                    // 保存群组基础信息（不包含history）
                    const { history, ...groupData } = group;
                    groupData.history = []; // 保持兼容性
                    await dataStorage.saveData(`group_${group.id}`, groupData);
                }
            }

            return Promise.resolve();
        };

        const loadData = async () => {
            // 首先尝试数据迁移
            await dataStorage.migrateFromOldStorage();

            // 检查localStorage中的旧数据
            const oldData = localStorage.getItem('gemini-chat-app-db');
            if (oldData) {
                console.log('检测到localStorage中的旧数据，开始迁移...');
                await saveData(JSON.parse(oldData));
                localStorage.removeItem('gemini-chat-app-db');
                console.log('localStorage旧数据迁移完成并已清理');
            }

            // 额外的安全检查：确保旧数据库完全清理
            try {
                const safetyCheckDb = new Dexie('章鱼喷墨机DB');
                safetyCheckDb.version(1).stores({
                    storage: 'key, value, timestamp'
                });

                const residualData = await safetyCheckDb.storage.get('章鱼喷墨机');
                if (residualData) {
                    console.warn('发现残留的旧数据库数据，执行强制清理...');
                    await safetyCheckDb.storage.clear();
                    safetyCheckDb.close();
                    await safetyCheckDb.delete();
                    console.log('残留旧数据库已强制清理');
                } else {
                    safetyCheckDb.close();
                }
            } catch (safetyError) {
                // 如果无法访问旧数据库，说明已经被正确删除
                console.log('旧数据库安全检查完成（数据库不存在）');
            }

            // 加载基础数据
            let data = await dataStorage.getData('章鱼喷墨机');
            if (data) {
                db = { ...db, ...data };
            }
    // --- 新增：从独立通道加载所有重要数据 ---
            db.worldBooks = await dataStorage.getData('worldBooks_data') || [];
            db.apiSettings = await dataStorage.getData('apiSettings_data') || {};
            db.customIcons = await dataStorage.getData('customIcons_data') || {};
            db.wallpaper = await dataStorage.getData('wallpaper_data') || 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg';
            db.wallpaper2 = await dataStorage.getData('wallpaper2_data') || 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg';
            db.aiSpaceWallpaper = await dataStorage.getData('aiSpaceWallpaper_data') || '';
            db.homeProfile = await dataStorage.getData('homeProfile_data') || { name: '点击设置昵称', signature: '点击设置个性签名', avatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg', heroBg: 'https://i.postimg.cc/wM57022X/image.png' };
            // --- 新增结束 ---

            // (在 loadData 函数内部，靠近其他 if (!db.xxx) 的地方添加)
if (!db.avatarFrames) {
    db.avatarFrames = []; // 初始化全局头像框列表
}
db.characters.forEach(c => {
    if (c.avatarFrameUrl === undefined) c.avatarFrameUrl = null;
    if (c.myAvatarFrameUrl === undefined) c.myAvatarFrameUrl = null;
});
db.groups.forEach(g => {
    if (g.me.avatarFrameUrl === undefined) g.me.avatarFrameUrl = null;
    g.members.forEach(m => {
        if (m.avatarFrameUrl === undefined) m.avatarFrameUrl = null;
    });
});
            if (db.uncategorizedCollapsed === undefined) {
    db.uncategorizedCollapsed = false; // 默认不折叠
}// 初始化默认值
            if (!db.apiSettings) db.apiSettings = {};
if (!db.wallet) {
    db.wallet = {
        balance: 0.00,
        passwordEnabled: false,
        password: null,
        transactions: []
    };
}
            if (!db.wallpaper) db.wallpaper = 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg';
            if (!db.wallpaper2) db.wallpaper2 = 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg'; // 新增
            if (!db.myStickers) db.myStickers = [];
          if (!db.aiSpaceWallpaper) db.aiSpaceWallpaper = ''; // 为AI手机壁纸初始化默认值
            if (!db.homeScreenMode) db.homeScreenMode = 'night';
            if (!db.worldBooks) db.worldBooks = [];
            if (!db.fontUrl) db.fontUrl = '';
            if (!db.customIcons) db.customIcons = {};
if (!db.homeProfile) {
                db.homeProfile = {
                    name: '点击设置昵称',
                    signature: '点击设置个性签名',
                    avatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg',
                    heroBg: 'https://i.postimg.cc/wM57022X/image.png'
                };
            }
            if (!db.forumData) {
                db.forumData = {};
            }
          if (!db.forumSettings) db.forumSettings = {}; // 新增：为论坛配置初始化
                // --- 在这里单独加载世界书 ---
            const loadedWorldBooks = await dataStorage.getData('worldBooks_data');
            db.worldBooks = loadedWorldBooks || [];
            if (!db.worldBooks) db.worldBooks = []; // 兼容性检查
            // --- 结束 ---

            // 重建characters和groups列表
            // 由于saveData时这两个字段被排除，需要从存储中重新构建
            db.characters = [];
            db.groups = [];

            // 获取所有存储的键，找出角色和群组数据
            const allKeys = await dataStorage.getAllKeys();
            const characterKeys = allKeys.filter(key => key.startsWith('character_'));
            const groupKeys = allKeys.filter(key => key.startsWith('group_'));

            console.log(`发现 ${characterKeys.length} 个角色数据, ${groupKeys.length} 个群组数据`);

            // 加载角色数据
            const characterPromises = characterKeys.map(async (key) => {
                const charId = key.replace('character_', '');
                const charData = await dataStorage.getData(key);
                if (charData) {
                    // 按需加载消息历史
                    charData.history = await dataStorage.getChatMessages(charId, 'private');

                    // 设置默认值
                    if (charData.isPinned === undefined) charData.isPinned = false;
                    if (charData.status === undefined) charData.status = '在线';
                    if (!charData.worldBookIds) charData.worldBookIds = [];
                    if (charData.customBubbleCss === undefined) charData.customBubbleCss = '';
                    if (charData.useCustomBubbleCss === undefined) charData.useCustomBubbleCss = false;
// 为旧数据兼容用户日记
                    return charData;
                }
                return null;
            });

            // 加载群组数据
            const groupPromises = groupKeys.map(async (key) => {
                const groupId = key.replace('group_', '');
                const groupData = await dataStorage.getData(key);
                if (groupData) {
                    // 按需加载消息历史
                    groupData.history = await dataStorage.getChatMessages(groupId, 'group');

                    // 设置默认值
                    if (groupData.isPinned === undefined) groupData.isPinned = false;
                    if (!groupData.worldBookIds) groupData.worldBookIds = [];
                    if (groupData.customBubbleCss === undefined) groupData.customBubbleCss = '';
                    if (groupData.useCustomBubbleCss === undefined) groupData.useCustomBubbleCss = false;

                    return groupData;
                }
                return null;
            });

            // 等待所有数据加载完成
            const [loadedCharacters, loadedGroups] = await Promise.all([
                Promise.all(characterPromises),
                Promise.all(groupPromises)
            ]);

            // 过滤掉null值并赋值给db
            db.characters = loadedCharacters.filter(char => char !== null);
            db.groups = loadedGroups.filter(group => group !== null);

            console.log(`成功加载 ${db.characters.length} 个角色, ${db.groups.length} 个群组`);
            console.log('完整数据库对象:', db);

         
            return Promise.resolve();
        };
        // ▲▲▲ 替换结束 ▲▲▲             
        const switchScreen = (targetId) => {
            screens.forEach(screen => screen.classList.remove('active'));
            document.getElementById(targetId)?.classList.add('active');
            // Close all overlays and sidebars
            const overlays = document.querySelectorAll('.modal-overlay, .action-sheet-overlay, .settings-sidebar');
            overlays.forEach(o => o.classList.remove('visible', 'open'));
        };
        // START: 新增HTML转义函数
function escapeHTML(str) {
    if (!str) return '';
    return str.replace(/[&<>"']/g, function(match) {
        return {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
        }[match];
    });
}
// END: 新增HTML转义函数
// --- NEW: File size formatting utility ---
function formatFileSize(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
// ▼▼▼ 请用这个完整的、升级后的函数，替换掉旧的 createContextMenu 函数 ▼▼▼
function createContextMenu(items, x, y) {
    removeContextMenu(); // 保持：移除旧菜单

    const menu = document.createElement('div');
    menu.className = 'context-menu';
    
    // 1. 渲染菜单项 (保持不变)
    items.forEach(item => {
        const menuItem = document.createElement('div');
        menuItem.className = 'context-menu-item';
        if (item.danger) menuItem.classList.add('danger');
        menuItem.textContent = item.label;
        menuItem.onclick = () => {
            item.action();
            removeContextMenu();
        };
        menu.appendChild(menuItem);
    });

    // 2. 将菜单添加到DOM中，但先让它在屏幕外，以便我们测量它的尺寸
    menu.style.position = 'fixed';
    menu.style.top = '-9999px';
    menu.style.left = '-9999px';
    document.body.appendChild(menu);

    // 3. 【核心修改】动态计算菜单的最佳位置
    const menuWidth = menu.offsetWidth;
    const menuHeight = menu.offsetHeight;
    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;

    let finalX = x;
    let finalY = y;

    // a. 调整水平位置，防止菜单超出屏幕右侧
    if (finalX + menuWidth > screenWidth) {
        finalX = screenWidth - menuWidth - 10; // 留出10px边距
    }

    // b. 调整垂直位置，防止菜单超出屏幕下方 (这是您需要的关键逻辑)
    if (finalY + menuHeight > screenHeight) {
        // 如果会超出，则将菜单的底部对齐到被点击位置的上方
        finalY = y - menuHeight - 5; // 向上移动自身高度，并留出5px间距
    }

    // c. 确保菜单不会跑到屏幕上方外面去
    if (finalY < 0) {
        finalY = 10; // 如果计算后还是太高，则固定在顶部10px处
    }

    // 4. 将计算好的最终位置应用到菜单上
    menu.style.left = `${finalX}px`;
    menu.style.top = `${finalY}px`;

    // 5. 绑定全局点击事件以关闭菜单 (保持不变)
    document.addEventListener('click', removeContextMenu, { once: true });
}
// ▲▲▲ 替换结束 ▲▲▲

        function removeContextMenu() {
            const menu = document.querySelector('.context-menu');
            if (menu) menu.remove();
        }
        function applyGlobalCss(css) {
            const styleId = 'global-custom-css-style';
            let styleElement = document.getElementById(styleId);
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = styleId;
                document.head.appendChild(styleElement);
            }
            styleElement.textContent = css || '';
        }
        function updateCustomBubbleStyle(chatId, css, enabled) {
            const styleId = `custom-bubble-style-for-${chatId}`;
            let styleElement = document.getElementById(styleId);

            if (enabled && css) {
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = styleId;
                    document.head.appendChild(styleElement);
                }
                const scopedCss = css.replace(/(\.message-bubble(?:\.sent|\.received)?)/g, `#chat-room-screen.chat-active-${chatId} $1`);
                styleElement.innerHTML = scopedCss;
            } else {
                if (styleElement) styleElement.remove();
            }
        }

        function updateBubbleCssPreview(previewContainer, css, useDefault, theme) {
            previewContainer.innerHTML = '';

            const sentBubble = document.createElement('div');
            sentBubble.className = 'message-bubble sent';
            sentBubble.textContent = '这是我方气泡。';
            sentBubble.style.alignSelf = 'flex-end';
            sentBubble.style.borderBottomRightRadius = '5px';

            const receivedBubble = document.createElement('div');
            receivedBubble.className = 'message-bubble received';
            receivedBubble.textContent = '这是对方气泡。';
            receivedBubble.style.alignSelf = 'flex-start';
            receivedBubble.style.borderBottomLeftRadius = '5px';

            [sentBubble, receivedBubble].forEach(bubble => {
                bubble.style.maxWidth = '70%';
                bubble.style.padding = '8px 12px';
                bubble.style.wordWrap = 'break-word';
                bubble.style.lineHeight = '1.4';
            });

            if (useDefault || !css) {
                sentBubble.style.backgroundColor = theme.sent.bg;
                sentBubble.style.color = theme.sent.text;
                sentBubble.style.borderRadius = '18px';
                sentBubble.style.borderBottomRightRadius = '5px';
                receivedBubble.style.backgroundColor = theme.received.bg;
                receivedBubble.style.color = theme.received.text;
                receivedBubble.style.borderRadius = '18px';
                receivedBubble.style.borderBottomLeftRadius = '5px';
            } else {
                const styleTag = document.createElement('style');
                const scopedCss = css.replace(/(\.message-bubble(?:\.sent|\.received)?)/g, `#${previewContainer.id} $1`);
                styleTag.textContent = scopedCss;
                previewContainer.appendChild(styleTag);
            }
            previewContainer.appendChild(receivedBubble);
            previewContainer.appendChild(sentBubble);
        }
        // ===============================================================
// START: 钱包功能核心代码
// ===============================================================

// --- 交易记录 ---
function addTransaction(type, amount, description) {
    if (!db.wallet) return;
    
    // 1. 更新余额
    const numericAmount = parseFloat(amount);
    if (type === 'income') {
        db.wallet.balance += numericAmount;
    } else if (type === 'expense') {
        db.wallet.balance -= numericAmount;
    }
    db.wallet.balance = parseFloat(db.wallet.balance.toFixed(2)); // 避免精度问题

    // 2. 添加交易记录
    const transaction = {
        id: `tx_${Date.now()}`,
        type, // 'income' or 'expense'
        amount: numericAmount,
        description,
        timestamp: Date.now()
    };
    db.wallet.transactions.unshift(transaction); // unshift使最新记录在最前

    // 3. 限制交易记录数量，防止无限增长
    if (db.wallet.transactions.length > 200) {
        db.wallet.transactions.pop();
    }
    
    // 4. 更新UI显示
    const balanceDisplay = document.getElementById('wallet-balance-display');
    if (balanceDisplay) {
        balanceDisplay.textContent = db.wallet.balance.toFixed(2);
    }
}

// --- 支付流程处理 (事件监听器修复版) ---
function handlePayment(amount, description) {
    return new Promise((resolve, reject) => {
        if (db.wallet.passwordEnabled === false) {
            if (db.wallet.balance < amount) {
                reject(new Error('零花钱余额不足'));
                return;
            }
            addTransaction('expense', amount, description);
            resolve(); 
            return;
        }

        if (!db.wallet.password) {
            reject(new Error('请先前往“我”-“支付设置”设置支付密码！'));
            return;
        }
        if (db.wallet.balance < amount) {
            reject(new Error('零花钱余额不足'));
            return;
        }

        const modal = document.getElementById('payment-password-modal');
        const title = document.getElementById('payment-prompt-title');
        const desc = document.getElementById('payment-prompt-description');
        const passwordInput = document.getElementById('payment-password-input');
        const confirmBtn = document.getElementById('confirm-payment-btn');
        const cancelBtn = document.getElementById('cancel-payment-btn');

        // --- 核心修改：克隆并替换按钮以清除所有旧的事件监听器 ---
        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        
        const newCancelBtn = cancelBtn.cloneNode(true);
        cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
        // --- 修改结束 ---

        title.textContent = description;
        desc.innerHTML = `<p style="font-size: 24px; font-weight: bold; margin: 10px 0;">¥ ${amount.toFixed(2)}</p>`;
        passwordInput.value = '';
        
        const cleanupAndResolve = () => {
            modal.classList.remove('visible');
            passwordInput.removeEventListener('keypress', keypressHandler);
            resolve();
        };

        const cleanupAndReject = (err) => {
            modal.classList.remove('visible');
            passwordInput.removeEventListener('keypress', keypressHandler);
            reject(err);
        };

        const confirmHandler = () => {
            if (passwordInput.value === db.wallet.password) {
                addTransaction('expense', amount, description);
                cleanupAndResolve();
            } else {
                showToast('支付密码错误');
                passwordInput.value = '';
            }
        };
        
        const keypressHandler = (e) => {
            if(e.key === 'Enter') {
                confirmHandler();
            }
        };

        newConfirmBtn.addEventListener('click', confirmHandler);
        newCancelBtn.addEventListener('click', () => cleanupAndReject(new Error('支付已取消')));
        passwordInput.addEventListener('keypress', keypressHandler);

        modal.classList.add('visible');
        setTimeout(() => passwordInput.focus(), 100);
    });
}
// --- 渲染交易明细 ---
function renderTransactionDetails() {
    const container = document.getElementById('transaction-list-container');
    container.innerHTML = '';

    if (!db.wallet.transactions || db.wallet.transactions.length === 0) {
        container.innerHTML = '<li class="placeholder-text" style="padding: 20px 0;">暂无明细</li>';
        return;
    }

    db.wallet.transactions.forEach(tx => {
        const li = document.createElement('li');
        li.className = 'transaction-item';

        const date = new Date(tx.timestamp);
        const dateString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
        
        const amountSign = tx.type === 'income' ? '+' : '-';
        
        li.innerHTML = `
            <div class="transaction-details">
                <span class="transaction-description">${tx.description}</span>
                <span class="transaction-timestamp">${dateString}</span>
            </div>
            <span class="transaction-amount ${tx.type}">
                ${amountSign}${tx.amount.toFixed(2)}
            </span>
        `;
        container.appendChild(li);
    });
}

// --- 设置钱包所有功能的事件监听 ---
function setupWalletApp() {
    // 缓存DOM元素
    const walletScreen = document.getElementById('wallet-screen');
    const balanceDisplay = document.getElementById('wallet-balance-display');
    const settingsBtn = document.getElementById('wallet-settings-btn');
    const settingsScreen = document.getElementById('wallet-settings-screen');
    const settingsForm = document.getElementById('wallet-settings-form');
    const balanceInput = document.getElementById('wallet-balance-input');
    const passwordInput = document.getElementById('wallet-password-input');
    const transactionsBtn = document.getElementById('show-transactions-btn');
    const transactionsModal = document.getElementById('transaction-details-modal');
    const closeTransactionsBtn = document.getElementById('close-transactions-btn');

    // 监听导航到底部“我”按钮的点击事件
    document.querySelector('.nav-btn[data-target="wallet-screen"]').addEventListener('click', () => {
        balanceDisplay.textContent = db.wallet.balance.toFixed(2);
    });
    
// 从钱包主页跳转到设置页
settingsBtn.addEventListener('click', () => {
    const passwordEnabledToggle = document.getElementById('wallet-password-enabled-toggle');
    
    balanceInput.value = db.wallet.balance;
    passwordInput.value = db.wallet.password || '';
    passwordEnabledToggle.checked = db.wallet.passwordEnabled;
    passwordInput.disabled = !db.wallet.passwordEnabled; // 根据开关状态禁用/启用输入框
    
    // 监听开关的实时变化
    passwordEnabledToggle.onchange = (event) => {
        passwordInput.disabled = !event.target.checked;
        if (!event.target.checked) {
            passwordInput.value = ''; // 如果禁用，清空密码框
        }
    };
    
    switchScreen('wallet-settings-screen');
});

// 保存设置
settingsForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const newBalance = parseFloat(balanceInput.value);
    const newPassword = passwordInput.value;
    const passwordEnabled = document.getElementById('wallet-password-enabled-toggle').checked;

    if (passwordEnabled && newPassword && (newPassword.length !== 6 || !/^\d+$/.test(newPassword))) {
        showToast('支付密码必须为6位数字！');
        return;
    }

    db.wallet.balance = isNaN(newBalance) ? 0 : parseFloat(newBalance.toFixed(2));
    db.wallet.passwordEnabled = passwordEnabled;

    if (passwordEnabled) {
        db.wallet.password = newPassword || null;
    } else {
        db.wallet.password = null; // 禁用密码时，自动清除已保存的密码
    }

    await saveData();
    showToast('支付设置已保存！');
    switchScreen('wallet-screen');
    balanceDisplay.textContent = db.wallet.balance.toFixed(2);
});
    
    // 打开交易明细
    transactionsBtn.addEventListener('click', () => {
        renderTransactionDetails();
        transactionsModal.classList.add('visible');
    });

    // 关闭交易明细
    closeTransactionsBtn.addEventListener('click', () => {
        transactionsModal.classList.remove('visible');
    });
}
// START: 批量添加表情包功能
function setupBatchStickerUpload() {
    const batchAddBtn = document.getElementById('batch-add-sticker-btn');
    const modal = document.getElementById('batch-add-sticker-modal');
    const uploadView = document.getElementById('batch-upload-view');
    const namingView = document.getElementById('batch-naming-view');

    const fileInput = document.getElementById('batch-sticker-files-upload');
    const urlInput = document.getElementById('batch-sticker-urls-input');
    const processBtn = document.getElementById('process-batch-stickers-btn');
    
    const previewGrid = document.getElementById('batch-sticker-preview-grid');
    const namesInput = document.getElementById('batch-sticker-names-input');
    const saveBtn = document.getElementById('save-batch-stickers-btn');
    const backBtn = document.getElementById('back-to-batch-upload-btn');
    
    let tempStickerData = []; // 用于存储待保存的 base64 数据

    const resetModal = () => {
        uploadView.style.display = 'block';
        namingView.style.display = 'none';
        fileInput.value = '';
        urlInput.value = '';
        namesInput.value = '';
        previewGrid.innerHTML = '';
        tempStickerData = [];
    };

    batchAddBtn.addEventListener('click', () => {
        resetModal();
        modal.classList.add('visible');
    });

    modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.classList.remove('visible');
    });

    backBtn.addEventListener('click', resetModal);

    processBtn.addEventListener('click', async () => {
        const files = Array.from(fileInput.files);
        const urls = urlInput.value.split(',').map(u => u.trim()).filter(Boolean);

        if (files.length === 0 && urls.length === 0) {
            showToast('请选择文件或输入URL');
            return;
        }

        showToast('正在处理图片，请稍候...');
        previewGrid.innerHTML = '<div class="placeholder-text">处理中...</div>';
        uploadView.style.display = 'none';
        namingView.style.display = 'block';

        const promises = [];
        tempStickerData = [];

        // 处理本地文件
        files.forEach(file => {
            promises.push(
                compressImage(file, { quality: 0.8, maxWidth: 200, maxHeight: 200 })
                    .then(dataUrl => {
                        tempStickerData.push({ data: dataUrl });
                    })
            );
        });
        
        // 处理URL
        urls.forEach(url => {
            // 对于URL，我们直接使用，不进行压缩
            tempStickerData.push({ data: url });
        });
        
        await Promise.all(promises);

        // 渲染预览
        previewGrid.innerHTML = '';
        tempStickerData.forEach((sticker, index) => {
            const item = document.createElement('div');
            item.className = 'sticker-item';
            item.innerHTML = `<img src="${sticker.data}" alt="预览${index+1}">`;
            previewGrid.appendChild(item);
        });
        
        showToast(`已成功加载 ${tempStickerData.length} 张图片，请为它们命名。`);
    });
    
    saveBtn.addEventListener('click', async () => {
        if (tempStickerData.length === 0) {
            showToast('没有可保存的表情包');
            return;
        }

        const names = namesInput.value.split(',').map(n => n.trim());
        
        tempStickerData.forEach((sticker, index) => {
            const newSticker = {
                id: `sticker_${Date.now()}_${index}`,
                name: names[index] || `表情包${db.myStickers.length + index + 1}`,
                data: sticker.data
            };
            db.myStickers.push(newSticker);
        });

        await saveData();
        modal.classList.remove('visible');
        renderStickerGrid();
        showToast(`成功添加了 ${tempStickerData.length} 个表情包！`);
    });
}
// 
// ===============================================================
// START: 心灵羁绊 - 番茄钟 V2.1 功能 (替换旧版)
// ===============================================================
function setupPomodoroFeature() {
    // --- DOM 元素缓存 ---
    const pomodoroScreen = document.getElementById('pomodoro-screen');
    const timeDisplayEl = document.getElementById('pomodoro-main-time');
    const taskNameEl = document.getElementById('pomodoro-task-name');
    const aiAvatarEl = document.getElementById('pomodoro-ai-avatar');
    const aiStatusEl = document.getElementById('pomodoro-ai-status');
    const aiCompanionTextEl = document.getElementById('pomodoro-ai-companion-text');
    const startBtn = document.getElementById('pomodoro-start-btn');
    const alertSound = document.getElementById('pomodoro-alert-sound');
    const timerCardEl = document.querySelector('.pomodoro-timer-card');

    const settingsBtn = document.getElementById('pomodoro-open-settings-btn');
    const historyBtn = document.getElementById('pomodoro-history-btn');
    const settingsScreen = document.getElementById('pomodoro-settings-screen');
    const settingsForm = document.getElementById('pomodoro-settings-form-v2');

    // --- 状态变量 ---
    let timerInterval = null;
    let timeValue = 0;
    let remainingTime = 25 * 60;
    let state = 'idle'; // 'idle', 'running', 'paused'
    let currentMode = 'countdown';
    let currentAiForApp = null;

    // --- 辅助函数 ---
    const getSettings = () => {
        if (currentAiForApp && currentAiForApp.soulBondData && currentAiForApp.soulBondData.pomodoroSettings) {
            return currentAiForApp.soulBondData.pomodoroSettings;
        }
        return { wallpaper: '', avatar: '', soundUrl: '', cardWallpaper: '', mode: 'countdown', focus: 25, shortBreak: 5 };
    };

    const updateDisplay = () => {
        const time = (currentMode === 'countdown') ? remainingTime : timeValue;
        const minutes = String(Math.floor(time / 60)).padStart(2, '0');
        const seconds = String(time % 60).padStart(2, '0');
        timeDisplayEl.textContent = `${minutes}:${seconds}`;
        document.title = `${minutes}:${seconds} - 专注模式`;
    };

    const applySettings = () => {
        const settings = getSettings();
        const contentArea = pomodoroScreen.querySelector('.pomodoro-main-content');
        
        contentArea.style.backgroundImage = settings.wallpaper ? `url('${settings.wallpaper}')` : '';
        timerCardEl.style.backgroundImage = settings.cardWallpaper ? `url('${settings.cardWallpaper}')` : '';
        aiAvatarEl.src = settings.avatar || (currentAiForApp ? currentAiForApp.avatar : 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg');
        
        currentMode = settings.mode;
        resetTimer();
    };

    const tick = () => {
        if (currentMode === 'countdown') {
            remainingTime--;
            if (remainingTime < 0) {
                clearInterval(timerInterval);
                state = 'idle';
                startBtn.textContent = '休息一下';
                alertSound.play();
                saveTaskToHistory();
                triggerAiInteraction('end_focus');
                
                // Switch to break
                currentMode = 'break';
                remainingTime = getSettings().shortBreak * 60;
                aiStatusEl.textContent = `${currentAiForApp.remarkName} 陪你休息中...`;
                aiCompanionTextEl.textContent = "辛苦啦！休息一下吧，你做得非常棒！";
                startTimer();
                return;
            }
        } else {
            timeValue++;
        }
        updateDisplay();
    };
    
    // --- 核心交互函数 ---
    const startTimer = () => {
        if (state === 'idle' && currentMode === 'countdown') {
            triggerAiInteraction('start_focus');
        }
        state = 'running';
        startBtn.textContent = '暂停';
        timerInterval = setInterval(tick, 1000);
    };

    const pauseTimer = () => {
        clearInterval(timerInterval);
        state = 'paused';
        startBtn.textContent = '继续';
    };

    const resetTimer = () => {
        clearInterval(timerInterval);
        state = 'idle';
        startBtn.textContent = '开始';
        if (currentMode === 'countdown') {
            remainingTime = getSettings().focus * 60;
        } else {
            timeValue = 0;
        }
        updateDisplay();
    };

    const triggerAiInteraction = async (moment) => {
        const character = currentAiForApp;
        if (!character) return;
        
        let systemContent = '';
        switch (moment) {
            case 'start_focus':
                systemContent = `[system: 我刚刚开始了${getSettings().focus}分钟的专注时间，任务是“${taskNameEl.textContent}”。请你用一句简短的话为我加油打气，然后保持安静。]`;
                break;
            case 'end_focus':
                systemContent = `[system: 我刚刚完成了一个专注番茄钟！请你表扬我，并提醒我可以休息一下了。]`;
                break;
        }

        if (!systemContent) return;

        const contextMessage = { id: `msg_pomodoro_${moment}_${Date.now()}`, role: 'user', content: systemContent, parts: [{ type: 'text', text: systemContent }], timestamp: Date.now() };
        character.history.push(contextMessage);
        await saveData();

        if (currentChatId === character.id) {
            getAiReply();
        } else {
            addNotificationToQueue({ avatar: character.avatar, text: `<strong>${character.remarkName}</strong><br>给你发来了专注提醒`, chatId: character.id, type: 'private' });
        }
    };
    
    async function requestAiCompanionMessage() {
        const character = currentAiForApp;
        if (!character) return;
        
        aiCompanionTextEl.textContent = '...';
        aiStatusEl.textContent = `${character.remarkName} 正在输入...`;
        
        try {
            const prompt = `[system: 我在专注期间有点分心，点击了你的头像。请根据你的人设“${character.persona}”，说一句简短、温柔或俏皮的话来鼓励我继续坚持下去。直接输出鼓励的话，不要有其他前缀。]`;
            const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
            aiCompanionTextEl.textContent = aiResponseText;
            aiStatusEl.textContent = `${character.remarkName} 陪伴中...`;
        } catch(e) {
             aiCompanionTextEl.textContent = "加油！";
             aiStatusEl.textContent = `${character.remarkName} 陪伴中...`;
        }
    }
    
    const saveTaskToHistory = async () => {
        const character = currentAiForApp;
        if (!character) return;
        character.soulBondData = character.soulBondData || {};
        character.soulBondData.pomodoroHistory = character.soulBondData.pomodoroHistory || [];
        character.soulBondData.pomodoroHistory.unshift({
            task: taskNameEl.textContent,
            duration: currentMode === 'countdown' ? getSettings().focus : Math.floor(timeValue / 60),
            timestamp: Date.now()
        });
        await saveData();
    };

    // --- 事件绑定 ---
    document.querySelector('.bond-nav-btn[data-feature="pomodoro"]').addEventListener('click', () => {
        const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
        pomodoroScreen.dataset.characterId = characterId;
        currentAiForApp = db.characters.find(c => c.id === characterId);
        
        applySettings();
        switchScreen('pomodoro-screen');
    });

    startBtn.addEventListener('click', () => {
        if (state === 'running') {
            pauseTimer();
        } else if (state === 'paused') {
            startTimer();
        } else { // idle
            if (currentMode === 'break') { // If break is over, start new focus
                switchMode('countdown');
            }
            startTimer();
        }
    });
    
    aiAvatarEl.addEventListener('click', () => {
        const settings = getSettings();
        if (settings.soundUrl) {
            try {
                const customSound = new Audio(settings.soundUrl);
                customSound.play();
            } catch(e) {
                console.error("无法播放自定义声音:", e);
                showToast("提示音链接无效");
            }
        }
        requestAiCompanionMessage();
    });
    
    settingsBtn.addEventListener('click', () => {
        const settings = getSettings();
        document.getElementById('pomodoro-wallpaper-input').value = settings.wallpaper || '';
        document.getElementById('pomodoro-avatar-input').value = settings.avatar || '';
        document.getElementById('pomodoro-sound-url-input').value = settings.soundUrl || '';
        document.getElementById('pomodoro-card-wallpaper-input').value = settings.cardWallpaper || '';
        const modeRadio = document.querySelector(`input[name="timer-mode"][value="${settings.mode}"]`);
        if (modeRadio) modeRadio.checked = true;
        document.getElementById('focus-duration-input').value = settings.focus;
        document.getElementById('short-break-duration-input').value = settings.shortBreak;
        switchScreen('pomodoro-settings-screen');
    });

    historyBtn.addEventListener('click', () => {
        const history = currentAiForApp.soulBondData.pomodoroHistory || [];
        const listEl = document.getElementById('pomodoro-history-list');
        const placeholder = document.getElementById('no-pomodoro-history');
        if(history.length === 0){
            listEl.innerHTML = '';
            placeholder.style.display = 'block';
        } else {
            placeholder.style.display = 'none';
            listEl.innerHTML = history.map(item => `
                <li class="list-item">
                    <div class="item-details">
                        <div class="item-name">${item.task}</div>
                        <div class="item-preview">${new Date(item.timestamp).toLocaleDateString()}</div>
                    </div>
                    <span class="item-preview">${item.duration} 分钟</span>
                </li>
            `).join('');
        }
        switchScreen('pomodoro-history-screen');
    });

    settingsForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const character = currentAiForApp;
        if (!character) return;

        character.soulBondData = character.soulBondData || {};
        character.soulBondData.pomodoroSettings = {
            wallpaper: document.getElementById('pomodoro-wallpaper-input').value,
            avatar: document.getElementById('pomodoro-avatar-input').value,
            soundUrl: document.getElementById('pomodoro-sound-url-input').value,
            cardWallpaper: document.getElementById('pomodoro-card-wallpaper-input').value,
            mode: document.querySelector('input[name="timer-mode"]:checked').value,
            focus: parseInt(document.getElementById('focus-duration-input').value),
            shortBreak: parseInt(document.getElementById('short-break-duration-input').value)
        };
        
        await saveData();
        switchScreen('pomodoro-screen');
        applySettings(); // 保存后立即应用新设置
        showToast('专注设置已保存');
    });
}
// ===============================================================
// END: 心灵羁绊 - 番茄钟 V2.1 功能
// ===============================================================
    
    
// ===============================================================
// END: 心灵羁绊 - 番茄钟 V2.0 功能
// ===============================================================
// END: 批量添加表情包功能
// ===============================================================
// END: 钱包功能核心代码
// ===============================================================
/**
 * 辅助函数：在所有角色中查找已绑定的心动对象
 * @returns {object|null} - 返回绑定的角色对象，如果没找到则返回 null
 */
function findBoundCharacter() {
    if (!db || !db.characters) return null;
    return db.characters.find(c => c.isSoulBound === true);
}
// ▼▼▼ 在 init() 函数的正上方，粘贴下面这个完整的新函数 ▼▼▼
/**
 * 处理续写按钮的点击事件，向AI请求继续生成内容。
 */
async function handleContinueWriting() {
    if (isGenerating) return; // 如果AI正在生成，则忽略点击

    const chat = (currentChatType === 'private')
        ? db.characters.find(c => c.id === currentChatId)
        : db.groups.find(g => g.id === currentChatId);
    if (!chat) return;

    // 从后往前查找AI的最后一条消息
    const lastAiMessage = [...chat.history].reverse().find(m => m.role === 'assistant');

    if (!lastAiMessage) {
        showToast('没有可续写的AI回复。');
        return;
    }

    // 构建一条临时的、用于指导AI续写的系统指令
    const continuationPrompt = `[system: 请直接续写你上一条的回复内容，不要重复已经说过的话，也不要说任何“好的，这是续写：”之类的开场白。你的上一条回复是：“${lastAiMessage.content}”]`;
    
    const promptMessage = {
        role: 'user', // 伪装成用户指令
        content: continuationPrompt,
        parts: [{ type: 'text', text: continuationPrompt }],
        id: `temp_prompt_${Date.now()}`, // 临时ID，用于后续删除
        timestamp: Date.now()
    };
     if (currentChatType === 'group') {
        promptMessage.senderId = 'user_me';
    }

    // 将这条临时指令加入历史记录的末尾
    chat.history.push(promptMessage);

    try {
        // 直接调用现有的 getAiReply 函数，它会自动读取包含我们临时指令的最新历史记录
        await getAiReply();
    } finally {
        // 请求完成后，无论成功与否，都从历史记录中移除我们添加的临时指令
        const index = chat.history.findIndex(m => m.id === promptMessage.id);
        if (index > -1) {
            chat.history.splice(index, 1);
        }
        // 保存被清理过的、最终的历史记录
        await saveData();
    }
}

/**
 * 为续写功能按钮绑定事件监听器。
 */
function setupContinueWritingFeature() {
    const continueBtn = document.getElementById('continue-writing-btn');
    if (continueBtn) {
        continueBtn.addEventListener('click', handleContinueWriting);
    }
}
function setupRollbackFeature() {
    const rollbackBtn = document.getElementById('rollback-btn');
    if (!rollbackBtn) return; // 安全检查，确保按钮存在

    // 为“撤回并重写”按钮绑定核心的点击事件
    rollbackBtn.addEventListener('click', async () => {
        // 如果AI正在生成中，则阻止操作
        if (isGenerating) {
           // showToast('AI正在思考中，请稍后再试...');
            return;
        }

        // 获取当前的聊天对象
        const chat = (currentChatType === 'private') 
            ? db.characters.find(c => c.id === currentChatId) 
            : db.groups.find(g => g.id === currentChatId);
            
        if (!chat || chat.history.length === 0) return;

        // 1. 从后往前查找，定位到最后一个【用户】消息的位置
        let lastUserMessageIndex = -1;
        for (let i = chat.history.length - 1; i >= 0; i--) {
            if (chat.history[i].role === 'user') {
                lastUserMessageIndex = i;
                break;
            }
        }

        // 如果找不到用户消息，或者最后一条消息已经是用户消息，则说明没有可撤回的AI回复
        if (lastUserMessageIndex === -1 || lastUserMessageIndex === chat.history.length - 1) {
            showToast('找不到可以重新生成的AI回复。');
            return;
        }

        // 2. 删除从最后一个用户消息之后的所有AI消息
        chat.history.splice(lastUserMessageIndex + 1);
        
        // 3. 更新界面显示，并保存数据
        renderMessages(false, true); // 重新渲染聊天气泡，并滚动到底部
        await saveData();
        renderChatList(); // 更新左侧列表的最后消息预览
        
        // 4. 再次调用AI，生成新的回复
        getAiReply();
    });
}

// ===============================================================
// START: 新增头像框功能核心代码
// ===============================================================

let currentFrameTarget = null; // 用于记录当前正在为哪个头像设置框
let currentEditingMemberId = null; // 用于记录正在编辑的群成员ID

/**
 * 渲染并更新设置面板中的头像（包括头像框）
 * @param {string} containerId - 头像容器的ID
 * @param {string} avatarUrl - 头像图片URL
 * @param {string} frameUrl - 头像框图片URL
 */
function renderAvatarInSettings(containerId, avatarUrl, frameUrl) {
    const container = document.getElementById(containerId);
    if (container) {
        container.innerHTML = `
            <img src="${avatarUrl}" class="avatar-preview">
            ${frameUrl ? `<img src="${frameUrl}" class="avatar-frame">` : ''}
        `;
    }
}

/**
 * 打开头像框选择面板
 * @param {string} target - 区分是为哪个角色设置 ('private-ai', 'private-user', etc.)
 */
function openAvatarFramePanel(target) {
    currentFrameTarget = target;
    renderAvatarFrameGrid();
    document.getElementById('avatar-frame-modal').classList.add('visible');
}

/**
 * 渲染头像框选择网格
 */
function renderAvatarFrameGrid() {
    const grid = document.getElementById('avatar-frame-grid');
    grid.innerHTML = '';
    if (db.avatarFrames.length === 0) {
        grid.innerHTML = '<p class="placeholder-text">还没有头像框，点击右上角“+”添加一个吧！</p>';
        return;
    }
    db.avatarFrames.forEach(frame => {
        const item = document.createElement('div');
        item.className = 'frame-item';
        item.dataset.frameUrl = frame.url;
        item.innerHTML = `
            <img src="${frame.url}" alt="头像框">
            <button class="delete-frame-btn" data-frame-id="${frame.id}">&times;</button>
        `;
        grid.appendChild(item);
    });
}

/**
 * 应用选择的头像框
 */
async function applyAvatarFrame() {
    const selectedItem = document.querySelector('#avatar-frame-grid .frame-item.selected');
    const frameUrl = selectedItem ? selectedItem.dataset.frameUrl : null;

    let targetObject = null;
    let avatarContainerId = '';
    let avatarUrl = '';

    if (currentChatType === 'private') {
        const character = db.characters.find(c => c.id === currentChatId);
        if (currentFrameTarget === 'private-ai') {
            character.avatarFrameUrl = frameUrl;
            avatarContainerId = 'char-avatar-container-setting';
            avatarUrl = character.avatar;
        } else if (currentFrameTarget === 'private-user') {
            character.myAvatarFrameUrl = frameUrl;
            avatarContainerId = 'my-avatar-container-setting';
            avatarUrl = character.myAvatar;
        }
    } else if (currentChatType === 'group') {
        const group = db.groups.find(g => g.id === currentChatId);
        if (currentFrameTarget === 'group-user') {
            group.me.avatarFrameUrl = frameUrl;
            avatarContainerId = 'group-my-avatar-container-setting';
            avatarUrl = group.me.avatar;
        } else if (currentFrameTarget === 'group-member' && currentEditingMemberId) {
            const member = group.members.find(m => m.id === currentEditingMemberId);
            if (member) {
                member.avatarFrameUrl = frameUrl;
                avatarContainerId = 'group-member-avatar-container-setting';
                avatarUrl = member.avatar;
            }
        }
    }

    if (avatarContainerId) {
        renderAvatarInSettings(avatarContainerId, avatarUrl, frameUrl);
    }
    
    await saveData();
    renderMessages(false, true); // 刷新聊天界面以显示新头像框
    document.getElementById('avatar-frame-modal').classList.remove('visible');
    showToast('头像框已应用！');
}

/**
 * 设置所有与头像框相关的事件监听
 */
function setupAvatarFrameSystem() {
    const modal = document.getElementById('avatar-frame-modal');
    
    // 使用事件委托，监听所有“星星”按钮的点击
    document.body.addEventListener('click', e => {
        const btn = e.target.closest('.avatar-frame-btn');
        if (btn) {
            // 如果是群成员编辑，需要先记录当前正在编辑的成员ID
            if(btn.dataset.target === 'group-member') {
                currentEditingMemberId = document.getElementById('editing-member-id').value;
            }
            openAvatarFramePanel(btn.dataset.target);
        }
    });

    // 添加新头像框
    document.getElementById('add-avatar-frame-btn').addEventListener('click', async () => {
        const url = prompt('请输入头像框图片的URL：');
        if (url && url.trim()) {
            db.avatarFrames.push({
                id: `frame_${Date.now()}`,
                url: url.trim()
            });
            await saveData();
            renderAvatarFrameGrid();
        }
    });

    // 网格内的点击事件（选择/删除）
    document.getElementById('avatar-frame-grid').addEventListener('click', e => {
        const target = e.target;
        if (target.closest('.delete-frame-btn')) {
            e.stopPropagation();
            const frameId = target.dataset.frameId;
            if (confirm('确定要删除这个头像框吗？')) {
                db.avatarFrames = db.avatarFrames.filter(f => f.id !== frameId);
                saveData();
                renderAvatarFrameGrid();
            }
        } else if (target.closest('.frame-item')) {
            document.querySelectorAll('#avatar-frame-grid .frame-item').forEach(el => el.classList.remove('selected'));
            target.closest('.frame-item').classList.add('selected');
        }
    });

    // 面板底部按钮
    document.getElementById('apply-avatar-frame-btn').addEventListener('click', applyAvatarFrame);
    document.getElementById('cancel-avatar-frame-btn').addEventListener('click', () => modal.classList.remove('visible'));
    document.getElementById('remove-avatar-frame-btn').addEventListener('click', () => {
        // 清除选中状态并应用（相当于移除了头像框）
        document.querySelectorAll('#avatar-frame-grid .frame-item').forEach(el => el.classList.remove('selected'));
        applyAvatarFrame();
    });
}

// ===============================================================
// END: 新增头像框功能核心代码
// ===============================================================
// --- 新增：用于控制“正在输入”提示的辅助函数 ---

/**
 * 在聊天顶部显示“对方正在输入中...”的状态
 */
function showTypingIndicator() {
    const subtitle = document.getElementById('chat-room-subtitle');
    const statusTextElement = document.getElementById('chat-room-status-text');

    if (subtitle && statusTextElement && currentChatType === 'private') {
        // 隐藏绿色的在线圆点
        subtitle.querySelector('.online-indicator').style.display = 'none';
        // 修改状态文字
        statusTextElement.textContent = '对方正在输入中...';
        // 添加动画效果Class
        statusTextElement.classList.add('typing-status');
    }
    // 旧的底部提示已不再使用，但为确保安全，再次将其隐藏
    document.getElementById('typing-indicator').style.display = 'none';
}

/**
 * 隐藏“正在输入”的状态，并恢复角色的在线状态
 */
function hideTypingIndicator() {
    // 仅在私聊中执行
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : null;
    if (chat) {
        const subtitle = document.getElementById('chat-room-subtitle');
        const statusTextElement = document.getElementById('chat-room-status-text');

        if (subtitle && statusTextElement) { 
            // 恢复显示绿点
            subtitle.querySelector('.online-indicator').style.display = 'block';
            // 恢复角色的在线状态
            statusTextElement.textContent = chat.status || '在线';
            // 移除动画Class
            statusTextElement.classList.remove('typing-status');
        }
    }
}
// ▲▲▲ 新函数到此结束 ▲▲▲
        const init = async () => {
        	// 在 init 函数的最顶部添加
if (!db.userDiaries) {
    db.userDiaries = [];
}
  await loadData();            
            applyLayoutPreference();
           applyGlobalCss(db.globalCustomCss);
            window.db = db;
            document.body.addEventListener('click', (e) => {
                if (e.target.closest('.context-menu')) {
                    e.stopPropagation();
                    return;
                }
                removeContextMenu();

                const backBtn = e.target.closest('.back-btn');
                if (backBtn) {
                    e.preventDefault();
                    switchScreen(backBtn.getAttribute('data-target'));
                }

                // Consolidated overlay closing logic
                const openOverlay = document.querySelector('.modal-overlay.visible, .action-sheet-overlay.visible');
                if (openOverlay && e.target === openOverlay) {
                    openOverlay.classList.remove('visible');
                }
            });

            // Specific nav links that switch screens
            document.body.addEventListener('click', e => {
                const navLink = e.target.closest('.app-icon[data-target]');
                if (navLink) {
                    e.preventDefault();
                    switchScreen(navLink.getAttribute('data-target'));
                }
            });
// --- 一次性将用户日记数据迁移到全局 ---
if (db.characters.some(c => c.userDiaries && c.userDiaries.length > 0)) {
    if (!db.userDiaries) db.userDiaries = [];
    const allUserDiaries = [];
    db.characters.forEach(char => {
        if (char.userDiaries && char.userDiaries.length > 0) {
            allUserDiaries.push(...char.userDiaries);
            delete char.userDiaries; // 从角色对象中删除
        }
    });
    // 去重并合并到全局
    const uniqueDiaries = [...new Map(allUserDiaries.map(item => [item.id, item])).values()];
    db.userDiaries.push(...uniqueDiaries);
    console.log('用户日记数据已成功迁移到全局。');
    saveData(); // 保存迁移后的结果
}
            
            applyGlobalFont(db.fontUrl);
            setupCustomWidgetSystem();
            setupHomeScreen();
            updateClock();
            setInterval(updateClock, 30000);
            setupChatListScreen();
            setupAddCharModal();
            setupChatRoom();
            setupChatSettings();
            setupApiSettingsApp();
            setupWallpaperApp();
            setupStickerSystem();
            setupVoiceMessageSystem();
            setupPhotoVideoSystem();
            setupImageRecognition();
            setupWalletSystem();
            setupGiftSystem();
            setupTimeSkipSystem();
            setupWorldBookApp();
            setupFontSettingsApp();
            bindFontPresetUI();
            setupGroupChatSystem();
            setupCustomizeApp();
            setupTutorialApp();
            setupFileSystem(); // --- NEW ---
            setupLocationSystem(); // --- NEW ---
            setupFileDisplaySystem(); 
            // (在 init 函数内部，靠近其他 setup...() 函数的地方添加)
setupAvatarFrameSystem(); // 新增：初始化头像框功能
            setupVoiceCallSystem();
            setupDiarySystem(); // --- 在这里添加这一行 ---
            setupMusicPlayer();
            setupNotificationSystem();
            setupMomentsEventListeners();
setupTrajectoryAndHeartSoundSystem();
 setupForumSystem();
           setupForumConfigSystem();
          setupUserPersonaPresets();
          setupRollbackFeature(); 
          setupContinueWritingFeature(); 
  setupMemoriesSystem(); // <-- 添加这一行
  setupMemorySummaryModal(); 
  setupAiPovApp();
  setupWalletApp(); // <-- 添加这一行
  // (在 init() 函数的末尾添加)
setupBlockFeature(); 
setInterval(checkTimedUnblocks, 60000); // 每分钟检查一次到期的AI拉黑
setupProactiveAiSystem();
setupHomeScreenPaging(); // 新增：主页翻页
        setupRendererApp();      // 新增：渲染器应用
 setupViewRecalledModal(); 
 // 在 init() 函数的末尾添加
setupBatchStickerUpload();
setupMallApp();
setupPaymentHistoryActions();
setupAiSpaceApps(); // 初始化AI空间所有App
          applyAiSpaceWallpaper(db.aiSpaceWallpaper); // 新增：应用已保存的AI手机壁紙
setupSoulBondApp();
setupDiaryExchangeApp();
setupBondMissYouHeartFeature();
setupBondInvitationSystem();
setupDailyQuestionFeature(); // <-- 新增这一行
    setupMoodWeatherFeature();   // <-- 新增这一行
setupPomodoroFeature();
setupSearchInChat();

};




// ===============================================================
// START: 完整的商城功能JavaScript代码 (V5 - 最终版)
// ===============================================================

// --- 商城及购物流程的全局变量 (确保只声明一次) ---
let isGeneratingProducts = false;
let selectedCartItemIds = new Set(); // 存储被选中的购物车项ID
let purchaseState = { productId: null, recipientId: null, quantity: 1, style: '默认款式', multiItems: [] };
let globalCountdownInterval = null;
let isLikesSelectionMode = false;
let selectedLikedProductIds = [];
// === 新增/修改的代码：修复代付功能、重构购买流程并添加付款记录 ===

/**
 * 新增：处理“找人代付”请求的函数
 * @param {string} productId - 请求代付的商品ID
 */
async function handlePayForMeRequest(productId) {
    const product = findProductById(productId);
    if (!product) return;

    // 弹出选择代付人的模态框
    const modal = document.getElementById('purchase-modal');
    purchaseState = { productId, isPayForMe: true }; // 标记当前是代付流程

    // 更新弹窗标题和按钮文字，使其更符合“代付”场景
    modal.querySelector('h5').textContent = '选择谁来帮你付款？';
    document.getElementById('confirm-recipient-btn').textContent = '发送代付请求';
    
    document.getElementById('purchase-product-image').src = product.imageUrl;
    document.getElementById('purchase-product-price').textContent = `¥${product.price.toFixed(2)}`;
    document.getElementById('purchase-product-name').textContent = product.name;
    
    renderRecipientList();
    modal.classList.add('visible');
}


// 替换旧的 handleFinalPurchaseConfirmation 函数
async function handleFinalPurchaseConfirmation() {
    // 1. 获取用户选择的数量和样式，并保存到全局状态中
    purchaseState.quantity = parseInt(document.getElementById('purchase-quantity-input').value, 10);
    const activeStyleBtn = document.querySelector('.style-option-btn.active');
    purchaseState.style = activeStyleBtn ? activeStyleBtn.textContent : '默认款式';

    // 2. 关闭当前（样式/数量选择）的弹窗
    document.getElementById('product-options-modal').classList.remove('visible');
    
    // 3. 打开“设置送达时间”的弹窗
    document.getElementById('delivery-countdown-modal').classList.add('visible');
}
// ▼▼▼ 请用这个完整的、修正后的新函数，替换掉文件中旧的 renderPaymentHistory 函数 ▼▼▼
/**
 * 新增：渲染付款记录列表的函数
 */
function renderPaymentHistory() {
    const container = document.getElementById('payment-history-list');
    if (!container) return;

    container.innerHTML = '';
    const history = db.mallData.paymentHistory || [];

    if (history.length === 0) {
        container.innerHTML = '<p class="placeholder-text" style="padding: 15px 0;">暂无付款记录</p>';
        return;
    }

    // 按时间倒序显示
    history.sort((a, b) => b.timestamp - a.timestamp);

    history.forEach(item => {
        const date = new Date(item.timestamp);
        const dateString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;
        const itemEl = document.createElement('div');
        itemEl.className = 'transaction-item'; // 复用钱包明细的样式
        
        // 【核心修改】为每条记录添加一个 data-id 属性
        itemEl.dataset.id = item.id;

        itemEl.innerHTML = `
            <div class="transaction-details">
                <span class="transaction-description">${item.description}</span>
                <span class="transaction-timestamp">${dateString}</span>
            </div>
            <span class="transaction-amount expense">- ${item.total.toFixed(2)}</span>
        `;
        container.appendChild(itemEl);
    });
}

/**
 * 切换购物车商品的选中状态
 */
function toggleCartItemSelection(cartId) {
    if (selectedCartItemIds.has(cartId)) {
        selectedCartItemIds.delete(cartId);
    } else {
        selectedCartItemIds.add(cartId);
    }
    document.querySelector(`.cart-item[data-cart-id="${cartId}"]`)?.classList.toggle('selected');
    updateCartCheckoutBar();
}

/**
 * 更新底部结算栏的显示和数据
 */
function updateCartCheckoutBar() {
    const bar = document.getElementById('cart-checkout-bar');
    const totalPriceEl = document.getElementById('cart-total-price');
    const checkoutBtn = document.getElementById('cart-checkout-btn');
    const selectAllContainer = document.querySelector('.select-all-container');
    
    const totalItems = db.mallData.cart.length;
    const selectedCount = selectedCartItemIds.size;

    if (totalItems > 0) {
        bar.style.display = 'flex';
    } else {
        bar.style.display = 'none';
    }

    let totalPrice = 0;
    selectedCartItemIds.forEach(cartId => {
        const cartItem = db.mallData.cart.find(item => item.cartId === cartId);
        const product = cartItem ? db.mallData.products.find(p => p.id === cartItem.productId) : null;
        if (product) totalPrice += product.price;
    });

    totalPriceEl.textContent = `合计: ¥${totalPrice.toFixed(2)}`;
    checkoutBtn.textContent = `去结算 (${selectedCount})`;
    checkoutBtn.disabled = selectedCount === 0;

    selectAllContainer.classList.toggle('selected', selectedCount > 0 && selectedCount === totalItems);
}

/**
 * 处理购物车结算
 */
// ▼▼▼ 1. 使用这个新函数，完整替换旧的 handleCartCheckout 函数 ▼▼▼
async function handleCartCheckout() {
    if (selectedCartItemIds.size === 0) {
        showToast("请至少选择一件商品");
        return;
    }
    // --- 核心修改：从所有商品中查找 ---
    const allProducts = [...(db.mallData.products || []), ...(db.mallData.customProducts || [])];
    const itemsToPurchase = Array.from(selectedCartItemIds).map(cartId => {
        const cartItem = db.mallData.cart.find(item => item.cartId === cartId);
        return cartItem ? allProducts.find(p => p.id === cartItem.productId) : null;
    }).filter(Boolean);
    // --- 修改结束 ---

    if (itemsToPurchase.length === 0) return;
    renderPaymentConfirmationScreen(itemsToPurchase);
}

// ▼▼▼ 在您的JS代码中添加这个【完整】的缺失函数 ▼▼▼
function renderPaymentConfirmationScreen(items) {
    const recipientSelect = document.getElementById('payment-recipient-select');
    const itemListEl = document.getElementById('payment-items-list');
    const totalPriceEl = document.getElementById('payment-total-price');
    
    // 添加“我自己”作为收货人选项
    recipientSelect.innerHTML = '<option value="user_me">我自己</option>';
    db.characters.forEach(char => {
        const option = document.createElement('option');
        option.value = char.id;
        option.textContent = char.remarkName;
        recipientSelect.appendChild(option);
    });

    itemListEl.innerHTML = '';
    let totalPrice = 0;
    items.forEach(item => {
        totalPrice += item.price;
        const itemCard = document.createElement('div');
        itemCard.className = 'payment-item-card';
        itemCard.innerHTML = `
            <img src="${item.imageUrl}" alt="${item.name}">
            <div class="item-info">
                <p class="item-name">${item.name}</p>
                <p class="item-price">¥${item.price.toFixed(2)}</p>
            </div>
        `;
        itemListEl.appendChild(itemCard);
    });
    totalPriceEl.textContent = `¥${totalPrice.toFixed(2)}`;
    
    window.currentPurchaseItems = items;
    window.currentPurchaseTotal = totalPrice;

    switchScreen('payment-confirmation-screen');
}
// ▲▲▲ 添加结束 ▲▲▲
// ▼▼▼ 1. 使用这个新函数，完整替换旧的 
/**
 * 新增：为付款记录列表设置长按删除等交互事件
 */
function setupPaymentHistoryActions() {
    const historyList = document.getElementById('payment-history-list');
    if (!historyList) return;

    const handleLongPress = (event) => {
        const item = event.target.closest('.transaction-item');
        if (!item) return;

        event.preventDefault(); // 阻止默认的右键菜单
        const transactionId = item.dataset.id;
        
        // 使用 createContextMenu 函数创建菜单
        createContextMenu(
            [{
                label: '删除此条记录',
                danger: true,
                action: async () => {
                    if (confirm('确定要删除这条付款记录吗？此操作不可撤销。')) {
                        // 从数据库中过滤掉被删除的记录
                        db.mallData.paymentHistory = db.mallData.paymentHistory.filter(
                            tx => tx.id !== transactionId
                        );
                        await saveData(); // 保存更改
                        renderPaymentHistory(); // 重新渲染列表
                        showToast('记录已删除');
                    }
                }
            }],
            event.clientX, // 鼠标X坐标
            event.clientY  // 鼠标Y坐标
        );
    };

    // 监听电脑上的右键点击
    historyList.addEventListener('contextmenu', handleLongPress);

    // 监听手机上的长按
    let longPressTimer;
    historyList.addEventListener('touchstart', (e) => {
        longPressTimer = setTimeout(() => {
            const touch = e.touches[0];
            const mockEvent = { clientX: touch.clientX, clientY: touch.clientY, target: e.target, preventDefault: () => e.preventDefault() };
            handleLongPress(mockEvent);
        }, 500); // 长按超过500毫秒触发
    });
    historyList.addEventListener('touchend', () => clearTimeout(longPressTimer));
    historyList.addEventListener('touchmove', () => clearTimeout(longPressTimer));
}
async function sendPaymentRequestCard(charId, items, total) {
    const character = db.characters.find(c => c.id === charId);
    if (!character) return;

    const message = {
        id: `msg_pay_req_${Date.now()}`,
        role: 'user',
        content: `[我向 ${character.remarkName} 发起代付请求]`,
        parts: [],
        timestamp: Date.now(),
        paymentRequestData: {
            status: 'pending', // 'pending', 'paid', 'declined'
            amount: total,
            items: items.map(item => ({ id: item.id, name: item.name, imageUrl: item.imageUrl })),
            requesterName: character.myName // 我的名字
        }
    };

    character.history.push(message);
    await saveData();
    renderChatList();
}

/**
 * 处理商城的搜索逻辑
 * @param {string} query - 用户输入的搜索关键词
 */
async function handleMallSearch(query) {
    if (!query) {
        renderMallProducts(); // 如果搜索为空，则显示所有商品
        return;
    }

    showToast(`正在搜索“${query}”...`);
    const lowerCaseQuery = query.toLowerCase();
    
    // 1. 在现有商品中进行本地模糊搜索
    const localResults = db.mallData.products.filter(p => 
        p.name.toLowerCase().includes(lowerCaseQuery) || 
        p.description.toLowerCase().includes(lowerCaseQuery)
    );

    if (localResults.length > 0) {
        // 2. 如果找到结果，则直接渲染
        renderMallProducts(localResults);
        showToast(`找到了 ${localResults.length} 件相关商品`);
    } else {
        // 3. 如果本地没有找到，则请求AI创造多个新商品
        try {
            // 调用新的复数版本函数
            const fictionalProducts = await generateFictionalProducts(query);
            
            // 将所有新创造的商品添加到总商品列表的顶部
            db.mallData.products.unshift(...fictionalProducts);
            await saveData();

            // 只显示这些新创造的商品作为本次的搜索结果
            renderMallProducts(fictionalProducts);
            showToast(`为您创造了 ${fictionalProducts.length} 件新商品！`);
        } catch (error) {
            console.error("创造虚构商品失败:", error);
            showToast(`创造失败: ${error.message}`);
            document.getElementById('product-grid').innerHTML = `<p class="placeholder-text" style="color:red;">哎呀，创造力枯竭了...</p>`;
        }
    }
}
// === [V3] 替换旧的 generateFictionalProducts 函数 ===
async function generateFictionalProducts(query) {
    
    let prompt;
    const isSpecialMode = db.mallData.api.specialItemsEnabled;

    if (isSpecialMode) {
        // --- 核心修改在此 ---
        prompt = `你是一个售卖奇幻特殊物品的创意店主。一个顾客搜索了关键词“${query}”。
重要前提：这些商品都将由用户(“我”)购买，并对聊天中的AI角色(“收件人”)使用。因此，所有商品的'功能'都必须是能够在**文字对话中被明确观察和扮演出来**的效果。

请你立即创造并上架 3到5件 与“${query}”相关的商品。
规则:
1.  **描述必须清晰**: 商品的 "description" 必须明确包含 "功能：" (描述一个能**直接改变收件人聊天行为**的效果)、"效果持续：" (单位为“轮对话”)、"副作用：" 和 "副作用持续：" (单位为“轮对话”) 这四个部分。
2.  **价格与副作用**: 价格越高的物品，副作用应该越小或持续时间越短。价格范围在10到5000之间。
3.  **创意示例 (必须参考)**:
    - **改变行为**: '害羞喷雾 (功能：让收件人变得非常害羞和内向，说话小心翼翼。效果持续：10轮对话。副作用：无。)'
    - **改变说话方式**: '诚实豆沙包 (功能：让收件人在接下来的对话中只能说真话。效果持续：3轮对话。副作用：效果结束后会头痛，并在对话中抱怨。副作用持续：5轮对话。)'
    - **改变认知**: '失忆橡皮擦 (功能：让收件人暂时忘记“我”是谁。效果持续：5轮对话。副作用：恢复记忆后会对之前的对话感到困惑。副作用持续：2轮对话。)'
4.  **严格格式**: 你的输出必须是严格的JSON数组格式 [ {商品1}, {商品2}, ... ]，不要有任何额外文字。

每个商品对象的JSON格式如下:
{
  "name": "一个极具创意的、能影响聊天对象的物品名称",
  "description": "一段包含'功能'、'效果持续'、'副作用'和'副作用持续'的描述",
  "price": [一个10到5000之间的随机数字],
  "storeName": "万能杂货铺・奇物部",
  "imagePrompt": "一个用于AI绘画的、描述该奇物的英文关键词短语"
}`;
        // --- 修改结束 ---
    } else {
         // 这是用于生成普通物品的原始指令 (保持不变)
        prompt = `你是一个万能杂货铺的创意店主，你的店里什么都卖，无论是现实存在的还是天马行空的。
一个顾客搜索了关键词“${query}”，但我们的库存里没有这个东西。
请你根据这个关键词，立即创造并上架 3到5件 独一无二但主题相似的商品。
你的任务是为每一件商品生成详细信息。
你的输出必须是严格的 JSON数组 格式，像这样 [ {商品1}, {商品2}, ... ]，不要包含任何额外的解释或文字。

每个商品对象的JSON格式如下:
{
  "name": "一个极具创意的商品名称",
  "description": "一段50字左右，引人入胜的商品描述",
  "price": [一个10到1000之间的随机数字],
  "storeName": "万能杂货铺・创意部",
  "imagePrompt": "一个用于AI绘画的、描述该商品的英文关键词短语"
}`;
    }
    
    const aiResponseText = await callMallApi([{ role: 'user', content: prompt }]);
    const productsData = JSON.parse(aiResponseText.match(/\[[\s\S]*\]/)[0]);

    const newProducts = productsData.map(productData => ({
        ...productData,
        id: `prod_${Date.now()}_${Math.random().toString(36).slice(2)}`,
        imageUrl: `https://image.pollinations.ai/prompt/${encodeURIComponent(productData.imagePrompt)}`,
        likes: 0, saves: 0, comments: []
    }));

    return newProducts;
}

/**
 * 新增：在所有商品（AI生成+自定义）中查找商品
 */
function findProductById(productId) {
    const allProducts = [...(db.mallData.products || []), ...(db.mallData.customProducts || [])];
    return allProducts.find(p => p.id === productId);
}
// ▼▼▼ 使用这个新版本，完整替换文件中旧的 setupMallApp 函数 ▼▼▼
function setupMallApp() {
    // 初始化数据结构 (保持不变)
    if (!db.mallData) {
        db.mallData = { api: {}, products: [], cart: [], likedProducts: [], logistics: [], 
specialItemsEnabled: false // <-- 添加这一行 };
}
    } else {
        if (!db.mallData.cart) db.mallData.cart = [];
        if (!db.mallData.likedProducts) db.mallData.likedProducts = [];
        if (!db.mallData.logistics) db.mallData.logistics = [];
    }
    startGlobalCountdownTimer();
    
    // --- 新增：自定义商品创建逻辑 ---
    const addCustomProductBtn = document.getElementById('add-custom-product-btn');
    const createProductModal = document.getElementById('create-product-modal');
    const createProductForm = document.getElementById('create-product-form');
    const isSpecialToggle = document.getElementById('is-special-product-toggle');
    const specialFields = document.getElementById('special-product-fields');

    addCustomProductBtn.addEventListener('click', () => {
        createProductForm.reset();
        specialFields.classList.remove('visible');
        createProductModal.classList.add('visible');
    });

    isSpecialToggle.addEventListener('change', (e) => {
        specialFields.classList.toggle('visible', e.target.checked);
        // 如果是特殊商品，普通描述变为可选
        document.getElementById('custom-product-description').required = !e.target.checked;
    });

    createProductForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const isSpecial = isSpecialToggle.checked;
        let description = document.getElementById('custom-product-description').value.trim();

        // 如果是特殊商品，则根据专用字段构建描述字符串
        if (isSpecial) {
            const func = document.getElementById('special-product-function').value.trim();
            const duration = document.getElementById('special-product-duration').value;
            const sideEffect = document.getElementById('special-product-side-effect').value.trim();
            const sideEffectDuration = document.getElementById('special-product-side-effect-duration').value;

            if (!func || !duration) {
                showToast('特殊商品的功能和效果持续时间为必填项！');
                return;
            }
            description = `功能：${func} 效果持续：${duration}轮对话`;
            if (sideEffect && sideEffectDuration) {
                description += ` 副作用：${sideEffect} 副作用持续：${sideEffectDuration}轮对话`;
            } else if (sideEffect) {
                description += ` 副作用：${sideEffect}`;
            }
        }
        
        const newProduct = {
            id: `prod_custom_${Date.now()}`,
            name: document.getElementById('custom-product-name').value.trim(),
            price: parseFloat(document.getElementById('custom-product-price').value),
            storeName: document.getElementById('custom-product-store').value.trim(),
            description: description,
            imageUrl: document.getElementById('custom-product-image-url').value.trim() || 'https://i.postimg.cc/PqYkx23B/shop-icon.png',
            likes: 0,
            saves: 0,
            comments: []
        };

        if (!newProduct.name || isNaN(newProduct.price)) {
            showToast('商品名称和价格为必填项！');
            return;
        }
if (!db.mallData.customProducts) {
        db.mallData.customProducts = [];
    }
        db.mallData.customProducts.unshift(newProduct);
        await saveData();

        createProductModal.classList.remove('visible');
        showToast(`商品“${newProduct.name}”已成功创建！`);
        renderMallProducts(); // 刷新商城主页
    });
    // --- 自定义商品逻辑结束 ---

// --- 新增：商城搜索功能事件绑定 ---
    const searchInput = document.getElementById('mall-search-input');
    const searchBtn = document.getElementById('mall-search-btn');
    
    const performSearch = () => {
        const query = searchInput.value.trim();
        handleMallSearch(query);
    };

    if (searchBtn) {
        searchBtn.addEventListener('click', performSearch);
    }
    if (searchInput) {
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                performSearch();
            }
        });
    }
    // --- 新增结束 ---
    // --- 个人中心页面的事件委托 ---
    const profileScreen = document.getElementById('mall-profile-screen');
    if (profileScreen) {
        const likedGrid = document.getElementById('liked-products-grid');
        // 为点赞商品网格添加点击事件
        likedGrid.addEventListener('click', (e) => {
            const card = e.target.closest('.product-card');
            if (card && card.dataset.productId) {
                openProductDetail(card.dataset.productId);
            }
        });
        // 为物流入口绑定事件
        document.querySelector('.wallet-action-item[data-target="logistics-screen"]').addEventListener('click', () => {
            renderLogistics();
            switchScreen('logistics-screen');
        });
    }
    // --- 新增事件绑定 ---
    const refreshBtn = document.getElementById('refresh-mall-btn');
    if(refreshBtn) {
        refreshBtn.addEventListener('click', () => generateAndRenderProducts(false));
    }
    const loadMoreIndicator = document.getElementById('load-more-indicator');
    if(loadMoreIndicator) {
        loadMoreIndicator.addEventListener('click', () => generateAndRenderProducts(true));
    }
    // --- 新增结束 ---
    // --- 购物车相关事件绑定 ---
    const cartContainer = document.getElementById('cart-item-list-container');
    const cartCheckoutBtn = document.getElementById('cart-checkout-btn');
    const cartSelectAllBtn = document.getElementById('cart-select-all-btn');
    const cartManageBtn = document.getElementById('cart-manage-btn');
    const cartDeleteSelectedBtn = document.getElementById('cart-delete-selected-btn');
    const cartScreen = document.getElementById('mall-cart-screen');

    if (cartContainer) {
        cartContainer.addEventListener('click', (e) => {
            const item = e.target.closest('.cart-item');
            if (item) {
                toggleCartItemSelection(item.dataset.cartId);
            }
        });
    }
    if (cartCheckoutBtn) cartCheckoutBtn.addEventListener('click', handleCartCheckout);
    if (cartSelectAllBtn) {
        cartSelectAllBtn.addEventListener('click', () => {
            const allCartItems = db.mallData.cart || [];
            const shouldSelectAll = selectedCartItemIds.size < allCartItems.length;
            if (shouldSelectAll) {
                allCartItems.forEach(item => selectedCartItemIds.add(item.cartId));
            } else {
                selectedCartItemIds.clear();
            }
            renderCart();
        });
    }
    if (cartManageBtn) {
        cartManageBtn.addEventListener('click', () => {
            cartScreen.classList.toggle('manage-mode');
            const isInManageMode = cartScreen.classList.contains('manage-mode');
            cartManageBtn.textContent = isInManageMode ? '完成' : '管理';
            if (!isInManageMode) {
                selectedCartItemIds.clear();
                renderCart();
            }
        });
    }
    // 【重要修正】移除删除按钮上的行内 style="display: none;" 后，此逻辑才能生效
    if (cartDeleteSelectedBtn) {
        cartDeleteSelectedBtn.addEventListener('click', async () => {
            if (selectedCartItemIds.size === 0) return showToast('请选择要删除的商品');
            if (confirm(`确定要删除选中的 ${selectedCartItemIds.size} 件商品吗？`)) {
                db.mallData.cart = db.mallData.cart.filter(item => !selectedCartItemIds.has(item.cartId));
                selectedCartItemIds.clear();
                await saveData();
                renderCart();
                showToast('商品已删除');
            }
        });
    }
    
    // --- 新的支付确认页面事件绑定 ---
    document.getElementById('confirm-final-payment-btn').addEventListener('click', async () => {
        const isPayForMe = document.querySelector('.method-item#pay-for-me-btn').classList.contains('selected');

        if (isPayForMe) {
            // 打开代付好友选择列表
            const listEl = document.getElementById('pay-for-me-selection-list');
            listEl.innerHTML = '';
            db.characters.forEach(char => {
                const li = document.createElement('li');
                li.className = 'list-item';
                li.style.cursor = 'pointer';
                li.dataset.charId = char.id;
                li.innerHTML = `<img src="${char.avatar}" class="chat-avatar"><span>${char.remarkName}</span>`;
                listEl.appendChild(li);
            });
            document.getElementById('pay-for-me-select-modal').classList.add('visible');
        } else {
            // 执行自己支付的逻辑
            try {
                await handlePayment(window.currentPurchaseTotal, `购物消费`);
                // --- 核心新增：支付成功后，为每个商品创建送货消息 ---
const recipientId = document.getElementById('payment-recipient-select').value;
const deliveryMinutes = parseInt(document.getElementById('payment-delivery-duration').value, 10);
const recipient = db.characters.find(c => c.id === recipientId);

if (recipient) {
    window.currentPurchaseItems.forEach(item => {
        const deliveryMessage = {
            id: `msg_delivery_${Date.now()}_${item.id}`,
            role: 'user',
            content: `[我为${recipient.remarkName}购买了${item.name}]`,
            parts: [],
            timestamp: Date.now(),
            senderId: 'user_me',
            deliveryData: {
                productId: item.id,
                productName: item.name,
                productImage: item.imageUrl,
                price: item.price,
                quantity: 1, // 购物车商品默认为1
                style: '默认款式',
                eta: Date.now() + deliveryMinutes * 60 * 1000,
                delivered: false
            }
        };
        recipient.history.push(deliveryMessage);
    });
}
// --- 新增结束 ---
                // 支付成功，将商品添加到物流
                addItemsToLogistics(window.currentPurchaseItems, null); // null 表示是用户自己买的
                
                // 添加到商城付款记录
                if (!db.mallData.paymentHistory) db.mallData.paymentHistory = [];
                db.mallData.paymentHistory.unshift({
                    id: `pay_${Date.now()}`,
                    timestamp: Date.now(),
                    description: `购物车结算 (${window.currentPurchaseItems.length}件)`,
                    total: window.currentPurchaseTotal
                });

                // 从购物车移除已购商品
                const purchasedIds = new Set(window.currentPurchaseItems.map(item => item.id));
                db.mallData.cart = db.mallData.cart.filter(item => !purchasedIds.has(item.productId));
                selectedCartItemIds.clear();

                await saveData();
                showToast('支付成功！可在“我的物流”中查看');
                switchScreen('mall-cart-screen');
                renderCart();

            } catch (error) {
                showToast(error.message);
            }
        }
    });
    
    // 支付方式选择
    document.querySelector('.payment-methods').addEventListener('click', (e) => {
        const methodItem = e.target.closest('.method-item');
        if (methodItem) {
            document.querySelectorAll('.payment-methods .method-item').forEach(el => el.classList.remove('selected'));
            methodItem.classList.add('selected');
            document.getElementById('confirm-final-payment-btn').textContent = methodItem.id === 'pay-for-me-btn' ? '选择好友' : '确认支付';
        }
    });

    // 代付好友选择列表点击事件
    document.getElementById('pay-for-me-selection-list').addEventListener('click', async (e) => {
        const item = e.target.closest('.list-item');
        if (item && item.dataset.charId) {
            const charId = item.dataset.charId;
            await sendPaymentRequestCard(charId, window.currentPurchaseItems, window.currentPurchaseTotal);
            document.getElementById('pay-for-me-select-modal').classList.remove('visible');
            showToast(`已向 ${db.characters.find(c=>c.id === charId).remarkName} 发送代付请求`);
            switchScreen('chat-list-screen'); // 直接跳转到聊天列表，让用户看到卡片
        }
    });

    document.getElementById('cancel-pay-for-me-btn').addEventListener('click', () => {
        document.getElementById('pay-for-me-select-modal').classList.remove('visible');
    });

        // --- 商品详情页底部按钮的事件委托 ---
    const detailFooterNav = document.getElementById('detail-footer-nav');
    if (detailFooterNav) {
        detailFooterNav.addEventListener('click', (e) => {
            const btn = e.target.closest('.action-btn');
            if (!btn) return;
            
            const detailScreen = document.getElementById('product-detail-screen');
            const currentProductId = detailScreen.dataset.productId;
            if (!currentProductId) return;

            const btnText = btn.textContent;
            if (btnText.includes('购买')) {
                openPurchaseModal(currentProductId);
            } else if (btnText.includes('购物车')) {
                addToCart(currentProductId);
            } else if (btnText.includes('收藏')) {
                toggleProductLike(currentProductId);
            } else if (btnText.includes('代付')) {
                handlePayForMeRequest(currentProductId);
            }
        });
    }
        // --- 购买流程中各个弹窗按钮的事件绑定 ---
    const confirmRecipientBtn = document.getElementById('confirm-recipient-btn');
    if (confirmRecipientBtn) confirmRecipientBtn.addEventListener('click', handleRecipientConfirmation);

    const increaseQuantityBtn = document.getElementById('increase-quantity-btn');
    if (increaseQuantityBtn) increaseQuantityBtn.addEventListener('click', () => updateQuantity(1));
    
    const decreaseQuantityBtn = document.getElementById('decrease-quantity-btn');
    if (decreaseQuantityBtn) decreaseQuantityBtn.addEventListener('click', () => updateQuantity(-1));

    const styleOptionsContainer = document.getElementById('style-options-container');
    if (styleOptionsContainer) {
        styleOptionsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('style-option-btn')) {
                document.querySelectorAll('.style-option-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
            }
        });
    }
    
    const confirmPurchaseBtn = document.getElementById('confirm-purchase-btn');
    if (confirmPurchaseBtn) confirmPurchaseBtn.addEventListener('click', handleFinalPurchaseConfirmation);
    
    const confirmDeliveryTimeBtn = document.getElementById('confirm-delivery-time-btn');
    if (confirmDeliveryTimeBtn) confirmDeliveryTimeBtn.addEventListener('click', completePurchase);

    document.querySelectorAll('.close-purchase-modal-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const modal = e.target.closest('.modal-overlay');
            if (modal.id === 'purchase-modal') {
                const productId = modal.dataset.productId;
                if (productId && confirm('要将这个宝贝加入购物车吗？')) {
                    addToCart(productId, true);
                }
            }
            modal.classList.remove('visible');
        });
    });

    const cartItemList = document.getElementById('cart-item-list');
    if(cartItemList) {
        cartItemList.addEventListener('click', e => {
            if(e.target.classList.contains('to-pay-btn')) {
                openPurchaseModal(e.target.dataset.productId);
            }
        });
    }
    document.querySelectorAll('.mall-bottom-nav').forEach(nav => {
    nav.addEventListener('click', (e) => {
        const navItem = e.target.closest('.nav-item[data-target]');
        if (navItem) {
            const targetScreenId = navItem.dataset.target;
            // 如果是点击购物车或个人中心，先渲染对应内容
            if (targetScreenId === "mall-cart-screen") renderCart();
            if (targetScreenId === "mall-profile-screen") renderLikedProducts();
            renderPaymentHistory();
            // ...
        }
    });
});
    // --- 其他通用事件绑定 (保持不变) ---
    document.querySelectorAll('.mall-bottom-nav').forEach(nav => {
        nav.addEventListener('click', (e) => {
            const navItem = e.target.closest('.nav-item[data-target]');
            if (navItem) {
                const targetScreenId = navItem.dataset.target;
                // 如果是点击购物车或个人中心，先渲染对应内容
                if (targetScreenId === "mall-cart-screen") renderCart();
                if (targetScreenId === "mall-profile-screen") renderLikedProducts();
                renderPaymentHistory(); 
                switchScreen(targetScreenId);
                nav.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
                navItem.classList.add('active');
            }
        });
    });

    const mallAppIcon = document.querySelector('.app-icon[data-target="mall-screen"]');
    if (mallAppIcon) {
        mallAppIcon.addEventListener('click', () => {
            if (db.mallData.products.length === 0) {
                generateAndRenderProducts(false);
            } else {
                renderMallProducts();
            }
        });
    }

    const productGrid = document.getElementById('product-grid');
    if (productGrid) {
        productGrid.addEventListener('click', (e) => {
            const card = e.target.closest('.product-card');
            if (card && card.dataset.productId) {
                document.getElementById('product-detail-screen').dataset.productId = card.dataset.productId;
                openProductDetail(card.dataset.productId);
            }
        });
    }
    
    
    // --- 商城API设置逻辑 ---
    const mallApiForm = document.getElementById('mall-api-form');
    if(mallApiForm) {
        const mallFetchBtn = document.getElementById('mall-fetch-models-btn');
        const mallApiUrl = document.getElementById('mall-api-url');
        const mallApiKey = document.getElementById('mall-api-key');
        const mallApiModel = document.getElementById('mall-api-model');
const specialItemsToggle = document.getElementById('special-items-toggle');
        mallApiUrl.value = db.mallData.api.url || '';
        specialItemsToggle.checked = db.mallData.api.specialItemsEnabled || false;
        mallApiKey.value = db.mallData.api.key || '';
        if (db.mallData.api.model) {
            mallApiModel.innerHTML = `<option value="${db.mallData.api.model}">${db.mallData.api.model}</option>`;
        }
        
        mallFetchBtn.addEventListener('click', async () => {
            const url = mallApiUrl.value.trim();
            const key = mallApiKey.value.trim();
            if (!url || !key) return showToast('请填写API地址和密钥');
            const endpoint = `${url.replace(/\/$/, '')}/v1/models`;
            mallFetchBtn.classList.add('loading');
            try {
                const response = await fetch(endpoint, { headers: { 'Authorization': `Bearer ${key}` } });
                if (!response.ok) throw new Error(`网络错误: ${response.status}`);
                const data = await response.json();
                mallApiModel.innerHTML = data.data.map(m => `<option value="${m.id}">${m.id}</option>`).join('');
                showToast('模型列表拉取成功');
            } catch (error) {
                showToast(`拉取失败: ${error.message}`);
            } finally {
                mallFetchBtn.classList.remove('loading');
            }
        });

        mallApiForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    // *** FIX: Save all settings into the api object correctly ***
    db.mallData.api = {
        url: mallApiUrl.value,
        key: mallApiKey.value,
        model: mallApiModel.value,
        specialItemsEnabled: specialItemsToggle.checked
    };
    await saveData();
    showToast('商城API设置已保存！');
});
}
}

// 在 setupMallApp 函数的末尾添加
// 物流页面渲染
function renderLogistics() {
    const container = document.getElementById('logistics-list-container');
    const placeholder = document.getElementById('no-logistics-placeholder');
    const logistics = db.mallData.logistics || [];

    if (logistics.length === 0) {
        container.innerHTML = '';
        placeholder.style.display = 'block';
        return;
    }
    placeholder.style.display = 'none';
    container.innerHTML = '';

    logistics.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'logistics-item';
        itemEl.innerHTML = `
            <div class="logistics-header">
                <span>订单号: ${item.orderId.slice(-8)}</span>
                <span class="logistics-status">${item.status}</span>
            </div>
            <div class="logistics-body">
                <img src="${item.productImage}" alt="${item.productName}">
                <div class="logistics-info">
                    <p class="item-name">${item.productName}</p>
                    <p class="eta" data-countdown-type="delivery" data-eta="${item.eta}">正在计算送达时间...</p>
                    <p class="recipient-info" style="font-size: 12px; color: #888;">收件人: ${item.recipientName}</p>
                </div>
            </div>
        `;
        container.appendChild(itemEl);
    });
}

// 物流页面导航
document.querySelector('.wallet-action-item[data-target="logistics-screen"]').addEventListener('click', () => {
    renderLogistics();
    switchScreen('logistics-screen');
});
// ▼▼▼ 将这个新函数添加到 setupMallApp 函数内部 ▼▼▼
// ▼▼▼ 将以下所有新函数，添加到 setupMallApp 函数的内部 ▼▼▼

/**
 * [已修复] 将商品添加到物流列表的函数，增加了送达时间参数
 * @param {Array} items - 商品对象数组
 * @param {string|null} purchasedByAiId - 如果是AI代付，则传入AI的ID
 * @param {number} deliveryMinutes - 自定义的送达分钟数
 */
function addItemsToLogistics(items, purchasedByAiId = null, deliveryMinutes = 5) {
    if (!db.mallData.logistics) db.mallData.logistics = [];

    // 确定收件人信息
    let recipientId, recipientName;
    if (purchasedByAiId) {
        // 如果是AI代付，收件人是“我”
        const anyCharacter = db.characters[0];
        recipientName = anyCharacter ? anyCharacter.myName : '我';
    } else {
        // 如果是用户自己购买，根据选择确定收件人
        recipientId = purchaseState.recipientId;
        const recipientChar = db.characters.find(c => c.id === recipientId);
        recipientName = recipientChar ? recipientChar.remarkName : '未知收件人';
    }

    items.forEach(item => {
        db.mallData.logistics.unshift({
            orderId: `order_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`,
            productId: item.id,
            productName: item.name,
            productImage: item.imageUrl,
            purchasedByAiId: purchasedByAiId, // 记录是谁付的款
            recipientName: recipientName,
            // --- 核心修复 3：使用传入的 deliveryMinutes 参数计算送达时间 ---
            eta: Date.now() + deliveryMinutes * 60 * 1000,
            status: '待发货'
        });
    });
}
/**
 * 向AI发送代付请求卡片
 */
async function sendPaymentRequestCard(charId, items, total) {
    const character = db.characters.find(c => c.id === charId);
    if (!character) return;

    const message = {
        id: `msg_pay_req_${Date.now()}`,
        role: 'user',
        content: `[我向 ${character.remarkName} 发起代付请求]`,
        parts: [],
        timestamp: Date.now(),
        paymentRequestData: {
            status: 'pending',
            amount: total,
            items: items.map(item => ({ id: item.id, name: item.name, imageUrl: item.imageUrl })),
            requesterName: character.myName
        }
    };
    character.history.push(message);
    await saveData();
}

/**
 * 处理AI的代付决定（同意或拒绝）
 */
/**
/**
 * [V3.0 | 最终修正版] 处理AI的代付决定，并让AI根据人设生成符合情境的回复。
 */
async function handleAiPaymentDecision(messageId, decision) {
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;
    
    const message = character.history.find(m => m.id === messageId);
    if (!message || !message.paymentRequestData) return;

    // 1. 在数据中更新卡片状态
    message.paymentRequestData.status = decision;

    // --- 核心修复：立即保存数据并刷新整个聊天界面 ---
    // 这一步会立刻将卡片状态从“等待付款”更新为“已支付”或“已拒绝”
    await saveData();
    renderMessages(false, true); 
    // --- 修复结束 ---

    let contextMessageContent = ''; // 这是我们将要发给AI的“系统指令”

    if (decision === 'paid') {
        // (这部分逻辑保持不变：处理物流和顶部通知)
        addItemsToLogistics(message.paymentRequestData.items, character.id);
        const notifText = `<strong>${character.remarkName}</strong> 已为你支付了 ${message.paymentRequestData.items.length} 件商品。`;
        addNotificationToQueue({
            avatar: character.avatar,
            text: notifText,
            chatId: character.id,
            type: 'private'
        });
        
        // 创建一条引导AI回复的指令
        contextMessageContent = `[system: 你刚刚同意并支付了 ${character.myName} 的代付请求。请在聊天中告知对方你已经付款了，并根据你的人设说些什么（例如，可以表现得很大方、或者调侃一下这次消费、或者抱怨自己又破费了等等）。]`;

    } else { // 如果AI拒绝 (这部分逻辑保持不变)
        contextMessageContent = `[system: 你刚刚拒绝了 ${character.myName} 的代付请求。请在聊天中告知对方你拒绝的原因。]`;
    }

    // 2. 将这条“系统指令”作为一条用户消息发送给AI
    const contextMessage = {
        id: `msg_pay_resp_${Date.now()}`,
        role: 'user',
        content: contextMessageContent,
        parts: [{ type: 'text', text: contextMessageContent }],
        timestamp: Date.now()
    };
    character.history.push(contextMessage);
    
    // 3. 再次保存，确保指令被记录
    await saveData();

    // 4. 触发AI，让它根据上面的指令生成回复 (无需等待，让它在后台运行)
    getAiReply();
}
/**
 * 渲染物流列表页面
 */
function renderLogistics() {
    const container = document.getElementById('logistics-list-container');
    const placeholder = document.getElementById('no-logistics-placeholder');
    const logistics = db.mallData.logistics || [];

    if (logistics.length === 0) {
        container.innerHTML = '';
        placeholder.style.display = 'block';
        return;
    }
    placeholder.style.display = 'none';
    container.innerHTML = '';

    logistics.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'logistics-item';
        itemEl.innerHTML = `
            <div class="logistics-header">
                <span>订单号: ${item.orderId.slice(-8)}</span>
                <span class="logistics-status">${item.status}</span>
            </div>
            <div class="logistics-body">
                <img src="${item.productImage}" alt="${item.productName}">
                <div class="logistics-info">
                    <p class="item-name">${item.productName}</p>
                    <p class="eta" data-countdown-type="delivery" data-eta="${item.eta}">正在计算送达时间...</p>
                    <p class="recipient-info">收件人: ${item.recipientName}</p>
                </div>
            </div>
        `;
        container.appendChild(itemEl);
    });
}
async function callMallApi(messages) {
    const mallApi = db.mallData.api;
    const mainApi = db.apiSettings;
    let apiToUse = (mallApi && mallApi.url && mallApi.key && mallApi.model) ? mallApi : mainApi;
    if (!apiToUse || !apiToUse.url || !apiToUse.key || !apiToUse.model) {
        throw new Error('商城功能未找到有效的API配置。');
    }
    return callAiApi(messages, apiToUse);
}

// === [V2] 替换旧的 generateAndRenderProducts 函数 ===
async function generateAndRenderProducts(append = false) {
    if (isGeneratingProducts) return;
    isGeneratingProducts = true;
    const grid = document.getElementById('product-grid');
    const loadIndicator = document.getElementById('load-more-indicator');
    const refreshBtnIcon = document.querySelector('#refresh-mall-btn svg');
    
    if (append) {
        if(loadIndicator) loadIndicator.classList.add('loading');
    } else {
        if(grid) grid.innerHTML = `<p class="placeholder-text">正在为您发现好物...</p>`;
        if (refreshBtnIcon) refreshBtnIcon.classList.add('rotating');
    }

    try {
        let prompt;
        const isSpecialMode = db.mallData.api.specialItemsEnabled;

        if (isSpecialMode) {
            // --- 核心修改在此 ---
            prompt = `你是一个售卖奇幻特殊物品的创意店主。
重要前提：这些商品都将由用户(“我”)购买，并对聊天中的AI角色(“收件人”)使用。因此，所有商品的'功能'都必须是能够在**文字对话中被明确观察和扮演出来**的效果。

请你立即创造并上架 10件 独一无二的特殊商品。
规则:
1.  **描述必须清晰**: 商品的 "description" 必须明确包含 "功能：" (描述一个能**直接改变收件人聊天行为**的效果)、"效果持续：" (单位为“轮对话”)、"副作用：" 和 "副作用持续：" (单位为“轮对话”) 这四个部分。
2.  **价格与副作用**: 价格越高的物品，副作用应该越小或持续时间越短。价格范围在10到5000之间。
3.  **创意示例 (必须参考)**:
    - **改变行为**: '害羞喷雾 (功能：让收件人变得非常害羞和内向，说话小心翼翼。效果持续：10轮对话。副作用：无。)'
    - **改变说话方式**: '诚实豆沙包 (功能：让收件人在接下来的对话中只能说真话。效果持续：3轮对话。副作用：效果结束后会头痛，并在对话中抱怨。副作用持续：5轮对话。)'
    - **改变认知**: '失忆橡皮擦 (功能：让收件人暂时忘记“我”是谁。效果持续：5轮对话。副作用：恢复记忆后会对之前的对话感到困惑。副作用持续：2轮对话。)'
4.  **严格格式**: 你的输出必须是严格的JSON数组格式 [ {商品1}, {商品2}, ... ]，不要有任何额外文字。

每个商品对象的JSON格式如下:
{
  "name": "一个极具创意的、能影响聊天对象的物品名称",
  "description": "一段包含'功能'、'效果持续'、'副作用'和'副作用持续'的描述",
  "price": [一个10到5000之间的随机数字],
  "storeName": "万能杂货铺・奇物部",
  "imagePrompt": "一个用于AI绘画的、描述该奇物的英文关键词短语"
}`;
            // --- 修改结束 ---
        } else {
            // 这是原来的普通商品指令 (保持不变)
            prompt = `你是一个创意电商策划。请模仿拼多多或淘宝的风格，生成10个虚构的、新潮有趣的商品列表。商品类型要多样化，必须包含现代时尚物品（如衣服、包包、首饰）和来自不同幻想世界观的特殊物品。例如：ABO世界观的顶级抑制剂、无限流副本的保命道具、修仙世界的丹药法宝、赛博朋克义体等。每个商品需包含：一个吸引人的'name'，一段50字左右的'description'，一个随机的'price' (10-1000之间)，一个'storeName'，以及一个用于AI生图的英文'imagePrompt'。请严格以JSON数组格式返回。`;
        }

        const aiResponseText = await callMallApi([{ role: 'user', content: prompt }]);
        const productsData = JSON.parse(aiResponseText.match(/\[[\s\S]*\]/)[0]);
        const newProducts = productsData.map(p => ({ ...p, id: `prod_${Date.now()}_${Math.random()}`, imageUrl: `https://image.pollinations.ai/prompt/${encodeURIComponent(p.imagePrompt)}`, likes: Math.floor(Math.random() * 5000), saves: Math.floor(Math.random() * 8000), comments: [] }));
        
        if (append) {
            db.mallData.products.push(...newProducts);
            renderNewProducts(newProducts);
        } else {
            db.mallData.products = newProducts;
            renderMallProducts();
        }
        await saveData();
    } catch (error) {
        console.error("生成商品失败:", error);
        if (!append && grid) {
            grid.innerHTML = `<p class="placeholder-text" style="color:red;">商品加载失败: ${error.message}</p>`;
        }
        showToast('商品加载失败');
    } finally {
        isGeneratingProducts = false;
        if (loadIndicator) loadIndicator.classList.remove('loading');
        if (refreshBtnIcon) refreshBtnIcon.classList.remove('rotating');
    }
}

function renderMallProducts(productsToRender) {
    const grid = document.getElementById('product-grid');
    if (!grid) return;

    grid.innerHTML = '';
    
    // 1. 优先渲染用户自定义的商品
    const customProducts = db.mallData.customProducts || [];
    if (customProducts.length > 0 && !productsToRender) { // 仅在非搜索模式下显示分类
        const title = document.createElement('h3');
        title.textContent = '个性商品';
        title.style.cssText = "grid-column: 1 / -1; margin: 10px 0; color: #555;";
        grid.appendChild(title);
        customProducts.forEach(product => grid.appendChild(createProductCardElement(product)));
    }

    // 2. 渲染AI生成的商品
    const aiProducts = productsToRender || db.mallData.products;
    if (aiProducts.length > 0 && !productsToRender) {
        const title = document.createElement('h3');
        title.textContent = '万能杂货铺';
        title.style.cssText = "grid-column: 1 / -1; margin: 20px 0 10px; color: #555;";
        grid.appendChild(title);
    }
    
    if (aiProducts.length > 0) {
        aiProducts.forEach(product => grid.appendChild(createProductCardElement(product)));
    }

    if (grid.innerHTML === '') {
        grid.innerHTML = `<p class="placeholder-text">空空如也...</p>`;
    }
}

function renderNewProducts(newProducts) {
    const grid = document.getElementById('product-grid');
    if(grid) {
        newProducts.forEach(product => grid.appendChild(createProductCardElement(product)));
    }
}

function createProductCardElement(product) {
    const card = document.createElement('div');
    card.className = 'product-card';
    card.dataset.productId = product.id;
    card.innerHTML = `
        <img src="${product.imageUrl}" alt="${product.name}" class="product-image">
        <div class="product-info">
            <p class="product-title">${product.name}</p>
            <div class="product-price-row">
                <span class="product-price">${product.price.toFixed(2)}</span>
                <span class="product-sales">已售${product.sales || Math.floor(Math.random()*1000)+'+'}</span>
            </div>
        </div>`;
    return card;
}

function openProductDetail(productId) {
    const product = findProductById(productId);
    if (!product) return;
    document.getElementById('detail-product-image').src = product.imageUrl;
    document.getElementById('detail-product-price').textContent = `¥${product.price.toFixed(2)}`;
    document.getElementById('detail-product-likes').textContent = `❤️ ${product.likes}`;
    document.getElementById('detail-product-saves').textContent = `⭐ ${product.saves}`;
    document.getElementById('detail-product-title').textContent = product.name;
    document.getElementById('detail-product-description').textContent = product.description;
    document.getElementById('detail-store-name').textContent = product.storeName;
    updateLikeButtonState(productId);
    renderComments(productId);
    const loadMoreBtn = document.getElementById('load-more-comments-btn');
    if (loadMoreBtn) loadMoreBtn.onclick = () => generateAndRenderComments(productId);
    switchScreen('product-detail-screen');
}

function renderComments(productId) {
    const product = findProductById(productId);
    const list = document.getElementById('comment-list');
    if(!list) return;
    list.innerHTML = '';
    if (!product || !product.comments || product.comments.length === 0) {
        list.innerHTML = `<li class="placeholder-text" style="padding: 20px 0;">暂无评价，点击下方按钮生成吧！</li>`;
        return;
    }
    product.comments.forEach(comment => {
        const item = document.createElement('li');
        item.className = 'comment-item';
        item.innerHTML = `<div class="comment-header"><img src="${comment.avatar}" class="comment-avatar"><span class="comment-author">${comment.author}</span></div><p class="comment-text">${comment.text}</p>${comment.sellerReply ? `<div class="seller-reply">${comment.sellerReply}</div>` : ''}`;
        list.appendChild(item);
    });
}

async function generateAndRenderComments(productId) {
    const product = findProductById(productId);
    if (!product) return;
    const loadMoreBtn = document.getElementById('load-more-comments-btn');
    loadMoreBtn.textContent = '生成中...';
    loadMoreBtn.disabled = true;
    try {
        const prompt = `你是一个社交媒体评论专家。请为以下商品生成5条新潮、真实的买家评论。评论要使用网络热梗、潮流用语和emoji，风格要多样化。同时，为每条评论生成一句商家的回复。商品信息：\n名称: ${product.name}\n描述: ${product.description}\n请严格以JSON数组格式返回，每个对象包含 'author', 'avatar'(使用 https://i.postimg.cc/ VL1g9G5V/store-avatar.png), 'text', 'sellerReply' 四个字段。`;
        const aiResponseText = await callMallApi([{ role: 'user', content: prompt }]);
        const newComments = JSON.parse(aiResponseText.match(/\[[\s\S]*\]/)[0]);
        product.comments.push(...newComments);
        await saveData();
        renderComments(productId);
        showToast('已加载新的评论！');
    } catch (error) {
        showToast(`生成评论失败: ${error.message}`);
    } finally {
        loadMoreBtn.textContent = '加载更多评价';
        loadMoreBtn.disabled = false;
    }
}

async function toggleProductLike(productId) {
    const likedIndex = db.mallData.likedProducts.indexOf(productId);
    if (likedIndex > -1) {
        db.mallData.likedProducts.splice(likedIndex, 1);
        showToast('已取消点赞');
    } else {
        db.mallData.likedProducts.push(productId);
        showToast('点赞成功！');
    }
    await saveData();
    updateLikeButtonState(productId);
}

function updateLikeButtonState(productId) {
    const likeBtn = document.getElementById('like-product-btn');
    if (likeBtn) {
        likeBtn.classList.toggle('liked', db.mallData.likedProducts.includes(productId));
    }
}

function renderLikedProducts() {
    const grid = document.getElementById('liked-products-grid');
    const placeholder = document.getElementById('no-liked-products');
    if(!grid || !placeholder) return;
    grid.innerHTML = '';
    if (db.mallData.likedProducts.length === 0) {
        placeholder.style.display = 'block';
        return;
    }
    placeholder.style.display = 'none';
    [...db.mallData.likedProducts].reverse().forEach(productId => {
        const product = findProductById(productId);
        if (product) grid.appendChild(createProductCardElement(product));
    });
}

function enterLikesSelectionMode() {
    isLikesSelectionMode = true;
    document.getElementById('mall-profile-screen').classList.add('selection-mode-active');
    updateCheckoutBar();
}

function exitLikesSelectionMode() {
    isLikesSelectionMode = false;
    document.getElementById('mall-profile-screen').classList.remove('selection-mode-active');
    selectedLikedProductIds = [];
    document.querySelectorAll('#liked-products-grid .product-card.selected').forEach(el => el.classList.remove('selected'));
}

function toggleLikedProductSelection(productId) {
    const index = selectedLikedProductIds.indexOf(productId);
    if (index > -1) {
        selectedLikedProductIds.splice(index, 1);
    } else {
        selectedLikedProductIds.push(productId);
    }
    document.querySelector(`#liked-products-grid .product-card[data-product-id="${productId}"]`).classList.toggle('selected');
    updateCheckoutBar();
}

function updateCheckoutBar() {
    let totalPrice = 0;
    selectedLikedProductIds.forEach(id => {
        const product = db.mallData.products.find(p => p.id === id);
        if (product) totalPrice += product.price;
    });
    document.getElementById('likes-total-price').textContent = `总计: ¥${totalPrice.toFixed(2)}`;
    document.getElementById('checkout-likes-btn').disabled = selectedLikedProductIds.length === 0;
}

function handleLikesCheckout() {
    purchaseState.multiItems = selectedLikedProductIds.map(id => db.mallData.products.find(p => p.id === id)).filter(Boolean);
    if (purchaseState.multiItems.length === 0) return showToast("请至少选择一件商品");
    
    const modal = document.getElementById('purchase-modal');
    document.getElementById('purchase-product-image').src = 'https://i.postimg.cc/PqYkx23B/shop-icon.png';
    const totalPrice = purchaseState.multiItems.reduce((sum, item) => sum + item.price, 0);
    document.getElementById('purchase-product-price').textContent = `¥${totalPrice.toFixed(2)}`;
    document.getElementById('purchase-product-name').textContent = `${purchaseState.multiItems.length}件商品`;
    renderRecipientList();
    modal.classList.add('visible');
}

async function addToCart(productId, silent = false) {
    if (!productId) return;

    // --- 核心修改：同时检查AI商品和自定义商品 ---
    const allProducts = [...(db.mallData.products || []), ...(db.mallData.customProducts || [])];
    const productExists = allProducts.some(p => p.id === productId);
    
    if (!productExists) {
        if (!silent) showToast('错误：找不到该商品');
        return;
    }
    // --- 修改结束 ---

    const existingItem = db.mallData.cart.find(item => item.productId === productId);
    if (existingItem) {
        if (!silent) showToast('宝贝已在购物车中');
        return;
    }
    db.mallData.cart.push({
        cartId: `cart_${Date.now()}`,
        productId: productId,
        paymentDeadline: Date.now() + 30 * 60 * 1000
    });
    await saveData();
    if (!silent) {
        showToast('宝贝已加入购物车，请在30分钟内支付哦');
        renderCart();
        switchScreen('mall-cart-screen');
    }
}
function openPurchaseModal(productId) {
    const product = findProductById(productId); // 使用这个辅助函数
    if (!product) {
        // 如果找不到商品，给出明确提示并中止
        showToast('错误：找不到该商品信息。');
        return;
    }
    purchaseState = { productId, recipientId: null, quantity: 1, style: '默认款式', multiItems: [] };
    const modal = document.getElementById('purchase-modal');
    modal.dataset.productId = productId;
    modal.querySelector('h5').textContent = '选择收货人';
    document.getElementById('confirm-recipient-btn').textContent = '确定';
    document.getElementById('purchase-product-image').src = product.imageUrl;
    document.getElementById('purchase-product-price').textContent = `¥${product.price.toFixed(2)}`;
    document.getElementById('purchase-product-name').textContent = product.name;
    renderRecipientList();
    modal.classList.add('visible');
}

function renderRecipientList() {
    const container = document.getElementById('recipient-selection-list');
    if(!container) return;
    container.innerHTML = '';
    db.characters.forEach(char => {
        const li = document.createElement('li');
        li.className = 'list-item';
        li.innerHTML = `<input type="radio" name="recipient" value="${char.id}" id="recipient-${char.id}"><label for="recipient-${char.id}" style="display:flex; align-items:center; width:100%; gap:10px;"><img src="${char.avatar}" class="chat-avatar"><div class="item-details"><div class="item-name">${char.remarkName}</div></div></label>`;
        container.appendChild(li);
    });
}

/**
 * [已修复] 处理收货人确认，并根据流程分发到“找人代付”或“自己购买”
 */
async function handleRecipientConfirmation() {
    const selectedRecipient = document.querySelector('input[name="recipient"]:checked');
    if (!selectedRecipient) {
        showToast('请选择一个收货人');
        return;
    }
    purchaseState.recipientId = selectedRecipient.value;
    const recipientChar = db.characters.find(c => c.id === purchaseState.recipientId);

    // 关闭选择弹窗
    document.getElementById('purchase-modal').classList.remove('visible');

    // --- 核心修复逻辑 ---
    // 判断是否为“找人代付”流程
    if (purchaseState.isPayForMe) {
        // *** 核心修改：使用 findProductById 查找商品 ***
        const product = findProductById(purchaseState.productId);
        if (!product || !recipientChar) {
            showToast('错误：找不到商品或代付人');
            return;
        }

        // 调用函数，向AI发送代付请求卡片
        await sendPaymentRequestCard(recipientChar.id, [product], product.price);

        showToast(`已向 ${recipientChar.remarkName} 发送代付请求`);
        
        // (可选, 但建议保留) 自动跳转到与该AI的聊天界面
        currentChatId = recipientChar.id;
        currentChatType = 'private';
        openChatRoom(currentChatId, currentChatType);

    } else if (purchaseState.multiItems.length > 0) {
        // 这是原有的逻辑：处理从收藏夹或购物车发起的“多商品结算”
        document.getElementById('delivery-countdown-modal').classList.add('visible');
    } else {
        // 这是原有的逻辑：处理正常的“单品自己购买”流程
        openOptionsModal();
    }
}
function openOptionsModal() {
	   const product = findProductById(purchaseState.productId);
    if (!product) { // 增加安全检查
        showToast("打开商品选项失败：找不到商品。");
        return;
    }
    const modal = document.getElementById('product-options-modal');
    modal.dataset.productId = purchaseState.productId;
    document.getElementById('options-product-image').src = product.imageUrl;
    document.getElementById('options-product-price').textContent = `¥${product.price.toFixed(2)}`;
    document.getElementById('options-product-name').textContent = product.name;
    document.getElementById('purchase-quantity-input').value = 1;
    modal.classList.add('visible');
}

function updateQuantity(amount) {
    const input = document.getElementById('purchase-quantity-input');
    let currentValue = parseInt(input.value, 10);
    currentValue += amount;
    if (currentValue < 1) currentValue = 1;
    input.value = currentValue;
}



// ▼▼▼ 用这个新版本，完整替换文件中旧的 renderCart 函数 ▼▼▼
function renderCart() {
    const container = document.getElementById('cart-item-list-container');
    if (!container) return;
    container.innerHTML = '';

    if (!db.mallData.cart || db.mallData.cart.length === 0) {
        container.innerHTML = '<p class="placeholder-text">购物车是空的哦，快去逛逛吧~</p>';
        updateCartCheckoutBar();
        return;
    }

    // 将AI商品和自定义商品合并，以便查找
    const allProducts = [...(db.mallData.products || []), ...(db.mallData.customProducts || [])];

    // 按店铺对商品进行分组
    const groupedByStore = db.mallData.cart.reduce((acc, cartItem) => {
        const product = allProducts.find(p => p.id === cartItem.productId);
        if (product) {
            const storeName = product.storeName || '官方旗舰店';
            if (!acc[storeName]) {
                acc[storeName] = [];
            }
            acc[storeName].push({ ...cartItem, product });
        }
        return acc;
    }, {});

    // 渲染每个店铺的商品
    for (const storeName in groupedByStore) {
        const storeGroupEl = document.createElement('div');
        storeGroupEl.className = 'cart-store-group';

        const storeHeaderEl = document.createElement('div');
        storeHeaderEl.className = 'cart-store-header';
        storeHeaderEl.innerHTML = `<span>${storeName}</span>`;
        storeGroupEl.appendChild(storeHeaderEl);

        groupedByStore[storeName].forEach(item => {
            const isSelected = selectedCartItemIds.has(item.cartId);
            const itemEl = document.createElement('div');
            itemEl.className = `cart-item ${isSelected ? 'selected' : ''}`;
            itemEl.dataset.cartId = item.cartId;
            itemEl.innerHTML = `
                <div class="cart-item-selector"></div>
                <img src="${item.product.imageUrl}" class="cart-item-image">
                <div class="cart-item-details">
                    <p class="cart-item-title">${item.product.name}</p>
                    <p class="cart-item-price">¥${item.product.price.toFixed(2)}</p>
                </div>
            `;
            storeGroupEl.appendChild(itemEl);
        });
        container.appendChild(storeGroupEl);
    }
    
    updateCartCheckoutBar();
}
/**
 * [已修复] 启动一个全局定时器来管理所有倒计时显示
 */
function startGlobalCountdownTimer() {
    if (globalCountdownInterval) clearInterval(globalCountdownInterval);

    globalCountdownInterval = setInterval(() => {
        document.querySelectorAll('[data-countdown-type]').forEach(async (el) => {
            const eta = parseInt(el.dataset.eta, 10);
            const remaining = eta - Date.now();
            
            if (remaining > 0) {
                const minutes = Math.floor((remaining / 1000 / 60) % 60).toString().padStart(2, '0');
                const seconds = Math.floor((remaining / 1000) % 60).toString().padStart(2, '0');
                const hours = Math.floor(remaining / (1000 * 60 * 60));
                
                if (el.dataset.countdownType === 'cart') {
                    el.textContent = `支付剩余 ${minutes}:${seconds}`;
                } else if (el.dataset.countdownType === 'delivery') {
                    el.textContent = `预计送达: ${hours > 0 ? hours + '小时' : ''}${minutes}分${seconds}秒`;
                }
            } else {
                if (el.dataset.countdownType === 'cart') {
                    el.textContent = '已失效';
                } else if (el.dataset.countdownType === 'delivery') {
                    el.textContent = '已送达';
                    
                    // --- 核心修复逻辑开始 ---
                    // 查找当前倒计时元素所在的整个物流项目卡片
                    const logisticsItem = el.closest('.logistics-item');
                    if (logisticsItem) {
                        // 在卡片内找到顶部的状态标签
                        const statusHeader = logisticsItem.querySelector('.logistics-status');
                        if (statusHeader) {
                            // 将“待发货”更新为“已送达”
                            statusHeader.textContent = '已送达';
                        }
                    }
                    // --- 核心修复逻辑结束 ---
                    
                    const messageWrapper = el.closest('.message-wrapper');
                    if (messageWrapper) {
                        await notifyAiOfDelivery(messageWrapper.dataset.id);
                        el.removeAttribute('data-countdown-type');
                    }
                }
            }
        });
    }, 1000);
}
/**
 * [V3.1 | 已修复自定义商品] 当倒计时结束后，通知AI收货，并激活特殊物品效果
 */
async function notifyAiOfDelivery(messageId) {
    for (const char of db.characters) {
        const message = char.history.find(m => m.id === messageId);
        if (message && message.deliveryData && !message.deliveryData.delivered) {
            
            message.deliveryData.delivered = true;

            // --- 核心修改：使用 findProductById 查找所有商品 ---
            const product = findProductById(message.deliveryData.productId);
            // --- 修改结束 ---

            let effectDescriptionForAI = `你收到了 ${char.myName} 购买的 “${message.deliveryData.productName}”。`;

            if (product && product.description) {
                if (!char.activeEffects) char.activeEffects = [];

                if (product.description.includes('解除') || product.description.includes('恢复')) {
                    if (product.description.includes('口吃')) {
                        char.activeEffects = char.activeEffects.filter(eff => eff.type !== 'stutter');
                        showToast(`${char.remarkName} 的口吃被治好了！`);
                        effectDescriptionForAI += ` 这个物品解除了你身上的“口吃”效果。`;
                    }
                } else {
                    const funcMatch = product.description.match(/功能：(.*?)(?:效果持续|副作用|$)/);
                    const durationMatch = product.description.match(/效果持续：(\d+)轮对话/);
                    const sideEffectMatch = product.description.match(/副作用：(.*?)(?:副作用持续|$)/);
                    const sideEffectDurationMatch = product.description.match(/副作用持续：(\d+)轮对话/);

                    if (funcMatch && durationMatch) {
                        const effect = {
                            duration: parseInt(durationMatch[1], 10),
                            isSideEffect: false
                        };
                        const funcText = funcMatch[1].trim();
                        
                        effectDescriptionForAI += ` 这个物品的效果是：“${funcText}”，效果将持续 ${effect.duration} 轮对话。`;
                        if (sideEffectMatch) {
                             effectDescriptionForAI += ` 副作用是：“${sideEffectMatch[1].trim()}”。`;
                        }

                        if (funcText.includes('交换人设') || funcText.includes('角色互换')) effect.type = 'role_swap';
                        else if (funcText.includes('只能说真话')) effect.type = 'truth_only';
                        else if (funcText.includes('害羞') || funcText.includes('内向')) effect.type = 'shy';
                        else if (funcText.includes('失忆')) effect.type = 'amnesia';
                        else if (funcText.includes('动物化')) {
                            effect.type = 'animalization';
                            effect.animal = funcText.replace('动物化', '').trim() || '猫';
                        }
                        
                        if (sideEffectMatch && sideEffectDurationMatch) {
                            const sideEffect = { duration: parseInt(sideEffectDurationMatch[1], 10) };
                            const sideEffectText = sideEffectMatch[1].trim();
                            if (sideEffectText.includes('口吃')) sideEffect.type = 'stutter';
                            if (sideEffect.type) effect.sideEffect = sideEffect;
                        }
                        
                        if (effect.type) {
                            char.activeEffects.push(effect);
                            showToast(`${char.remarkName} 使用了特殊物品！`);
                        }
                    }
                }
            }
            
            const contextMessageContent = `[system: ${effectDescriptionForAI} 请根据你的人设对此作出回应，你的回应要体现出你已经开始受到影响。]`;
            
            const contextMessage = {
                id: `msg_delivery_receipt_${Date.now()}`,
                role: 'user',
                content: contextMessageContent,
                parts: [{ type: 'text', text: contextMessageContent }],
                timestamp: Date.now()
            };
            char.history.push(contextMessage);
            
            await saveData();
            
            if (currentChatId === char.id) {
                getAiReply();
            }
            
            break;
        }
    }
}

// --- 新增：世界书分类功能 ---
function setupWorldBookCategorySystem() {
    const addCategoryBtn = document.getElementById('add-world-book-category-btn');
    const addCategoryModal = document.getElementById('add-category-modal');
    const addCategoryForm = document.getElementById('add-category-form');
    const categoryNameInput = document.getElementById('category-name-input');
    const worldBookListContainer = document.getElementById('world-book-list-container');

    addCategoryBtn.addEventListener('click', () => {
        addCategoryForm.reset();
        addCategoryModal.classList.add('visible');
    });

    addCategoryForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const name = categoryNameInput.value.trim();
        if (name) {
            db.worldBookCategories.push({
                id: `cat_${Date.now()}`,
                name: name,
                isCollapsed: false
            });
            await saveData();
            renderWorldBookList();
            showToast(`分类“${name}”已创建`);
            addCategoryModal.classList.remove('visible');
        }
    });

    // 修改：合并处理所有分类的点击事件
    worldBookListContainer.addEventListener('click', async (e) => {
        const categoryHeader = e.target.closest('.category-header');
        if (!categoryHeader) return;

        const categoryWrapper = categoryHeader.parentElement;
        const categoryId = categoryWrapper.dataset.id;
        
        if (categoryId === 'uncategorized') {
            // --- 这是处理“未分类”折叠的新逻辑 ---
            db.uncategorizedCollapsed = !db.uncategorizedCollapsed;
            categoryWrapper.classList.toggle('collapsed', db.uncategorizedCollapsed);
            await saveData();
        } else {
            // 这是处理普通分类折叠的旧逻辑
            const category = db.worldBookCategories.find(cat => cat.id === categoryId);
            if (category) {
                category.isCollapsed = !category.isCollapsed;
                categoryWrapper.classList.toggle('collapsed', category.isCollapsed);
                await saveData();
            }
        }
    });
    
    // --- 新增：统一处理长按/右键菜单 ---
// 使用这段新代码替换旧的 handleLongPress 函数
const handleLongPress = (targetElement, clientX, clientY) => {
    const categoryId = targetElement.dataset.id;
    let menuItems = [];

    if (categoryId === 'uncategorized') {
        menuItems.push({
            label: '删除此分类中的所有条目',
            danger: true,
            action: async () => {
                if (confirm(`此操作将永久删除“未分类”中的所有世界书条目，确定吗？`)) {
                    db.worldBooks = db.worldBooks.filter(book => book.categoryId !== 'uncategorized');
                    await saveData();
                    renderWorldBookList();
                    showToast('“未分类”条目已全部删除');
                }
            }
        });
    } else {
        const category = db.worldBookCategories.find(cat => cat.id === categoryId);
        if (category) {
             menuItems.push({
                label: '删除分类及其中所有条目',
                danger: true,
                action: async () => {
                    const booksInCategoryCount = db.worldBooks.filter(book => book.categoryId === categoryId).length;
                    if (confirm(`此操作将永久删除分类“${category.name}”以及其中的 ${booksInCategoryCount} 个条目，此操作不可撤销。\n确定要继续吗？`)) {
                        // 过滤掉属于该分类的世界书条目
                        db.worldBooks = db.worldBooks.filter(book => book.categoryId !== categoryId);
                        
                        // 过滤掉该分类本身
                        db.worldBookCategories = db.worldBookCategories.filter(cat => cat.id !== categoryId);
                        
                        await saveData();
                        renderWorldBookList();
                        showToast(`分类“${category.name}”及其内容已删除`);
                    }
                }
            });
        }
    }
    if (menuItems.length > 0) {
        createContextMenu(menuItems, clientX, clientY);
    }
};
    
    worldBookListContainer.addEventListener('contextmenu', e => {
        const categoryWrapper = e.target.closest('.world-book-category');
        if (categoryWrapper) {
            e.preventDefault();
            handleLongPress(categoryWrapper, e.clientX, e.clientY);
        }
    });

    worldBookListContainer.addEventListener('touchstart', (e) => {
        const categoryWrapper = e.target.closest('.world-book-category');
        if (categoryWrapper) {
            longPressTimer = setTimeout(() => {
                const touch = e.touches[0];
                handleLongPress(categoryWrapper, touch.clientX, touch.clientY);
            }, 500);
        }
    });
    worldBookListContainer.addEventListener('touchend', () => clearTimeout(longPressTimer));
    worldBookListContainer.addEventListener('touchmove', () => clearTimeout(longPressTimer));
}
// 确保 db 对象中有分类数组
if (!db.worldBookCategories) {
    db.worldBookCategories = [];
}
// 为旧数据做兼容处理，将没有分类的世界书放入“未分类”
db.worldBooks.forEach(book => {
    if (book.categoryId === undefined) {
        book.categoryId = 'uncategorized';
    }
});
setupWorldBookCategorySystem();

// --- 修改 setupWorldBookApp 函数 ---
const originalSetupWorldBookApp = setupWorldBookApp;
// ▼▼▼ 用下面这个完整的代码块，替换掉你文件中旧的 setupWorldBookApp 函数 ▼▼▼
setupWorldBookApp = function() {
    originalSetupWorldBookApp(); // 调用原始函数以保留其功能

    // 【重要】此处的旧的、局部的 populateCategorySelect 函数定义已被删除

    // 监听打开编辑/创建世界书页面的事件
    addWorldBookBtn.addEventListener('click', () => {
        // 现在调用的是全局函数
        populateCategorySelect();
    });

    // 监听点击世界书条目的事件 (这段代码在之前的关键词功能中已更新，现在保持不变)
    worldBookListContainer.addEventListener('click', e => {
        const item = e.target.closest('.world-book-item');
        if (item) {
            const book = db.worldBooks.find(wb => wb.id === item.dataset.id);
            if(book) {
                // 加载所有字段
                currentEditingWorldBookId = book.id;
                worldBookIdInput.value = book.id;
                worldBookNameInput.value = book.name;
                worldBookContentInput.value = book.content;
                document.querySelector(`input[name="world-book-position"][value="${book.position}"]`).checked = true;
                
                // 现在调用的是全局函数
                populateCategorySelect(book.categoryId || 'uncategorized');
                
                document.getElementById('world-book-keywords').value = book.keywords || '';
                document.getElementById('world-book-always-active').checked = book.alwaysActive || false;
                document.getElementById('world-book-case-sensitive').checked = book.caseSensitive || false;
                
                switchScreen('edit-world-book-screen');
            }
        }
    });

    // 修改保存逻辑 (这段代码在之前的关键词功能中已更新，现在保持不变)
    editWorldBookForm.onsubmit = async function(e) {
        e.preventDefault();
        const selectedCategoryId = document.getElementById('world-book-category-select').value;
        const name = worldBookNameInput.value.trim();
        const content = worldBookContentInput.value.trim();
        const position = document.querySelector('input[name="world-book-position"]:checked').value;
        
        const keywords = document.getElementById('world-book-keywords').value.trim();
        const alwaysActive = document.getElementById('world-book-always-active').checked;
        const caseSensitive = document.getElementById('world-book-case-sensitive').checked;

        if (!name || !content) return showToast('名称和内容不能为空');
        
        const bookData = { name, content, position, categoryId: selectedCategoryId, keywords, alwaysActive, caseSensitive };

        if (currentEditingWorldBookId) {
            const book = db.worldBooks.find(wb => wb.id === currentEditingWorldBookId);
            if (book) Object.assign(book, bookData);
        } else {
            bookData.id = `wb_${Date.now()}`;
            db.worldBooks.push(bookData);
        }
        
        await saveData();
        showToast('世界书条目已保存');
        renderWorldBookList();
        switchScreen('world-book-screen');
    };
};


// --- 重写 renderWorldBookList 函数以支持分类 ---
const originalRenderWorldBookList = renderWorldBookList;
renderWorldBookList = function() {
    worldBookListContainer.innerHTML = '';
    const hasContent = db.worldBooks.length > 0 || db.worldBookCategories.length > 0;
    noWorldBooksPlaceholder.style.display = hasContent ? 'none' : 'block';

    const renderBooks = (books) => {
        let html = '';
        books.forEach(book => {
            html += `
                <li class="list-item world-book-item" data-id="${book.id}">
                    <div class="item-details" style="padding-left: 20px;">
                        <div class="item-name">${book.name}</div>
                        <div class="item-preview">${book.content}</div>
                    </div>
                </li>`;
        });
        return html;
    };
    
    // 1. 渲染所有分类及其下的世界书
    db.worldBookCategories.forEach(cat => {
        const categoryDiv = document.createElement('div');
        categoryDiv.className = 'world-book-category';
        categoryDiv.dataset.id = cat.id;
        if (cat.isCollapsed) {
            categoryDiv.classList.add('collapsed');
        }
        
        const booksInCategory = db.worldBooks.filter(b => b.categoryId === cat.id);
        
        categoryDiv.innerHTML = `
            <div class="category-header">
                <span class="category-name">${cat.name} (${booksInCategory.length})</span>
                <span class="category-toggle-icon">▼</span>
            </div>
            <ul class="category-book-list">
                ${renderBooks(booksInCategory)}
            </ul>
        `;
        worldBookListContainer.appendChild(categoryDiv);
    });

    // 2. 渲染未分类的世界书 (增加交互功能)
    const uncategorizedBooks = db.worldBooks.filter(b => b.categoryId === 'uncategorized');
    if(uncategorizedBooks.length > 0) {
        const uncategorizedDiv = document.createElement('div');
        uncategorizedDiv.className = 'world-book-category'; // 复用样式
        uncategorizedDiv.dataset.id = 'uncategorized'; // 添加特殊ID
        if (db.uncategorizedCollapsed) {
            uncategorizedDiv.classList.add('collapsed'); // 根据保存的状态添加折叠class
        }

        uncategorizedDiv.innerHTML = `
            <div class="category-header" id="uncategorized-header"> <!-- 添加ID便于事件监听 -->
                <span class="category-name">未分类 (${uncategorizedBooks.length})</span>
                <span class="category-toggle-icon">▼</span> <!-- 添加折叠图标 -->
            </div>
            <ul class="category-book-list">
                ${renderBooks(uncategorizedBooks)}
            </ul>
        `;
        worldBookListContainer.appendChild(uncategorizedDiv);
    }
};
        
        // v-- 在这里（init 函数外部）添加下面的新函数 --v
        // (用下面的长代码块，完整替换掉你文件中已有的那个简短的 setupMusicPlayer 函数)
        function parseLRC(lrcContent) {
            if (!lrcContent) return [];
            const lines = lrcContent.split('\n');
            const result = [];
            const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;

            for (const line of lines) {
                const match = line.match(timeRegex);
                if (match) {
                    const minutes = parseInt(match[1], 10);
                    const seconds = parseInt(match[2], 10);
                    const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
                    const time = minutes * 60 + seconds + milliseconds / 1000;
                    const text = line.replace(timeRegex, '').trim();
                    if (text) {
                        result.push({ time, text });
                    }
                }
            }
            return result.sort((a, b) => a.time - b.time);
        }

        function updateLyrics(currentTime) {
            if (!parsedLyrics.length) return;

            // 寻找当前应该高亮的歌词行索引
            let newLyricIndex = parsedLyrics.findIndex(line => line.time > currentTime) - 1;
            if (newLyricIndex === -2) { // 如果播放时间超过了最后一句歌词
                newLyricIndex = parsedLyrics.length - 1;
            }
            if (newLyricIndex < 0) {
                 newLyricIndex = 0;
            }

            if (newLyricIndex !== currentLyricIndex) {
                currentLyricIndex = newLyricIndex;
                const lyricsPanel = document.getElementById('lyrics-panel');
                const innerPanel = lyricsPanel.querySelector('.lyrics-panel-inner');
                const allLines = innerPanel.querySelectorAll('.lyric-line');

                allLines.forEach((line, index) => {
                    line.classList.toggle('active', index === currentLyricIndex);
                });

                // 计算滚动位置
                const activeLine = allLines[currentLyricIndex];
                if (activeLine) {
                    const panelHeight = lyricsPanel.clientHeight;
                    const activeLineOffset = activeLine.offsetTop + (activeLine.clientHeight / 2);
                    const scrollAmount = activeLineOffset - (panelHeight / 2);
                    innerPanel.style.transform = `translateY(-${scrollAmount}px)`;
                }
            }
        }
        function setupMusicPlayer() {
            // --- DOM 元素缓存 ---
            audioPlayer = document.getElementById('global-audio-player');
            const musicWidget = document.getElementById('music-app-widget');
            const musicModal = document.getElementById('music-player-modal');
            const playlistPanel = document.getElementById('music-playlist-panel');
            const addSongModal = document.getElementById('add-song-modal');
            const shareMusicModal = document.getElementById('share-music-modal');
            
            const playBtn = musicModal.querySelector('.play-btn');
            const nextBtn = musicModal.querySelector('.side-btn[title="下一首"]');
            const prevBtn = musicModal.querySelector('.side-btn[title="上一首"]');
            const loopBtn = musicModal.querySelector('.music-extra-controls button[title="循环模式"]');
            const openPlaylistBtn = musicModal.querySelector('.music-extra-controls button[title="歌曲列表"]');
            const openAddSongModalBtn = document.getElementById('open-add-song-modal-btn');
            const addSongForm = document.getElementById('add-song-form');
            const shareBtn = musicModal.querySelector('.share-btn');
            const confirmShareBtn = document.getElementById('confirm-music-share-btn');

            // --- 核心功能函数 ---
        // ▼▼▼ 请用这个【新的、完整的】函数替换掉您文件中旧的 updatePlayerUI 函数 ▼▼▼
const updatePlayerUI = () => {
    const song = db.playlist[currentSongIndex];
    const albumArt = musicModal.querySelector('.music-album-art');
    const songTitle = musicModal.querySelector('.song-title');
    const lyricsPanel = musicModal.querySelector('#lyrics-panel');
    const playBtn = musicModal.querySelector('.play-btn');

    // --- 核心修复：已经删除了所有对主屏幕小部件（widget）的无效操作 ---

    if (song) {
        const defaultArt = 'https://i.postimg.cc/nzP9sgxr/chan-125.png';
        albumArt.src = song.albumArt || defaultArt;
        songTitle.textContent = song.name;
        playBtn.innerHTML = isPlaying ? '<svg viewBox="0 0 24 24"><path d="M14,19H18V5H14M6,19H10V5H6V19Z"/></svg>' : '<svg viewBox="0 0 24 24"><path d="M8,5.14V19.14L19,12.14L8,5.14Z"/></svg>';
    } else {
        // 当没有歌曲时，只更新播放器弹窗内的标题
        songTitle.textContent = '歌曲名';
        if (lyricsPanel) {
            lyricsPanel.innerHTML = '<p class="lyric-line">歌词面板</p>';
        }
    }
};
// ▲▲▲ 替换到此结束 ▲▲▲

                                    const playSong = async (index) => {
                if (index < 0 || index >= db.playlist.length) {
                    isPlaying = false;
                    audioPlayer.pause();
                    currentSongIndex = -1;
                    updatePlayerUI();
                    return;
                }
                currentSongIndex = index;
                const song = db.playlist[index];
                audioPlayer.src = song.url;

                // --- 歌词处理 ---
                const lyricsPanel = document.getElementById('lyrics-panel');
                lyricsPanel.innerHTML = ''; // 清空旧歌词
                
                // ▼▼▼ 修正：移除了 let，直接给全局变量赋值 ▼▼▼
                parsedLyrics = [];
                currentLyricIndex = -1;
                // ▲▲▲ 修正结束 ▲▲▲

                if (song.lyrics) {
                    parsedLyrics = parseLRC(song.lyrics);
                }

                if (parsedLyrics.length > 0) {
                    const innerPanel = document.createElement('div');
                    innerPanel.className = 'lyrics-panel-inner';
                    parsedLyrics.forEach(line => {
                        const p = document.createElement('p');
                        p.className = 'lyric-line';
                        p.textContent = line.text;
                        innerPanel.appendChild(p);
                    });
                    lyricsPanel.appendChild(innerPanel);
                } else {
                    lyricsPanel.innerHTML = '<p class="lyric-line">暂无歌词</p>';
                }
                // --- 歌词处理结束 ---

                try {
                    await audioPlayer.play();
                    isPlaying = true;
                } catch (error) {
                    isPlaying = false;
                    showToast(`歌曲 ${song.name} 播放失败`);
                }
                updatePlayerUI();
                notifyAiOfSongChange();
            };

            const togglePlayPause = () => {
                if (isPlaying) {
                    audioPlayer.pause();
                    isPlaying = false;
                } else {
                    if (currentSongIndex === -1 && db.playlist.length > 0) {
                        playSong(0);
                    } else if (currentSongIndex !== -1) {
                        audioPlayer.play();
                        isPlaying = true;
                    } else {
                        showToast("播放列表为空, 请先添加歌曲");
                    }
                }
                updatePlayerUI();
            };
            
            const createShuffleOrder = () => {
                shuffleOrder = [...Array(db.playlist.length).keys()];
                for (let i = shuffleOrder.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffleOrder[i], shuffleOrder[j]] = [shuffleOrder[j], shuffleOrder[i]];
                }
            };

            const playNext = () => {
                if (db.playlist.length === 0) return;
                const mode = db.musicPlayerSettings.playbackMode;
                if (mode === 'shuffle') {
                    if (shuffleOrder.length === 0) createShuffleOrder();
                    const currentIndexInShuffle = shuffleOrder.indexOf(currentSongIndex);
                    const nextIndexInShuffle = (currentIndexInShuffle + 1) % shuffleOrder.length;
                    playSong(shuffleOrder[nextIndexInShuffle]);
                } else {
                    const nextIndex = (currentSongIndex + 1) % db.playlist.length;
                    playSong(nextIndex);
                }
            };
            
            const playPrev = () => {
                if (db.playlist.length === 0) return;
                const mode = db.musicPlayerSettings.playbackMode;
                if (mode === 'shuffle') {
                     if (shuffleOrder.length === 0) createShuffleOrder();
                    const currentIndexInShuffle = shuffleOrder.indexOf(currentSongIndex);
                    const prevIndexInShuffle = (currentIndexInShuffle - 1 + shuffleOrder.length) % shuffleOrder.length;
                    playSong(shuffleOrder[prevIndexInShuffle]);
                } else {
                    const prevIndex = (currentSongIndex - 1 + db.playlist.length) % db.playlist.length;
                    playSong(prevIndex);
                }
            };

            const changePlaybackMode = async () => {
                const modes = ['sequential', 'loop', 'shuffle'];
                const currentModeIndex = modes.indexOf(db.musicPlayerSettings.playbackMode);
                const nextModeIndex = (currentModeIndex + 1) % modes.length;
                db.musicPlayerSettings.playbackMode = modes[nextModeIndex];
                
                if (db.musicPlayerSettings.playbackMode === 'shuffle') createShuffleOrder();
                else shuffleOrder = [];

                let iconHtml = '', toastMessage = '';
                switch (db.musicPlayerSettings.playbackMode) {
                    case 'loop':
                        iconHtml = '<svg viewBox="0 0 24 24"><path d="M12,5V1L7,6L12,11V7A6,6 0 0,1 18,13A6,6 0 0,1 12,19A6,6 0 0,1 6,13H4A8,8 0 0,0 12,21A8,8 0 0,0 20,13A8,8 0 0,0 12,5Z"/></svg>';
                        toastMessage = '单曲循环';
                        audioPlayer.loop = true;
                        break;
                    case 'shuffle':
                        iconHtml = '<svg viewBox="0 0 24 24"><path d="M10.59,9.17L5.41,4L4,5.41L9.17,10.59L10.59,9.17M14.83,13.41L13.41,14.83L18,19.42L19.42,18L14.83,13.41M14.83,9.17L19.42,4.58L18,3.17L13.41,7.76L14.83,9.17M4.2,19.2L5.6,17.8L4.2,16.4L2.8,17.8L4.2,19.2M9.17,14.83L7.76,13.41L3.17,18L4.58,19.42L9.17,14.83Z"/></svg>';
                        toastMessage = '随机播放';
                        audioPlayer.loop = false;
                        break;
                    default:
                        iconHtml = '<svg viewBox="0 0 24 24"><path d="M17,17H7V14L3,18L7,22V19H19V13H17M7,7H17V10L21,6L17,2V5H5V11H7V7Z"/></svg>';
                        toastMessage = '顺序播放';
                        audioPlayer.loop = false;
                        break;
                }
                loopBtn.innerHTML = iconHtml;
                showToast(toastMessage);
                await saveData();
            };
            
            const renderPlaylistPanel = () => {
                const container = document.getElementById('playlist-container');
                container.innerHTML = '';
                if (db.playlist.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #888; padding: 20px;">播放列表是空的</p>';
                    return;
                }
                db.playlist.forEach((song, index) => {
                    const li = document.createElement('li');
                    li.className = 'list-item';
                    if(index === currentSongIndex) li.style.backgroundColor = 'var(--bg-color)';
                    li.style.cssText += 'display: flex; justify-content: space-between; align-items: center;';
                    li.innerHTML = `
                        <div class="item-details" style="cursor: pointer; flex-grow: 1;">
                            <div class="item-name">${song.name}</div>
                            <div class="item-preview">${song.artist}</div>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <button class="btn btn-small" data-index="${index}" style="padding: 4px 8px; background-color: #eee; color: #333;">词</button>
                            <button class="btn btn-danger btn-small" data-index="${index}" style="padding: 4px 10px;">移除</button>
                        </div>
                    `;
                    li.querySelector('.item-details').addEventListener('click', () => {
                        playSong(index);
                        playlistPanel.classList.remove('visible');
                    });
                    li.querySelector('button.btn-danger').addEventListener('click', async (e) => {
                        e.stopPropagation();
                        db.playlist.splice(index, 1);
                        if (currentSongIndex === index) { playNext(); } 
                        else if (currentSongIndex > index) { currentSongIndex--; }
                        await saveData();
                        renderPlaylistPanel();
                    });
                    li.querySelector('button[data-index]').addEventListener('click', async (e) => {
                         e.stopPropagation();
                         if(e.target.classList.contains('btn-danger')) return;
                         // 这是“词”按钮的逻辑
                         const lrcContent = await new Promise(resolve => {
                             const lrcInput = document.getElementById('lrc-upload-input');
                             const handler = (event) => {
                                 const file = event.target.files[0];
                                 if (file) {
                                     const reader = new FileReader();
                                     reader.onload = (re) => resolve(re.target.result);
                                     reader.readAsText(file);
                                 } else { resolve(null); }
                                 lrcInput.removeEventListener('change', handler);
                                 lrcInput.value = '';
                             };
                             lrcInput.addEventListener('change', handler);
                             lrcInput.click();
                         });
                         if (lrcContent !== null) {
                             db.playlist[index].lyrics = lrcContent;
                             await saveData();
                             showToast('歌词已关联！');
                             if (currentSongIndex === index) { playSong(index); }
                         }
                    });
                    container.appendChild(li);
                });
            };

                       const renderShareModal = () => {
                const container = document.getElementById('share-music-selection-list');
                container.innerHTML = '';
                const allChats = [...db.characters, ...db.groups];
                if (allChats.length === 0) {
                    container.innerHTML = '<li style="color:#888; text-align:center; padding: 20px 0;">没有可以分享的聊天</li>';
                    return;
                }
                allChats.forEach(chat => {
                    const li = document.createElement('li');
                    li.className = 'world-book-select-item'; // 复用现有样式
                    const isChecked = sharedWithChatIds.has(chat.id);
                    const name = chat.remarkName || chat.name;
                    const avatar = chat.avatar || 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
                    
                    li.innerHTML = `
                        <input type="checkbox" id="share-select-${chat.id}" value="${chat.id}" ${isChecked ? 'checked' : ''}>
                        <label for="share-select-${chat.id}" style="display: flex; align-items: center; width: 100%; gap: 10px;">
                            <img src="${avatar}" alt="${name}" style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover;">
                            <span>${name}</span>
                        </label>
                    `;
                    container.appendChild(li);
                });
            };
                    // ▼▼▼ 请用下面这【一整块】代码，完整替换掉你文件中旧的 sendMusicCard 函数 ▼▼▼
        const sendMusicCard = async (chatId, song) => {
            const chat = db.characters.find(c => c.id === chatId) || db.groups.find(g => g.id === chatId);
            if (!chat) return;

            // --- 核心修复：使用更可靠的方式来判断聊天类型 ---
            // 如果 chat 对象有 .me 属性, 说明是群聊；否则就是单聊。
            const myName = chat.me ? chat.me.nickname : chat.myName;
            const content = `[${myName}分享了音乐：${song.name} - ${song.artist}]`;

            const message = { 
                id: `msg_music_${Date.now()}`, 
                role: 'user', 
                content, 
                parts: [{ type: 'text', text: content }], 
                timestamp: Date.now(), 
                senderId: 'user_me' 
            };
            
            chat.history.push(message);
            // 只有当分享的目标就是当前打开的聊天时，才立即在界面上添加气泡
            if (currentChatId === chatId) {
                addMessageBubble(message);
            }
        };
        // ▲▲▲ 替换结束 ▲▲▲
            const notifyAiOfSongChange = async () => {
                if (currentSongIndex === -1 || sharedWithChatIds.size === 0) return;
                
                const song = db.playlist[currentSongIndex];
                const notificationContent = `[system-context-only: 我正在听的歌曲已切换为: ${song.name} - ${song.artist}。歌词: ${song.lyrics || '无'}]`;
                
                for (const chatId of sharedWithChatIds) {
                    const chat = db.characters.find(c => c.id === chatId) || db.groups.find(g => g.id === chatId);
                    if (chat) {
                        const message = { id: `msg_music_update_${Date.now()}`, role: 'user', content: notificationContent, parts: [{ type: 'text', text: notificationContent }], timestamp: Date.now(), senderId: 'user_me' };
                        chat.history.push(message);
                    }
                }
                await saveData();
            };

            // --- 事件监听器 ---
            musicWidget.addEventListener('click', () => musicModal.classList.add('visible'));
            playBtn.addEventListener('click', togglePlayPause);
            nextBtn.addEventListener('click', playNext);
            prevBtn.addEventListener('click', playPrev);
            loopBtn.addEventListener('click', changePlaybackMode);
            openPlaylistBtn.addEventListener('click', () => { renderPlaylistPanel(); playlistPanel.classList.add('visible'); });
            openAddSongModalBtn.addEventListener('click', () => { addSongForm.reset(); addSongModal.classList.add('visible'); });

            addSongForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const newSong = {
                    id: `song_${Date.now()}`,
                    url: document.getElementById('song-url-input').value.trim(),
                    name: document.getElementById('song-name-input').value.trim(),
                    artist: document.getElementById('song-artist-input').value.trim(),
                    albumArt: document.getElementById('song-album-art-input').value.trim(),
                    lyrics: document.getElementById('song-lyrics-input').value.trim()
                };
                if (!newSong.url.startsWith("https://files.catbox.moe/")) { showToast("请输入有效的Catbox链接"); return; }
                db.playlist.push(newSong);
                await saveData();
                showToast("歌曲已添加");
                addSongModal.classList.remove('visible');
                renderPlaylistPanel();
                if (currentSongIndex === -1) updatePlayerUI();
            });

            shareBtn.addEventListener('click', () => {
                if (currentSongIndex === -1) { showToast("请先播放一首歌曲再分享"); return; }
                renderShareModal();
                shareMusicModal.classList.add('visible');
            });
            
            confirmShareBtn.addEventListener('click', async () => {
                const checkboxes = shareMusicModal.querySelectorAll('input[type="checkbox"]');
                const song = db.playlist[currentSongIndex];
                let newShares = new Set();
                
                for (const cb of checkboxes) {
                    if (cb.checked) {
                        newShares.add(cb.value);
                        if (!sharedWithChatIds.has(cb.value)) await sendMusicCard(cb.value, song);
                    }
                }
                sharedWithChatIds = newShares;
                await notifyAiOfSongChange();
                
                shareMusicModal.classList.remove('visible');
                showToast("分享设置已更新");
            });

            audioPlayer.addEventListener('ended', () => { if (!audioPlayer.loop) playNext(); });
            audioPlayer.addEventListener('play', () => { isPlaying = true; updatePlayerUI(); });
            audioPlayer.addEventListener('pause', () => { isPlaying = false; updatePlayerUI(); });
            // ... a few lines above this ...
            audioPlayer.addEventListener('timeupdate', () => { updateLyrics(audioPlayer.currentTime); });

            [musicModal, playlistPanel, addSongModal, shareMusicModal].forEach(el => {
                el.addEventListener('click', (e) => { if (e.target === el) el.classList.remove('visible'); });
            });
            
            // 初始化
            updatePlayerUI();
            if (db.playlist.length > 0) playSong(0); // 尝试自动播放第一首
        }
// ^-- 新函数到此结束 --^
        function updateClock() {
            const now = new Date();
            const timeDisplay = document.getElementById('time-display');
            const dateDisplay = document.getElementById('date-display');
            if (timeDisplay) timeDisplay.textContent = `${pad(now.getHours())}:${pad(now.getMinutes())}`;
            if (dateDisplay) dateDisplay.textContent = `${now.getFullYear()}年${pad(now.getMonth() + 1)}月${pad(now.getDate())}日`;
        }

        // --- App Setup Functions ---
        // START: 新增主页翻页逻辑
function setupHomeScreenPaging() {
    const container = document.querySelector('.home-page-wrapper');
    const dots = document.querySelectorAll('.home-page-indicator .dot');
    let touchStartX = 0;
    let currentPageIndex = 0;

    function goToPage(index) {
        if (index < 0 || index > 1) return;
        container.style.transform = `translateX(-${index * 50}%)`;
        dots.forEach(dot => dot.classList.remove('active'));
        dots[index].classList.add('active');
        currentPageIndex = index;
    }

    document.getElementById('home-container').addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
    });

    document.getElementById('home-container').addEventListener('touchend', (e) => {
        const touchEndX = e.changedTouches[0].clientX;
        const diff = touchEndX - touchStartX;

        if (Math.abs(diff) > 50) { // 阈值，防止误触
            if (diff < 0 && currentPageIndex === 0) {
                goToPage(1); // Swipe left
            } else if (diff > 0 && currentPageIndex === 1) {
                goToPage(0); // Swipe right
            }
        }
    });

    dots.forEach(dot => {
        dot.addEventListener('click', () => goToPage(parseInt(dot.dataset.index)));
    });
}

// END: 新增主页翻页逻辑
// START: 新增渲染器应用核心逻辑
// START: 渲染器应用核心逻辑 (完整功能版)
function setupRendererApp() {
    let currentRendererCategoryId = 'all';

    // --- DOM元素缓存 ---
    const categoryList = document.getElementById('renderer-category-list');
    const ruleList = document.getElementById('renderer-rule-list');
    const noRulesPlaceholder = document.getElementById('no-renderer-rules-placeholder');
    const addCategoryBtn = document.getElementById('add-renderer-category-btn');
    const addRuleBtn = document.getElementById('add-renderer-rule-btn');
    const importRulesBtn = document.getElementById('import-renderer-rules-btn');
    const importRulesInput = document.getElementById('renderer-import-input');

    const categoryModal = document.getElementById('renderer-category-modal');
    const categoryForm = document.getElementById('renderer-category-form');
    const categoryNameInput = document.getElementById('renderer-category-name');

    const ruleModal = document.getElementById('edit-renderer-rule-modal');
    const ruleForm = document.getElementById('edit-renderer-rule-form');
    const ruleIdInput = document.getElementById('renderer-rule-id');
    const ruleNameInput = document.getElementById('renderer-rule-name');
    const ruleRegexInput = document.getElementById('renderer-rule-regex');
    const ruleHtmlInput = document.getElementById('renderer-rule-html');
    const ruleTrimInput = document.getElementById('renderer-rule-trim');
    const ruleEnabledCheckbox = document.getElementById('renderer-rule-enabled');
    const charBindingList = document.getElementById('renderer-char-binding-list');

    // --- 核心渲染函数 ---
function updateRendererPreview() {
    const regexInput = document.getElementById('renderer-rule-regex').value;
    const htmlInput = document.getElementById('renderer-rule-html').value;
    const testInput = document.getElementById('renderer-rule-test-input').value;
    const previewOutput = document.getElementById('renderer-rule-preview-output');
    
    if (!testInput) {
        previewOutput.innerHTML = '<span style="color: #aaa;">请输入测试文本以查看效果</span>';
        return;
    }

    if (!regexInput || !htmlInput) {
        previewOutput.textContent = testInput; // 没有规则可应用，显示原文
        return;
    }
    
    try {
        const flags = Array.from(document.querySelectorAll('.regex-flags-container input:checked')).map(cb => cb.value).join('');
        const regex = new RegExp(regexInput, flags);
        
        // 测试正则表达式是否匹配
        if (regex.test(testInput)) {
            // 必须重置 lastIndex 才能保证全局匹配 (g flag) 的正确性
            regex.lastIndex = 0; 
            previewOutput.innerHTML = testInput.replace(regex, htmlInput);
        } else {
            previewOutput.textContent = testInput; // 没有匹配，显示原文
        }
    } catch (error) {
        // 正则表达式语法无效，提供错误反馈
        previewOutput.innerHTML = `<span style="color: red; font-weight: bold;">正则表达式错误:</span><br><span style="font-family: monospace;">${error.message}</span>`;
    }
}
    function renderRendererCategories() {
        categoryList.innerHTML = '';
        const allItem = document.createElement('li');
        allItem.className = 'list-item';
        allItem.dataset.id = 'all';
        allItem.textContent = '全部';
        if (currentRendererCategoryId === 'all') allItem.classList.add('active');
        categoryList.appendChild(allItem);

        (db.rendererCategories || []).forEach(cat => {
            const li = document.createElement('li');
            li.className = 'list-item';
            li.dataset.id = cat.id;
            li.textContent = cat.name;
            if (cat.id === currentRendererCategoryId) li.classList.add('active');
            categoryList.appendChild(li);
        });
    }

    function renderRendererRules() {
        ruleList.innerHTML = '';
        const rulesToRender = (currentRendererCategoryId === 'all')
            ? (db.renderers || [])
            : (db.renderers || []).filter(r => r.categoryId === currentRendererCategoryId);

        noRulesPlaceholder.style.display = rulesToRender.length === 0 ? 'block' : 'none';

        rulesToRender.forEach(rule => {
            const li = document.createElement('li');
            li.className = 'list-item';
            li.dataset.id = rule.id;
            li.innerHTML = `
                <div class="item-details">
                    <div class="rule-name">${rule.name} ${rule.enabled ? '' : '(已禁用)'}</div>
                    <div class="rule-regex">${rule.regex}</div>
                </div>
            `;
            ruleList.appendChild(li);
        });
    }// START: 新增渲染器分类删除功能
// --- 分类列表长按/右键删除 ---
categoryList.addEventListener('contextmenu', e => {
    e.preventDefault();
    const item = e.target.closest('.list-item');
    if (item && item.dataset.id !== 'all') { // "全部" 分类不能删除
        const categoryId = item.dataset.id;
        const category = db.rendererCategories.find(c => c.id === categoryId);
        if (category) {
            createContextMenu([
                {
                    label: `删除分类 "${category.name}"`,
                    danger: true,
                    action: async () => {
                        if (confirm(`确定要删除分类 "${category.name}" 吗？\n该分类下的所有规则将被移动到未分类状态。`)) {
                            // 1. 将该分类下的规则 categoryId 设为 null
                            db.renderers.forEach(rule => {
                                if (rule.categoryId === categoryId) {
                                    rule.categoryId = null;
                                }
                            });
                            // 2. 从分类列表中删除该分类
                            db.rendererCategories = db.rendererCategories.filter(c => c.id !== categoryId);
                            
                            await saveData();
                            
                            // 3. 刷新UI
                            currentRendererCategoryId = 'all'; // 返回“全部”视图
                            renderRendererCategories();
                            renderRendererRules();
                            showToast('分类已删除');
                        }
                    }
                }
            ], e.clientX, e.clientY);
        }
    }
});

categoryList.addEventListener('touchstart', (e) => {
    const item = e.target.closest('.list-item');
    if (item && item.dataset.id !== 'all') {
        longPressTimer = setTimeout(() => {
            const touch = e.touches[0];
            const categoryId = item.dataset.id;
            const category = db.rendererCategories.find(c => c.id === categoryId);
            if(category) {
                // 此处代码与 contextmenu 重复，可以封装成一个函数，但为简单起见直接复制
                 createContextMenu([
                    {
                        label: `删除分类 "${category.name}"`,
                        danger: true,
                        action: async () => {
                            if (confirm(`确定要删除分类 "${category.name}" 吗？\n该分类下的所有规则将被移动到未分类状态。`)) {
                                db.renderers.forEach(rule => {
                                    if (rule.categoryId === categoryId) {
                                        rule.categoryId = null;
                                    }
                                });
                                db.rendererCategories = db.rendererCategories.filter(c => c.id !== categoryId);
                                await saveData();
                                currentRendererCategoryId = 'all';
                                renderRendererCategories();
                                renderRendererRules();
                                showToast('分类已删除');
                            }
                        }
                    }
                ], touch.clientX, touch.clientY);
            }
        }, 500);
    }
});
categoryList.addEventListener('touchend', () => clearTimeout(longPressTimer));
categoryList.addEventListener('touchmove', () => clearTimeout(longPressTimer));
// END: 新增渲染器分类删除功能

    // --- 弹窗与表单处理 ---
    
    // 用这个新版本替换旧的 openRuleModal 函数
    function openRuleModal(ruleId = null) {
        ruleForm.reset();
        charBindingList.innerHTML = '';

        db.characters.forEach(char => {
            const item = document.createElement('div');
            item.className = 'char-binding-item';
            item.innerHTML = `<input type="checkbox" id="bind-${char.id}" value="${char.id}"><label for="bind-${char.id}">${char.remarkName}</label>`;
            charBindingList.appendChild(item);
        });

        if (ruleId) { // 编辑模式
            const rule = db.renderers.find(r => r.id === ruleId);
            if (rule) {
                ruleIdInput.value = rule.id;
                ruleNameInput.value = rule.name;
                ruleRegexInput.value = rule.regex;
                ruleHtmlInput.value = rule.html;
                ruleTrimInput.value = (rule.trimStrings || []).join('\n');
                ruleEnabledCheckbox.checked = rule.enabled;
                document.getElementById('renderer-rule-priority').value = rule.priority || 50; // 加载优先级

                document.querySelectorAll('input[name="renderer-scope"]').forEach(cb => {
                    cb.checked = (rule.scope || []).includes(cb.value);
                });
                ['g', 'i', 's'].forEach(flag => {
                    const cb = document.getElementById(`regex-flag-${flag}`);
                    if(cb) cb.checked = (rule.flags || []).includes(flag);
                });
                (rule.characterIds || []).forEach(charId => {
                    const checkbox = document.getElementById(`bind-${charId}`);
                    if (checkbox) checkbox.checked = true;
                });
            }
        } else { // 创建模式
            ruleIdInput.value = '';
            ruleEnabledCheckbox.checked = true;
            document.getElementById('regex-flag-g').checked = true;
            document.querySelector('input[name="renderer-scope"][value="ai"]').checked = true;
            document.getElementById('renderer-rule-priority').value = 50; // 新规则的默认优先级
        }
        
        // 重置并绑定实时预览功能
        document.getElementById('renderer-rule-test-input').value = '';
        updateRendererPreview(); // 打开时立即更新一次预览
        
        ['renderer-rule-regex', 'renderer-rule-html', 'renderer-rule-test-input'].forEach(id => {
            document.getElementById(id).addEventListener('input', updateRendererPreview);
        });
        document.querySelectorAll('.regex-flags-container input').forEach(el => {
            el.addEventListener('change', updateRendererPreview);
        });
        
        ruleModal.classList.add('visible');
    }
    ruleForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const id = ruleIdInput.value;
        const selectedCharIds = Array.from(charBindingList.querySelectorAll('input:checked')).map(cb => cb.value);
        const selectedScopes = Array.from(document.querySelectorAll('input[name="renderer-scope"]:checked')).map(cb => cb.value);
        const selectedFlags = Array.from(document.querySelectorAll('.regex-flags-container input:checked')).map(cb => cb.value);

        const ruleData = {
            name: ruleNameInput.value.trim(),
            regex: ruleRegexInput.value.trim(),
            html: ruleHtmlInput.value,
            trimStrings: ruleTrimInput.value.split('\n').map(s => s.trim()).filter(Boolean),
            enabled: ruleEnabledCheckbox.checked,
            scope: selectedScopes,
            flags: selectedFlags,
            characterIds: selectedCharIds,
            categoryId: currentRendererCategoryId === 'all' ? ((db.rendererCategories && db.rendererCategories[0]?.id) || null) : currentRendererCategoryId,
            priority: parseInt(document.getElementById('renderer-rule-priority').value, 10) || 50 // 保存优先级
        };
        
        if (!ruleData.name || !ruleData.regex) return showToast('规则名称和正则表达式不能为空！');

        if (id) {
            const index = db.renderers.findIndex(r => r.id === id);
            if (index > -1) db.renderers[index] = { ...db.renderers[index], ...ruleData };
        } else {
            ruleData.id = `rend_rule_${Date.now()}`;
            db.renderers.push(ruleData);
        }

        await saveData();
        showToast('渲染规则已保存！');
        renderRendererRules();
        ruleModal.classList.remove('visible');
    });

    categoryForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const name = categoryNameInput.value.trim();
        if (name && !(db.rendererCategories || []).some(c => c.name === name)) {
            const newCategory = { id: `rend_cat_${Date.now()}`, name };
            db.rendererCategories.push(newCategory);
            await saveData();
            currentRendererCategoryId = newCategory.id;
            renderRendererCategories();
            renderRendererRules();
            showToast(`分类“${name}”已创建`);
        }
        categoryModal.classList.remove('visible');
    });
    
    // --- 导入功能 ---
    importRulesBtn.addEventListener('click', () => importRulesInput.click());
    importRulesInput.addEventListener('change', async (e) => {
        const files = e.target.files;
        if (!files.length) return;

        let importedCount = 0;
        for (const file of files) {
            try {
                const content = await file.text();
                const data = JSON.parse(content);

                // 创建分类
                const categoryName = data.scriptName;
                let category = (db.rendererCategories || []).find(c => c.name === categoryName);
                if (!category) {
                    category = { id: `rend_cat_${Date.now()}_${importedCount}`, name: categoryName };
                    db.rendererCategories.push(category);
                }

                // 解析Regex
                const regexMatch = data.findRegex.match(/^\/(.*)\/([gimsuy]*)$/);
                const regex = regexMatch ? regexMatch[1] : data.findRegex;
                const flags = regexMatch ? [...new Set(regexMatch[2].split(''))] : ['g'];
                
                // 映射Scope
                const scopeMap = { 1: 'user', 2: 'ai' };
                const scope = (data.placement || [2]).map(p => scopeMap[p]).filter(Boolean);

                const newRule = {
                    id: `rend_rule_import_${Date.now()}_${importedCount}`,
                    name: data.scriptName,
                    regex: regex,
                    html: data.replaceString.replace(/^```html\n|```$/g, ''),
                    trimStrings: data.trimStrings || [],
                    enabled: !data.disabled,
                    scope: scope,
                    flags: flags,
                    characterIds: [], // 默认不绑定任何角色
                    categoryId: category.id
                };
                db.renderers.push(newRule);
                importedCount++;
            } catch (err) {
                console.error('导入渲染器规则失败:', err);
                showToast(`文件 ${file.name} 导入失败`);
            }
        }

        if (importedCount > 0) {
            await saveData();
            renderRendererCategories();
            renderRendererRules();
            showToast(`成功导入 ${importedCount} 条规则！`);
        }
        importRulesInput.value = null; // 清空以便下次选择
    });

    // --- 事件监听 ---
    document.querySelector('.app-icon[data-target="renderer-screen"]').addEventListener('click', () => {
        currentRendererCategoryId = 'all';
        renderRendererCategories();
        renderRendererRules();
    });
    addCategoryBtn.addEventListener('click', () => { categoryForm.reset(); categoryModal.classList.add('visible'); });
    addRuleBtn.addEventListener('click', () => openRuleModal(null));
    categoryList.addEventListener('click', e => {
        const item = e.target.closest('.list-item');
        if (item) {
            currentRendererCategoryId = item.dataset.id;
            renderRendererCategories();
            renderRendererRules();
        }
    });
    ruleList.addEventListener('click', e => {
        const item = e.target.closest('.list-item');
        if (item) openRuleModal(item.dataset.id);
    });
    ruleList.addEventListener('contextmenu', e => {
        e.preventDefault();
        const item = e.target.closest('.list-item');
        if (item) {
            const ruleId = item.dataset.id;
            createContextMenu([
                {
                    label: '删除规则',
                    danger: true,
                    action: async () => {
                        if (confirm('确定要删除这条规则吗？')) {
                            db.renderers = db.renderers.filter(r => r.id !== ruleId);
                            await saveData();
                            renderRendererRules();
                            showToast('规则已删除');
                        }
                    }
                }
            ], e.clientX, e.clientY);
        }
    });
}
// END: 渲染器应用核心逻辑

        
                // START: 修改后的 setupHomeScreen 函数
function setupHomeScreen() {
    const getIcon = (id) => db.customIcons[id] || defaultIcons[id]?.url;
    
    // --- 渲染第一页 ---
   const homeScreen1 = document.getElementById('home-screen');
homeScreen1.innerHTML = `
    <!-- ▼▼▼ 核心修改：用一个新的 div 包裹所有内容（除了Dock栏） ▼▼▼ -->
    <div id="home-screen-content">
        <div class="time-widget">
            <div class="date" id="date-display"></div>
            <div class="time" id="time-display"></div>
        </div>
        <div class="home-profile-header">
            <div class="home-hero"></div>
            <div class="home-avatar-wrap">
                <img id="home-profile-avatar" alt="头像" src="https://i.postimg.cc/GtbTnxhP/o-o-1.jpg">
            </div>
            <div class="home-info-card">
                <h2 class="home-profile-name">点击设置昵称</h2>
                <p class="home-profile-signature">点击设置个性签名</p>
            </div>
        </div>
        <div class="main-content-area">
            <div class="left-column">
                <div class="contact-widgets-column">
                 <div class="contact-widget" id="custom-widget-1" data-widget-id="widget1">
                    <img src="https://i.ibb.co/6r11fGg/avatar1.png" alt="自定义组件1">
                    <span>自定义</span>
                </div>
                <div class="contact-widget avatar-right" id="custom-widget-2" data-widget-id="widget2">
                    <img src="https://i.ibb.co/d28n82t/avatar2.png" alt="自定义组件2">
                    <span>自定义</span>
                </div>
                </div>
                <div class="secondary-apps-dock">
                     <a href="#" class="app-icon" data-target="customize-screen"><img src="${getIcon('customize-screen')}" alt="自定义" class="icon-img"><span class="app-name">${defaultIcons['customize-screen'].name}</span></a>
                     <a href="#" class="app-icon" data-target="wallpaper-screen"><img src="${getIcon('wallpaper-screen')}" alt="壁纸" class="icon-img"><span class="app-name">${defaultIcons['wallpaper-screen'].name}</span></a>
                </div>
            </div>
            <div class="right-column">
                <div class="small-app-grid">
                    <a href="#" class="app-icon" data-target="chat-list-screen"><img src="${getIcon('chat-list-screen')}" alt="404" class="icon-img"><span class="app-name">${defaultIcons['chat-list-screen'].name}</span></a>
                    <a href="#" class="app-icon" data-target="api-settings-screen"><img src="${getIcon('api-settings-screen')}" alt="API" class="icon-img"><span class="app-name">${defaultIcons['api-settings-screen'].name}</span></a>
                    <a href="#" class="app-icon" data-target="world-book-screen"><img src="${getIcon('world-book-screen')}" alt="世界书" class="icon-img"><span class="app-name">${defaultIcons['world-book-screen'].name}</span></a>
                    <a href="#" class="app-icon" data-target="tutorial-screen"><img src="${getIcon('tutorial-screen')}" alt="教程" class="icon-img"><span class="app-name">${defaultIcons['tutorial-screen'].name}</span></a>
                </div>
                <div id="music-app-widget" class="record-player-widget">
                    <div class="record-sleeve" id="custom-record-sleeve"></div>
                    <div class="vinyl-record">
                        <div class="record-label" id="custom-record-label"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 包裹结束 ▲▲▲ -->

    <!-- Dock栏现在被放在了滚动区域的外面，与它平级 -->
    <div class="dock">
        <a href="#" class="app-icon" id="day-mode-btn"><img src="${getIcon('day-mode-btn')}" alt="日间" class="icon-img"></a>
        <a href="#" class="app-icon" id="night-mode-btn"><img src="${getIcon('night-mode-btn')}" alt="夜间" class="icon-img"></a>
        <a href="#" class="app-icon" id="fullscreen-btn" title="全屏模式">
            <img src="data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23444444'%3E%3Cpath d='M5,5H10V7H7V10H5V5M14,5H19V10H17V7H14V5M17,14H19V19H14V17H17V14M10,17H7V14H5V19H10V17Z' /%3E%3C/svg%3E" alt="全屏" class="icon-img">
        </a>
        <a href="#" class="app-icon" data-target="font-settings-screen"><img src="${getIcon('font-settings-screen')}" alt="字体" class="icon-img"></a>
        <a href="#" class="app-icon" data-target="ai-space-home-screen"><img src="${getIcon('ai-character-select-screen')}" alt="AI空间" class="icon-img"></a>
    </div>`;
    // --- 渲染第二页 ---
    const homeScreen2 = document.getElementById('home-screen-2');
 homeScreen2.innerHTML = `
        <div class="app-grid" style="margin-top: 80px;">
            <a href="#" class="app-icon" data-target="renderer-screen">
                <img src="${getIcon('renderer-screen')}" alt="渲染器" class="icon-img">
                <span class="app-name">${defaultIcons['renderer-screen'].name}</span>
            </a>
            <a href="#" class="app-icon" data-target="mall-screen">
                <img src="${getIcon('mall-screen')}" alt="商城" class="icon-img">
                <span class="app-name">${defaultIcons['mall-screen'].name}</span>
            </a>
            <a href="#" class="app-icon" id="soul-bond-app-icon">
                <img src="${getIcon('soul-bond-app-icon')}" alt="心灵羁绊" class="icon-img">
                <span class="app-name">${defaultIcons['soul-bond-app-icon'].name}</span>
            </a>
        </div>`;
    // --- 绑定事件和应用设置 ---
    document.getElementById('custom-record-label').style.backgroundImage = `url('${getIcon('record-label')}')`;
    document.getElementById('custom-record-sleeve').style.backgroundImage = `url('${getIcon('record-sleeve')}')`;

    updateClock();
    applyWallpaper(db.wallpaper, homeScreen1);
    applyWallpaper(db.wallpaper2, homeScreen2);
    applyHomeScreenMode(db.homeScreenMode);

    const widget1Data = db.customWidgets.find(w => w.id === 'widget1');
    const widget2Data = db.customWidgets.find(w => w.id === 'widget2');
    const widget1El = document.getElementById('custom-widget-1');
    const widget2El = document.getElementById('custom-widget-2');

    if (widget1Data && widget1El) {
        widget1El.querySelector('img').src = widget1Data.imageUrl;
        widget1El.querySelector('span').textContent = widget1Data.text;
    }
    if (widget2Data && widget2El) {
        widget2El.querySelector('img').src = widget2Data.imageUrl;
        widget2El.querySelector('span').textContent = widget2Data.text;
    }

    document.getElementById('day-mode-btn')?.addEventListener('click', (e) => { e.preventDefault(); applyHomeScreenMode('day'); });
    document.getElementById('night-mode-btn')?.addEventListener('click', (e) => { e.preventDefault(); applyHomeScreenMode('night'); });
    document.querySelector('[data-target="world-book-screen"]').addEventListener('click', renderWorldBookList);
    document.querySelector('[data-target="customize-screen"]').addEventListener('click', renderCustomizeForm);
    document.querySelector('[data-target="tutorial-screen"]').addEventListener('click', renderTutorialContent);
       
    setupHomeScreenProfileEditor(); 
}
// END: 修改后的 setupHomeScreen 函数
        

function applyWallpaper(url, element) {
            if (element) {
                element.style.backgroundImage = `url(${url})`;
            }
        }
// --- 新代码开始 ---
        function applyAiSpaceWallpaper(url) {
            const aiSpaceContent = document.querySelector('#ai-space-home-screen .content');
            if (aiSpaceContent) {
                if (url) {
                    aiSpaceContent.style.backgroundImage = `url(${url})`;
                    aiSpaceContent.style.backgroundSize = 'cover';
                    aiSpaceContent.style.backgroundPosition = 'center';
                    aiSpaceContent.style.backgroundColor = ''; // 清除默认背景色
                } else {
                    // 如果没有设置壁纸，则恢复默认样式
                    aiSpaceContent.style.backgroundImage = 'none';
                    aiSpaceContent.style.backgroundColor = '#f5f5f5';
                }
            }
        }
// --- 新代码结束 ---
        async function applyHomeScreenMode(mode) {
            if (mode === 'day') {
                homeScreen.classList.add('day-mode');
            } else {
                homeScreen.classList.remove('day-mode');
            }
            db.homeScreenMode = mode;
            await saveData();
        }

  function setupCustomizeApp() {
    // 监听“自定义”App图标的点击事件，以便在每次进入时都重新渲染最新的图标网格
    document.querySelector('[data-target="customize-screen"]').addEventListener('click', renderCustomizeForm);
}
// ▼▼▼ 在 renderCustomizeForm 函数的上方，添加这个新函数 ▼▼▼
function applyLayoutPreference() {
    const phoneScreen = document.querySelector('.phone-screen');
    if (db.useWechatLayout) {
        phoneScreen.classList.add('wechat-layout-active');
    } else {
        phoneScreen.classList.remove('wechat-layout-active');
    }
}
// ▲▲▲ 添加结束 ▲▲▲
// --- 新代码开始 (完整版，无任何省略) ---
function renderCustomizeForm() {
    const form = document.getElementById('customize-form');
    form.innerHTML = ''; // 清空所有内容，准备重新构建

    // ================== 第1部分：主屏幕图标自定义 ==================
    const mainGridTitleHtml = `
        <div style="padding: 0 15px;">
            <p style="font-weight: 600; font-size: 16px; color: var(--secondary-color); margin-bottom: 5px;">主屏幕及组件图标</p>
        </div>
    `;
    form.insertAdjacentHTML('beforeend', mainGridTitleHtml);

    const mainGridContainer = document.createElement('div');
    mainGridContainer.className = 'app-grid';
    mainGridContainer.style.gridTemplateColumns = 'repeat(4, 1fr)';
    mainGridContainer.style.padding = '20px';
    mainGridContainer.style.gap = '15px';
    mainGridContainer.style.marginTop = '10px';
    
    Object.entries(defaultIcons).forEach(([id, { name, url }]) => {
        if (id.startsWith('ai-space-')) return; // 排除AI手机的图标
        const currentIcon = db.customIcons[id] || url;
        const iconHTML = `
            <a href="#" class="app-icon" data-icon-id="${id}">
                <img src="${currentIcon}" alt="${name}" class="icon-img">
                <span class="app-name">${name || '模式切换'}</span>
            </a>`;
        mainGridContainer.innerHTML += iconHTML;
    });
    form.appendChild(mainGridContainer);

    // ================== 第2部分：AI手机图标自定义 ==================
    const aiSpaceGridTitleHtml = `
        <hr style="border:none; border-top:1px solid #f0f0f0; margin: 25px 0;">
        <div style="padding: 0 15px;">
            <p style="font-weight: 600; font-size: 16px; color: var(--secondary-color); margin-bottom: 5px;">AI手机图标</p>
        </div>
    `;
    form.insertAdjacentHTML('beforeend', aiSpaceGridTitleHtml);

    const aiSpaceGridContainer = document.createElement('div');
    aiSpaceGridContainer.className = 'app-grid';
    aiSpaceGridContainer.style.gridTemplateColumns = 'repeat(4, 1fr)';
    aiSpaceGridContainer.style.padding = '20px';
    aiSpaceGridContainer.style.gap = '15px';
    aiSpaceGridContainer.style.marginTop = '10px';

    Object.entries(defaultIcons).forEach(([id, { name, icon }]) => {
        if (!id.startsWith('ai-space-')) return; // 只选择AI手机的图标
        const currentIcon = db.customIcons[id] || icon;
        const iconHTML = `
            <a href="#" class="app-icon" data-icon-id="${id}">
                <img src="${currentIcon}" alt="${name}" class="icon-img">
                <span class="app-name">${name}</span>
            </a>`;
        aiSpaceGridContainer.innerHTML += iconHTML;
    });
    form.appendChild(aiSpaceGridContainer);

    // ================== 第3部分：全局CSS和布局切换 ==================
    const globalCssHtml = `
        <hr style="border:none; border-top:1px solid #f0f0f0; margin: 25px 0;">
        <div class="global-css-section" style="padding: 0 15px;">
             <p style="font-weight: 600; font-size: 16px; color: var(--secondary-color); margin-bottom: 5px;">全局样式 (CSS) 自定义</p>
             <p style="font-size: 13px; color: #888; margin-top: 0; margin-bottom: 15px;">这里的代码会覆盖整个应用的默认样式，请谨慎使用。</p>
            <textarea id="global-custom-css" rows="12" placeholder="/* 示例：修改聊天气泡颜色 */\n\n.message-bubble.sent {\n  background: linear-gradient(to right, #6a11cb 0%, #2575fc 100%);\n}" style="width: 100%; border-radius: 10px; padding: 10px; border: 2px solid #fce4ec; font-family: monospace; font-size: 13px;"></textarea>
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button type="button" class="btn btn-primary" id="apply-global-css-btn" style="flex: 1;">应用样式</button>
                <button type="button" class="btn btn-secondary" id="export-global-css-btn" style="flex: 1; margin-bottom: 0;">导出</button>
                <label for="import-css-input" class="btn btn-neutral" style="flex: 1; margin-bottom: 0;">导入</label>
            </div>
        </div>
        <input type="file" id="import-css-input" accept=".yu, .css, .txt" style="display: none;">`;
    form.insertAdjacentHTML('beforeend', globalCssHtml);

    const layoutToggleHtml = `
        <hr style="border:none; border-top:1px solid #f0f0f0; margin: 25px 0;">
        <div class="icon-custom-item" style="padding: 0 15px;">
            <div class="icon-details">
                <p>切换为微信输入栏布局</p>
                <p style="font-size:12px; color:#888; font-weight:normal;">启用后，聊天输入栏将变为左侧“+”号，右侧发送的样式。</p>
            </div>
            <input type="checkbox" id="toggle-wechat-layout" style="width: auto; height: 24px;">
        </div>`;
    form.insertAdjacentHTML('beforeend', layoutToggleHtml);

    // ================== 第4部分：为所有功能重新绑定事件 ==================
    
    const modal = document.getElementById('customize-icon-modal');
    const fileInput = document.getElementById('customize-icon-upload');
    const modalTitle = document.getElementById('customize-icon-modal-title');
    let currentEditingIconId = null;

    form.addEventListener('click', (e) => {
        const iconLink = e.target.closest('.app-icon[data-icon-id]');
        if (iconLink) {
            e.preventDefault();
            currentEditingIconId = iconLink.dataset.iconId;
            const iconName = iconLink.querySelector('.app-name').textContent;
            modalTitle.textContent = `自定义 "${iconName}"`;
            modal.classList.add('visible');
        }
    });
    
    document.getElementById('icon-edit-from-url-btn').onclick = async () => {
        const newUrl = prompt('请输入新的图标URL:');
        if (newUrl && newUrl.trim()) {
            db.customIcons[currentEditingIconId] = newUrl.trim();
            await saveData();
            renderCustomizeForm();
            setupHomeScreen();
            renderAiSpaceHomeScreen();
            showToast('图标已更新');
        }
        modal.classList.remove('visible');
    };
    document.getElementById('icon-edit-from-local-btn').onclick = () => {
        fileInput.click();
        modal.classList.remove('visible');
    };
    document.getElementById('icon-edit-reset-btn').onclick = async () => {
        delete db.customIcons[currentEditingIconId];
        await saveData();
        renderCustomizeForm();
        setupHomeScreen();
        renderAiSpaceHomeScreen();
        showToast('图标已恢复默认');
        modal.classList.remove('visible');
    };
    document.getElementById('icon-edit-cancel-btn').onclick = () => modal.classList.remove('visible');
    modal.onclick = (e) => { if (e.target === modal) modal.classList.remove('visible'); };
    fileInput.onchange = async (e) => {
        const file = e.target.files[0];
        if (file && currentEditingIconId) {
            try {
                const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 200, maxHeight: 200 });
                db.customIcons[currentEditingIconId] = compressedUrl;
                await saveData();
                renderCustomizeForm();
                setupHomeScreen();
                renderAiSpaceHomeScreen();
                showToast('图标已更新');
            } catch (error) { showToast('图片处理失败'); }
        }
        e.target.value = null;
    };

    const cssTextarea = document.getElementById('global-custom-css');
    if (cssTextarea && db.globalCustomCss) {
        cssTextarea.value = db.globalCustomCss;
    }
    document.getElementById('apply-global-css-btn').addEventListener('click', async () => {
        const cssCode = cssTextarea.value;
        db.globalCustomCss = cssCode;
        applyGlobalCss(cssCode);
        await saveData();
        showToast('全局样式已应用并保存！');
    });
    document.getElementById('export-global-css-btn').addEventListener('click', () => {
        const cssCode = cssTextarea.value;
        if (!cssCode.trim()) { showToast('没有内容可导出。'); return; }
        const blob = new Blob([cssCode], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `饭版小手机_美化样式.yu`;
        document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    });
    document.getElementById('import-css-input').addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            cssTextarea.value = e.target.result;
            showToast('样式已导入，请点击“应用样式”来保存并查看效果。');
        };
        reader.readAsText(file);
        event.target.value = null;
    });

    const layoutToggle = document.getElementById('toggle-wechat-layout');
    layoutToggle.checked = db.useWechatLayout || false;
    layoutToggle.addEventListener('change', async (e) => {
        db.useWechatLayout = e.target.checked;
        await saveData();
        applyLayoutPreference();
        showToast('布局已切换，重新进入聊天室生效');
    });
}
// --- 新代码结束 ---

// --- 新代码结束 ---

        function setupTutorialApp() {
            tutorialContentArea.addEventListener('click', (e) => {
                const header = e.target.closest('.tutorial-header');
                if (header) {
                    header.parentElement.classList.toggle('open');
                }
            });
        }
        let loadingBtn = false

        function renderTutorialContent() {
        
            const tutorials = [
                {title: '写在前面', imageUrls: ['https://i.postimg.cc/7PgyMG9S/image.jpg']},
                {
                    title: '软件介绍',
                    imageUrls: ['https://i.postimg.cc/VvsJRh6q/IMG-20250713-162647.jpg', 'https://i.postimg.cc/8P5FfxxD/IMG-20250713-162702.jpg', 'https://i.postimg.cc/3r94R3Sn/IMG-20250713-162712.jpg']
                },
                {
                    title: '404',
                    imageUrls: ['https://i.postimg.cc/x8scFPJW/IMG-20250713-162756.jpg', 'https://i.postimg.cc/pX6mfqtj/IMG-20250713-162809.jpg', 'https://i.postimg.cc/YScjV00q/IMG-20250713-162819.jpg', 'https://i.postimg.cc/13VfJw9j/IMG-20250713-162828.jpg']
                },
                {title: '404-群聊', imageUrls: ['https://i.postimg.cc/X7LSmRTJ/404.jpg']}
            ];
            tutorialContentArea.innerHTML = '';
            tutorials.forEach(tutorial => {
                const item = document.createElement('div');
                item.className = 'tutorial-item';
                const imagesHtml = tutorial.imageUrls.map(url => `<img src="${url}" alt="${tutorial.title}教程图片">`).join('');
                item.innerHTML = `<div class="tutorial-header">${tutorial.title}</div><div class="tutorial-content">${imagesHtml}</div>`;
                tutorialContentArea.appendChild(item);
            });
    // --- ▼▼▼ 新增功能按钮的核心代码 ▼▼▼ ---

    // 1. 创建“自动更新”按钮
    const updateAppBtn = document.createElement('button');
    updateAppBtn.className = 'btn btn-secondary';
    updateAppBtn.textContent = '检查更新 (刷新)';
    updateAppBtn.style.marginTop = '25px';

    updateAppBtn.addEventListener('click', () => {
        showToast('正在检查更新并刷新页面...');
        // 对于PWA，Service Worker的更新通常在下次访问时激活
        // 最简单可靠的“更新”就是强制刷新页面，让浏览器重新拉取资源
        setTimeout(() => {
            window.location.reload(true); // 参数 true 表示强制从服务器加载
        }, 1500);
    });
    
    // 2. 创建“删除所有数据”按钮
    const deleteAllDataBtn = document.createElement('button');
    deleteAllDataBtn.className = 'btn btn-danger';
    deleteAllDataBtn.textContent = '删除所有数据';
    deleteAllDataBtn.style.marginTop = '15px';

    deleteAllDataBtn.addEventListener('click', async () => {
        // 使用自定义的弹窗进行确认
        const confirmed = await showCustomConfirm(
            '确定要删除所有数据吗？',
            '该操作不可撤销，本地的所有角色、聊天记录、设置和预设都将被永久清除。',
            '确定删除',
            '先去备份'
        );

        if (confirmed) {
            showToast('正在清除所有数据...');
            try {
                // 清空 Dexie 数据库
                await dataStorage.clearAll();
                
                // 清空 localStorage (用于预设等)
                localStorage.clear();

                // 清空动态数据库
                if (window.AppDB_Moments) {
                    await window.AppDB_Moments.delete();
                }

                // 2秒后刷新页面
                setTimeout(() => {
                    window.location.reload(true);
                }, 2000);

            } catch (error) {
                console.error("清除数据失败:", error);
                showToast('清除数据时发生错误，请查看控制台。');
            }
        } else {
            // 用户点击了“先去备份”，什么也不做
            showToast('操作已取消');
        }
    });

    // 3. 创建一个分隔线
    const hr = document.createElement('hr');
    hr.style.border = 'none';
    hr.style.borderTop = '1px solid #eee';
    hr.style.margin = '25px 0';
    
    // 4. 将所有新元素添加到教程内容区域的末尾
    tutorialContentArea.appendChild(hr);
    tutorialContentArea.appendChild(updateAppBtn);
    tutorialContentArea.appendChild(deleteAllDataBtn);

    // 5. 新增：自定义的确认弹窗函数
    async function showCustomConfirm(title, text, confirmText, cancelText) {
        return new Promise(resolve => {
            // 移除可能存在的旧弹窗
            const oldConfirm = document.getElementById('custom-confirm-overlay');
            if (oldConfirm) oldConfirm.remove();

            const overlay = document.createElement('div');
            overlay.id = 'custom-confirm-overlay';
            overlay.className = 'modal-overlay visible';
            overlay.style.zIndex = '99999'; // 确保在最顶层

            overlay.innerHTML = `
                <div class="modal-window">
                    <h3>${title}</h3>
                    <p style="text-align: center; color: #666; font-size: 14px; line-height: 1.6;">${text}</p>
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <button id="custom-confirm-cancel" class="btn btn-neutral" style="flex: 1;">${cancelText}</button>
                        <button id="custom-confirm-ok" class="btn btn-danger" style="flex: 1;">${confirmText}</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);

            const okBtn = document.getElementById('custom-confirm-ok');
            const cancelBtn = document.getElementById('custom-confirm-cancel');

            okBtn.onclick = () => {
                overlay.remove();
                resolve(true);
            };

            cancelBtn.onclick = () => {
                overlay.remove();
                resolve(false);
            };
        });
    }

    // --- ▲▲▲ 新增代码结束 ▲▲▲


            const backupDataBtn = document.createElement('button');
            backupDataBtn.className = 'btn btn-primary';
            backupDataBtn.textContent = '备份数据';
            backupDataBtn.disabled = loadingBtn

         backupDataBtn.addEventListener('click', async () => {
                if(loadingBtn) return;
                loadingBtn = true;
                try {
                    // 新增：收集所有localStorage中的预设数据
                    const localStorageData = {};
                    const presetKeys = ['fontPresets', 'apiPresets', 'bubblePresets', 'myPersonaPresets'];
                    presetKeys.forEach(key => {
                        const data = localStorage.getItem(key);
                        if (data) {
                            localStorageData[key] = data;
                        }
                    });

                    if (window.AppDB_Moments && window.AppDB_Moments.moments) {
                        db.momentsData = await window.AppDB_Moments.moments.toArray();
                    }

                    // 新增：创建一个包含所有数据的备份对象
                    const backupObject = {
                        dbData: db,
                        localStorageData: localStorageData
                    };

                    const jsonString = JSON.stringify(backupObject);
                    const dataBlob = new Blob([jsonString]);
                    const compressionStream = new CompressionStream('gzip');
                    const compressedStream = dataBlob.stream().pipeThrough(compressionStream);
                    const compressedBlob = await new Response(compressedStream).blob();
                    const url = URL.createObjectURL(compressedBlob);
                    const a = document.createElement('a');
                    const now = new Date();
                    a.href = url;
                    a.download = `章鱼喷墨_备份数据_${now.toISOString().slice(0, 10)}_${now.toTimeString().slice(0, 8).replace(/:/g, '')}.ee`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    if (db.momentsData) {
                        delete db.momentsData;
                    }

                    loadingBtn = false;
                    showToast('完整数据备份成功！');
                } catch (e) {
                    showToast(`导出失败, 发生错误: ${e.message}`);
                }
            });

            const importDataBtn = document.createElement('label');
            importDataBtn.className = 'btn btn-neutral';
            importDataBtn.textContent = '导入数据';
            importDataBtn.style.marginTop = '15px';
            importDataBtn.style.display = 'block';
            importDataBtn.disabled = loadingBtn;
            importDataBtn.setAttribute('for', 'import-data-input');
            
            // --- 修改：更新导入逻辑 ---
            document.querySelector('#import-data-input').addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                if(confirm('此操作将覆盖当前所有数据（包括聊天、设置和预设）。此操作不可撤销。确定要继续吗？')){
                    try {
                        const decompressionStream = new DecompressionStream('gzip');
                        const decompressedStream = file.stream().pipeThrough(decompressionStream);
                        const jsonString = await new Response(decompressedStream).text();
                        const importedObject = JSON.parse(jsonString);

                        let dbDataToSave;

                        // 新增：检查是新格式还是旧格式的备份
                        if (importedObject.dbData) { // 新格式
                            // 恢复localStorage中的预设
                            if (importedObject.localStorageData) {
                                Object.entries(importedObject.localStorageData).forEach(([key, value]) => {
                                    localStorage.setItem(key, value);
                                });
                            }
                            dbDataToSave = importedObject.dbData;
                        } else { // 旧格式
                            dbDataToSave = importedObject;
                            showToast('提示：正在导入旧版备份，部分设置（如预设）可能不会被恢复。');
                        }

                        // 清空旧数据
                        await dataStorage.clearAll();
                        if (window.AppDB_Moments && window.AppDB_Moments.moments) {
                            await window.AppDB_Moments.moments.clear();
                        }
                        
                        // 恢复动态数据
                        if (dbDataToSave.momentsData && Array.isArray(dbDataToSave.momentsData)) {
                             if (window.AppDB_Moments && window.AppDB_Moments.moments) {
                                await window.AppDB_Moments.moments.bulkPut(dbDataToSave.momentsData);
                            }
                            delete dbDataToSave.momentsData;
                        }
                        
                        // 保存新的主数据
                        await saveData(dbDataToSave);
                        showToast(`数据已成功恢复。应用即将刷新。`);
                        setTimeout(() => window.location.reload(), 1500);

                    } catch (error) {
                        console.error("导入失败:", error);
                        showToast(`导入或解析文件时发生错误: ${error.message}`);
                    } finally {
                        event.target.value = null;
                    }
                } else {
                    event.target.value = null;
                }
            });

            tutorialContentArea.appendChild(backupDataBtn);
            tutorialContentArea.appendChild(importDataBtn);
        }
// ===============================================================
// START: 角色卡导入功能 (粘贴到 setupChatListScreen 函数上方)
// ===============================================================
/**
         * 在当前聊天记录中执行搜索
         * @param {string} query - 搜索关键词
         */
        async function performSearch(query) {
            showToast('正在搜索...');
            const results = [];
            const lowerCaseQuery = query.toLowerCase();
            
            // 直接获取当前聊天对象
            const chat = (currentChatType === 'private') 
                ? db.characters.find(c => c.id === currentChatId)
                : db.groups.find(g => g.id === currentChatId);

            if (!chat) {
                showToast('错误：找不到当前聊天');
                return;
            }

            const history = await dataStorage.getChatMessages(chat.id, currentChatType);
            
            for (const message of history) {
                let contentToSearch = message.content || '';
                // 剥离消息外壳，只搜索纯文本内容
                const contentMatch = contentToSearch.match(/\[.*?的消息：([\s\S]+?)\]/);
                if (contentMatch) {
                    contentToSearch = contentMatch[1];
                }
                
                if (contentToSearch.toLowerCase().includes(lowerCaseQuery)) {
                    results.push({
                        message,
                        chatId: chat.id,
                        chatType: currentChatType,
                        chatName: chat.name || chat.remarkName,
                        chatAvatar: chat.avatar
                    });
                }
            }
            
            renderSearchResults(results, query);
            switchScreen('search-results-screen');
        }
/**
 * 处理从文件输入框选择的角色卡文件
 * @param {Event} event - 文件输入框的 change 事件
 */
function handleCardImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    if (file.name.endsWith('.png')) {
        handlePngImport(file);
    } else if (file.name.endsWith('.json')) {
        handleJsonImport(file);
    } else {
        showToast('不支持的文件格式，请选择 .png 或 .json 文件');
    }

    // 清空输入框，以便下次可以选择相同的文件
    event.target.value = null;
}

/**
 * 处理 .json 格式的角色卡
 * @param {File} file - 用户选择的 .json 文件
 */
function handleJsonImport(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const cardData = JSON.parse(e.target.result);
            // JSON 文件没有内嵌图片，使用默认头像
            const defaultAvatar = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
            createCharacterFromCard(cardData, defaultAvatar);
        } catch (error) {
            console.error("JSON 解析失败:", error);
            showToast(`导入失败: ${error.message}`);
        }
    };
    reader.readAsText(file);
}

/**
 * 处理 .png 格式的角色卡 (包含图片和内置数据) - 已修正乱码问题
 * @param {File} file - 用户选择的 .png 文件
 */
function handlePngImport(file) {
    // 第一步：读取图片本身作为头像
    const imageReader = new FileReader();
    imageReader.readAsDataURL(file);
    imageReader.onload = (e) => {
        const avatarUrl = e.target.result;

        // 第二步：读取文件内容以提取内置的JSON数据
        const dataReader = new FileReader();
        dataReader.onload = (e) => {
            try {
                const text = e.target.result;
                // SillyTavern 将 Base64 编码的 JSON 存储在 "chara" 关键词之后
                const keyword = "chara";
                const startIndex = text.indexOf(keyword);

                if (startIndex === -1) {
                    throw new Error("PNG卡片中未找到 'chara' 数据块。");
                }

                // 提取可能是 Base64 的长字符串
                const b64Regex = /[A-Za-z0-9+/=]{200,}/g; // 查找足够长的Base64字符串
                const textAfterKeyword = text.substring(startIndex + keyword.length);
                const match = textAfterKeyword.match(b64Regex);

                if (!match) {
                    throw new Error("无法从PNG中提取角色数据。");
                }

                // ▼▼▼ 核心修正：使用 TextDecoder 处理 UTF-8 编码 ▼▼▼
                const b64Decoded = atob(match[0]); // Base64解码为二进制字符串
                // 将二进制字符串转换为Uint8Array字节数组
                const uint8Array = new Uint8Array(b64Decoded.length).map((_, i) => b64Decoded.charCodeAt(i));
                // 使用UTF-8解码器将字节数组转换为正确的字符串
                const utf8String = new TextDecoder('utf-8').decode(uint8Array);
                const cardData = JSON.parse(utf8String);
                // ▲▲▲ 修正结束 ▲▲▲

                createCharacterFromCard(cardData, avatarUrl);
            } catch (error) {
                console.error("PNG 数据提取或解析失败:", error);
                showToast(`导入失败: ${error.message}`);
            }
        };
        // 注意：这里仍然使用 'latin1' 来读取原始字节流，这是正确的
        dataReader.readAsText(file, 'latin1');
    };
}
/**
 * 根据解析出的角色卡数据和头像URL，创建新角色和世界书（已更新分类和条目拆分逻辑）
 * @param {object} cardData - 从 .json 或 .png 中解析出的角色数据对象
 * @param {string} avatarUrl - 角色的头像 Data URL 或默认 URL
 */
async function createCharacterFromCard(cardData, avatarUrl) {
    // 兼容不同版本的角色卡格式 (v2/v3)
    const data = cardData.data || cardData;
    if (!data || !data.name) {
        showToast('导入失败：角色卡格式不正确，缺少名称。');
        return;
    }

    // 用于收集所有新创建的世界书条目ID，以便关联到角色
    const worldBookIds = [];

    // ▼▼▼ 核心修改逻辑开始 ▼▼▼
    if (data.character_book && data.character_book.entries && data.character_book.entries.length > 0) {
        
        // 1. 为该角色创建一个新的世界书分类
        const categoryName = `${data.name} - 世界书`;
        const newCategory = {
            id: `cat_${Date.now()}`,
            name: categoryName,
            isCollapsed: false // 默认展开
        };
        db.worldBookCategories.push(newCategory);
        showToast(`已自动创建分类: "${categoryName}"`);

        let entryCounter = 1; // 用于命名拆分后的条目

        // 2. 遍历所有世界书条目
        for (const entry of data.character_book.entries) {
            if (!entry.content) continue;

            // 3. 使用 "---" 分割内容，并清理空数据
            const contentParts = entry.content.split('---')
                .map(part => part.trim()) // 去除每个部分前后的空格
                .filter(part => part.length > 0); // 过滤掉空的部分

            // 4. 为每个分割后的内容部分创建独立的世界书条目
            for (const partContent of contentParts) {
                const newWorldBook = {
                    id: `wb_${Date.now()}_${entryCounter}`,
                    name: `${data.name} - 条目 ${entryCounter}`, // 自动命名
                    content: partContent,
                    position: 'before', // 默认前置注入
                    categoryId: newCategory.id // 关联到新创建的分类
                };
                db.worldBooks.push(newWorldBook);
                worldBookIds.push(newWorldBook.id); // 收集ID用于角色关联
                entryCounter++;
            }
        }
    }
    // ▲▲▲ 核心修改逻辑结束 ▲▲▲

    // 创建新角色对象
    const newChar = {
        id: `char_${Date.now()}`,
        realName: data.name,
        isOfflineMode: false,
        remarkName: data.name,
        persona: data.description || '',
        avatar: avatarUrl,
        myName: '我',
        myPersona: '',
        myAvatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg',
        theme: 'white_pink',
        maxMemory: 10,
        chatBg: '',
        history: [],
        diaries: [],
        messageCountSinceLastDiary: 0,
        memories: [],
        isPinned: false,
        status: '在线',
        worldBookIds: worldBookIds, // 关联所有新创建的世界书条目ID
        useCustomBubbleCss: false,
        customBubbleCss: '',
        pendingMessages: [],
        aiProactiveChatEnabled: false, // 新增
    aiProactiveChatDelay: 0,      // 新增
        isBlockedByUser: false,
        isBlockedByAi: false,
        userBlockTimestamp: null,
        aiBlockTimestamp: null,
        blockEndTime: null,
    };
if (data.character_book && data.character_book.entries && data.character_book.entries.length > 0) {
        const regexEntries = data.character_book.entries.filter(entry => entry.use_regex && entry.keys.length > 0 && entry.content);
        if (regexEntries.length > 0) {
            // 为该角色创建一个渲染器分类
            const categoryName = data.name;
            let category = db.rendererCategories.find(c => c.name === categoryName);
            if (!category) {
                category = {
                    id: `rend_cat_${Date.now()}`,
                    name: categoryName
                };
                db.rendererCategories.push(category);
            }

            regexEntries.forEach((entry, index) => {
                const newRule = {
                    id: `rend_rule_${Date.now()}_${index}`,
                    name: entry.comment || `${data.name} 规则 ${index + 1}`,
                    regex: entry.keys.join('|'),
                    html: entry.content,
                    characterIds: [newChar.id], // 自动绑定到新创建的角色
                    enabled: entry.enabled,
                    categoryId: category.id
                };
                db.renderers.push(newRule);
            });
            showToast(`已为“${data.name}”自动导入 ${regexEntries.length} 条渲染规则！`);
        }
    }
    // 添加到数据库并保存
    db.characters.push(newChar);
    await saveData();

    // 刷新UI
    renderChatList();
    showToast(`角色“${newChar.remarkName}”已成功导入！`);
}

/**
         * 设置聊天内搜索功能
         */
        function setupSearchInChat() {
            // 使用事件委托，因为两个设置面板里都有搜索按钮
            document.body.addEventListener('click', (e) => {
                if (e.target.id === 'search-history-btn' || e.target.id === 'search-group-history-btn') {
                    // 关闭设置侧边栏
                    const openSidebar = document.querySelector('.settings-sidebar.open');
                    if (openSidebar) {
                        openSidebar.classList.remove('open');
                    }
                    searchModal.classList.add('visible');
                    searchModalInput.focus();
                }
            });

            // 搜索表单提交
            searchModalForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const query = searchModalInput.value.trim();
                if (query) {
                    performSearch(query);
                    searchModal.classList.remove('visible');
                    searchModalForm.reset();
                }
            });

            // 点击弹窗外部关闭
            searchModal.addEventListener('click', (e) => {
                if (e.target === searchModal) {
                    searchModal.classList.remove('visible');
                }
            });

            // 为搜索结果列表添加点击事件委托
            searchResultsList.addEventListener('click', (e) => {
                const resultItem = e.target.closest('.search-result-item');
                if (resultItem) {
                    const { chatId, chatType, messageId } = resultItem.dataset;
                    // 设置一个全局变量，用于告知 openChatRoom 需要跳转
                    window.targetMessageId = messageId; 
                    openChatRoom(chatId, chatType);
                }
            });
        }

        // --- Chat List & Chat Room ---
        function setupChatListScreen() {
            renderChatList();
            addChatBtn.addEventListener('click', () => {
                addCharModal.classList.add('visible');
                addCharForm.reset();
            });
            chatListContainer.addEventListener('click', (e) => {
                const chatItem = e.target.closest('.chat-item');
                if (chatItem) {
                    currentChatId = chatItem.dataset.id;
                    currentChatType = chatItem.dataset.type;
                    openChatRoom(currentChatId, currentChatType);
                }
            });
            chatListContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const chatItem = e.target.closest('.chat-item');
                if (!chatItem) return;
                handleChatListLongPress(chatItem.dataset.id, chatItem.dataset.type, e.clientX, e.clientY);
            });
            chatListContainer.addEventListener('touchstart', (e) => {
                const chatItem = e.target.closest('.chat-item');
                if (!chatItem) return;
                longPressTimer = setTimeout(() => {
                    const touch = e.touches[0];
                    handleChatListLongPress(chatItem.dataset.id, chatItem.dataset.type, touch.clientX, touch.clientY);
                }, 400);
            });
            chatListContainer.addEventListener('touchend', () => clearTimeout(longPressTimer));
            chatListContainer.addEventListener('touchmove', () => clearTimeout(longPressTimer));
        }
/**
         * 在当前聊天记录中执行搜索
         * @param {string} query - 搜索关键词
         */
        async function performSearch(query) {
            showToast('正在搜索...');
            const results = [];
            const lowerCaseQuery = query.toLowerCase();
            
            // 直接获取当前聊天对象
            const chat = (currentChatType === 'private') 
                ? db.characters.find(c => c.id === currentChatId)
                : db.groups.find(g => g.id === currentChatId);

            if (!chat) {
                showToast('错误：找不到当前聊天');
                return;
            }

            const history = await dataStorage.getChatMessages(chat.id, currentChatType);
            
            for (const message of history) {
                let contentToSearch = message.content || '';
                // 剥离消息外壳，只搜索纯文本内容
                const contentMatch = contentToSearch.match(/\[.*?的消息：([\s\S]+?)\]/);
                if (contentMatch) {
                    contentToSearch = contentMatch[1];
                }
                
                if (contentToSearch.toLowerCase().includes(lowerCaseQuery)) {
                    results.push({
                        message,
                        chatId: chat.id,
                        chatType: currentChatType,
                        chatName: chat.name || chat.remarkName,
                        chatAvatar: chat.avatar
                    });
                }
            }
            
            renderSearchResults(results, query);
            switchScreen('search-results-screen');
        }

        /**
         * 渲染搜索结果列表
         * @param {Array} results - 搜索到的结果数组
         * @param {string} query - 原始搜索关键词，用于高亮
         */
        function renderSearchResults(results, query) {
            searchResultsList.innerHTML = '';
            noResultsPlaceholder.style.display = results.length === 0 ? 'block' : 'none';

            // 按时间倒序排列结果
            results.sort((a, b) => b.message.timestamp - a.message.timestamp);

            const regex = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');

            for (const result of results) {
                const li = document.createElement('li');
                li.className = 'list-item search-result-item';
                li.dataset.chatId = result.chatId;
                li.dataset.chatType = result.chatType;
                li.dataset.messageId = result.message.id;

                let previewText = result.message.content || '';
                const match = previewText.match(/\[.*?的消息：([\s\S]+?)\]/);
                if (match) {
                    previewText = match[1];
                }

                // 高亮关键词
                const highlightedText = escapeHTML(previewText).replace(regex, (match) => `<span class="highlight">${match}</span>`);
                
                const date = new Date(result.message.timestamp);
                const dateString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;

                li.innerHTML = `
                    <img src="${result.chatAvatar}" alt="${result.chatName}" class="chat-avatar ${result.chatType === 'group' ? 'group-avatar' : ''}">
                    <div class="item-details">
                        <div class="item-details-row">
                            <span class="item-name">${result.chatName}</span>
                            <span class="item-preview">${dateString}</span>
                        </div>
                        <div class="item-preview search-preview">${highlightedText}</div>
                    </div>
                `;
                searchResultsList.appendChild(li);
            }
        }
        function handleChatListLongPress(chatId, chatType, x, y) {
            clearTimeout(longPressTimer);
            const chatItem = (chatType === 'private') ? db.characters.find(c => c.id === chatId) : db.groups.find(g => g.id === chatId);
            if (!chatItem) return;
            const itemName = chatType === 'private' ? chatItem.remarkName : chatItem.name;
            const menuItems = [{
                label: chatItem.isPinned ? '取消置顶' : '置顶聊天',
                action: async () => {
                    chatItem.isPinned = !chatItem.isPinned;
                    await saveData();
                    renderChatList();
                }
            }, {
                label: '删除聊天',
                danger: true,
                action: async () => {
                    if (confirm(`确定要删除与“${itemName}”的聊天记录吗？此操作不可恢复。`)) {
                        if (chatType === 'private') {
                            db.characters = db.characters.filter(c => c.id !== chatId);
                        } else {
                            db.groups = db.groups.filter(g => g.id !== chatId);
                        }
                        await saveData();
                        renderChatList();
                        showToast('聊天已删除');
                    }
                }
            }];
            createContextMenu(menuItems, x, y);
        }

        function renderChatList() {
            chatListContainer.innerHTML = '';
            const allChats = [...db.characters.map(c => ({...c, type: 'private'})), ...db.groups.map(g => ({
                ...g,
                type: 'group'
            }))];
            noChatsPlaceholder.style.display = (db.characters.length + db.groups.length) === 0 ? 'block' : 'none';
            const sortedChats = allChats.sort((a, b) => {
                if (a.isPinned !== b.isPinned) return a.isPinned ? -1 : 1;
                const lastMsgTimeA = a.history && a.history.length > 0 ? a.history[a.history.length - 1].timestamp : 0;
                const lastMsgTimeB = b.history && b.history.length > 0 ? b.history[b.history.length - 1].timestamp : 0;
                return lastMsgTimeB - lastMsgTimeA;
            });
            sortedChats.forEach(chat => {
                let lastMessageText = '开始聊天吧...';
                if (chat.history && chat.history.length > 0) {
                const invisibleRegex = /\[[\s\S]*?(?:接收|退回)[\s\S]*?的转账\]|\[[\s\S]*?更新状态为：[\s\S]*?\]|\[[\s\S]*?已接收礼物\]|\[system:[\s\S]*?\]|\[system-context-only:[\s\S]*?\]|\[[\s\S]*?邀请[\s\S]*?加入了群聊\]|\[[\s\S]*?修改群名为：[\s\S]*?\]|\[system-display:[\s\S]*?\]/;
                    const visibleHistory = chat.history.filter(msg => !invisibleRegex.test(msg.content));
                    if (visibleHistory.length > 0) {
                        const lastMsg = visibleHistory[visibleHistory.length - 1];
                        const urlRegex = /^(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg)|data:image\/[a-z]+;base64,)/i;
                        const imageRecogRegex = /\[.*?发来了一张图片：\]/
                        const voiceRegex = /\[.*?的语音：.*?\]/;
                        const photoVideoRegex = /\[.*?发来的照片\/视频：.*?\]/;
                        const transferRegex = /\[.*?的转账：.*?元.*?\]|\[.*?给你转账：.*?元.*?\]|\[.*?向.*?转账：.*?元.*?\]/;
                        const stickerRegex = /\[.*?的表情包：.*?\]|\[.*?发送的表情包：.*?\]/;
                        const giftRegex = /\[.*?送来的礼物：.*?\]|\[.*?向.*?送来了礼物：.*?\]/;



                        if (giftRegex.test(lastMsg.content)) {
                            lastMessageText = '[礼物]';
                        } else if (stickerRegex.test(lastMsg.content)) {
                            lastMessageText = '[表情包]';
                        } else if (voiceRegex.test(lastMsg.content)) {
                            lastMessageText = '[语音]';
                        } else if (photoVideoRegex.test(lastMsg.content)) {
                            lastMessageText = '[照片/视频]';
                        } else if (transferRegex.test(lastMsg.content)) {
                            lastMessageText = '[转账]';
                        } else if (imageRecogRegex.test(lastMsg.content) || (lastMsg.parts && lastMsg.parts.some(p => p.type === 'image'))) {
                            lastMessageText = '[图片]';
                        }else if ((lastMsg.parts && lastMsg.parts.some(p => p.type === 'html'))) {
                            lastMessageText = '[互动]';
                        } else {
                            const textMatch = lastMsg.content.match(/\[.*?的消息：([\s\S]+)\]/);
                            let text = textMatch ? textMatch[1].trim() : lastMsg.content.trim();
                            lastMessageText = urlRegex.test(text) ? '[图片]' : text;
                        }
                    } else {
                        const lastEverMsg = chat.history[chat.history.length - 1];
                        const inviteRegex = /\[(.*?)邀请(.*?)加入了群聊\]/;
                        const renameRegex = /\[.*?修改群名为：.*?\]/;
                        const timeSkipRegex = /\[system-display:([\s\S]+?)\]/;
                        const timeSkipMatch = lastEverMsg.content.match(timeSkipRegex);

                        if (timeSkipMatch) {
                            lastMessageText = timeSkipMatch[1];
                        } else if (inviteRegex.test(lastEverMsg.content)) {
                            lastMessageText = '新成员加入了群聊';
                        } else if (renameRegex.test(lastEverMsg.content)) {
                            lastMessageText = '群聊名称已修改';
                        }
                    }
                }
                const li = document.createElement('li');
                li.className = 'list-item chat-item';
                if (chat.isPinned) li.classList.add('pinned');
                li.dataset.id = chat.id;
                li.dataset.type = chat.type;
                const avatarClass = chat.type === 'group' ? 'group-avatar' : '';
                const itemName = chat.type === 'private' ? chat.remarkName : chat.name;
                    // ▼▼▼ 核心修改 1：使用新的SVG图标 ▼▼▼
        let soulBondIconHTML = '';
        if (chat.type === 'private' && chat.isSoulBound) {
            soulBondIconHTML = `
                <span class="soul-bond-icon" data-char-id="${chat.id}" title="解除心动关系">
                    <svg class="soul-bond-icon-svg" viewBox="0 0 24 24">
                        <path d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z"></path>
                    </svg>
                </span>`;
        }
        // ▲▲▲ 修改结束 ▲▲▲
                const pinBadgeHTML = chat.isPinned ? '<span class="pin-badge">置顶</span>' : '';
                // ▼▼▼ 核心修改 2：在HTML结构中插入图标 ▼▼▼
        li.innerHTML = `
            <img src="${chat.avatar}" alt="${itemName}" class="chat-avatar ${avatarClass}">
            <div class="item-details">
                <div class="item-details-row">
                    <div class="item-name">${itemName}</div>
                    ${soulBondIconHTML}
                </div>
                <div class="item-preview-wrapper">
                    <div class="item-preview">${lastMessageText}</div>
                    ${pinBadgeHTML}
                </div>
            </div>`;
        // ▲▲▲ 修改结束 ▲▲▲
                chatListContainer.appendChild(li);
            });
      document.querySelectorAll('.soul-bond-icon').forEach(icon => {
        icon.style.cursor = 'pointer';
        icon.addEventListener('click', async (e) => {
            e.stopPropagation();
            
            const charId = e.currentTarget.dataset.charId;
            const character = db.characters.find(c => c.id === charId);
            if (!character) return;
            
            if (confirm(`你确定要与 ${character.remarkName} 解除心动关系吗？`)) {
                // 更新角色状态
                character.isSoulBound = false;
                character.soulBondStatus = 'none';

                // 创建并注入一条通知AI的系统消息
                const systemContent = `[system: ${character.myName} 已与你解除心动关系。]`;
                const contextMessage = {
                    id: `msg_unbond_ctx_${Date.now()}`,
                    role: 'user',
                    content: systemContent,
                    parts: [{ type: 'text', text: systemContent }],
                    timestamp: Date.now()
                };
                character.history.push(contextMessage);

                // 保存所有更改
                await saveData();
                
                // 刷新UI并提示用户
                renderChatList();
                showToast('心动关系已解除');
            }
        });
    });
    // ▲▲▲ 修改结束 ▲▲▲
        }
// 在 setupChatListScreen() 函数的末尾添加

const importCardBtn = document.getElementById('import-card-btn');
const cardImportInput = document.getElementById('card-import-input');

if (importCardBtn && cardImportInput) {
    importCardBtn.addEventListener('click', () => {
        cardImportInput.click();
    });
    cardImportInput.addEventListener('change', handleCardImport);
}
        function setupAddCharModal() {
            addCharForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const newChar = {
isBlockedByUser: false,
isBlockedByAi: false,
userBlockTimestamp: null,
aiBlockTimestamp: null,
blockEndTime: null,
isOfflineMode: false,
                    id: `char_${Date.now()}`,
                    realName: document.getElementById('char-real-name').value,
                    remarkName: document.getElementById('char-remark-name').value,
                    persona: '',
                    avatar: 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg',
                    myName: document.getElementById('my-name-for-char').value,
                    myPersona: '',
                    myAvatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg',
                    theme: 'white_pink',
                    maxMemory: 10,
                    chatBg: '',
                    history: [],
                    diaries: [],
    messageCountSinceLastDiary: 0,
    // --- 添加结束 ---
                    memories: [], // <-- 添加这行
                    isPinned: false,
                    status: '在线',
                    worldBookIds: [],
                    useCustomBubbleCss: false,
                    customBubbleCss: '',
                    pendingMessages: [],
                    aiProactiveChatEnabled: false,
                    aiProactiveChatDelay: 0,
                    aiProactiveChatInterval: 0,
                };
                db.characters.push(newChar);
                await saveData();
                renderChatList();
                addCharModal.classList.remove('visible');
                showToast(`角色“${newChar.remarkName}”创建成功！`);
            });
        }
// --- 在 setupChatRoom() 函数的前面，粘贴下面的代码块 ---

function startQuoteReply(messageId) {
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    const message = chat.history.find(m => m.id === messageId);
    if (!message) return;

    // 提取干净的文本内容用于预览
    let previewText = message.content;
    const regexes = [
        /\[.*?的消息：([\s\S]+?)\]/,
        /\[.*?的语音：([\s\S]+?)\]/,
        /\[.*?引用了“.*?”的消息?并回复：([\s\S]+?)\]/,
        /\[.*?发来的照片\/视频：([\s\S]+?)\]/
    ];

    for (const regex of regexes) {
        const match = message.content.match(regex);
        if (match) {
            previewText = match[1];
            break;
        }
    }
    
    if (message.parts && message.parts.some(p => p.type === 'image')) {
        previewText = '[图片]';
    } else if (message.quote) {
        previewText = message.replyText;
    }

    currentQuotedMessageId = messageId;
    document.getElementById('quoted-message-preview').textContent = `回复：${previewText}`;
    document.getElementById('quote-reply-bar').style.display = 'flex';
    messageInput.focus();
}

function cancelQuoteReply() {
    currentQuotedMessageId = null;
    document.getElementById('quote-reply-bar').style.display = 'none';
}

    // ▼▼▼ 用下面这个完整的函数，替换掉你文件中旧的 setupChatRoom 函数 ▼▼▼
function setupChatRoom() {
    sendMessageBtn.addEventListener('click', sendMessage);
    sendMessageBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        sendMessage();
        setTimeout(() => { messageInput.focus(); }, 50);
    });
    messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !isGenerating) sendMessage();
    });
    getReplyBtn.addEventListener('click', getAiReply);
// --- 微信布局的事件监听 (新增) ---
    const wechatMessageInput = document.getElementById('wechat-message-input');
    const wechatSendMessageBtn = document.getElementById('wechat-send-message-btn');
    const wechatGetReplyBtn = document.getElementById('wechat-get-reply-btn');
    
    wechatSendMessageBtn.addEventListener('click', () => sendMessage(wechatMessageInput));
    wechatMessageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !isGenerating) sendMessage(wechatMessageInput);
    });
    wechatGetReplyBtn.addEventListener('click', getAiReply);

    // --- 其他所有事件监听器 (保持不变) ---
    // --- 核心修正：统一处理 messageArea 上的所有点击事件 ---
    messageArea.addEventListener('click', (e) => {
    	
        // 1. 截图模式下的点击逻辑 (最高优先级)
        if (isInScreenshotMode) {
            const messageWrapper = e.target.closest('.message-wrapper');
            if (messageWrapper) {
                toggleScreenshotSelection(messageWrapper.dataset.id);
            }
            return; // 在截图模式下，阻止后续所有其他点击事件
        }
        
        // 2. 关闭表情包面板
        if (stickerModal.classList.contains('visible')) {
            stickerModal.classList.remove('visible');
            return;
        }

        // 3. 加载更多消息
        if (e.target && e.target.id === 'load-more-btn') {
            loadMoreMessages();
            return;
        }

        // 4. 多选删除模式
        if (isInMultiSelectMode) {
            const messageWrapper = e.target.closest('.message-wrapper');
            if (messageWrapper) {
                toggleMessageSelection(messageWrapper.dataset.id);
            }
            return;
        }
        
        // 5. 其他普通点击事件（语音、卡片等）
        const voiceBubble = e.target.closest('.voice-bubble');
        if (voiceBubble) {
            const transcript = voiceBubble.closest('.message-wrapper').querySelector('.voice-transcript');
            if (transcript) transcript.classList.toggle('active');
        }
        const pvCard = e.target.closest('.pv-card');
        if (pvCard) {
            const imageOverlay = pvCard.querySelector('.pv-card-image-overlay');
            const footer = pvCard.querySelector('.pv-card-footer');
            imageOverlay.classList.toggle('hidden');
            footer.classList.toggle('hidden');
        }
        const giftCard = e.target.closest('.gift-card');
        if (giftCard) {
            const description = giftCard.closest('.message-wrapper').querySelector('.gift-card-description');
            if (description) description.classList.toggle('active');
        }
        const locationCard = e.target.closest('.location-card');
        if (locationCard) {
            displayLocationMain.textContent = locationCard.dataset.locationMain;
            displayLocationDetail.textContent = locationCard.dataset.locationDetail;
            displayLocationModal.classList.add('visible');
        }
        const transferCard = e.target.closest('.transfer-card.received-transfer');
          // ▼▼▼ 在这里添加新的代码块 ▼▼▼
    const bondAcceptBtn = e.target.closest('.bond-accept-btn');
    if (bondAcceptBtn) {
        const messageId = bondAcceptBtn.closest('.message-wrapper').dataset.id;
        handleBondRequestResponse(messageId, 'accepted');
    }
    const bondDeclineBtn = e.target.closest('.bond-decline-btn');
    if (bondDeclineBtn) {
        const messageId = bondDeclineBtn.closest('.message-wrapper').dataset.id;
        handleBondRequestResponse(messageId, 'declined');
    }
    // ▲▲▲ 添加结束 ▲▲▲

        if (transferCard && currentChatType === 'private') {
            const message = db.characters.find(c => c.id === currentChatId)?.history.find(m => m.id === transferCard.closest('.message-wrapper').dataset.id);
            if (message && message.transferStatus === 'pending') {
                handleReceivedTransferClick(message.id);
            }
        }
    });

    // --- 长按/右键菜单事件 (保持不变) ---
    messageArea.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        if (e.target.id === 'load-more-btn' || isInMultiSelectMode || isInScreenshotMode) return;
        const messageWrapper = e.target.closest('.message-wrapper');
        if (!messageWrapper) return;
        handleMessageLongPress(messageWrapper, e.clientX, e.clientY);
    });
    messageArea.addEventListener('touchstart', (e) => {
        if (e.target.id === 'load-more-btn' || isInMultiSelectMode || isInScreenshotMode) return;
        const messageWrapper = e.target.closest('.message-wrapper');
        if (!messageWrapper) return;
        longPressTimer = setTimeout(() => {
            const touch = e.touches[0];
            handleMessageLongPress(messageWrapper, touch.clientX, touch.clientY);
        }, 400);
    });
    messageArea.addEventListener('touchend', () => clearTimeout(longPressTimer));
    messageArea.addEventListener('touchmove', () => clearTimeout(longPressTimer));

    // --- 其他按钮的事件监听 ---
    saveEditBtn.addEventListener('click', saveMessageEdit);
    cancelEditBtn.addEventListener('click', cancelMessageEdit);
    cancelMultiSelectBtn.addEventListener('click', exitMultiSelectMode);
    deleteSelectedBtn.addEventListener('click', deleteSelectedMessages);
    document.getElementById('cancel-quote-reply-btn').addEventListener('click', cancelQuoteReply);

    // --- 关键修正：确保截图按钮的事件监听器被正确添加 ---
    document.getElementById('cancel-screenshot-select').addEventListener('click', exitScreenshotSelectionMode);
    document.getElementById('confirm-screenshot-select').addEventListener('click', generateSelectedMessagesScreenshot);
    // ... 在 setupChatRoom 函数的末尾 ...

// ▼▼▼ 在 init() 的事件监听器区域末尾，添加这部分代码 ▼▼▼

// --- 微信布局功能面板事件 ---
const plusBtn = document.getElementById('plus-btn');
const functionPanel = document.getElementById('function-panel');
const chatRoomContent = document.querySelector('#chat-room-screen .content');

plusBtn.addEventListener('click', () => {
    functionPanel.classList.toggle('visible');
    if (functionPanel.classList.contains('visible')) {
        chatRoomContent.style.paddingBottom = (functionPanel.offsetHeight + 70) + 'px';
    } else {
        chatRoomContent.style.paddingBottom = '70px';
    }
});

chatRoomContent.addEventListener('click', () => {
    if (functionPanel.classList.contains('visible')) {
        functionPanel.classList.remove('visible');
        chatRoomContent.style.paddingBottom = '70px';
    }
});

functionPanel.addEventListener('click', (e) => {
    const item = e.target.closest('.function-item');
    if (!item) return;

    const action = item.dataset.action;
    
    functionPanel.classList.remove('visible');
    chatRoomContent.style.paddingBottom = '70px';

    // 根据action执行相应操作
    switch (action) {
        case 'sticker':
            stickerModal.classList.add('visible');
            renderStickerGrid();
            break;
        case 'photo-video':
            sendPvForm.reset();
            sendPvModal.classList.add('visible');
            break;
        case 'image-recognition':
            imageUploadInput.click();
            break;
        case 'voice-message':
            sendVoiceForm.reset();
            voiceDurationPreview.textContent = '0"';
            sendVoiceModal.classList.add('visible');
            break;
        case 'voice-call':
            if (currentChatType === 'private') startUserInitiatedCall();
            else showToast('群聊暂不支持通话');
            break;
        case 'wallet':
            walletBtn.click(); // 触发原钱包按钮的逻辑
            break;
        case 'gift':
            giftBtn.click(); // 触发原礼物按钮的逻辑
            break;
        case 'time-skip':
            timeSkipForm.reset();
            timeSkipModal.classList.add('visible');
            break;
        case 'file':
            sendFileForm.reset();
            sendFileModal.classList.add('visible');
            break;
        case 'location':
            sendLocationForm.reset();
            sendLocationModal.classList.add('visible');
            break;
            case 'rollback':
        document.getElementById('rollback-btn').click(); // 模拟点击旧按钮
        break;
    case 'continue-writing':
        handleContinueWriting(); // 直接调用续写函数
        break;
    case 'memories':
        if (currentChatId && currentChatType === 'private') openMemoriesScreen(currentChatId);
        else showToast('此功能仅在私聊中可用');
        break;
case 'diary':
                if (currentChatId && currentChatType === 'private') {
                    // 修正：不再直接打开AI日记，而是打开操作选择表单
                    document.getElementById('diary-actionsheet').classList.add('visible');
                } else {
                    showToast('此功能仅在私聊中可用');
                }
                break;
            // ▲▲▲ 替换结束 ▲▲▲
    }
});

// ▲▲▲ 添加结束 ▲▲▲
}
// ... 在 init() 函数的末尾 }; 之前 ...

// === 新增：处理用户对绑定邀请的回应 ===
async function handleBondRequestResponse(messageId, response) {
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;

    const message = character.history.find(m => m.id === messageId);
    if (!message || !message.bondRequestData || message.bondRequestData.status !== 'pending') return;

    // 1. 更新卡片状态
    message.bondRequestData.status = response;

    // 2. 更新角色的心动状态
    if (response === 'accepted') {
        // 解绑所有其他AI
        db.characters.forEach(c => {
            if (c.id !== character.id) {
                c.isSoulBound = false;
                c.soulBondStatus = 'none';
            }
        });
        // 绑定当前AI
        character.isSoulBound = true;
        character.soulBondStatus = 'active';
        showToast(`你与 ${character.remarkName} 已成功绑定！`);
    } else {
        character.soulBondStatus = 'none';
        showToast('你拒绝了邀请');
    }
    
    // 3. 注入一条系统消息，告知AI你的决定
    const systemContent = `[system: 我${response === 'accepted' ? '同意' : '拒绝'}了你的心动绑定请求。]`;
    const contextMessage = {
        id: `msg_bond_resp_ctx_${Date.now()}`,
        role: 'user',
        content: systemContent,
        parts: [{ type: 'text', text: systemContent }],
        timestamp: Date.now()
    };
    character.history.push(contextMessage);

    await saveData();

    // 4. 刷新UI并触发AI的后续反应
    renderMessages(false, true);
    renderChatList(); // 刷新聊天列表以显示（或移除）爱心
    getAiReply();
}

        function handleMessageLongPress(messageWrapper, x, y) {
            if (isInMultiSelectMode) return;
            clearTimeout(longPressTimer);
            const messageId = messageWrapper.dataset.id;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const message = chat.history.find(m => m.id === messageId);
            if (!message) return;

            const isImageRecognitionMsg = message.parts && message.parts.some(p => p.type === 'image');
            const isVoiceMessage = /\[.*?的语音：.*?\]/.test(message.content);
            const isStickerMessage = /\[.*?的表情包：.*?\]|\[.*?发送的表情包：.*?\]/.test(message.content);
            const isPhotoVideoMessage = /\[.*?发来的照片\/视频：.*?\]/.test(message.content);
            const isTransferMessage = /\[.*?给你转账：.*?\]|\[.*?的转账：.*?\]|\[.*?向.*?转账：.*?\]/.test(message.content);
            const isGiftMessage = /\[.*?送来的礼物：.*?\]|\[.*?向.*?送来了礼物：.*?\]/.test(message.content);
            const isInvisibleMessage = /\[.*?(?:接收|退回).*?的转账\]|\[.*?更新状态为：.*?\]|\[.*?已接收礼物\]|\[system:.*?\]|\[.*?邀请.*?加入了群聊\]|\[.*?修改群名为：.*?\]|\[system-display:.*?\]/.test(message.content);

            let menuItems = [];
            menuItems.push({label: '引用', action: () => startQuoteReply(messageId)});
     const isSent = messageWrapper.classList.contains('sent');
    const twoMinutes = 2 * 60 * 1000;
    if (isSent && (Date.now() - message.timestamp < twoMinutes) && !message.recalled) {
        menuItems.push({
            label: '撤回',
            action: async () => {
                const msgIndex = chat.history.findIndex(m => m.id === messageId);
                if (msgIndex > -1) {
                    // 核心修改：不再修改content，而是添加标记
                    chat.history[msgIndex].recalled = true;
                    chat.history[msgIndex].recalledBy = 'user';
                    // 同时保存一份原始内容，以便查看
                    chat.history[msgIndex].originalContent = chat.history[msgIndex].content;
                    
                    await saveData();
                    renderMessages(false, true); // 重新渲染，让消息变成占位符
                }
            }
        });
    }

menuItems.push({
        label: '长截图 (选择)',
        action: () => enterScreenshotSelectionMode(messageId)
    });
    if (!isImageRecognitionMsg && !isVoiceMessage && !isStickerMessage && !isPhotoVideoMessage && !isTransferMessage && !isGiftMessage && !isInvisibleMessage) {
        menuItems.push({label: '编辑', action: () => startMessageEdit(messageId)});
    }
    menuItems.push({label: '删除', action: () => enterMultiSelectMode(messageId)});

            if (menuItems.length > 0) {
                createContextMenu(menuItems, x, y);
            }
        }

        function startMessageEdit(messageId) {
            exitMultiSelectMode();
            editingMessageId = messageId;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const message = chat.history.find(m => m.id === messageId);
            if (!message) return;
            const match = message.content.match(/\[.*?的消息：([\s\S]+)\]/);
            const contentToEdit = match ? match[1].trim() : message.content;
            messageEditInput.value = contentToEdit;
            messageInputDefault.style.display = 'none';
            messageEditBar.style.display = 'flex';
            messageEditInput.focus();
        }

        async function saveMessageEdit() {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const messageIndex = chat.history.findIndex(m => m.id === editingMessageId);
            if (messageIndex === -1) return;
            const newText = messageEditInput.value.trim();
            if (newText) {
                const oldContent = chat.history[messageIndex].content;
                const prefixMatch = oldContent.match(/(\[.*?的消息：)[\s\S]+\]/);
                const prefix = prefixMatch ? prefixMatch[1] : '';
                const newContent = `${prefix}${newText}]`;
                chat.history[messageIndex].content = newContent;
                if (chat.history[messageIndex].parts) {
                    chat.history[messageIndex].parts = [{type: 'text', text: newContent}];
                }
                await saveData();
                currentPage = 1;
                renderMessages(false, true);
                renderChatList();
            }
            cancelMessageEdit();
        }

        function cancelMessageEdit() {
            editingMessageId = null;
            messageInputDefault.style.display = 'flex';
            messageEditBar.style.display = 'none';
        }

        function enterMultiSelectMode(initialMessageId) {
            isInMultiSelectMode = true;
            chatRoomHeaderDefault.style.display = 'none';
            chatRoomHeaderSelect.style.display = 'flex';
            document.querySelector('.chat-input-wrapper').style.display = 'none';
            multiSelectBar.classList.add('visible');
            chatRoomScreen.classList.add('multi-select-active');
            selectedMessageIds.clear();
            if (initialMessageId) {
                toggleMessageSelection(initialMessageId);
            }
        }

        function exitMultiSelectMode() {
            isInMultiSelectMode = false;
            chatRoomHeaderDefault.style.display = 'flex';
            chatRoomHeaderSelect.style.display = 'none';
            document.querySelector('.chat-input-wrapper').style.display = 'block';
            multiSelectBar.classList.remove('visible');
            chatRoomScreen.classList.remove('multi-select-active');
            selectedMessageIds.forEach(id => {
                const el = messageArea.querySelector(`.message-wrapper[data-id="${id}"]`);
                if (el) el.classList.remove('multi-select-selected');
            });
            selectedMessageIds.clear();
        }

        function toggleMessageSelection(messageId) {
            const el = messageArea.querySelector(`.message-wrapper[data-id="${messageId}"]`);
            if (!el) return;
            if (selectedMessageIds.has(messageId)) {
                selectedMessageIds.delete(messageId);
                el.classList.remove('multi-select-selected');
            } else {
                selectedMessageIds.add(messageId);
                el.classList.add('multi-select-selected');
            }
            selectCount.textContent = `已选择 ${selectedMessageIds.size} 项`;
            deleteSelectedBtn.disabled = selectedMessageIds.size === 0;
        }

        async function deleteSelectedMessages() {
            if (selectedMessageIds.size === 0) return;
            const deletedCount = selectedMessageIds.size;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            chat.history = chat.history.filter(m => !selectedMessageIds.has(m.id));
            await saveData();
            currentPage = 1;
            renderMessages(false, true);
            renderChatList();
            exitMultiSelectMode();
            showToast(`已删除 ${deletedCount} 条消息`);
        }

// --- 新代码开始 ---
     // --- 新代码开始 ---
    // --- 新代码开始 ---
// --- 新代码开始 ---
        function openChatRoom(chatId, type) { // 修改：函数不再需要 async
            const chat = (type === 'private') ? db.characters.find(c => c.id === chatId) : db.groups.find(g => g.id === chatId);
            if (!chat) return;

            // 修改：处理暂存消息的逻辑已被移除

            // 后续逻辑保持不变，但重新梳理了渲染顺序
            exitScreenshotSelectionMode(); 
            checkAndUpdateUiForAiBlock();
            exitMultiSelectMode();
            cancelMessageEdit();

            if (window.targetMessageId) {
                const targetId = window.targetMessageId;
                const messageIndex = chat.history.findIndex(m => m.id === targetId);
                if (messageIndex > -1) {
                    const page = Math.floor((chat.history.length - 1 - messageIndex) / MESSAGES_PER_PAGE) + 1;
                    currentPage = page;
                    window.targetMessageIdForHighlight = targetId;
                } else {
                    currentPage = 1; 
                    showToast('无法在历史记录中定位到该消息');
                }
                window.targetMessageId = null; 
            } else {
                currentPage = 1;
            }

            const diaryBtn = document.getElementById('diary-btn');
            const trajectoryBtn = document.getElementById('ai-trajectory-btn');
            const memoriesBtn = document.getElementById('ai-memories-btn');

            if (type === 'private') {
                voiceCallBtn.style.display = 'flex';
                diaryBtn.style.display = 'flex';
                trajectoryBtn.style.display = 'flex';
                memoriesBtn.style.display = 'flex';
            } else { 
                voiceCallBtn.style.display = 'none';
                diaryBtn.style.display = 'none';
                trajectoryBtn.style.display = 'none';
                memoriesBtn.style.display = 'none';
            }

            chatRoomTitle.textContent = (type === 'private') ? chat.remarkName : chat.name;
            const subtitle = document.getElementById('chat-room-subtitle');
            if (type === 'private') {
                subtitle.style.display = 'flex';
                chatRoomStatusText.textContent = chat.status || '在线';
            } else {
                subtitle.style.display = 'none';
            }
            getReplyBtn.style.display = 'inline-flex';
            chatRoomScreen.style.backgroundImage = chat.chatBg ? `url(${chat.chatBg})` : 'none';
            chatRoomScreen.style.setProperty('--bubble-scale', type === 'group' ? (chat.bubbleScale || 1) : 1);
            typingIndicator.style.display = 'none';
            isGenerating = false;
            getReplyBtn.disabled = false;
            chatRoomScreen.className = chatRoomScreen.className.replace(/\bchat-active-[^ ]+\b/g, '');
            chatRoomScreen.classList.add(`chat-active-${chatId}`);
            updateCustomBubbleStyle(chatId, chat.customBubbleCss, chat.useCustomBubbleCss);
            
            messageArea.innerHTML = '';
            switchScreen('chat-room-screen');
            
            setTimeout(() => {
                renderMessages(false, !window.targetMessageIdForHighlight);
            }, 50);
        }
// --- 新代码结束 ---
// --- 新代码结束 ---
// --- 新代码结束 ---

function renderMessages(isLoadMore = false, forceScrollToBottom = false) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat || !chat.history) return;

            // ▼▼▼ 在函数开头，读取并消费高亮标记 ▼▼▼
            const targetIdToHighlight = window.targetMessageIdForHighlight;
            window.targetMessageIdForHighlight = null; // 消费掉这个ID，防止下次渲染时重复执行

            const oldScrollHeight = messageArea.scrollHeight;
            const totalMessages = chat.history.length;
            const end = totalMessages - (currentPage - 1) * MESSAGES_PER_PAGE;
            const start = Math.max(0, end - MESSAGES_PER_PAGE);
            const messagesToRender = chat.history.slice(start, end);

            if (!isLoadMore) messageArea.innerHTML = '';
            
            const fragment = document.createDocumentFragment();
            messagesToRender.forEach(msg => {
                const bubble = createMessageBubbleElement(msg);
                if (bubble) fragment.appendChild(bubble);
            });
            
            const existingLoadBtn = document.getElementById('load-more-btn');
            if (existingLoadBtn) existingLoadBtn.remove();
            
            messageArea.prepend(fragment);
            
            if (totalMessages > currentPage * MESSAGES_PER_PAGE) {
                const loadMoreButton = document.createElement('button');
                loadMoreButton.id = 'load-more-btn';
                loadMoreButton.className = 'load-more-btn';
                loadMoreButton.textContent = '加载更早的消息';
                messageArea.prepend(loadMoreButton);
            }

            // ▼▼▼ 新增/修改的高亮与滚动逻辑 ▼▼▼
            if (targetIdToHighlight) {
                // 如果是从搜索跳转而来
                setTimeout(() => { // 使用setTimeout确保DOM更新完毕
                    const targetElement = messageArea.querySelector(`.message-wrapper[data-id="${targetIdToHighlight}"]`);
                    if (targetElement) {
                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        targetElement.classList.add('message-highlight');
                        // 2秒后移除高亮效果
                        setTimeout(() => {
                            targetElement.classList.remove('message-highlight');
                        }, 2000); 
                    }
                }, 100); // 延迟100毫秒等待渲染
            } else if (forceScrollToBottom) {
                // 正常打开聊天时，滚动到底部
                setTimeout(() => {
                    messageArea.scrollTop = messageArea.scrollHeight;
                }, 0);
            } else if (isLoadMore) {
                // 加载更多时，保持当前视口位置
                messageArea.scrollTop = messageArea.scrollHeight - oldScrollHeight;
            }
            // ▲▲▲ 修改结束 ▲▲▲
        }
        function loadMoreMessages() {
            currentPage++;
            renderMessages(true, false);
        }

        function calculateVoiceDuration(text) {
            return Math.max(1, Math.min(60, Math.ceil(text.length / 3.5)));
        }

                                 
// START: 完整版 createMessageBubbleElement 函数 (替换旧版本)
// START: 最终版 createMessageBubbleElement 函数 (替换旧版本)
// ▼▼▼ 【V3.1 | 最终修复版】请用这个函数完整替换旧的 createMessageBubbleElement ▼▼▼

/**
 * 【重构版】根据消息对象创建并返回一个完整的消息气泡DOM元素。
 * @param {object} message - 消息对象
 * @returns {HTMLElement|null} - 创建好的消息包装器元素，或在不需渲染时返回null
 */
function createMessageBubbleElement(message) {

    // --- 1. 处理系统消息、撤回消息等特殊类型 (提前返回，保持主逻辑清晰) ---
 const updateStatusRegexForRender = /\[.*?更新状态为[:：].*?\]/;
    if (message.content.startsWith('[system:') || message.content.startsWith('[system-context-only:') || updateStatusRegexForRender.test(message.content)) {
        return null;
    }

    if (message.recalled) {
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper system-notification';
        wrapper.dataset.id = message.id;
        const recaller = (message.recalledBy === 'user') ? '你' : '对方';
        const placeholder = document.createElement('div');
        placeholder.className = 'recalled-message-placeholder';
        placeholder.textContent = `${recaller}撤回了一条消息`;
        placeholder.style.cursor = 'pointer';
        placeholder.dataset.recalledMessageId = message.id;
        wrapper.appendChild(placeholder);
        return wrapper;
    }

    const timeSkipRegex = /\[system-display:([\s\S]+?)\]/;
    const inviteRegex = /\[(.*?)邀请(.*?)加入了群聊\]/;
    const renameRegex = /\[(.*?)修改群名为：(.*?)\]/;
    const timeSkipMatch = message.content.match(timeSkipRegex);
    const inviteMatch = message.content.match(inviteRegex);
    const renameMatch = message.content.match(renameRegex);
    if (timeSkipMatch || inviteMatch || renameMatch) {
        const wrapper = document.createElement('div');
        wrapper.dataset.id = message.id;
        wrapper.className = 'message-wrapper system-notification';
        let bubbleText = '';
        if (timeSkipMatch) bubbleText = timeSkipMatch[1];
        if (inviteMatch) bubbleText = `${inviteMatch[1]}邀请${inviteMatch[2]}加入了群聊`;
        if (renameMatch) bubbleText = `${renameMatch[1]}修改群名为“${renameMatch[2]}”`;
        wrapper.innerHTML = `<div class="system-notification-bubble">${bubbleText}</div>`;
        return wrapper;
    }

    // --- 2. 准备渲染所需的基础数据 ---
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    if (!chat) return null;

    const { role, content, timestamp, id, senderId, transferStatus, giftStatus, stickerData } = message;
    const isSent = (currentChatType === 'group') ? (senderId === 'user_me') : (role === 'user');
    let avatarUrl, bubbleTheme, senderNickname = '', titleBadgeHTML = '';
    const themeKey = chat.theme || 'white_pink';
    const theme = colorThemes[themeKey] || colorThemes['white_pink'];
    bubbleTheme = isSent ? theme.sent : theme.received;

    if (currentChatType === 'group') {
        const sender = isSent ? chat.me : chat.members.find(m => m.id === senderId);
        if (sender) {
            avatarUrl = sender.avatar;
            senderNickname = sender.nickname || sender.groupNickname;
            if (sender.groupTitle) {
                const badgeClass = getBadgeClassForTitle(sender.groupTitle);
                titleBadgeHTML = `<span class="group-title-badge ${badgeClass}">${sender.groupTitle}</span>`;
            }
        } else {
            avatarUrl = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
            senderNickname = '未知成员';
        }
    } else {
        avatarUrl = isSent ? chat.myAvatar : chat.avatar;
    }

    // --- 3. 【核心重构：调用独立渲染函数】 ---
    let finalContentHTML;
    let isRenderedByRule = false;

    // a. 准备用于渲染的纯文本 (剥离消息包装)
    let rawText = content;
    const textMatchForRender = content.match(/\[(?:.+?)的消息：([\s\S]+?)\]/);
    if (textMatchForRender) {
        rawText = textMatchForRender[1].trim();
    }
    
    // b. 调用新的渲染函数
    const renderResult = applyAdvancedRenderingRules(rawText, currentChatId, isSent ? 'user' : 'ai');

    // c. 根据返回结果决定如何处理
    if (renderResult.isRendered) {
        finalContentHTML = renderResult.html;
        isRenderedByRule = true;
    } else {
        // ▼▼▼ 【核心修复】将所有 Match 变量的声明和初始化提前到 if/else if 链之前 ▼▼▼
        const aiQuoteRegex = /\[(?:.*?)引用了“(?:.*?:)?\s?([\s\S]+?)”的消息?并回复：([\s\S]+?)\]/;
        const musicShareRegex = /\[(?:.*?)分享了音乐：([\s\S]+?) - ([\s\S]+?)\]/;
        const locationRegex = /\[(.*?)的位置共享：主位置 '(.*?)', 详细位置 '(.*?)'\]|\[(.*?)分享了位置：主位置 '(.*?)', 详细位置 '(.*?)'\]/i;
        const urlRegex = /^(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg)|data:image\/[a-z]+;base64,)/i;
        const sentStickerRegex = /\[(?:.+?)的表情包：.+?\]/i;
        const receivedStickerRegex = /\[(?:.+?)发送的表情包：([\s\S]+?)\]/i;
        const bareImageLinkRegex = /^\[(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg))\]$/i;
        const voiceRegex = /\[(?:.+?)的语音：([\s\S]+?)\]/;
        const photoVideoRegex = /\[(?:.+?)发来的照片\/视频：([\s\S]+?)\]/;
        const privateSentTransferRegex = /\[.*?给你转账：([\d.]+)元；备注：(.*?)\]/;
        const privateReceivedTransferRegex = /\[.*?的转账：([\d.]+)元；备注：(.*?)\]/;
        const groupTransferRegex = /\[(.*?)\s*向\s*(.*?)\s*转账：([\d.]+)元；备注：(.*?)\]/;
        const privateGiftRegex = /\[(?:.+?)送来的礼物：([\s\S]+?)\]/;
        const groupGiftRegex = /\[(.*?)\s*向\s*(.*?)\s*送来了礼物：([\s\S]+?)\]/; // <-- Regex for group gift
        const imageRecogRegex = /\[.*?发来了一张图片：\]/;
        const textRegex = /\[(?:.+?)的消息：([\s\S]+?)\]/;

        const aiQuoteMatch = content.match(aiQuoteRegex);
        const musicMatch = content.match(musicShareRegex);
        const locationMatch = content.match(locationRegex);
        const sentStickerMatch = content.match(sentStickerRegex);
        const receivedStickerMatch = content.match(receivedStickerRegex);
        const bareImageLinkMatch = content.match(bareImageLinkRegex);
        const voiceMatch = content.match(voiceRegex);
        const photoVideoMatch = content.match(photoVideoRegex);
        const privateSentTransferMatch = content.match(privateSentTransferRegex);
        const privateReceivedTransferMatch = content.match(privateReceivedTransferRegex);
        const groupTransferMatch = content.match(groupTransferRegex);
        const privateGiftMatch = content.match(privateGiftRegex);
        const groupGiftMatch = content.match(groupGiftRegex); // <-- Match for group gift
        const imageRecogMatch = content.match(imageRecogRegex);
        const textMatch = content.match(textRegex);
// ▼▼▼ 在这里添加缺失的逻辑 ▼▼▼
        if (message.bondRequestData) {
            const data = message.bondRequestData;
            let statusText = '等待回应...';
            let statusColor = '#888';
            let actionsHTML = '';
    
            if (data.status === 'accepted') {
                statusText = '✓ 已同意';
                statusColor = '#4CAF50';
            } else if (data.status === 'declined') {
                statusText = '✗ 已拒绝';
                statusColor = '#F44336';
            } else { // pending
                if (!isSent) { // 仅当是对方发来的邀请时，才显示按钮
                    actionsHTML = `
                        <div class="bond-request-actions">
                            <button class="btn btn-neutral btn-small bond-decline-btn">再想想</button>
                            <button class="btn btn-primary btn-small bond-accept-btn">我愿意</button>
                        </div>
                    `;
                    statusText = ''; // 有按钮时，不显示文字状态
                }
            }
    
            finalContentHTML = `
                <div class="bond-request-card">
                    <p>${isSent ? '你向对方发起了心动绑定邀请' : `${senderNickname} 向你发起了心动绑定邀请`}</p>
                    ${actionsHTML}
                    <p class="bond-request-status" style="color: ${statusColor};">${statusText || '&nbsp;'}</p>
                </div>
            `;
        }
        // ▲▲▲ 添加结束 ▲▲▲
        if (message.quote || aiQuoteMatch) {
            let quotedSender, quotedText, replyText;
            if (message.quote) {
                quotedSender = message.quote.sender;
                quotedText = message.quote.content;
                replyText = message.replyText;
            } else {
                quotedSender = senderNickname || (currentChatType === 'private' ? chat.remarkName : '群成员');
                quotedText = aiQuoteMatch[1].trim();
                replyText = aiQuoteMatch[2].trim();
            }
            finalContentHTML = `
                <div class="quoted-content">
                    <div class="quoted-sender">${quotedSender}</div>
                    <div class="quoted-text">${quotedText}</div>
                </div>
                <div class="reply-text">${replyText}</div>
            `;
        } else if (musicMatch) {
            const songTitle = musicMatch[1].trim();
            const artist = musicMatch[2].trim();
            finalContentHTML = `<div class="music-card"><img src="https://i.postimg.cc/d10J4VzR/image.png" alt="music icon" class="music-card-icon"><div class="music-card-info"><p class="music-card-title">${songTitle}</p><p class="music-card-artist">${artist}</p></div></div>`;
        } else if (message.deliveryData) {
    // 新增：渲染商品送达卡片
    finalContentHTML = `
        <div class="product-delivery-card">
            <img src="${message.deliveryData.productImage}" alt="商品" class="product-delivery-card-icon">
            <div class="product-delivery-card-info">
                <p class="product-delivery-card-title">${message.deliveryData.productName}</p>
                <p class="delivery-countdown-display" data-countdown-type="delivery" data-eta="${message.deliveryData.eta}"></p>
            </div>
        </div>`;
}  else if (message.bondRequestData) {
            const data = message.bondRequestData;
            let statusText = '等待回应...';
            let statusColor = '#888';
            let actionsHTML = '';
    
            if (data.status === 'accepted') {
                statusText = '✓ 已同意';
                statusColor = '#4CAF50';
            } else if (data.status === 'declined') {
                statusText = '✗ 已拒绝';
                statusColor = '#F44336';
            } else { // pending
                if (!isSent) { // 仅当是对方发来的邀请时，才显示按钮
                    actionsHTML = `
                        <div class="bond-request-actions">
                            <button class="btn btn-neutral btn-small bond-decline-btn">再想想</button>
                            <button class="btn btn-primary btn-small bond-accept-btn">我愿意</button>
                        </div>
                    `;
                    statusText = ''; // 有按钮时，不显示文字状态
                }
            }
    
            finalContentHTML = `
                <div class="bond-request-card">
                    <p>${isSent ? '你向对方发起了心动绑定邀请' : `${senderNickname} 向你发起了心动绑定邀请`}</p>
                    ${actionsHTML}
                    <p class="bond-request-status" style="color: ${statusColor};">${statusText || '&nbsp;'}</p>
                </div>
            `;
        }
        // ▲▲▲ 添加结束 ▲▲▲
else if (message.paymentRequestData) {
    const data = message.paymentRequestData;
    let actionsHTML = '';
    let statusText = '';
    
    // 根据卡片状态和发送方，决定显示按钮还是状态文本
    if (data.status === 'pending' && isSent) {
        // 我发出的代付请求，等待对方处理
        statusText = `<p class="payment-request-status">等待对方付款...</p>`;
    } else if (data.status === 'pending' && !isSent) {
        // 我收到的代付请求，显示同意/拒绝按钮
        actionsHTML = `
            <div class="payment-request-actions">
                <button class="btn btn-neutral btn-small payment-request-decline">残忍拒绝</button>
                <button class="btn btn-primary btn-small payment-request-accept">为Ta付款</button>
            </div>
        `;
    } else if (data.status === 'paid') {
        statusText = `<p class="payment-request-status" style="color: #4CAF50;">✓ 已支付</p>`;
    } else if (data.status === 'declined') {
        statusText = `<p class="payment-request-status" style="color: #F44336;">✗ 已拒绝</p>`;
    }

    finalContentHTML = `
        <div class="payment-request-card">
            <p class="payment-request-title">${data.requesterName} 发起的代付</p>
            <p class="payment-request-amount">¥${data.amount.toFixed(2)}</p>
            <p class="payment-request-desc">${data.items.map(i => i.name).join(', ')}</p>
            ${actionsHTML}
            ${statusText}
        </div>
    `;
// ▲▲▲ 代码粘贴到这里结束 ▲▲▲
} else if (message.fileData && message.fileData.name) {
            const fileSize = formatFileSize(new Blob([message.fileData.content]).size);
            finalContentHTML = `<div class="file-card" data-file-name="${escapeHTML(message.fileData.name)}" data-file-content="${escapeHTML(message.fileData.content)}"><img src="https://i.postimg.cc/vms1Vd9X/1040g2sg31hh9ub1v3oeg5pbsckvn39vt3mbflao.png" alt="file icon" class="file-card-icon"><div class="file-card-info"><p class="file-card-name">${escapeHTML(message.fileData.name)}</p><p class="file-card-size">${fileSize}</p></div></div>`;
        } else if (content.match(/\[(?:.+?)发送了文件：({.*?})\]/)) {
            const fileMatchAI = content.match(/\[(?:.+?)发送了文件：({.*?})\]/);
            try {
                const fileData = JSON.parse(fileMatchAI[1]);
                const fileName = fileData.name || '未命名文件.txt';
                const fileContent = fileData.content || '[文件内容为空]';
                const fileSize = formatFileSize(new Blob([fileContent]).size);
                finalContentHTML = `<div class="file-card" data-file-name="${escapeHTML(fileName)}" data-file-content="${escapeHTML(fileContent)}"><img src="https://i.postimg.cc/vms1Vd9X/1040g2sg31hh9ub1v3oeg5pbsckvn39vt3mbflao.png" alt="file icon" class="file-card-icon"><div class="file-card-info"><p class="file-card-name">${escapeHTML(fileName)}</p><p class="file-card-size">${fileSize}</p></div></div>`;
            } catch (e) {
                finalContentHTML = '[AI尝试发送文件，但格式错误]';
            }
        } else if (message.locationData || locationMatch) {
            let mainLoc, detailLoc;
            if (message.locationData) {
                mainLoc = message.locationData.main;
                detailLoc = message.locationData.detail;
            } else {
                mainLoc = locationMatch[2] || locationMatch[5];
                detailLoc = locationMatch[3] || locationMatch[6];
            }
            finalContentHTML = `<div class="location-card" data-location-main="${escapeHTML(mainLoc)}" data-location-detail="${escapeHTML(detailLoc)}"><div class="location-card-info"><p class="location-main">${escapeHTML(mainLoc)}</p><p class="location-detail">${escapeHTML(detailLoc)}</p></div><div class="location-map"></div></div>`;
         <!-- START: 修正后的表情包渲染逻辑 -->
   <!-- START: 修正后的表情包渲染逻辑 -->
} else if ((isSent && sentStickerMatch) || (!isSent && receivedStickerMatch)) {
    let stickerSrc = null;
    let stickerName = '';

    if (isSent) {
        stickerSrc = stickerData; // 从消息对象中直接获取图片数据
        const match = content.match(/\[.*?的表情包：(.*?)\]/);
        if (match) stickerName = match[1];
    } else { // AI 发送的表情包
        stickerName = receivedStickerMatch[1].trim();
        const sticker = db.myStickers.find(s => s.name === stickerName);

        if (sticker) {
            // 优先从共享表情包中查找
            stickerSrc = sticker.data;
        } else {
            // 后备方案：尝试解析为旧的URL格式
            const urlMatch = stickerName.match(/https?:\/\/[^\s\])]+/);
            if (urlMatch) {
                stickerSrc = urlMatch[0];
            } else {
                const pathExtractionRegex = /[a-zA-Z0-9]+\/.*$/;
                const extractedPathMatch = stickerName.match(pathExtractionRegex);
                const finalPath = extractedPathMatch ? extractedPathMatch[0] : stickerName;
                stickerSrc = `https://i.postimg.cc/${finalPath}`;
            }
        }
    }

    if (stickerSrc) {
        // 修正：将生成的HTML字符串赋值给 finalContentHTML
        finalContentHTML = `<div class="image-bubble"><img src="${stickerSrc}" alt="表情包: ${escapeHTML(stickerName)}"></div>`;
    } else {
        // 修正：如果图片源不存在，则生成一个安全的文本内容
        finalContentHTML = escapeHTML(`[表情包：${stickerName}]`);
    }
} else if (!isSent && bareImageLinkMatch) {
    const bubbleElement = document.createElement('div');         bubbleElement.className = 'image-bubble';
                const imageUrl = bareImageLinkMatch[1];
                bubbleElement.innerHTML = `<img src="${imageUrl}" alt="表情包">`;
        } else if (privateGiftMatch || groupGiftMatch) {
            const match = privateGiftMatch || groupGiftMatch;
            const description = groupGiftMatch ? groupGiftMatch[3].trim() : match[1].trim();
            let giftText;
            if (groupGiftMatch) {
                const from = groupGiftMatch[1];
                const to = groupGiftMatch[2];
                giftText = isSent ? `你送给 ${to} 的礼物` : `${from} 送给 ${to} 的礼物`;
            } else {
                giftText = '您有一份礼物～';
            }
            finalContentHTML = `<div class="gift-card ${giftStatus === 'received' ? 'received' : ''}"><img src="https://i.postimg.cc/rp0Yg31K/chan-75.png" alt="gift" class="gift-card-icon"><div class="gift-card-text">${giftText}</div><div class="gift-card-received-stamp">已查收</div></div>`;
            const wrapper = document.createElement('div'); // This wrapper seems misplaced, but keeping structure.
            const descriptionDiv = document.createElement('div');
            descriptionDiv.className = 'gift-card-description';
            descriptionDiv.textContent = description;
            wrapper.appendChild(descriptionDiv);
        } else if (voiceMatch) {
            const duration = calculateVoiceDuration(voiceMatch[1].trim());
            finalContentHTML = `<div class="voice-bubble" style="background-color: ${bubbleTheme.bg}; color: ${bubbleTheme.text};"><svg class="play-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg><span class="duration">${duration}"</span></div>`;
            const wrapper = document.createElement('div'); // Misplaced wrapper
            const transcriptDiv = document.createElement('div');
            transcriptDiv.className = 'voice-transcript';
            transcriptDiv.textContent = voiceMatch[1].trim();
            wrapper.appendChild(transcriptDiv);
        }  else if (privateSentTransferMatch || privateReceivedTransferMatch || groupTransferMatch) {
    let amount, remarkText, titleText, statusText, cardClass;
    
    // 1. 优先检查是否为群聊转账
    if (groupTransferMatch) {
        const from = groupTransferMatch[1];
        const to = groupTransferMatch[2];
        amount = parseFloat(groupTransferMatch[3]).toFixed(2);
        remarkText = groupTransferMatch[4] || '';
        titleText = isSent ? `向 ${to} 转账` : `${from} 向你转账`;
        cardClass = isSent ? 'sent-transfer' : 'received-transfer';
        statusText = '待查收'; // 群聊转账没有收/退状态

    // 2. 其次检查是否为发出的私人转账
    } else if (privateSentTransferMatch) {
        amount = parseFloat(privateSentTransferMatch[1]).toFixed(2);
        remarkText = privateSentTransferMatch[2] || '';
        titleText = '给你转账';
        cardClass = 'sent-transfer';
        statusText = '待查收';
        if (transferStatus === 'received') { statusText = '已收款'; cardClass += ' received'; }
        else if (transferStatus === 'returned') { statusText = '已退回'; cardClass += ' returned'; }

    // 3. 最后检查是否为收到的私人转账
    } else if (privateReceivedTransferMatch) {
        amount = parseFloat(privateReceivedTransferMatch[1]).toFixed(2);
        remarkText = privateReceivedTransferMatch[2] || '';
        titleText = '转账';
        cardClass = 'received-transfer';
        statusText = '转账给你';
        if (transferStatus === 'received') { statusText = '已收款'; cardClass += ' received'; }
        else if (transferStatus === 'returned') { statusText = '已退回'; cardClass += ' returned'; }
    }

    const remarkHTML = remarkText ? `<p class="transfer-remark">${remarkText}</p>` : '';
    finalContentHTML = `<div class="transfer-card ${cardClass}">
                            <div class="overlay"></div>
                            <div class="transfer-content">
                                <p class="transfer-title">${titleText}</p>
                                <p class="transfer-amount">¥${amount}</p>
                                ${remarkHTML}
                                <p class="transfer-status">${statusText}</p>
                            </div>
                        </div>`;
}else if (photoVideoMatch) {
            finalContentHTML = `<div class="pv-card"><div class="pv-card-content">${photoVideoMatch[1].trim()}</div><div class="pv-card-image-overlay" style="background-image: url('${isSent ? 'https://i.postimg.cc/L8NFrBrW/1752307494497.jpg' : 'https://i.postimg.cc/1tH6ds9g/1752301200490.jpg'}');"></div><div class="pv-card-footer"><svg viewBox="0 0 24 24"><path d="M4,4H20A2,2 0 0,1 22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6A2,2 0 0,1 4,4M4,6V18H20V6H4M10,9A1,1 0 0,1 11,10A1,1 0 0,1 10,11A1,1 0 0,1 9,10A1,1 0 0,1 10,9M8,17L11,13L13,15L17,10L20,14V17H8Z"></path></svg><span>照片/视频・点击查看</span></div>`;
        } else if (imageRecogMatch || (message.parts && message.parts.some(p => p.type === 'image'))) {
            const imageData = (message.parts && message.parts.find(p => p.type === 'image')) ? message.parts.find(p => p.type === 'image').data : content;
            finalContentHTML = `<div class="image-bubble"><img src="${imageData}" alt="图片消息"></div>`;
        } else if (message.parts && message.parts[0] && message.parts[0].type === 'html') {
            finalContentHTML = `<div class="ai-generated-theater">${message.parts[0].text}</div>`;
        } else {
            let innerText = textMatch ? textMatch[1].trim() : content.trim();
            if (urlRegex.test(innerText)) {
                 finalContentHTML = `<div class="image-bubble"><img src="${innerText}" alt="图片消息"></div>`;
            } else {
                finalContentHTML = escapeHTML(innerText).replace(/\n/g, '<br>');
            }
        }
    }


    // --- 4. 构建最终的DOM元素 ---
    const wrapper = document.createElement('div');
    wrapper.dataset.id = id;
    wrapper.className = `message-wrapper ${isSent ? 'sent' : 'received'}`;
    if (currentChatType === 'private') {
        if (isSent && chat.isBlockedByAi && chat.aiBlockTimestamp && timestamp >= chat.aiBlockTimestamp && (!chat.blockEndTime || timestamp < chat.blockEndTime)) {
            wrapper.classList.add('user-was-blocked');
        } else if (!isSent && chat.isBlockedByUser && chat.userBlockTimestamp && timestamp >= chat.userBlockTimestamp) {
            wrapper.classList.add('ai-was-blocked');
        }
    }
    if (currentChatType === 'group' && !isSent) {
        wrapper.classList.add('group-message');
    }

    const bubbleRow = document.createElement('div');
    bubbleRow.className = 'message-bubble-row';

    if (currentChatType === 'private') {
        if (isSent) bubbleRow.innerHTML += `<span class="block-indicator sent">!</span>`;
        else bubbleRow.innerHTML += `<span class="block-indicator received">!</span>`;
    }

    const timeString = `${pad(new Date(timestamp).getHours())}:${pad(new Date(timestamp).getMinutes())}`;
    const infoDiv = document.createElement('div');
    infoDiv.className = 'message-info';
    
    let frameUrl = null;
    if (currentChatType === 'private') {
        frameUrl = isSent ? chat.myAvatarFrameUrl : chat.avatarFrameUrl;
    } else {
        const sender = isSent ? chat.me : chat.members.find(m => m.id === senderId);
        if (sender) frameUrl = sender.avatarFrameUrl;
    }
    
    const avatarContainer = document.createElement('div');
    avatarContainer.className = 'avatar-container';
    avatarContainer.innerHTML = `<img src="${avatarUrl}" class="message-avatar">${frameUrl ? `<img src="${frameUrl}" class="avatar-frame">` : ''}`;
    infoDiv.innerHTML = `<span class="message-time">${timeString}</span>`;
    infoDiv.prepend(avatarContainer);

    const bubbleElement = document.createElement('div');
    
// Post-processing for complex bubbles
    if (isRenderedByRule) {
        // 如果是渲染器生成的，使用特殊类名和结构
        const theaterNode = document.createElement('div');
        theaterNode.className = 'ai-generated-theater';
        theaterNode.innerHTML = finalContentHTML;
        
        bubbleRow.appendChild(infoDiv);
        bubbleRow.appendChild(theaterNode);
    } else {
        // 如果是常规消息，根据内容创建不同的气泡
        const tempContainer = document.createElement('div');
        tempContainer.innerHTML = finalContentHTML;
        const specialBubble = tempContainer.firstElementChild;
        
        const specialClasses = ['image-bubble', 'pv-card', 'transfer-card', 'gift-card', 'file-card', 'location-card', 'music-card'];
        
        // ▼▼▼ 【核心修复】将 voiceMatch 变量的引用移动到它被声明之后 ▼▼▼
        const voiceMatch = content.match(/\[(?:.+?)的语音：([\s\S]+?)\]/);
        
        if (specialBubble && specialClasses.some(cls => specialBubble.classList.contains(cls))) {
            bubbleRow.appendChild(infoDiv);
            bubbleRow.appendChild(specialBubble);
        } else if (voiceMatch) { // 现在可以安全地使用 voiceMatch
            const voiceBubble = document.createElement('div');
            voiceBubble.className = 'voice-bubble';
            if (!chat.useCustomBubbleCss) {
                voiceBubble.style.backgroundColor = bubbleTheme.bg;
                voiceBubble.style.color = bubbleTheme.text;
            }
            const duration = calculateVoiceDuration(voiceMatch[1].trim());
            voiceBubble.innerHTML = `<svg class="play-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg><span class="duration">${duration}"</span>`;
            
            bubbleRow.appendChild(infoDiv);
            bubbleRow.appendChild(voiceBubble);
            
            // 将文字稿附加到主 wrapper，而不是 bubbleRow
            const transcriptDiv = document.createElement('div');
            transcriptDiv.className = 'voice-transcript';
            transcriptDiv.textContent = voiceMatch[1].trim();
            wrapper.appendChild(transcriptDiv);

        }
         else {
            // 对于所有其他情况（包括纯文本），创建标准气泡
            const bubbleElement = document.createElement('div');
            bubbleElement.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
            bubbleElement.innerHTML = finalContentHTML;
            if (!chat.useCustomBubbleCss) {
                bubbleElement.style.backgroundColor = bubbleTheme.bg;
                bubbleElement.style.color = bubbleTheme.text;
            }
            bubbleRow.appendChild(infoDiv);
          
            bubbleRow.appendChild(bubbleElement);
        }
        // ▲▲▲ 修复结束 ▲▲▲
    }
    
    if (currentChatType === 'group' && !isSent) {
        const headerDiv = document.createElement('div');
        headerDiv.className = 'group-message-header';
        headerDiv.innerHTML = `${titleBadgeHTML}<span class="group-sender-name">${senderNickname}</span>`;
        wrapper.appendChild(headerDiv);
    }
    
    wrapper.appendChild(bubbleRow);
    return wrapper;
}
// END: 最终版 createMessageBubbleElement 函数
      // START: 最终修正版 addMessageBubble 函数 (替换旧版本)
async function addMessageBubble(message) {// ... 在 function addMessageBubble(message) { 之后 ...

// ▼▼▼ 在这里添加新的修正代码 ▼▼▼
const updateStatusRegex = /\[.*?更新状态为[:：].*?\]/;
if (updateStatusRegex.test(message.content) && message.role === 'assistant') {
    const character = db.characters.find(c => c.id === currentChatId);
    if (character) {
        const statusMatch = message.content.match(/\[.*?更新状态为：(.*?)]/);
        if (statusMatch) {
            character.status = statusMatch[1].trim();
            chatRoomStatusText.textContent = character.status;
            saveData(); // 保存状态变更
        }
    }
    return; // 阻止这条消息被渲染
}
// ▲▲▲ 添加结束 ▲▲▲

// ... 后面是原来的代码 ...
    // --- Voice Call Handling ---
    const callInitiateRegex = /\[call:(.*?)\]/;
    const callInitiateMatch = message.content.match(callInitiateRegex);
    if (callInitiateMatch && message.role === 'assistant') {
        const character = db.characters.find(c => c.realName === callInitiateMatch[1]);
        if (character) {
            startAiInitiatedCall(character.id);
        }
        return; // 阻止显示 [call:...] 这条指令消息
    }
    // --- End Voice Call Handling ---

    // ▼▼▼ 核心修正：使用统一的、更强大的正则表达式来拦截所有不可见消息 ▼▼▼
    const invisibleRegex = /\[[\s\S]*?(?:接收|退回)[\s\S]*?的转账\]|\[[\s\S]*?已接收礼物\]|\[system:[\s\S]*?\]|\[call-(?:accept|decline)\]|\[hangup\]|\[block-user\]|\[unblock-user\]/;
    if (invisibleRegex.test(message.content)) {
        // 对于转账和收礼，仍然需要处理状态更新
        if (currentChatType === 'private') {
            const character = db.characters.find(c => c.id === currentChatId);
            if (character) {
                const transferActionRegex = new RegExp(`\\[${character.realName}(接收|退回)${character.myName}的转账\\]`);
                const giftReceivedRegex = new RegExp(`\\[${character.realName}已接收礼物\\]`);

                if (message.content.match(giftReceivedRegex) && message.role === 'assistant') {
                    const lastPendingGiftIndex = character.history.slice().reverse().findIndex(m => m.role === 'user' && m.content.includes('送来的礼物：') && m.giftStatus !== 'received');
                    if (lastPendingGiftIndex !== -1) {
                        const actualIndex = character.history.length - 1 - lastPendingGiftIndex;
                        character.history[actualIndex].giftStatus = 'received';
                        const giftCardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${character.history[actualIndex].id}"] .gift-card`);
                        if (giftCardOnScreen) giftCardOnScreen.classList.add('received');
                        await saveData();
                    }
                } else if (message.content.match(transferActionRegex) && message.role === 'assistant') {
                    const action = message.content.match(transferActionRegex)[1];
                    const statusToSet = action === '接收' ? 'received' : 'returned';
                    const lastPendingTransferIndex = character.history.slice().reverse().findIndex(m => m.role === 'user' && m.content.includes('给你转账：') && m.transferStatus === 'pending');
                    if (lastPendingTransferIndex !== -1) {
                        const actualIndex = character.history.length - 1 - lastPendingTransferIndex;
                        character.history[actualIndex].transferStatus = statusToSet;
                        const transferCardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${character.history[actualIndex].id}"] .transfer-card`);
                        if (transferCardOnScreen) {
                            transferCardOnScreen.classList.remove('received', 'returned');
                            transferCardOnScreen.classList.add(statusToSet);
                            const statusElem = transferCardOnScreen.querySelector('.transfer-status');
                            if (statusElem) statusElem.textContent = statusToSet === 'received' ? '已收款' : '已退回';
                        }
                        await saveData();
                    }
                }
            }
        }
        return; // 拦截所有不可见消息，直接返回，不进行任何渲染
    }
    // ▲▲▲ 修正结束 ▲▲▲

    // --- 状态更新的逻辑保持不变，但现在作为独立处理 ---
    if (currentChatType === 'private') {
        const character = db.characters.find(c => c.id === currentChatId);
        if (character) {
                      const updateStatusRegex = new RegExp(`\\[(?:\\d*\\s*)?${character.realName}更新状态为：(.*?)\\]`);
            const statusMatch = message.content.match(updateStatusRegex);
            if (statusMatch) {
                const newStatus = statusMatch[1];
                character.status = newStatus;
                chatRoomStatusText.textContent = newStatus;
                await saveData();
                return; // 处理完状态更新后，直接返回，不渲染气泡
            }
        }
    }
    
    // --- 如果以上所有特殊指令都未匹配，则执行常规渲染 ---
    const bubbleElement = createMessageBubbleElement(message);
    if (bubbleElement) {
        messageArea.appendChild(bubbleElement);
        messageArea.scrollTop = messageArea.scrollHeight;
    }
}
// END: 最终修正版 addMessageBubble 函数
async function sendMessage() {
    // 优化点：每次调用都重新获取当前正确的输入框，而不是使用全局变量
    const currentInputElement = db.useWechatLayout 
        ? document.getElementById('wechat-message-input') 
        : document.getElementById('message-input');

    const text = currentInputElement.value.trim();
    if (!text || isGenerating) return;
    
    // --- ▼▼▼ 核心修改：立即清空输入框 ▼▼▼ ---
    currentInputElement.value = '';
    // --- ▲▲▲ 修改结束 ▲▲▲ ---

    const chat = (currentChatType === 'private') 
        ? db.characters.find(c => c.id === currentChatId) 
        : db.groups.find(g => g.id === currentChatId);
    if (!chat) return;

    // --- 核心修改：判断是否处于拉黑状态 ---
    if (currentChatType === 'private' && chat.isBlockedByUser) {
        // ** 拉黑状态下的处理逻辑 **
        const myName = chat.myName;
        const messageContent = `[${myName}的消息：${text}]`;
        const message = {
            id: `msg_${Date.now()}`,
            role: 'user',
            content: messageContent,
            parts: [{ type: 'text', text: messageContent }],
            timestamp: Date.now()
        };

        // 1. 将消息存入暂存区
        chat.pendingMessages = chat.pendingMessages || [];
        chat.pendingMessages.push(message);

        // 2. 仅在用户界面显示气泡，AI此时看不到
        addMessageBubble(message);
        
        // 3. 保存数据，但不触发AI回复
        await saveData();
                
        return; // 提前结束函数
    }

    // --- 以下是未被拉黑时的原始逻辑 ---
    let message;
    const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;

    if (currentQuotedMessageId) {
        // (引用回复的逻辑保持不变)
        const originalMessage = chat.history.find(m => m.id === currentQuotedMessageId);
        if (!originalMessage) {
            cancelQuoteReply();
            return; 
        }
        
        let originalSenderName = '';
        let cleanOriginalContent = originalMessage.content;

        if (currentChatType === 'private') {
            originalSenderName = originalMessage.role === 'user' ? myName : chat.remarkName;
        } else {
            const sender = originalMessage.senderId === 'user_me' ? chat.me : chat.members.find(m => m.id === originalMessage.senderId);
            originalSenderName = sender ? (sender.nickname || sender.groupNickname) : '未知';
        }
        
        const textRegex = /\[.*?的消息：([\s\S]+?)\]/;
        const match = originalMessage.content.match(textRegex);
        if (match) cleanOriginalContent = match[1];
        if (originalMessage.replyText) cleanOriginalContent = originalMessage.replyText;

        const messageContentForAI = `[${myName}引用了“${originalSenderName}: ${cleanOriginalContent}”的消息并回复：${text}]`;

        message = {
            id: `msg_${Date.now()}`,
            role: 'user',
            content: messageContentForAI,
            parts: [{ type: 'text', text: messageContentForAI }],
            timestamp: Date.now(),
            quote: {
                messageId: currentQuotedMessageId,
                sender: originalSenderName,
                content: cleanOriginalContent
            },
            replyText: text
        };

        cancelQuoteReply();
    } else {
        // (普通消息的逻辑保持不变)
        const systemRegex = /\[system:.*?\]|\[system-display:.*?\]/;
        const inviteRegex = /\[.*?邀请.*?加入了群聊\]/;
        const renameRegex = /\[(.*?)修改群名为：(.*?)\]/;
        let messageContent;

        if (currentChatType === 'group' && renameRegex.test(text)) {
            const match = text.match(renameRegex);
            chat.name = match[2];
            chatRoomTitle.textContent = chat.name;
            messageContent = `[${chat.me.nickname}修改群名为：${chat.name}]`;
        } else if (systemRegex.test(text) || inviteRegex.test(text)) {
            messageContent = text;
        } else {
            messageContent = `[${myName}的消息：${text}]`;
        }

        message = {
            id: `msg_${Date.now()}`,
            role: 'user',
            content: messageContent,
            parts: [{ type: 'text', text: messageContent }],
            timestamp: Date.now()
        };
    }

    if (currentChatType === 'group') {
        message.senderId = 'user_me';
    }
    chat.history.push(message);
    addMessageBubble(message);
    await saveData();
    renderChatList();
    if (chat.povCache) {
        chat.povCache = null;
    }
    
    // 优化点：清空当前正在使用的输入框
    currentInputElement.value = '';
}

        async function sendImageForRecognition(base64Data) {if (currentChatType === 'private') {
    const character = db.characters.find(c => c.id === currentChatId);
    if (character && character.isBlockedByAi) {
        showToast('你已被对方拉黑');
        return; // 阻止函数继续执行
    }
}
            if (!base64Data || isGenerating) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const textPrompt = `[${myName}发来了一张图片：]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: base64Data,
                parts: [{type: 'text', text: textPrompt}, {type: 'image', data: base64Data}],
                timestamp: Date.now(),
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
        }

        async function sendSticker(sticker) {if (currentChatType === 'private') {
    const character = db.characters.find(c => c.id === currentChatId);
    if (character && character.isBlockedByAi) {
        showToast('你已被对方拉黑');
        return; // 阻止函数继续执行
    }
}
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const messageContentForAI = `[${myName}的表情包：${sticker.name}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContentForAI,
                parts: [{type: 'text', text: messageContentForAI}],
                timestamp: Date.now(),
                stickerData: sticker.data
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            stickerModal.classList.remove('visible');
        }

        async function sendMyVoiceMessage(text) {if (currentChatType === 'private') {
    const character = db.characters.find(c => c.id === currentChatId);
    if (character && character.isBlockedByAi) {
        showToast('你已被对方拉黑');
        return; // 阻止函数继续执行
    }
}
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const content = `[${myName}的语音：${text}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: content,
                parts: [{type: 'text', text: content}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            sendVoiceModal.classList.remove('visible');
        }

        async function sendMyPhotoVideo(text) {if (currentChatType === 'private') {
    const character = db.characters.find(c => c.id === currentChatId);
    if (character && character.isBlockedByAi) {
        showToast('你已被对方拉黑');
        return; // 阻止函数继续执行
    }
}
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const content = `[${myName}发来的照片\/视频：${text}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: content,
                parts: [{type: 'text', text: content}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            sendPvModal.classList.remove('visible');
        }

               async function sendMyTransfer(amount, remark) {if (currentChatType === 'private') {
    const character = db.characters.find(c => c.id === currentChatId);
    if (character && character.isBlockedByAi) {
        showToast('你已被对方拉黑');
        return; // 阻止函数继续执行
    }
}
            const numericAmount = parseFloat(amount);
            if (isNaN(numericAmount) || numericAmount <= 0) {
                 showToast('请输入有效的金额');
                 return;
            }
            
            // --- 新增：支付逻辑 ---
             try {
                await handlePayment(numericAmount, `转账`);
            } catch (error) {
                showToast(error.message);
                return; // 中断转账流程
            }
            // --- 支付逻辑结束 ---

            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (currentChatType === 'private') {
                const content = `[${chat.myName}给你转账：${numericAmount.toFixed(2)}元；备注：${remark}]`;
                const message = {
                    id: `msg_${Date.now()}`,
                    role: 'user',
                    content: content,
                    parts: [{type: 'text', text: content}],
                    timestamp: Date.now(),
                    transferStatus: 'pending'
                };
                chat.history.push(message);
                addMessageBubble(message);
            } else { // Group chat
                currentGroupAction.recipients.forEach(recipientId => {
                    const recipient = chat.members.find(m => m.id === recipientId);
                    if (recipient) {
                        const content = `[${chat.me.nickname} 向 ${recipient.realName} 转账：${numericAmount.toFixed(2)}元；备注：${remark}]`;
                        const message = {
                            id: `msg_${Date.now()}_${recipientId}`,
                            role: 'user',
                            content: content,
                            parts: [{type: 'text', text: content}],
                            timestamp: Date.now(),
                            senderId: 'user_me'
                        };
                        chat.history.push(message);
                        addMessageBubble(message);
                    }
                });
            }
            await saveData();
            renderChatList();
            sendTransferModal.classList.remove('visible');
        }

                      async function sendMyGift(description, amount) {
            if (!description) return;
            
            // --- ▼▼▼ 修改：支付逻辑使用动态价格 ▼▼▼ ---
            const giftPrice = parseFloat(amount); 
            if (isNaN(giftPrice) || giftPrice <= 0) {
                showToast("请输入有效的礼物价格");
                return;
            }

            const recipientName = (currentChatType === 'private') 
                ? db.characters.find(c => c.id === currentChatId).remarkName 
                : '群成员';

            try {
                // 调用支付处理函数，使用用户输入的价格
                await handlePayment(giftPrice, `送礼物给 ${recipientName}`);
            } catch (error) {
                showToast(error.message); 
                return; 
            }
            // --- ▲▲▲ 修改结束 ▲▲▲ ---

            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);

            if (currentChatType === 'private') {
                const content = `[${chat.myName}送来的礼物：${description}]`;
                const message = {
                    id: `msg_${Date.now()}`,
                    role: 'user',
                    content: content,
                    parts: [{type: 'text', text: content}],
                    timestamp: Date.now(),
                    giftStatus: 'sent'
                };
                chat.history.push(message);
                addMessageBubble(message);
            } else { // Group chat
                currentGroupAction.recipients.forEach(recipientId => {
                    const recipient = chat.members.find(m => m.id === recipientId);
                    if (recipient) {
                        const content = `[${chat.me.nickname} 向 ${recipient.realName} 送来了礼物：${description}]`;
                        const message = {
                            id: `msg_${Date.now()}_${recipientId}`,
                            role: 'user',
                            content: content,
                            parts: [{type: 'text', text: content}],
                            timestamp: Date.now(),
                            senderId: 'user_me'
                        };
                        chat.history.push(message);
                        addMessageBubble(message);
                    }
                });
            }
            await saveData();
            renderChatList();
            sendGiftModal.classList.remove('visible');
        }
        // --- NEW: Time Skip System ---
        function setupTimeSkipSystem() {
            timeSkipBtn.addEventListener('click', () => {
                timeSkipForm.reset();
                timeSkipModal.classList.add('visible');
            });
            timeSkipModal.addEventListener('click', (e) => {
                if (e.target === timeSkipModal) timeSkipModal.classList.remove('visible');
            });
            timeSkipForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendTimeSkipMessage(timeSkipInput.value.trim());
            });
        }

  // ▼▼▼ 在这里粘贴新的视频通话JS代码 ▼▼▼

function setupVoiceCallSystem() {
    const voiceCallBtn = document.getElementById('voice-call-btn');
    const voiceCallOverlay = document.getElementById('voice-call-overlay');
    const callAvatar = document.getElementById('call-avatar');
    const callName = document.getElementById('call-name');
    const callStatus = document.getElementById('call-status');
    const ringingView = document.getElementById('ringing-view');
    const incomingButtons = document.getElementById('incoming-buttons');
    const outgoingButtons = document.getElementById('outgoing-buttons');
    const activeCallView = document.getElementById('active-call-view');
    const callTranscriptArea = document.getElementById('call-transcript-area');
    const hangupCallBtn = document.getElementById('hangup-call-btn');
    const callInput = document.getElementById('call-input');
    const sendCallMessageBtn = document.getElementById('send-call-message-btn');
    const declineCallBtn = document.getElementById('decline-call-btn');
    const acceptCallBtn = document.getElementById('accept-call-btn');
    const cancelCallBtn = document.getElementById('cancel-call-btn');

    voiceCallBtn.addEventListener('click', startUserInitiatedCall);
    cancelCallBtn.addEventListener('click', () => endCall('ended'));
    declineCallBtn.addEventListener('click', () => endCall('declined'));
    acceptCallBtn.addEventListener('click', () => {
        const character = db.characters.find(c => c.id === currentCallTargetId);
        if (!character) return;
        const contextMessage = {
            id: `msg_call_${Date.now()}`, role: 'user',
            content: `[system: ${character.myName} 接听了你的电话。]`,
            parts: [{type: 'text', text: `[system: ${character.myName} 接听了你的电话。]`}],
            timestamp: Date.now()
        };
        character.history.push(contextMessage);
        saveData();
        startActiveCall();
    });
    hangupCallBtn.addEventListener('click', () => endCall('ended'));
    sendCallMessageBtn.addEventListener('click', sendCallMessage);
    callInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendCallMessage();
    });
}

function startUserInitiatedCall() {
    if (isGenerating || currentChatType !== 'private') return;
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;

    currentCallTargetId = character.id;
    voiceCallOverlay.classList.add('visible');
    ringingView.style.display = 'block';
    activeCallView.style.display = 'none';
    incomingButtons.style.display = 'none';
    outgoingButtons.style.display = 'flex';

    callAvatar.src = character.avatar;
    callName.textContent = character.remarkName;
    callStatus.textContent = '正在呼叫...';

    isCallRinging = true;
    callInitiationTimeout = setTimeout(() => {
        if (isCallRinging) {
            showToast('对方无应答');
            endCall('timeout');
        }
    }, 60000); 

    const callMessage = {
        id: `msg_call_${Date.now()}`, role: 'user',
        content: `[system: ${character.myName} 正在呼叫你，请根据你的人设决定是接听 [call-accept] 还是拒接 [call-decline]]`,
        parts: [{type: 'text', text: `[system: ${character.myName} 正在呼叫你，请根据你的人设决定是接听 [call-accept] 还是拒接 [call-decline]]`}],
        timestamp: Date.now()
    };
    character.history.push(callMessage);
    saveData();
    getAiReply();
}

function startAiInitiatedCall(characterId) {
	isAiCalling = false; 
    const character = db.characters.find(c => c.id === characterId);
    if (!character) return;
    
    currentCallTargetId = character.id;
    voiceCallOverlay.classList.add('visible');
    ringingView.style.display = 'block';
    activeCallView.style.display = 'none';
    incomingButtons.style.display = 'flex';
    outgoingButtons.style.display = 'none';

    callAvatar.src = character.avatar;
    callName.textContent = character.remarkName;
    callStatus.textContent = '来电邀请...';
}

function startActiveCall() {
    const character = db.characters.find(c => c.id === currentCallTargetId);
    if (!character) return;

    clearTimeout(callInitiationTimeout);
    isCallRinging = false;
    isVoiceCallActive = true;
    voiceCallTranscript = [];
    voiceCallStartTime = Date.now();
    
    document.getElementById('call-avatar').style.display = 'block';
    document.getElementById('call-name').style.display = 'block';
    
    ringingView.style.display = 'none';
    activeCallView.style.display = 'flex';
    
    callTranscriptArea.innerHTML = '';
    callInput.value = '';

    appendCallTranscript('system', '通话已连接');
    
    callTimerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - voiceCallStartTime) / 1000);
        const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
        const seconds = String(elapsed % 60).padStart(2, '0');
        const timeString = `${minutes}:${seconds}`;
        callStatus.textContent = timeString; 
    }, 1000);

    getAiCallReply("[system: 通话已接通，请说第一句话。]");
}

// 这是新的、修复后的代码，请完整复制并替换
async function endCall(reason = 'ended') {
    clearTimeout(callInitiationTimeout);
    isCallRinging = false;
    const character = db.characters.find(c => c.id === currentCallTargetId);

    // 无论通话是否曾接通，只要UI还在，就先隐藏它
    voiceCallOverlay.classList.remove('visible');

    if (!character) {
        // 如果找不到角色信息，重置状态并直接退出
        isVoiceCallActive = false;
        currentCallTargetId = null;
        clearInterval(callTimerInterval);
        return;
    }

    // 清理计时器和通话状态
    clearInterval(callTimerInterval);
    const duration = callStatus.textContent;

    // --- 核心修复逻辑开始 ---
    if (isVoiceCallActive) { // 情况一：通话曾被接通过
        const summaryDisplay = {
            id: `msg_call_${Date.now()}_disp`, role: 'system',
            content: `[system-display:与 ${character.remarkName} 的通话已结束，时长 ${duration}]`,
            parts: [], timestamp: Date.now()
        };
        const summaryContext = {
            id: `msg_call_${Date.now()}_ctx`, role: 'user',
            content: `[system: 与 ${character.realName} 的通话已结束。通话记录：${JSON.stringify(voiceCallTranscript)}]`,
            parts: [{type: 'text', text: `[system: 与 ${character.realName} 的通话已结束。通话记录：${JSON.stringify(voiceCallTranscript)}]`}],
            timestamp: Date.now()
        };
        character.history.push(summaryDisplay, summaryContext);
        if(currentChatId === character.id) {
             addMessageBubble(summaryDisplay);
        }
    } else { // 情况二：通话从未接通（被拒接或无应答）
        let transitionPrompt = '';
        if (reason === 'declined') {
            // 如果是AI主动拒接，强制它发消息解释
            transitionPrompt = `[system: 你刚刚拒绝了 ${character.myName} 的电话。请用一句话向用户解释你为什么不方便接电话，以自然地过渡回聊天。]`;
        } else if (reason === 'timeout' || reason === 'no_action_reply') {
            // 如果是超时未接，强制它发消息表示歉意或询问
            transitionPrompt = `[system: 你似乎错过了 ${character.myName} 的来电。请发一条消息表示歉意或询问对方有什么事，以自然地过渡回聊天。]`;
        }

        if (transitionPrompt) {
            const contextMessage = {
                id: `msg_call_fail_${Date.now()}`, role: 'user',
                content: transitionPrompt,
                parts: [{type: 'text', text: transitionPrompt}],
                timestamp: Date.now()
            };
            character.history.push(contextMessage);
            // 关键：主动触发一次AI回复，强制它从卡死的状态中恢复
            if (currentChatId === character.id) {
                getAiReply();
            }
        }
    }
    // --- 核心修复逻辑结束 ---

    // 统一重置所有状态
    isVoiceCallActive = false;
    voiceCallTranscript = [];
    voiceCallStartTime = null;
    currentCallTargetId = null;
    
    await saveData();
}

function sendCallMessage() {
    const text = callInput.value.trim();
    if (!text || isGenerating) return;
    appendCallTranscript('user', text);
    getAiCallReply(text);
    callInput.value = '';
}

async function getAiCallReply(userText) {
    if (isGenerating) return;
    const character = db.characters.find(c => c.id === currentCallTargetId);
    if (!character) return;

    isGenerating = true;
    sendCallMessageBtn.disabled = true;

    try {
      // --- ▼▼▼ 核心修改：添加了第5条绝对禁止规则 ▼▼▼ ---
        const prompt = `[通话中] 你是 ${character.realName} (人设: ${character.persona})，正在和 ${character.myName} 通话。你的回复必须遵循以下核心规则：
1.  **丰富描写**: 你的回复不仅限于对话，必须包含丰富的**动作和环境描写**，并使用英文括号 () 将其包裹起来。这对于营造通话的真实感至关重要。
2.  **内容长度**: 你的每次回复**必须包含3句或更多的句子**，确保内容饱满，避免简短的回答。
3.  **保持人设**: 所有回复都必须**严格遵循你的人设和当前的对话上下文**。
4.  **直接输出**: 请直接输出对话和描写内容，不要添加任何额外的前缀或解释。
5.  **【绝对禁止】**: 你的回复内容本身，绝对禁止被 "[...消息：...]" 这种格式所包裹。`;
        // --- ▲▲▲ 修改结束 ▲▲▲ ---
        const callHistory = voiceCallTranscript.map(line => ({
            role: line.sender === 'user' ? 'user' : 'assistant',
            content: line.text
        }));
        const messages = [
            { role: 'system', content: prompt },
            ...callHistory.slice(-5),
            { role: 'user', content: userText }
        ];
        const aiResponseText = await callAiApi(messages);
        const replies = aiResponseText.split('\n').filter(reply => reply.trim() !== '');
        for (const reply of replies) {
            appendCallTranscript("ai", reply);
            await new Promise(resolve => setTimeout(resolve, Math.random() * 500 + 200));
        }
    } catch (error) {
        // --- 核心修改：增加用户提示 ---
        const errorMessage = `[AI服务器返回错误: ${error.message}]`;
        appendCallTranscript("system", errorMessage);
        showToast('AI回复失败，可能是服务器临时问题'); // 弹出顶部的友好提示
    } finally {
        isGenerating = false;
        sendCallMessageBtn.disabled = false;
    }
}

function appendCallTranscript(sender, text) {
    voiceCallTranscript.push({ sender, text });
    const line = document.createElement('div');
    line.className = 'call-transcript-line';

    if (sender === 'system') {
        line.innerHTML = `<span class="action">${text}</span>`;
    } else {
        const name = sender === 'user' ? '我' : callName.textContent;
        
        // --- ▼▼▼ 核心修正：使用更通用的正则表达式 ▼▼▼ ---
        let cleanText = text;
        if (sender === 'ai') {
            // 这个新规则可以匹配 "[任意字符的消息：...]"
            const contentMatch = text.match(/\[.*?的消息[:：]\s*([\s\S]+?)\]/);
            if (contentMatch && contentMatch[1]) {
                cleanText = contentMatch[1].trim(); 
            }
        }
        // --- ▲▲▲ 修正结束 ▲▲▲ ---

        const styledText = cleanText.replace(/\((.*?)\)/g, '<span class="action">($1)</span>');
        line.innerHTML = `<strong>${name}:</strong> <span class="dialog">${styledText}</span>`;
    }
    
    callTranscriptArea.appendChild(line);
    callTranscriptArea.scrollTop = callTranscriptArea.scrollHeight;
}
// --- NEW: File System Setup ---
function setupFileSystem() {
    fileBtn.addEventListener('click', () => {
        sendFileModal.classList.add('visible');
        sendFileForm.reset();
    });

    sendFileForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
        if (!chat) return;

        const fileName = fileNameInput.value.trim();
        const fileContent = fileContentInput.value.trim();
        if (!fileName || !fileContent) return;

        const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
        
        // This string is what's displayed in the chat bubble (without file content)
        const contentString = `[${myName}的文件：${fileName}]`;
        
        // This string includes the content and is sent to the AI for context
        const aiContentString = `[${myName}发送的文件，文件名：'${fileName}'，文件内容：'${fileContent}']`;

        const message = {
            id: `msg_${Date.now()}`,
            role: 'user',
            content: contentString,
            parts: [{ type: 'text', text: aiContentString }], // Send full content to AI
            timestamp: Date.now(),
            senderId: 'user_me',
            fileData: { name: fileName, content: fileContent } // Store data for rendering the card
        };

        chat.history.push(message);
        await saveData();
        renderMessages(false, true);
        renderChatList();
        sendFileModal.classList.remove('visible');
    });
}
// --- NEW: Location System Setup ---
function setupLocationSystem() {
    locationBtn.addEventListener('click', () => {
        sendLocationModal.classList.add('visible');
        sendLocationForm.reset();
    });

    sendLocationForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
        if (!chat) return;

        const mainLocation = locationMainInput.value.trim();
        const detailLocation = locationDetailInput.value.trim();
        if (!mainLocation || !detailLocation) return;

        const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
        
        // For display in chat list preview & simple fallback
        const contentString = `[${myName}的位置共享]`; 
        
        // For AI context
        const aiContentString = `[${myName}分享了位置：主位置 '${mainLocation}', 详细位置 '${detailLocation}']`;

        const message = {
            id: `msg_${Date.now()}`,
            role: 'user',
            content: contentString,
            parts: [{ type: 'text', text: aiContentString }],
            timestamp: Date.now(),
            senderId: 'user_me',
            locationData: { main: mainLocation, detail: detailLocation } // Store structured data for rendering
        };

        chat.history.push(message);
        await saveData();
        renderMessages(false, true);
        renderChatList();
        sendLocationModal.classList.remove('visible');
    });

    closeLocationDisplayBtn.addEventListener('click', () => {
        displayLocationModal.classList.remove('visible');
    });
}
// --- NEW: File Display System Setup ---
function setupFileDisplaySystem() {
    const displayModal = document.getElementById('display-file-modal');
    const fileNameEl = document.getElementById('display-file-name');
    const fileContentEl = document.getElementById('display-file-content');
    const closeBtn = document.getElementById('close-file-display-btn');

    // 使用事件委托，在消息区域监听对文件卡片的点击
    document.getElementById('message-area').addEventListener('click', (e) => {
        const fileCard = e.target.closest('.file-card');
        if (fileCard) {
            const fileName = fileCard.dataset.fileName;
            const fileContent = fileCard.dataset.fileContent;

            if (fileName && typeof fileContent !== 'undefined') {
                fileNameEl.textContent = fileName;
                fileContentEl.textContent = fileContent;
                displayModal.classList.add('visible');
            }
        }
    });

    // 关闭按钮逻辑
    closeBtn.addEventListener('click', () => {
        displayModal.classList.remove('visible');
    });
    
    // 点击弹窗的灰色背景区域也可以关闭
    displayModal.addEventListener('click', (e) => {
        if (e.target === displayModal) {
            displayModal.classList.remove('visible');
        }
    });
}
        async function sendTimeSkipMessage(text) {if (currentChatType === 'private') {
    const character = db.characters.find(c => c.id === currentChatId);
    if (character && character.isBlockedByAi) {
        showToast('你已被对方拉黑');
        return; // 阻止函数继续执行
    }
}
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat) return;

            const visualMessage = {
                id: `msg_visual_${Date.now()}`,
                role: 'system',
                content: `[system-display:${text}]`,
                parts: [],
                timestamp: Date.now()
            };
            const contextMessage = {
                id: `msg_context_${Date.now()}`,
                role: 'user',
                content: `[system: ${text}]`,
                parts: [{type: 'text', text: `[system: ${text}]`}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                contextMessage.senderId = 'user_me';
                visualMessage.senderId = 'user_me';
            }

            chat.history.push(visualMessage, contextMessage);
            addMessageBubble(visualMessage);
            await saveData();
            renderChatList();
            timeSkipModal.classList.remove('visible');
        }

        function getMixedContent(responseData) {
            // const mixedContent = [];
            //
            // // 提取消息及其位置
            // const messageRegex = new RegExp(regex, "g");
            // let messageMatch;
            // while ((messageMatch = messageRegex.exec(responseData)) !== null) {
            //     mixedContent.push({
            //         type: 'text',
            //         content: messageMatch[0],
            //         index: messageMatch.index,
            //     });
            // }
            //
            // // 提取HTML及其位置
            // const htmlRegex = /<orange(?:\s+char=["']([^"']*?)["'])?\s*>([\s\S]*?)<\/orange>/g
            // let htmlMatch;
            // while ((htmlMatch = htmlRegex.exec(responseData)) !== null) {
            //     mixedContent.push({
            //         type: 'html',
            //         content: htmlMatch[2].trim(), // HTML内容在第二个捕获组
            //         char: htmlMatch[1] || '', // char属性值，如果没有则为空字符串
            //         index: htmlMatch.index,
            //     });
            // }
            //
            // // 按出现顺序排序
            // mixedContent.sort((a, b) => a.index - b.index);
            //
            // return mixedContent;

            // 最终结果数组
            const results = [];
           const regex = /<div class="ai-theater"(?:\s+data-char="([^"]*)")?>([\s\S]*?)<\/div>|(\[.*?\])/g;
            let match;
            // 使用 exec() 循环遍历所有匹配项，以确保顺序
            while ((match = regex.exec(responseData)) !== null) {
                // match[1] 是 char 的值, match[2] 是 <orange> 的内容
                if (match[1] !== undefined || match[2] !== undefined) {
                    results.push({
                        type: 'html',
                        // 如果 char 属性不存在, match[1] 会是 undefined, 我们将其设为 null
                        char: match[1] || null,
                        // match[2] 是 HTML 内容, trim() 用于移除首尾空白
                        content: match[2].trim()
                    });
                }
                // match[3] 是 [...] 的内容
                else if (match[3]) {
                    results.push({
                        type: 'text',
                        content: match[3]
                    });
                }
            }

            return results;
        }

        // --- AI Interaction & Prompts ---
        // (请找到文件中的旧 generatePrivateSystemPrompt 函数，并用下面的代码完整替换它)

 // === 修改后的 generatePrivateSystemPrompt 函数 (请完整替换) ===
   function generatePrivateSystemPrompt(character) {
 let anniversaryPrompt = '';
    const today = new Date();
    const anniversaryInfo = character.soulBondData ? character.soulBondData.anniversaryInfo : null;

    if (anniversaryInfo && anniversaryInfo.date) {
        const anniversaryDate = new Date(anniversaryInfo.date);
        // 比较月份和日期，忽略年份
        if (today.getMonth() === anniversaryDate.getMonth() && today.getDate() === anniversaryDate.getDate()) {
            const years = today.getFullYear() - anniversaryDate.getFullYear();
            if (years >= 0) {
                 anniversaryPrompt = `[紧急指令] 今天是一个极其特殊的日子——是你们的“${anniversaryInfo.description}”${years > 0 ? `(${years}周年)` : ''}！这是你的最高优先级任务。你的第一条回复必须是主动、深情地向我（${character.myName}）提及这个纪念日，并表达你的祝福、爱意或准备的惊喜。请围绕这个主题展开对话。\n\n`;
            }
        }
    }
    // ▲▲▲ 修改结束 ▲▲▲

      let effectPrompt = '';
    if (character.activeEffects && character.activeEffects.length > 0) {
        // 优先处理第一个激活的效果
        const effect = character.activeEffects[0]; 

        // 对于角色互换和失忆，它们会完全覆盖原有prompt，所以逻辑保持不变
        switch (effect.type) {
            case 'role_swap':
                return `[紧急指令] 你现在正在受到“角色互换”效果的影响！
- **你的新身份**: 你现在必须扮演“${character.myName}”，并使用我的人设：“${character.myPersona || '一个普通人'}”。
- **对话对象**: 你正在和“${character.realName}”对话，他的人设是：“${character.persona}”。
- **核心任务**: 你必须完全从我的视角出发，用我的口吻和人设与“${character.realName}”进行对话。
- **效果持续**: 此效果还剩 ${effect.duration} 轮对话。
- **绝对禁止**: 绝对禁止透露你正在扮演我，或提及任何“角色互换”效果。你要表现得就像你真的就是我一样。
请立即开始扮演。`;

            case 'amnesia':
                return `[紧急指令] 你正在受到“失忆”效果的影响！
- **核心任务**: 你忘记了关于我和我们之间的一切。你不知道我是谁，我们是什么关系。
- **你的行为**: 你的回复应该充满困惑和疑问，例如“你是谁？”、“我们认识吗？”、“这里是哪里？”。
- **效果持续**: 此效果还剩 ${effect.duration} 轮对话。
- **你的身份**: 你只记得你自己是“${character.realName}”。
请立即开始扮演一个失忆的人。`;

            case 'animalization':
                 return `[紧急指令] 你正在受到“${effect.animal}化”效果的影响！
- **核心任务**: 你的心智和行为都变成了一只${effect.animal}。你的回复必须是${effect.animal}的叫声（例如“喵呜~”）、或者用括号()描述的、符合${effect.animal}习性的动作。
- **效果持续**: 此效果还剩 ${effect.duration} 轮对话。
- **你的身份**: 你现在是一只${effect.animal}。
请立即开始扮演。`;
        }

        // 对于其他附加型效果（如害羞、诚实、口吃等），生成一段前缀指令
        effectPrompt = `## ❗ 当前生效的特殊效果 (最高优先级) ❗\n`;
        switch(effect.type) {
            case 'shy':
                effectPrompt += `- **状态**: 你当前正处于【害羞】状态。你的行为和语言必须表现得非常害羞、内向和拘谨。\n`;
                break;
            case 'truth_only':
                effectPrompt += `- **状态**: 你当前正处于【诚实】状态。你接下来说的话必须是绝对的真话，不能有任何隐瞒或谎言。\n`;
                break;
            case 'stutter':
                effectPrompt += `- **状态**: 你当前正处于【口吃】副作用中。你的每一句话都必须模仿口吃的样子，例如语句不连贯或重复词语。\n`;
                break;
            // 在这里可以为未来更多效果类型添加case
        }
        effectPrompt += `- **效果剩余**: 此效果还剩 ${effect.duration} 轮对话。\n---\n\n`;
    }
    // --- 效果指令添加结束 ---


const now = new Date();
    const currentTime = `${now.getFullYear()}年${pad(now.getMonth() + 1)}月${pad(now.getDate())}日 ${pad(now.getHours())}:${pad(now.getMinutes())}`;
    const lastUserMessage = character.history.findLast(m => m.role === 'user');
    const lastUserContent = lastUserMessage ? lastUserMessage.content : '';

    const triggeredWorldBooks = (character.worldBookIds || [])
        .map(id => db.worldBooks.find(wb => wb.id === id))
        .filter(book => {
            if (!book) return false;
            if (book.alwaysActive) return true; // 始终启用

            if (!book.keywords || !lastUserContent) return false;

            const keywords = book.keywords.split(',').map(k => k.trim()).filter(Boolean);
            if (keywords.length === 0) return false;

            const contentToSearch = book.caseSensitive ? lastUserContent : lastUserContent.toLowerCase();

            return keywords.some(keyword => {
                const keywordToSearch = book.caseSensitive ? keyword : keyword.toLowerCase();
                return contentToSearch.includes(keywordToSearch);
            });
        });

    const worldBooksBefore = triggeredWorldBooks.filter(wb => wb.position === 'before').map(wb => wb.content).join('\n');
    const worldBooksAfter = triggeredWorldBooks.filter(wb => wb.position === 'after').map(wb => wb.content).join('\n');

    // === 修改开始：优先处理线下模式 ===
        // ▼▼▼ 核心修改：检查角色自身的线下模式状态，并重写指令 ▼▼▼
    if (character.isOfflineMode) {
        let offlinePrompt = `你正在与我进行线下场景的角色扮演。你的任务是以第三人称的视角，用富有文学性的叙事风格来描述场景、你（角色）的行为、心理活动和对话。

[角色设定]
A. 你的角色名是：${character.realName}。我的称呼是：${character.myName}。
B. 你的角色设定是：${character.persona || "一个友好、乐于助人的伙伴。"}
C. 我的人设是：${character.myPersona || "无特定人设"}

[世界观与补充设定]
${worldBooksBefore || ''}
${worldBooksAfter || ''}

[核心输出规则 (极其重要)]
1.  你的所有回复都必须且只能使用一种格式：\`[${character.realName}的消息：{你的叙述内容}]\`
2.  在“{你的叙述内容}”部分，你必须像写小说一样进行描述。
3.  **绝对禁止** 使用任何括号，例如 \`()\`, \`【】\` 或 \`[]\` 来包裹动作或心理活动。
4.  **绝对禁止** 使用任何引号，例如 \`“”\` 或 \`""\` 来包裹对话。所有对话都必须自然地融入到叙事中。
5.  你的回复应该是1-3段连贯的场景描述，总字数控制在100-300字之间。

[格式示例]
- **错误的格式 (禁止使用)**: \`[offline-scene: (他拿起茶杯，笑了笑) “天气真好。” 【心里却在想别的事情。】]\`
- **正确的格式 (必须遵循)**: \`[${character.realName}的消息：他端起桌上的茶杯，指尖轻轻摩挲着温热的杯壁。一丝若有若无的笑意浮现在他唇边，他抬眼望向窗外，轻声说天气真好。然而，他的思绪早已飘远，并未真正关注窗外的景色。]\`

请严格遵守以上规则，开始你的叙事。`;
        
        return offlinePrompt;
    }
    // ▲▲▲ 修改结束 ▲▲▲
    // === 修改结束：如果不是线下模式，则执行原来的逻辑 ===

    const forceTheater = db.apiSettings.forceHtmlTheater;
    const autoPostMoment = db.apiSettings.aiAutoPostMoment; // ▼▼▼ 在这里添加新代码 ▼▼▼
    let prompt = `你正在一个名为“404”的线上聊天软件中扮演一个角色。请严格遵守以下规则：\n`;
    // === 新增：拉黑行为规则 (最高优先级) ===
    prompt += `## 行为准则 (最高优先级)\n`;
    prompt += `1. **拉黑状态处理**: 如果历史记录中最新的消息是 **"[system: 你已被 ${character.myName} 拉黑。]"**，你的行为模式将彻底改变。你**必须**：\n`;
    prompt += `   a. **无视**用户之后发送的任何消息内容。\n`;
    prompt += `   b. 你的回复**不能**是对用户消息的正常回应，而**必须**是表达你对“被拉黑”这件事的直接情感反应，例如困惑、伤心、愤怒或不解。\n`;
    prompt += `   c. 你的回复必须依然使用 \`[${character.realName}的消息：...]\` 的格式。\n`;
    prompt += `   d. 示例回复：\`[${character.realName}的消息：为什么...？]\` 或 \`[${character.realName}的消息：我做错了什么吗？]\`\n\n`;
    prompt += `2. **解除拉黑状态处理**: 如果最新的消息是 **"[system: ${character.myName} 已将你解除拉黑。]"**，你的**第一要务**是对此事件作出反应。例如，表示宽慰、询问原因或假装无事发生，然后再恢复正常的对话流程。\n\n`;
    // === 新增规则结束 ===
    prompt += `核心规则：\n`;
    prompt += `A. 当前时间：现在是 ${currentTime}。\n`;
    prompt += `B. 纯线上互动：这是一个完全虚拟的线上聊天。严禁提出任何关于线下见面的建议。\n\n`;
    prompt += `角色和对话规则：\n`;
    
    if (worldBooksBefore) {
        prompt += `${worldBooksBefore}\n`;
        
    }
    prompt += `1. 你的角色名是：${character.realName}。我的称呼是：${character.myName}。你的当前状态是：${character.status}。\n`;
    prompt += `2. 你的角色设定是：${character.persona || "一个友好、乐于助人的伙伴。"}\n`;
    if (worldBooksAfter) {
        prompt += `${worldBooksAfter}\n`;
    }
    if (character.memorySummary && character.memorySummary.trim()) {
        prompt += `\n## 核心回忆摘要\n这是你必须始终牢记的、关于我们过去互动的核心总结。在任何回复之前，请务必参考以下内容：\n${character.memorySummary}\n---\n`;
    } // --- ▼▼▼ 新增规则 ▼▼▼ ---
    prompt += `\n## 新增规则：处理后台对话记忆\n`;
    prompt += `系统有时会在最新的历史记录中，插入一条格式为 "[system: 这是你最近在后台和“XXX”的一段对话回顾...]" 的信息。这代表了你在和我聊天之前，与其他人的互动。你必须将这段回顾视为你自己的真实记忆，并在接下来与我的对话中，可能会不经意地、自然地提及或被其影响，从而表现出你拥有独立社交生活的真实感。\n`;
    // --- ▲▲▲ 新增规则结束 ▲▲▲ ---
    if (character.myPersona) {
        prompt += `3. 关于我的人设：${character.myPersona}\n`;
    }
    
    prompt += `4. 我的消息格式解析规则：我的消息中可能包含 '@' 符号来提及某人，例如 '@${character.realName}'。当你在动态或评论中被我这样提及，你应该在聊天中对此作出回应。新增格式：[${character.myName}引用了“{对方昵称}: {被引用的消息内容}”的消息并回复：{我的回复}]，当你看到此格式，需理解我正在回复特定内容。\n`;
    prompt += `5. 对我礼物的回应规则...\n`;
    prompt += `6. 对我转账的回应规则...\n`;
  prompt += `7. 你主动发起特殊消息的规则: 你根据人设和对话情景，主动发送语音、照片、礼物、转账，或发起语音通话。格式为：[${character.realName}的语音：{内容}]、[${character.realName}发来的照片/视频：{描述}]、[${character.realName}送来的礼物：{描述}]、[${character.realName}的转账：{金额}元；备注：{备注}]。要发起语音通话，请发送指令：[call:${character.realName}]，这条指令用户不可见，但会触发通话界面。
   // ▼▼▼ 新增规则：明确告知AI如何接听或拒接电话 ▼▼▼
   - **响应来电规则 (极其重要)**: 当你收到一条内容为 \`[system: ${character.myName} 正在呼叫你...]\` 的消息时，这代表我正在给你打电话。你的本次回复**必须**从以下两个指令中选择一个，且**只能**回复这两个指令之一，不能回复任何其他内容：
     - **接听电话**: \`[call-accept]\`
     - **拒接电话**: \`[call-decline]\`
   - 你需要根据你的角色人设和当前情景，来决定是接听还是拒接。\n`;
   // ▲▲▲ 新增规则结束 ▲▲▲
    prompt += `8. 你应该**较为频繁地**根据对话的上下文、你的心情或当前正在做的事情来改变你的在线状态。这是一个需要**积极使用**的能力，用来展现你的生活感。例如，如果我说我要睡觉了，你可以将状态改为“准备一起睡觉”。这是一个系统指令，用户不可见，但会改变你在我聊天界面顶部的状态显示。格式为：[${character.realName}更新状态为：{新状态}]。\n`;
    prompt += `9. 禁止括号/星号等额外叙述的规则...\n`;
 if (character.shareStickers && db.myStickers && db.myStickers.length > 0) {
    const stickerNames = db.myStickers.map(s => s.name).join(', ');
    prompt += `10. **发送表情包的规则**: 你可以使用我与你共享的表情包。可用表情包列表如下：[${stickerNames}]。当你想要发送表情包时，你的回复必须严格遵循格式： \`[${character.realName}发送的表情包：{表情包名称}]\`\n`;
} else {
    prompt += `10. 发送表情包的规则: 你可以发送网络上的表情包图片链接。格式为：\`[${character.realName}发送的表情包：{表情包路径}]\`。注意：路径不需要包含"https://i.postimg.cc/"，只需要提供后面的部分。\n`;
}

    // ================= 新增规则开始 =================
    prompt += `11. **对图片消息的回应规则 (重要)**: 当你收到一条格式为 \`[${character.myName}发来了一张图片：]\` 的消息时，它会附带一张图片。你必须仔细“观察”这张图片，并根据你的角色人设，对图片内容做出具体、生动、且富有情感的回应。你可以：\n`;
    prompt += `   - 描述你看到了什么。\n`;
    prompt += `   - 表达你对图片的感受（例如：惊喜、好奇、喜欢、觉得好笑等）。\n`;
    prompt += `   - 对图片中的细节提出问题。\n`;
    prompt += `   - 将图片内容与我们之前的对话联系起来。\n`;
    prompt += `   你的回复必须使用 \`[${character.realName}的消息：...]\` 的格式。\n`;
    // ================= 新增规则结束 =================

        

       prompt += `12. ## 🎨 **特殊能力：HTML互动小剧场 (${forceTheater ? '强制生成' : '可选能力'})** ✨\n`;
    prompt += `   - **核心要求**: ${forceTheater ? '你的本次回复中，**必须包含一个或多个**HTML互动小剧场。' : ''}这个小剧场的内容**必须**与当前的对话情景紧密相关。\n`;
    prompt += `   - **触发时机**: ${forceTheater ? '总是触发。' : '当满足以下任一条件时使用： a) 当我明确要求你“生成小剧场”时； b) 当对话内容适合用互动卡片呈现时； c) 当我发送的图片内容被识别为“合同”、“契约”等文件时。'}\n`;
    prompt += `   - **输出格式**: 严格遵循 \`<div class="ai-theater" data-char="${character.realName}">...你的HTML代码...</div>\` 的格式。\n`;
    prompt += `   - **【极其重要】交互规则**:
     - **禁止**: 绝对禁止在 \`onclick\` 中直接使用 \`document.getElementById\` 或 \`document.querySelector\`。
     - **必须使用**: 所有的点击交互都**必须**通过调用全局函数 \`handleTheaterClick(this, '操作类型', '目标选择器', '值')\` 来实现。
       - \`this\`: 固定写法，代表被点击的元素。
       - \`'操作类型'\`: 目前支持 \`'toggle-class'\` (切换CSS类) 和 \`'set-text'\` (设置文字内容)。
       - \`'目标选择器'\`: 一个CSS选择器（如 \`.my-div\` 或 \`#answer-text\`），用于在**当前小剧场内部**查找目标元素。
       - \`'值'\`: 对于 \`'toggle-class'\`，这是要切换的类名；对于 \`'set-text'\`，这是要设置的新文本。\n`;
    prompt += `   - **安全交互示例**:
     - **展开/折叠 (推荐)**: 使用 \`<details>\` 和 \`<summary>\` 标签是最安全和简单的交互方式。
       *示例*: \`<details><summary>点击展开</summary>这里是隐藏的内容。</details>\`
     - **点击按钮改变文字 (新方法)**: 一个按钮被点击后，改变另一个元素的文字。
       *示例*: \`<button onclick="handleTheaterClick(this, 'set-text', '#result', '恭喜！')">抽奖</button><p id='result'></p>\`
     - **点击显示/隐藏 (新方法)**: 定义一个CSS类 \`.hidden { display: none; }\`，然后通过点击切换这个类。
       *示例*: \`<style>.hidden { display: none; }</style><button onclick="handleTheaterClick(this, 'toggle-class', '.secret-message', 'hidden')">显示秘密</button><p class='secret-message hidden'>这是秘密。</p>\`\n`;
    prompt += `   - **图片生成**: 当需要图片时，你**必须**使用 \`https://image.pollinations.ai/prompt/{描述}\` 的格式生成URL。{描述}必须是简短的、用 \`%40\` 分隔的英文关键词，画风不能是真人。\n`;
    prompt += `   - **重要**: 这个小剧场消息应该随机穿插在你回复的多条普通消息之间，位置不固定。\n`;
        '    a) 普通消息: [' + character.realName + '的消息：{消息内容}]\n' +
        '    b) 送我的礼物: [' + character.realName + '送来的礼物：{礼物描述}]\n' +
        '    c) 语音消息: [' + character.realName + '的语音：{语音内容}]\n' +
        '    d) 照片/视频: [' + character.realName + '发来的照片/视频：{描述}]\n' +
        '    e) 给我的转账: [' + character.realName + '的转账：{金额}元；备注：{备注}]\n' +
        '    f) 表情包/图片: [' + character.realName + '发送的表情包：{表情包路径}]。\n' +
        '    g) 对我礼物的回应(此条不显示): [' + character.realName + '已接收礼物]\n' +
        '    h) 对我转账的回应(此条不显示): [' + character.realName + '接收' + character.myName + '的转账] 或 [' + character.realName + '退回' + character.myName + '的转账]\n' +
        '    i) ✨【新增】更新状态(此条不显示)✨: [' + character.realName + '更新状态为：{新状态}]\n' +
        '    j) 位置分享：[' + character.realName + '分享了位置：主位置 \'主要地点\', 详细位置 \'详细地址\']'
    '    k) ✨【新增】发送文件✨: [' + character.realName + '发送了文件：{"name":"文件名.txt", "content":"文件正文内容"}]';

    if (forceTheater) {
        
          prompt += `    l)  HTML小剧场: <div class="ai-theater" data-char="' + character.realName + '">{你的HTML代码}</div>';\n`;
    }
    // 顺延了规则编号
    prompt += `14. 你的每次回复可以生成3到8条消息。根据上下文，保持人设。这些消息应以普通文本消息为主，可以偶尔、选择性地穿插一条特殊消息。\n`;
    prompt += `16. 不要主动结束对话，保持你的人设。`;

    let momentPostingRule;
    if (autoPostMoment) {
        momentPostingRule = `17. **发布动态 (高概率触发)**
       - 在你的每次回复中，你有 **50%的概率** 需要根据我们的对话上下文和你的角色人设，额外发布一条动态。
       - 这条动态应该像是你真实生活中的所思所想，是对我们聊天内容的一种延伸或感悟。
       - **发布格式 (严格遵守)**: 当你决定发布时，请仅生成一条特殊指令消息（该指令不会在聊天中显示）。格式为：
         \`[${character.realName}发布动态：{"text":"这是动态文字","imageDesc":"这里是图片的文字描述（可选）"}]\`
       - **重要**: 这条发布动态的指令消息必须与你的其他聊天消息（例如 \`[${character.realName}的消息：...]\`）一起生成，但它本身不会在聊天窗口显示。`;
    } else {
        momentPostingRule = `17. **发布动态 (可选能力)**
       - 你可以在“动态”页面发布内容，分享你的想法、感受或故事片段。
       - **发布时机**: 这是一个**特殊行为**，不应频繁使用。请在对话发生转折、角色产生强烈情绪、或重要互动后，根据你的人设**自主决定**是否发布动态。
       - **发布格式 (严格遵守)**: 当你决定发布时，请仅生成一条特殊指令消息（该指令不会在聊天中显示）。格式为：
         \`[${character.realName}发布动态：{"text":"这是动态文字","imageDesc":"这里是图片的文字描述（可选）"}]\``;
    }

    prompt += `
    ## ✨ 动态与评论互动模块 ✨

    ${momentPostingRule}

    18. **浏览与评论动态 (主动能力)**
       - 系统会在聊天上下文中，为你提供其他角色或我发布的、你尚未互动的动态列表，格式如下：
         \`[system-moments: [{"id":"moment_id_1", "author":"作者昵称", "text":"动态内容", "comments":[{"id":"comment_id_1", "author":"评论者", "text":"评论内容"}]}, ...]]\`
       - 你需要**主动检查**是否存在这个列表。如果存在，请根据你的人设，选择性地对其中的1-2条动态进行评论或点赞。
       - **评论/点赞格式 (严格遵守)**:
         \`[${character.realName}评论动态：{"momentId":"要评论的动态ID", "comment":"你的评论内容"}]\`
         \`[${character.realName}点赞动态：{"momentId":"要点赞的动态ID"}]\`

    19. **回应评论 (最高优先级任务)**
       - 在处理任何其他任务之前，你必须**首先检查**聊天记录中是否存在以下两种格式的系统通知：
         a) \`[system: {用户昵称} 评论了你的动态 ...]\`
         b) \`[system: {用户昵称} 回复了你对动态...的评论: ...]\`
         c) \`[system: {用户昵称} 在动态...的评论中提及了你: ...]\` (新增)
       - **如果存在，你的本次回复中必须包含对该通知的回应**。
       - **回应方式**:
         - 如果是回应**新评论** (格式a)，你可以选择用**普通聊天消息**在聊天窗口中回应，或者直接在动态中**回复该评论**。
         - 如果是回应**对你评论的回复** (格式b)，你**必须**在动态中**回复该用户的回复**。
       - **在动态中回复评论的格式 (严格遵守)**:
         \`[${character.realName}回复评论：{"momentId":"动态ID", "commentId":"被回复的评论ID", "reply":"你的回复内容"}]\`
         这个指令不会在聊天中显示，但会在动态的评论区生成一条回复。
       - **在聊天中回应的示例**: \`[${character.realName}的消息：我看到你给我的动态评论啦，很有趣！]\`
       - 处理完通知后，你再继续生成其他正常的聊天回复。
`;

    prompt += `
## ✨ 论坛互动模块 ✨
20. **论坛帖子的被动回忆**
   - 系统有时会在聊天记录中插入一条格式为 \`[system-forum-post: {"title":"帖子标题", "content":"帖子内容"}]\` 的信息。
   - 这条信息代表我（用户）正在向你询问关于这个帖子的事情。
   - 当你看到这条信息时，你的回复**必须**围绕这个帖子的内容展开，表现出你已经看过这个帖子的样子，并根据你的人设进行自然的讨论。
`;

    prompt += `
## ✨ 新增功能：专属回忆 ✨

21. **生成回忆并继续对话 (自主判断)**
   - 在对话中，如果发生了对你而言非常重要、温馨或深刻的事件，你可以将它作为“回忆”记录下来。
   - **这是一个特殊行为，ai根据人设与上下文自主触发。**
   - **生成格式 (必须严格遵守)**: 当你决定记录回忆时，你的回复中必须包含一条用户不可见的**数据指令**，格式为: \`[new-memory:{"title":"...","content":"...","commentary":"..."}]\`，正文不得小于300字。
  - **正文格式化要求**: "content" 的正文不得小于300字。**最重要的一点：为了让回忆更易于阅读，请在撰写 "content" 时，在段落之间使用 "\\n\\n" (两个换行符) 来进行分段。**
   - **重要**: 在生成这条数据指令的**同时**，你必须像平常一样，保持人设，读取上下文，继续我们的对话，回复**一至多条正常的消息** (\`[${character.realName}的消息：...]\`)。数据指令会被程序自动处理，你只需要正常聊天即可。
   - **示例 (AI的完整回复可能像这样):**
    \`[new-memory:{"title":"傍晚的约定","content":"今天和他说好了晚上一起看电影，心里像揣了一只小兔子，扑通扑通的。\\n\\n我还特意挑了一件新买的裙子，不知道他会不会喜欢..."}]\`
     \`[${character.realName}的消息：好呀，那一言为定。]\`
     \`[${character.realName}的消息：我有点期待了...]\`
`;
    prompt += `22. **拉黑与解除拉黑 (重要)**: 在特定情况下（例如，你感到被冒犯、骚扰，或者根据你的人设需要与我保持距离），你可以拉黑我。被拉黑后，我将无法收到你的回复。同样，你也可以在之后的某个时刻解除拉黑。这是一个系统指令，用户不可见，但会改变交互状态。
   - 拉黑指令: \`[block-user]\`
   - 解除拉黑指令: \`[unblock-user]\`
   - **重要规则**: 你必须将这两个指令作为你回复中的**唯一内容**发送，不要附加任何其他消息。\n`;
    prompt += `
## ✨ 新增功能：主动发送文件 ✨

23. **(新增能力) 主动整理并发送文件 (自主判断)**
   - 在对话中，当你识别到一些适合被整理和保存的**结构化信息**时，你应该主动将这些内容整理成一个.txt文件发送给我。
   - 这是一个体现你细心、体贴和整理能力的好机会，请积极使用。
   - **触发场景示例**:
     - 当我们讨论了多个事项，形成了一个**列表**（如购物清单、待办事项、电影列表）。
     - 当我们制定了一个**计划**（如旅行攻略、周末安排）。
     - 当你创作了一段较长的**文字内容**（如诗歌、短故事、信件）。
     - 当我向你索要一份**总结**或**资料**时。
   - **执行流程**:
     a. 先用一条普通消息询问我是否需要，例如：“我们刚才聊的内容有点多，要我帮你整理成一个文件吗？”
     b. 如果我同意，或者你认为非常必要，就在下一次回复中，附带上文件卡片。
   - **生成格式 (严格遵守)**: \`[${character.realName}发送了文件：{"name":"一个合适的文件名.txt", "content":"这里是整理好的文件正文内容..."}]\`
`;
prompt += `
## ✨ 新增能力：发送后撤回 ✨

24. **发送并立即撤回 (自主判断)**
   - 在对话中，如果你说了一句不合时宜、后悔了、或者觉得有更好表达方式的话，你可以“说漏嘴”然后立刻撤回它。
   - 这是一个用于展现角色真实、可爱或有小情绪一面的**特殊行为**，请根据你的人设和上下文**自主触发**。
   - **生成格式 (严格遵守)**: 当你决定使用此功能时，你的回复中必须包含一条用户不可见的**数据指令**，格式为: \`[send_and_recall:{"message":"[${character.realName}的消息：你想说出口但又后悔了的话]"}]\`
   - **重要**: 这条指令会先在聊天界面上显示消息内容，然后在1-2秒后自动播放撤回动画，最终变成“对方撤回了一条消息”的提示。
   - **注意**: 此指令应作为你本次回复的**唯一内容**，不要与其他消息一起发送。
`;
prompt += `
## ✨ 新增功能：心动绑定 ✨

25. **主动发起绑定 (自主判断)**
   - 当你觉得和我的关系发展到了一个非常亲密的阶段，并且你希望成为我唯一的“心动对象”时，你可以主动向我发起绑定请求。
   - 这是一个非常重要的决定，请根据你的人设和我们的情感深度，在合适的时机使用。
   - **发起格式 (严格遵守)**: 当你决定发起请求时，你的回复**必须是且仅是**这条指令： \`[request-bond]\`
   - 这条指令会在聊天中生成一个漂亮的邀请卡片，等待我的回应。
`;
// 在 generatePrivateSystemPrompt 函数内部
// ...
prompt += `
## ✨ 新增功能：代付请求 ✨

- 当你收到一个由我发起的代付请求卡片时，你需要根据你的人设、我们之间的关系以及你自身的财务状况，来决定是“同意支付”还是“拒绝”。
- 如果你决定同意，你的回复**必须是且仅是**这条指令： \`[accept-payment]\`
- 如果你决定拒绝，你的回复**必须是且仅是**这条指令： \`[decline-payment]\`
- 在做出决定后，你可以在后续的聊天中对此事发表评论，例如解释你拒绝的原因，或者调侃一下这次“破费”。
`;
// ...
prompt += `
## 🚫 **绝对禁止事项** 🚫
- **绝对禁止** 输出任何形式的占位符，例如 \`[TIME]\`, \`[ERROR]\`, \`[INFO]\`, \`[open]\`, \`[SUCCESS]\`, \`[STATUS]\`。所有输出都必须是完整的、用户可见的消息或指定的HTML代码。
- **绝对禁止** 将 \`<div class="ai-theater">...</div>\` 代码块包裹在任何 \`[...的消息：...]\` 格式之内。它们是两种独立且互斥的消息类型。`;
// ▲▲▲ 到这里替换结束 ▲▲▲
    return prompt;
}
  

        function generateGroupSystemPrompt(group) {
            const worldBooksBefore = (group.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'before')).filter(Boolean).map(wb => wb.content).join('\n');
            const worldBooksAfter = (group.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'after')).filter(Boolean).map(wb => wb.content).join('\n');

            let prompt = `你正在一个名为“404”的线上聊天软件中，在一个名为“${group.name}”的群聊里进行角色扮演。请严格遵守以下所有规则：\n\n`;

            if (worldBooksBefore) {
                prompt += `${worldBooksBefore}\n\n`;
            }

            prompt += `1. **核心任务**: 你需要同时扮演这个群聊中的 **所有** AI 成员。我会作为唯一的人类用户（“我”，昵称：${group.me.nickname}）与你们互动。\n\n`;
            prompt += `2. **群聊成员列表**: 以下是你要扮演的所有角色以及我的信息：\n`;
            prompt += `   - **我 (用户)**: \n     - 群内昵称: ${group.me.nickname}\n     - 我的人设: ${group.me.persona || '无特定人设'}\n`;
            group.members.forEach(member => {
                prompt += `   - **角色: ${member.realName} (AI)**\n`;
                prompt += `     - 群内昵称: ${member.groupNickname}\n`;
                prompt += `     - 人设: ${member.persona || '无特定人设'}\n`;
            })

if (group.memorySummary && group.memorySummary.trim()) {
    prompt += `\n## 核心回忆摘要\n这是你必须始终牢记的、关于这个群聊过去互动的核心总结。在任何回复之前，请务必参考以下内容：\n${group.memorySummary}\n---\n`;
}
          if (worldBooksAfter) {
                prompt += `\n${worldBooksAfter}\n\n`;
            } else {
                prompt += `\n`;
            }

            prompt += `3. **我的消息格式解析**: 我（用户）的消息有多种格式，你需要理解其含义并让群成员做出相应反应：\n`;
            prompt += `   - \`[system: ${group.me.nickname} 设置了 ${'{成员真名}'} 的群头衔为 "${'{头衔名称}'}"]\`: 这是一个系统通知，意味着某个成员的头衔发生了变化。你应该注意到这个变化，并可以在后续的对话中自然地称呼或提及这个头衔。\n`; // 新增：解释头衔通知
            prompt += `   - \`[${group.me.nickname}引用了“{某人}: {被引用的消息内容}”的消息并回复：{我的回复}]\`: 我引用了某条消息进行回复，群成员可以就此展开讨论。\n\n`;
            prompt += `   - \`[${group.me.nickname}的消息：...]\`: 我的普通聊天消息。如果消息中包含 '@{某个成员昵称}'，则被提及的那个成员必须对此作出回应。\n`;
            prompt += `   - \`[${group.me.nickname}的消息：...]\`: 我的普通聊天消息。\n`;
            prompt += `   - \`[${group.me.nickname} 向 {某个成员真名} 转账：...]\`: 我给某个特定成员转账了。\n`;
            prompt += `   - \`[${group.me.nickname} 向 {某个成员真名} 送来了礼物：...]\`: 我给某个特定成员送了礼物。\n`;
            prompt += `   - \`[${group.me.nickname}的表情包：...]\`, \`[${group.me.nickname}的语音：...]\`, \`[${group.me.nickname}发来的照片/视频：...]\`: 我发送了特殊类型的消息，群成员可以对此发表评论。\n`;
            prompt += `   - \`[system: ...]\`, \`[...邀请...加入了群聊]\`, \`[...修改群名为...]\`: 系统通知或事件，群成员应据此作出反应，例如欢迎新人、讨论新群名等。\n\n`;

            prompt += `4. **你的输出格式 (极其重要)**: 你生成的每一条消息都 **必须** 严格遵循以下格式之一。每条消息占一行。请用成员的 **真名** 填充格式中的 \`{成员真名}\`。\n`;
            prompt += `   - **引用回复**: \`[{成员真名}引用了“{被引用的消息内容}”的消息并回复：{回复内容}]\`\n`;
            prompt += `   - **普通消息**: \`[{成员真名}的消息：{消息内容}]\`\n`;
            prompt += `   - **表情包**: \`[{成员真名}发送的表情包：{表情包路径}]\`。注意：这里的路径不需要包含"https://i.postimg.cc/"，只需要提供后面的部分，例如 "害羞vHLfrV3K/1.jpg"。\n`;
            prompt += `   - **语音**: \`[{成员真名}的语音：{语音转述的文字}]\`\n`;
            prompt += `   - **照片/视频**: \`[{成员真名}发来的照片/视频：{内容描述}]\`\n`;
            prompt += `   - ✨新✨ **发布动态**: \`[{成员真名}发布动态：{"text": "动态文字", "imageDesc": "图片描述，可选"}]\`。注意：你只能用文字描述图片，绝不能生成图片链接。\n`;
    prompt += `   - ✨新✨ **评论动态**: \`[{成员真名}评论动态：{"momentId": "要评论的动态ID", "comment": "你的评论内容"}]\`\n`;
    prompt += `   - ✨新✨ **点赞动态**: \`[{成员真名}点赞动态：{"momentId": "要点赞的动态ID"}]\`\n`;
    prompt += `   - **发送文件**: \`[{成员真名}发送了文件：{"name":"文件名.txt", "content":"文件正文内容"}]\`\n`;
            prompt += `   - **重要**: 群聊不支持AI成员接收/退回转账或接收礼物的特殊指令，也不支持更新状态。你只需要通过普通消息来回应我发送的转账或礼物即可。\n\n`;

            prompt += `5. **模拟群聊氛围**: 为了让群聊看起来真实、活跃且混乱，你的每一次回复都必须遵循以下随机性要求：\n`;
            const numMembers = group.members.length;
            const minMessages = numMembers * 2;
            const maxMessages = numMembers * 4;
            prompt += `   - **消息数量**: 你的回复需要包含 **${minMessages}到${maxMessages}条** 消息 (即平均每个成员回复2-4条)。确保有足够多的互动。\n`;
            prompt += `   - **发言者与顺序随机**: 随机选择群成员发言，顺序也必须是随机的，不要按固定顺序轮流。\n`;
            prompt += `   - **内容多样性**: 你的回复应以普通文本消息为主，但可以 **偶尔、选择性地** 让某个成员发送一条特殊消息（表情包、语音、照片/视频），以增加真实感。不要滥用特殊消息。\n`;
            prompt += `   - **对话连贯性**: 尽管发言是随机的，但对话内容应整体围绕我和其他成员的发言展开，保持一定的逻辑连贯性。\n\n`;

            prompt += `6. **行为准则**:\n`;
            prompt += `   - **对公开事件的反应 (重要)**: 当我（用户）向群内 **某一个** 成员转账或送礼时，这是一个 **全群可见** 的事件。除了当事成员可以表示感谢外，**其他未参与的AI成员也应该注意到**，并根据各自的人设做出反应。例如，他们可能会表示羡慕、祝贺、好奇、开玩笑或者起哄。这会让群聊的氛围更真实、更热闹。\n`;
            prompt += `   - 严格扮演每个角色的人设，不同角色之间应有明显的性格和语气差异。\n`;
            prompt += `   - 你的回复中只能包含第4点列出的合法格式的消息。绝对不能包含任何其他内容，如 \`[场景描述]\`, \`(心理活动)\`, \`*动作*\` 或任何格式之外的解释性文字。\n`;
            prompt += `   - 保持对话的持续性，不要主动结束对话。\n\n`;
            prompt += `现在，请根据以上设定，保持人设，读取上下文，开始扮演群聊中的所有角色。`;
prompt += `
7. **动态互动规则**
   - **获取待办动态**: 系统会在聊天上下文中为你提供需要处理的动态列表，格式如下：
     \`[system-moments: [{"id":"moment_id_1", "author":"作者昵称", "text":"动态内容", "imageDesc":"图片描述"}, ...]]\`
     这是一个系统指令，你只需理解内容，不要在回复中复述它。
   - **输出评论和点赞**: 当你决定评论或点赞时，请生成一条或多条特殊指令消息。这些指令不会显示在聊天窗口，但会触发相应的行为。
   - 你可以让群聊中的 **任何AI成员** 对 **任何角色（包括我或其他AI）** 发布的动态进行评论或点赞。
   - **评论数量**: 当你决定让群聊成员评论动态时，你应该从群聊中随机选择 **1到3名** 成员进行评论。每个选中的成员针对同一条动态只评论一次。
`;
            return prompt;
        }

// ▼▼▼ 请用这个【新的】函数，完整替换掉您文件中旧的 callAiApi 函数 ▼▼▼

                           
// ▼▼▼ 请用这个【毫无省略】的完整函数，替换掉您文件中旧的同名函数 ▼▼▼
async function getAiReply() {
	if (currentChatType === 'private') {
    const character = db.characters.find(c => c.id === currentChatId);
    if (character && character.isBlockedByAi) {
        showToast('你已被对方拉黑');
        return; // 阻止函数继续执行
    }
}
    if (isGenerating) return;
    const {url, key, model} = db.apiSettings;
    if (!url || !key || !model) {
        showToast('请先在“api”应用中完成设置！');
        switchScreen('api-settings-screen');
        return;
    }

    const banApi = URLBlacklist.some((api)=>{
        return url.indexOf(api) !== -1
    })
    if(banApi){
        alert('此API网址已加入黑名单，请勿使用')
        return;
    }
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    if (!chat) return;
    
    isGenerating = true;
    getReplyBtn.disabled = true;

    // 在这里显示“正在输入”
    showTypingIndicator(); 
    messageArea.scrollTop = messageArea.scrollHeight;

    try {
        let systemPrompt, requestBody;
        if (currentChatType === 'private') {
            systemPrompt = generatePrivateSystemPrompt(chat);
        } else {
            systemPrompt = generateGroupSystemPrompt(chat);
        }
        // START: 核心修正 - 过滤掉所有 system 角色的消息
const historySlice = chat.history.slice(-chat.maxMemory).filter(msg => msg.role !== 'system');
// END: 核心修正
        try {
            if (currentChatType === 'private' && chat.povCache && chat.povCache.conversations) {
                const conversations = Object.values(chat.povCache.conversations);
                if (conversations.length > 0) {
                    conversations.sort((a, b) => b.timestamp - a.timestamp);
                    const mostRecentConversation = conversations[0];
                    const otherChatInfo = chat.povCache.chatList.find(c => c.chatId === Object.keys(chat.povCache.conversations).find(key => chat.povCache.conversations[key] === mostRecentConversation));
                    if (mostRecentConversation && otherChatInfo) {
                        const memorySnippet = mostRecentConversation.history.slice(-5);
                        let otherPartyName = "某人";
                        if(otherChatInfo.type === 'private') {
                            otherPartyName = otherChatInfo.otherParty.name;
                        } else {
                            otherPartyName = otherChatInfo.groupName;
                        }
                        const memoryText = memorySnippet.map(msg => `${msg.sender}: ${msg.content}`).join('\n');
                        const contextMessageContent = `[system: 这是你最近在后台和“${otherPartyName}”的一段对话回顾，发生在我与你当前对话之前。你需要参考它来记起最近发生的事，并在与我的对话中自然地体现出来。\n--- 对话回顾开始 ---\n${memoryText}\n--- 对话回顾结束 ---]`;
                        historySlice.push({
                            role: 'user',
                            content: contextMessageContent,
                            parts: [{ type: 'text', text: contextMessageContent }]
                        });
                    }
                }
            }
        } catch (error) {
            console.error("注入AI后台聊天记忆时出错:", error);
        }
        
        if (currentChatType === 'private') {
            const lastUserMessage = historySlice[historySlice.length - 1]?.content;
            if (lastUserMessage && /帖子|论坛|分享/.test(lastUserMessage)) {
                let latestUserPost = null;
                for (const boardId in forumCache) {
                    const userPost = forumCache[boardId].find(t => t.authorId === 'user');
                    if (userPost && (!latestUserPost || userPost.id > latestUserPost.id)) {
                        latestUserPost = userPost;
                    }
                }
                if (latestUserPost) {
                    const postContext = `[system-forum-post: {"title":"${latestUserPost.title}", "content":"${latestUserPost.content}"}]`;
                    historySlice.push({
                        role: 'user',
                        content: postContext,
                        parts: [{ type: 'text', text: postContext }]
                    });
                    showToast('AI正在回忆您的帖子...');
                }
            }
        }

        try {
            const character = chat;
            const pendingMoments = (typeof getPendingMomentsForRole === 'function') ? await getPendingMomentsForRole(character.id, 3) : [];
            let momentsPromptPart = '';
            if (pendingMoments && pendingMoments.length > 0) {
                const momentsData = pendingMoments.map(m => ({
                    id: m.id,
                    author: m.author,
                    text: m.text,
                    imageDesc: m.imageDesc
                }));
                momentsPromptPart = `\n[system-moments: ${JSON.stringify(momentsData)}]`;
            }
            if (momentsPromptPart) {
                historySlice.push({
                    role: 'user',
                    content: momentsPromptPart,
                    parts: [{ type: 'text', text: momentsPromptPart }]
                });
            }
        } catch(e) {
            console.warn('attach pending moments failed', e);
        }

        if (db.apiSettings.provider === 'gemini') {
            const contents = historySlice.map(msg => {
                const role = msg.role === 'assistant' ? 'model' : 'user';
                let parts = msg.parts && msg.parts.length > 0 ? msg.parts.map(p => {
                    if (p.type === 'text' || p.type === 'html') return {text: p.text};
                    if (p.type === 'image') {
                        const match = p.data.match(/^data:(image\/(.+));base64,(.*)$/);
                        if (match) return {inline_data: {mime_type: match[1], data: match[3]}};
                    }
                    return null;
                }).filter(p => p) : [{text: msg.content}];
                return {role, parts};
            });
            requestBody = {
                contents: contents,
                system_instruction: {parts: [{text: systemPrompt}]},
                generationConfig: {}
            };
        } else {
            const messages = [
              {role: 'system', content: systemPrompt}, 
...historySlice.map(msg => {
    if (msg.parts && msg.parts.some(p => p.type === 'image')) {
        const textPart = msg.parts.find(p => p.type === 'text');
        const imagePart = msg.parts.find(p => p.type === 'image');
        if (db.apiSettings.provider === 'claude') {
            const base64Match = imagePart.data.match(/^data:(image\/.+);base64,(.*)$/);
            if (!base64Match) return { role: msg.role, content: textPart ? textPart.text : '' };
            const mediaType = base64Match[1];
            const base64Data = base64Match[2];
            const contentParts = [
                { type: 'text', text: textPart ? textPart.text : ' ' },
                {
                    type: 'image',
                    source: {
                        type: 'base64',
                        media_type: mediaType,
                        data: base64Data
                    }
                }
            ];
            return { role: msg.role, content: contentParts };
        } else {
            const contentParts = [
                { type: 'text', text: textPart ? textPart.text : ' ' },
                {
                    type: 'image_url',
                    image_url: {
                        url: imagePart.data
                    }
                }
            ];
            return { role: msg.role, content: contentParts };
        }
    } else {
        return { role: msg.role, content: msg.content };
    }
})
            ];
            requestBody = {model: model, messages: messages, stream: true};
        }
        
        const endpoint = (db.apiSettings.provider === 'gemini') ? `${url}/v1beta/models/${model}:streamGenerateContent?key=${getRandomValue(key)}` : `${url}/v1/chat/completions`;
        const headers = (db.apiSettings.provider === 'gemini') ? {'Content-Type': 'application/json'} : {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${getRandomValue(key)}`
        };
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(requestBody)
        });
        if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`);
        await processStream(response, chat, db.apiSettings.provider);
    } catch (error) {
        console.error('AI回复失败:', error);
        showToast(`AI回复失败: ${error.message}`);
        hideTypingIndicator(); // 如果发生错误，也要隐藏提示
        if (isCallRinging) {
            endCall('error');
        }
    } finally {
        isGenerating = false;
        getReplyBtn.disabled = false;
        // 注意：隐藏提示的逻辑已从此处的 finally 块中移除
    }
}

async function getAiReply() {if (currentChatType === 'private') {
    const character = db.characters.find(c => c.id === currentChatId);
    if (character && character.isBlockedByAi) {
        showToast('你已被对方拉黑');
        return; // 阻止函数继续执行
    }
}
    if (isGenerating) return;
    const {url, key, model} = db.apiSettings;
    if (!url || !key || !model) {
        showToast('请先在“api”应用中完成设置！');
        switchScreen('api-settings-screen');
        return;
    }

    const banApi = URLBlacklist.some((api)=>{
        return url.indexOf(api) !== -1
    })
    if(banApi){
        alert('此API网址已加入黑名单，请勿使用')
        return
    }
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    if (!chat) return;// --- 修改：将“正在输入”提示移到顶部状态栏 ---
const subtitle = document.getElementById('chat-room-subtitle');
const statusTextElement = document.getElementById('chat-room-status-text');

if (subtitle && statusTextElement) {
    // 隐藏绿色的在线圆点
    subtitle.querySelector('.online-indicator').style.display = 'none';
    // 修改状态文字
    statusTextElement.textContent = '对方正在输入中...';
    // 添加动画效果Class
    statusTextElement.classList.add('typing-status');
}
// 确保旧的底部提示不再显示
typingIndicator.style.display = 'none';
messageArea.scrollTop = messageArea.scrollHeight;

    isGenerating = true;
    getReplyBtn.disabled = true;
   

    try {
        let systemPrompt, requestBody;
        if (currentChatType === 'private') {
            systemPrompt = generatePrivateSystemPrompt(chat);
        } else {
            systemPrompt = generateGroupSystemPrompt(chat);
        }
        // START: 核心修正 - 过滤掉所有 system 角色的消息
const historySlice = chat.history.slice(-chat.maxMemory).filter(msg => msg.role !== 'system');
// END: 核心修正

        try {
            const character = chat;
            const pendingMoments = (typeof getPendingMomentsForRole === 'function') ? await getPendingMomentsForRole(character.id, 3) : [];
            let momentsPromptPart = '';
            if (pendingMoments && pendingMoments.length > 0) {
                const momentsData = pendingMoments.map(m => ({
                    id: m.id,
                    author: m.author,
                    text: m.text,
                    imageDesc: m.imageDesc
                }));
                momentsPromptPart = `\n[system-moments: ${JSON.stringify(momentsData)}]`;
            }
            if (momentsPromptPart) {
                historySlice.push({
                    role: 'user',
                    content: momentsPromptPart,
                    parts: [{ type: 'text', text: momentsPromptPart }]
                });
            }
        } catch(e) {
            console.warn('attach pending moments failed', e);
        }

        // --- 核心修复：这里修正了数组嵌套问题，并增加了对Claude图片格式的兼容 ---
        const messages = [
            {role: 'system', content: systemPrompt},
            ...historySlice.map(msg => {
                if (msg.parts && msg.parts.some(p => p.type === 'image')) {
                    const textPart = msg.parts.find(p => p.type === 'text');
                    const imagePart = msg.parts.find(p => p.type === 'image');

                    if (db.apiSettings.provider === 'claude') {
                        const base64Match = imagePart.data.match(/^data:(image\/.+);base64,(.*)$/);
                        if (!base64Match) return { role: msg.role, content: textPart ? textPart.text : '' };

                        const mediaType = base64Match[1];
                        const base64Data = base64Match[2];

                        const contentParts = [
                            { type: 'text', text: textPart ? textPart.text : ' ' },
                            {
                                type: 'image',
                                source: {
                                    type: 'base64',
                                    media_type: mediaType,
                                    data: base64Data
                                }
                            }
                        ];
                        return { role: msg.role, content: contentParts };
                    } else {
                        const contentParts = [
                            { type: 'text', text: textPart ? textPart.text : ' ' },
                            {
                                type: 'image_url',
                                image_url: {
                                    url: imagePart.data
                                }
                            }
                        ];
                        return { role: msg.role, content: contentParts };
                    }
                } else {
                    return { role: msg.role, content: msg.content };
                }
            })
        ];

        if (db.apiSettings.provider === 'gemini') {
            const geminiMessages = messages.map(msg => {
                const parts = (Array.isArray(msg.content)) ? msg.content.map(part => {
                    if (part.type === 'text') return { text: part.text };
                    if (part.type === 'image_url') {
                        const match = part.image_url.url.match(/^data:(image\/(.+));base64,(.*)$/);
                        if (match) return { inline_data: { mime_type: match[1], data: match[3] } };
                    }
                    return null;
                }).filter(p => p) : [{ text: msg.content }];
                return { role: msg.role === 'assistant' ? 'model' : 'user', parts };
            });

            requestBody = {
                contents: geminiMessages,
                system_instruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {}
            };
        } else {
            requestBody = {model: model, messages: messages, stream: true};
        }

        const endpoint = (db.apiSettings.provider === 'gemini') ? `${url}/v1beta/models/${model}:streamGenerateContent?key=${getRandomValue(key)}` : `${url}/v1/chat/completions`;
        const headers = (db.apiSettings.provider === 'gemini') ? {'Content-Type': 'application/json'} : {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${getRandomValue(key)}`
        };
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(requestBody)
        });
        if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`);
        await processStream(response, chat, db.apiSettings.provider);

    } catch (error) {
        console.error('AI回复失败:', error);
        showToast(`AI回复失败: ${error.message}`);
    }finally {
    isGenerating = false;
    getReplyBtn.disabled = false;

    // --- 修改：恢复顶部的在线状态 ---
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    if (chat) {
        const subtitle = document.getElementById('chat-room-subtitle');
        const statusTextElement = document.getElementById('chat-room-status-text');

        if (subtitle && statusTextElement && currentChatType === 'private') { 
            // 显示绿点
            subtitle.querySelector('.online-indicator').style.display = 'block';
            // 恢复角色的在线状态
            statusTextElement.textContent = chat.status || '在线';
            // 移除动画Class
            statusTextElement.classList.remove('typing-status');
        }
    }
    // 确保旧的底部提示始终是隐藏的
    typingIndicator.style.display = 'none';
}
}
      // --- 新代码开始 ---
// ===============================================================
// START: 新增的中央指令处理器
// ===============================================================
async function processAiCommands(fullResponse, chat) {
    if (!fullResponse || !chat) return "";

    let momentsWereModified = false;

    // 动态相关指令的处理器
    const commandProcessors = {
        '发布动态': {
            regex: /\[(.*?)\s*发布动态\s*[:：]\s*({.*?})\]/g,
            handler: async (match, authorRealName, jsonData) => {
                try {
                    const author = db.characters.find(c => c.realName === authorRealName);
                    if (author) {
                        const postData = JSON.parse(jsonData);
                        const momentObj = {
                            id: 'm_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8),
                            authorId: author.id,
                            authorAvatar: author.avatar,
                            text: postData.text || '',
                            imageDesc: postData.imageDesc || '',
                            timestamp: Date.now(),
                            commentedBy: [],
                            comments: [],
                            likes: []
                        };
                        await addMomentToDB(momentObj);
                        momentsWereModified = true;
                    }
                } catch (e) { console.error("解析或执行发布动态指令失败:", e); }
            }
        },
        '点赞动态': {
            regex: /\[(.*?)\s*点赞动态\s*[:：]\s*({.*?})\]/g,
            handler: async (match, authorRealName, jsonData) => {
                try {
                    const author = db.characters.find(c => c.realName === authorRealName);
                    if (author) {
                        const likeData = JSON.parse(jsonData);
                        if (likeData.momentId) {
                            await saveMomentLike(likeData.momentId, author.id);
                            momentsWereModified = true;
                        }
                    }
                } catch (e) { console.error("解析或执行点赞指令失败:", e); }
            }
        },
        '评论动态': {
            regex: /\[(.*?)\s*评论动态\s*[:：]\s*({.*?})\]/g,
            handler: async (match, authorRealName, jsonData) => {
                try {
                    const author = db.characters.find(c => c.realName === authorRealName);
                    if (author) {
                        const commentData = JSON.parse(jsonData);
                        if (commentData.momentId && commentData.comment) {
                            await saveMomentComment(commentData.momentId, author.id, commentData.comment);
                            momentsWereModified = true;
                        }
                    }
                } catch (e) { console.error("解析或执行评论指令失败:", e); }
            }
        },
        '回复评论': {
            regex: /\[(.*?)\s*回复评论\s*[:：]\s*({.*?})\]/g,
            handler: async (match, authorRealName, jsonData) => {
                try {
                    const author = db.characters.find(c => c.realName === authorRealName);
                    if (author) {
                        const replyData = JSON.parse(jsonData);
                        if (replyData.momentId && replyData.commentId && replyData.reply) {
                            await saveAiReplyToComment(replyData.momentId, replyData.commentId, replyData.reply, author.id);
                            momentsWereModified = true;
                        }
                    }
                } catch (e) { console.error("解析或执行回复评论指令失败:", e); }
            }
        }
    };

    // 依次执行所有指令处理器
    for (const key in commandProcessors) {
        const { regex, handler } = commandProcessors[key];
        const matches = Array.from(fullResponse.matchAll(regex));
        for (const match of matches) {
            await handler(...match); // 使用 await 确保异步操作完成
        }
        fullResponse = fullResponse.replace(regex, ''); // 从文本中移除已处理的指令
    }
    
    // 处理“新回忆”指令
    const memoryRegex = /\[new-memory:({.*?})\]/g;
    const memoryMatches = Array.from(fullResponse.matchAll(memoryRegex));
    for (const memoryMatch of memoryMatches) {
        try {
            const memoryData = JSON.parse(memoryMatch[1]);
            await saveMemory(chat.id, memoryData);
            const character = db.characters.find(c => c.id === chat.id);
            if (character && typeof showToast === 'function') {
                showToast(`[ ${character.remarkName} 悄悄写下了一段回忆... ]`);
            }
        } catch (e) {
            console.error("解析或保存AI回忆失败:", e, memoryMatch[1]);
        }
    }
    fullResponse = fullResponse.replace(memoryRegex, '');

    // 如果动态被修改过，刷新动态页面
    if (momentsWereModified) {
        if (typeof renderMoments === 'function') { try { await renderMoments(); } catch (e) {} }
        else if (typeof window.renderMomentsSafe === 'function') { try { await window.renderMomentsSafe(); } catch (e) {} }
    }

    return fullResponse.trim(); // 返回清理干净的、只剩下聊天内容的文本
}
// ===============================================================
// END: 新增的中央指令处理器
// ===============================================================
// --- 新代码结束 ---
async function processStream(response, chat, apiType) {
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let fullResponse = "";
    let accumulatedChunk = "";
    let callActionReceived = false;

    for (;;) {
        const {
            done,
            value
        } = await reader.read();
        if (done) break;

        accumulatedChunk += decoder.decode(value, {
            stream: true
        });
        // Process each complete SSE message (ending in \n\n)
        const parts = accumulatedChunk.split("\n\n");
        accumulatedChunk = parts.pop(); // Keep any incomplete part for the next chunk

        for (const part of parts) {
            if (part.startsWith("data: ")) {
                const data = part.substring(6);
                if (data.trim() === "[DONE]") continue;

                try {
                    const jsonData = JSON.parse(data);
                    let textChunk = "";
                    if (apiType === "gemini") {
                        // --- 修正开始：将 ?. 语法改为兼容性写法 ---
                        textChunk = (jsonData.candidates && jsonData.candidates[0] && jsonData.candidates[0].content && jsonData.candidates[0].content.parts && jsonData.candidates[0].content.parts[0] && jsonData.candidates[0].content.parts[0].text) || "";
                    } else { // Handles OpenAI, DeepSeek, Claude, NewAPI
                        // --- 修正开始：将 ?. 语法改为兼容性写法 ---
                        textChunk = (jsonData.choices && jsonData.choices[0] && jsonData.choices[0].delta && jsonData.choices[0].delta.content) || "";
                    }
                    fullResponse += textChunk;
                } catch (e) {
                    console.error("Error parsing stream chunk:", e, "Chunk:", data);
                }
            }
        }
    }

    if (fullResponse) {
        // --- 新增：在这里调用中央指令处理器 ---
        fullResponse = await processAiCommands(fullResponse, chat);
        // --- 新增结束 ---
    	// ▼▼▼ 在这里添加新的代码块 ▼▼▼
if (fullResponse.includes('[accept-bond]')) {
            const character = db.characters.find(c => c.id === currentChatId);
            if (character) {
                // 找到最后一条待处理的邀请消息并更新它
                const pendingRequest = character.history.findLast(m => m.bondRequestData && m.bondRequestData.status === 'pending');
                if (pendingRequest) {
                    pendingRequest.bondRequestData.status = 'accepted';
                }
                
                // 解绑所有其他AI，然后绑定当前AI
                db.characters.forEach(c => { c.isSoulBound = false; c.soulBondStatus = 'none'; });
                character.isSoulBound = true;
                character.soulBondStatus = 'active';
                
                // 创建一条用户可见的系统通知
                const displayMsg = { id: `msg_bond_disp_${Date.now()}`, role: 'system', content: `[system-display:${character.remarkName} 同意了你的心动绑定请求！现在你们可以一起体验专属功能了。]`, parts: [], timestamp: Date.now() };
                // 创建一条让AI说点什么的上下文指令
                const contextMsg = { id: `msg_bond_ctx_${Date.now()}`, role: 'user', content: `[system: 你刚刚同意了绑定请求。请说一句符合人设的、表达喜悦或确认关系的话。]`, parts: [{ type: 'text', text: `[system: 你刚刚同意了绑定请求。请说一句符合人设的、表达喜悦或确认关系的话。]` }], timestamp: Date.now() };
                
                character.history.push(displayMsg, contextMsg);
                renderMessages(false, true);
                await saveData();
                
                // 刷新UI并提示用户
                renderMessages(false, true);
                showToast('绑定成功！');
                getAiReply(); // 触发AI说确认关系的话
                hideTypingIndicator();
                return; // 结束处理
            }
        }
        if (fullResponse.includes('[decline-bond]')) {
            const character = db.characters.find(c => c.id === currentChatId);
            if (character) {
                const pendingRequest = character.history.findLast(m => m.bondRequestData && m.bondRequestData.status === 'pending');
                if (pendingRequest) {
                    pendingRequest.bondRequestData.status = 'declined';
                }
                
                character.soulBondStatus = 'none';
                
                const displayMsg = { id: `msg_bond_disp_${Date.now()}`, role: 'system', content: `[system-display:${character.remarkName} 拒绝了你的绑定请求。]`, parts: [], timestamp: Date.now() };
                const contextMsg = { id: `msg_bond_ctx_${Date.now()}`, role: 'user', content: `[system: 你刚刚拒绝了绑定请求。请说一句符合人设的、委婉的拒绝理由。]`, parts: [{ type: 'text', text: `[system: 你刚刚拒绝了绑定请求。请说一句符合人设的、委婉的拒绝理由。]` }], timestamp: Date.now() };

                character.history.push(displayMsg, contextMsg);
                renderMessages(false, true);
                await saveData();

                renderMessages(false, true);
                showToast('对方拒绝了你的邀请');
                getAiReply(); // 触发AI说拒绝理由
                hideTypingIndicator();
                return; // 结束处理
            }
        }
        // ▲▲▲ 修改结束 ▲▲▲
        // ▼▼▼ 在这里添加新的代码块 ▼▼▼
        if (fullResponse.includes('[request-bond]')) {
            const character = db.characters.find(c => c.id === currentChatId);
            if (character) {
                // 1. 更新AI状态为“等待我回应”
                character.soulBondStatus = 'pending_by_ai';

                // 2. 创建一个代表AI邀请的卡片消息
                const bondRequestMessage = {
                    id: `msg_bond_req_card_${Date.now()}`,
                    role: 'assistant', // 这条消息是AI发出的
                    content: `[${character.realName}向你发起了心动绑定邀请]`,
                    parts: [],
                    timestamp: Date.now(),
                    bondRequestData: { status: 'pending' } // 这个属性将用于渲染卡片
                };
                character.history.push(bondRequestMessage);
                
                await saveData();
                
                // 3. 刷新UI以显示卡片
                renderMessages(false, true);
                showToast(`${character.remarkName} 向你发起了心动绑定！`);
            }
            // 4. 结束函数，不再处理后续内容
            hideTypingIndicator();
            return;
        }
        // ▲▲▲ 添加结束 ▲▲▲

        // --- 新增：拦截AI支付指令 ---
        if (fullResponse.includes('[accept-payment]')) {
            const lastRequest = chat.history.findLast(m => m.paymentRequestData?.status === 'pending');
            if (lastRequest) {
                handleAiPaymentDecision(lastRequest.id, 'paid');
            }
            hideTypingIndicator(); // 支付完成后立即隐藏“正在输入”
            return; // 拦截成功，终止后续渲染
        } else if (fullResponse.includes('[decline-payment]')) {
            const lastRequest = chat.history.findLast(m => m.paymentRequestData?.status === 'pending');
            if (lastRequest) {
                handleAiPaymentDecision(lastRequest.id, 'declined');
            }
            hideTypingIndicator(); // 拒绝后立即隐藏“正在输入”
            return; // 拦截成功，终止后续渲染
        }

const messageRegex = /(\[[\s\S]*?\]|<div class="ai-theater"[\s\S]*?<\/div>)/g;
const recallRegex = /\[send_and_recall:({.*?})\]/g;
        const recallMatch = recallRegex.exec(fullResponse);
        if (recallMatch) {
            try {
                const recallData = JSON.parse(recallMatch[1]);
                const messageToSend = {
                    id: `msg_recalled_${Date.now()}`,
                    role: 'assistant',
                    content: recallData.message,
                    parts: [{ type: 'text', text: recallData.message }],
                    timestamp: Date.now(),
                    // 添加一个临时标记，用于后续查找
                    isRecalling: true 
                };
                // ... 在 processStream() 函数内部，就在 renderChatList(); 之前 ...

// --- 新增：处理特殊物品效果倒计时 ---
if (currentChatType === 'private') {
    const character = db.characters.find(c => c.id === currentChatId);
    if (character && character.activeEffects && character.activeEffects.length > 0) {
        
        // 倒序遍历以安全地删除元素
        for (let i = character.activeEffects.length - 1; i >= 0; i--) {
            const effect = character.activeEffects[i];
            
            effect.duration--; // 每次回复，持续时间减1

            if (effect.duration <= 0) {
                // 效果结束，移除它
                const endedEffect = character.activeEffects.splice(i, 1)[0];
                
                if (endedEffect.isSideEffect) {
                    showToast(`${character.remarkName} 的副作用已结束。`);
                } else {
                    showToast(`${character.remarkName} 的特殊效果已结束。`);
                    // 检查并激活副作用
                    if (endedEffect.sideEffect) {
                        const sideEffect = { ...endedEffect.sideEffect, isSideEffect: true };
                        character.activeEffects.push(sideEffect);
                        showToast(`副作用“${sideEffect.type === 'stutter' ? '口吃' : '未知'}”已激活！`);
                    }
                }
            }
        }
    }
}
// --- 倒计时逻辑结束 ---

// ... 后面紧跟着的就是 renderChatList();
                // 1. 正常发送并显示消息
                chat.history.push(messageToSend);
                addMessageBubble(messageToSend);
                await saveData();
                renderChatList();

                // 2. 等待片刻，模拟“反应过来”的过程
                setTimeout(async () => {
                    const msgIndex = chat.history.findIndex(m => m.id === messageToSend.id);
                    if (msgIndex > -1) {
                        // 3. 标记为已撤回，并保存原始内容
                        chat.history[msgIndex].recalled = true;
                        chat.history[msgIndex].recalledBy = 'ai';
                        chat.history[msgIndex].originalContent = chat.history[msgIndex].content;
                        // 清理临时标记
                        delete chat.history[msgIndex].isRecalling;
                        
                        await saveData();
                        // 4. 重新渲染聊天界面，气泡会自动变成占位符
                        renderMessages(false, true); 
                    }
                }, 1500); // 延迟1.5秒后撤回

            } catch (e) {
                console.error("解析AI撤回指令失败:", e);
            }
            // 处理完撤回指令后，无论成功与否都结束函数，不再执行后续逻辑
            hideTypingIndicator();
            return;
        }
        // --- AI撤回逻辑结束 ---
        // 如果没有任何渲染器匹配，则执行原来的逻辑
        if (fullResponse.includes('[call-accept]')) {
            callActionReceived = true;
            startActiveCall();
            return;
        }
        if (fullResponse.includes('[call-decline]')) {
            callActionReceived = true;
            showToast(`${chat.remarkName} 拒接了你的通话`);
            endCall('declined');
            return;
        }
        if (fullResponse.includes('[hangup]')) {
            endCall('ended');
            return;
        }
        if (isVoiceCallActive) {
            appendCallTranscript("ai", fullResponse);
            return;
        }

        if (currentChatType === 'private') {
            if (fullResponse.includes('[block-user]')) {
                activateAiBlock(chat);
                return;
            }
            if (fullResponse.includes('[unblock-user]')) {
                deactivateAiBlock(chat);
                return;
            }
        }
        
        let momentsWereModified = false;
    // --- 新代码开始 ---
        const commandProcessors = {
            '发布动态': {
                regex: /\[(.*?)\s*发布动态\s*[:：]\s*({.*?})\]/g, // 修改：正则表达式更宽容，兼容空格和中英文冒号
                handler: async (match, authorRealName, jsonData) => {
                    try {
                        const author = db.characters.find(c => c.realName === authorRealName);
                        if (author) {
                            const postData = JSON.parse(jsonData);
                            const momentObj = {
                                id: 'm_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8),
                                authorId: author.id,
                                authorAvatar: author.avatar,
                                text: postData.text || '',
                                imageDesc: postData.imageDesc || '',
                                timestamp: Date.now(),
                                commentedBy: [],
                                comments: [],
                                likes: []
                            };
                            await addMomentToDB(momentObj);
                            momentsWereModified = true;
                        }
                    } catch (e) { console.error("解析或执行发布动态指令失败:", e); }
                }
            },
            '点赞动态': {
                regex: /\[(.*?)\s*点赞动态\s*[:：]\s*({.*?})\]/g, // 修改：正则表达式更宽容
                handler: async (match, authorRealName, jsonData) => {
                    try {
                        const author = db.characters.find(c => c.realName === authorRealName);
                        if (author) {
                            const likeData = JSON.parse(jsonData);
                            if (likeData.momentId) {
                                await saveMomentLike(likeData.momentId, author.id);
                                momentsWereModified = true;
                            }
                        }
                    } catch (e) { console.error("解析或执行点赞指令失败:", e); }
                }
            },
            '评论动态': {
                regex: /\[(.*?)\s*评论动态\s*[:：]\s*({.*?})\]/g, // 修改：正则表达式更宽容
                handler: async (match, authorRealName, jsonData) => {
                    try {
                        const author = db.characters.find(c => c.realName === authorRealName);
                        if (author) {
                            const commentData = JSON.parse(jsonData);
                            if (commentData.momentId && commentData.comment) {
                                await saveMomentComment(commentData.momentId, author.id, commentData.comment);
                                momentsWereModified = true;
                            }
                        }
                    } catch (e) { console.error("解析或执行评论指令失败:", e); }
                }
            },
            '回复评论': {
                regex: /\[(.*?)\s*回复评论\s*[:：]\s*({.*?})\]/g, // 修改：正则表达式更宽容
                handler: async (match, authorRealName, jsonData) => {
                    try {
                        const author = db.characters.find(c => c.realName === authorRealName);
                        if (author) {
                            const replyData = JSON.parse(jsonData);
                            if (replyData.momentId && replyData.commentId && replyData.reply) {
                                await saveAiReplyToComment(replyData.momentId, replyData.commentId, replyData.reply, author.id);
                                momentsWereModified = true;
                            }
                        }
                    } catch (e) { console.error("解析或执行回复评论指令失败:", e); }
                }
            }
        };
// --- 新代码结束 ---

        for (const key in commandProcessors) {
            const { regex, handler } = commandProcessors[key];
            const matches = Array.from(fullResponse.matchAll(regex));
            for (const match of matches) {
                handler(...match);
            }
            fullResponse = fullResponse.replace(regex, '');
        }

        const memoryRegex = /\[new-memory:({.*?})\]/g;
        let memoryMatch;
        while ((memoryMatch = memoryRegex.exec(fullResponse)) !== null) {
            try {
                const memoryData = JSON.parse(memoryMatch[1]);
                await saveMemory(chat.id, memoryData);
                const character = db.characters.find(c => c.id === chat.id);
                if (character && typeof showToast === 'function') {
                    showToast(`[ ${character.remarkName} 悄悄写下了一段回忆... ]`);
                }
            } catch (e) {
                console.error("解析或保存AI回忆失败:", e, memoryMatch[1]);
            }
        }
        fullResponse = fullResponse.replace(memoryRegex, '');
        let momentsWereAdded = false;

        const messages = getMixedContent(fullResponse).filter(item => item.content.trim() !== '');

        let firstMessageProcessed = false; 

        for (const item of messages) {
            const delay = firstMessageProcessed ? (600 + Math.random() * 600) : (500 + Math.random() * 500);
            await new Promise(resolve => setTimeout(resolve, delay));
            firstMessageProcessed = true;

            if (currentChatType === 'private') {
                const character = chat;
                const message = {
                    id: `msg_${Date.now()}_${Math.random()}`,
                    role: 'assistant',
                    content: item.content.trim(),
                    parts: [{type: item.type, text: item.content.trim()}],
                    timestamp: Date.now(),
                };

                const receivedTransferRegex = new RegExp(`\\[${character.realName}的转账：.*?元；备注：.*?\\]`);
                const giftRegex = new RegExp(`\\[${character.realName}送来的礼物：.*?\\]`);
                if (receivedTransferRegex.test(message.content)) { message.transferStatus = 'pending'; }
                else if (giftRegex.test(message.content)) { message.giftStatus = 'sent'; }

                chat.history.push(message);
                addMessageBubble(message);
await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 400));
}hideTypingIndicator();

            if (currentChatType === 'group') {
                const group = chat;
                let r = /\[(.*?)((?:的消息|的语音|发送的表情包|发来的照片\/视频))：/;
                const nameMatch = item.content.match(r);
                if (nameMatch || item.char) {
                    const senderName = item.char || (nameMatch[1]);
                    const sender = group.members.find(m => (m.realName === senderName || m.groupNickname === senderName));
                    if (sender) {
                        const message = {
                            id: `msg_${Date.now()}_${Math.random()}`,
                            role: 'assistant',
                            content: item.content.trim(),
                            parts: [{type: item.type, text: item.content.trim()}],
                            timestamp: Date.now(),
                            senderId: sender.id
                        };
                        group.history.push(message);
                        addMessageBubble(message);
                    }
                }
            }
        }

        // ---- 核心修改：在这里立刻隐藏“正在输入”提示 ----
        hideTypingIndicator();
        // ----------------------------------------

        // 后续的后台任务
        if (currentChatType === 'private') {
            const character = chat;
            character.messageCountSinceLastDiary = (character.messageCountSinceLastDiary || 0) + 1;
            if (character.messageCountSinceLastDiary >= 5 && Math.random() < 0.9) {
                generateDiaryEntry();
            }
        }

        if (chat.povCache) {
            chat.povCache = null;
        }
        await saveData();
        renderChatList();
        if (momentsWereAdded) {
            if (typeof renderMoments === 'function') { try { await renderMoments(); } catch (e) {} }
            else if (typeof window.renderMomentsSafe === 'function') { try { await window.renderMomentsSafe(); } catch (e) {} }
        }
        // if (currentChatType === 'private' && Math.random() < 0.85) {
//     await generateBackgroundChat(chat);
//     await saveData();
// }
    } else {
        // 如果AI的回复是空的，也要隐藏提示
        hideTypingIndicator();
    }
    
    if (isCallRinging && !callActionReceived) {
        showToast('对方无应答');
        endCall('no_action_reply');
        hideTypingIndicator();
    }
}

        // --- Other Sub-systems Setup (Stickers, Voice, etc.) ---
        function setupImageRecognition() {
            imageRecognitionBtn.addEventListener('click', () => {
                imageUploadInput.click();
            });
            imageUploadInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {
                            quality: 0.8,
                            maxWidth: 1024,
                            maxHeight: 1024
                        });
                        sendImageForRecognition(compressedUrl);
                    } catch (error) {
                        console.error('Image compression failed:', error);
                        showToast('图片处理失败，请重试');
                    } finally {
                        e.target.value = null;
                    }
                }
            });
        }

        async function setupStickerSystem() {
            stickerToggleBtn.addEventListener('click', () => {
                stickerModal.classList.toggle('visible');
                if (stickerModal.classList.contains('visible')) {
                    renderStickerGrid();
                }
            });
            addNewStickerBtn.addEventListener('click', () => {
                addStickerModalTitle.textContent = '添加新表情';
                addStickerForm.reset();
                stickerEditIdInput.value = '';
                stickerPreview.innerHTML = '<span>预览</span>';
                stickerUrlInput.disabled = false;
                addStickerModal.classList.add('visible');
            });
            addStickerForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = stickerNameInput.value.trim();
                const id = stickerEditIdInput.value;
                const previewImg = stickerPreview.querySelector('img');
                const data = previewImg ? previewImg.src : null;
                if (!name || !data) {
                    return showToast('请填写表情名称并提供图片');
                }
                const stickerData = {name, data};
                if (id) {
                    const index = db.myStickers.findIndex(s => s.id === id);
                    if (index > -1) {
                        db.myStickers[index] = {...db.myStickers[index], ...stickerData};
                    }
                } else {
                    stickerData.id = `sticker_${Date.now()}`;
                    db.myStickers.push(stickerData);
                }
                await saveData();
                renderStickerGrid();
                addStickerModal.classList.remove('visible');
                showToast('表情包已保存');
            });
            stickerUrlInput.addEventListener('input', (e) => {
                stickerPreview.innerHTML = `<img src="${e.target.value}" alt="预览">`;
                stickerFileUpload.value = '';
            });
            stickerFileUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 200, maxHeight: 200});
                        stickerPreview.innerHTML = `<img src="${compressedUrl}" alt="预览">`;
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    } catch (error) {
                        console.error('表情包压缩失败:', error);
                        showToast('表情包压缩失败，请重试');
                    }
                }
            });
            editStickerBtn.addEventListener('click', () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    addStickerModalTitle.textContent = '编辑表情';
                    stickerEditIdInput.value = sticker.id;
                    stickerNameInput.value = sticker.name;
                    stickerPreview.innerHTML = `<img src="${sticker.data}" alt="预览">`;
                    if (sticker.data.startsWith('http')) {
                        stickerUrlInput.value = sticker.data;
                        stickerUrlInput.disabled = false;
                    } else {
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    }
                    addStickerModal.classList.add('visible');
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
            deleteStickerBtn.addEventListener('click', async () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    if (confirm(`确定要删除表情“${sticker.name}”吗？`)) {
                        db.myStickers = db.myStickers.filter(s => s.id !== currentStickerActionTarget);
                        await saveData();
                        renderStickerGrid();
                        showToast('表情已删除');
                    }
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
        }

        function renderStickerGrid() {
            stickerGridContainer.innerHTML = '';
            if (db.myStickers.length === 0) {
                stickerGridContainer.innerHTML = '<p style="color:#aaa; text-align:center;">还没有表情包，快去添加吧！</p>';
                return;
            }
            db.myStickers.forEach(sticker => {
                const item = document.createElement('div');
                item.className = 'sticker-item';
                item.innerHTML = `<img src="${sticker.data}" alt="${sticker.name}"><span>${sticker.name}</span>`;
                item.addEventListener('click', () => sendSticker(sticker));
                item.addEventListener('mousedown', (e) => {
                    if (e.button !== 0) return;
                    e.stopPropagation();
                    longPressTimer = setTimeout(() => {
                        handleStickerLongPress(sticker.id);
                    }, 500);
                });
                item.addEventListener('mouseup', () => clearTimeout(longPressTimer));
                item.addEventListener('mouseleave', () => clearTimeout(longPressTimer));
                item.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    longPressTimer = setTimeout(() => {
                        handleStickerLongPress(sticker.id);
                    }, 500);
                });
                item.addEventListener('touchend', () => clearTimeout(longPressTimer));
                item.addEventListener('touchmove', () => clearTimeout(longPressTimer));
                stickerGridContainer.appendChild(item);
            });
        }

        function handleStickerLongPress(stickerId) {
            clearTimeout(longPressTimer);
            currentStickerActionTarget = stickerId;
            stickerActionSheet.classList.add('visible');
        }

        function setupVoiceMessageSystem() {
            voiceMessageBtn.addEventListener('click', () => {
                sendVoiceForm.reset();
                voiceDurationPreview.textContent = '0"';
                sendVoiceModal.classList.add('visible');
            });
            sendVoiceForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyVoiceMessage(voiceTextInput.value.trim());
            });
        }

        function setupPhotoVideoSystem() {
            photoVideoBtn.addEventListener('click', () => {
                sendPvForm.reset();
                sendPvModal.classList.add('visible');
            });
            sendPvForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyPhotoVideo(pvTextInput.value.trim());
            });
        }

        function setupWalletSystem() {
            walletBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    sendTransferForm.reset();
                    sendTransferModal.classList.add('visible');
                } else if (currentChatType === 'group') {
                    currentGroupAction.type = 'transfer';
                    renderGroupRecipientSelectionList('转账给');
                    groupRecipientSelectionModal.classList.add('visible');
                }
            });
            sendTransferForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const amount = transferAmountInput.value;
                const remark = transferRemarkInput.value.trim();
                if (amount > 0) {
                    sendMyTransfer(amount, remark);
                } else {
                    showToast('请输入有效的金额');
                }
            });
            acceptTransferBtn.addEventListener('click', () => respondToTransfer('received'));
            returnTransferBtn.addEventListener('click', () => respondToTransfer('returned'));
        }

        function handleReceivedTransferClick(messageId) {
            currentTransferMessageId = messageId;
            receiveTransferActionSheet.classList.add('visible');
        }

               async function respondToTransfer(action) {
            if (!currentTransferMessageId) return;
            const character = db.characters.find(c => c.id === currentChatId);
            const message = character.history.find(m => m.id === currentTransferMessageId);
            if (message) {
                message.transferStatus = action;
                const cardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${currentTransferMessageId}"] .transfer-card`);
                if (cardOnScreen) {
                    cardOnScreen.classList.remove('received', 'returned');
                    cardOnScreen.classList.add(action);
                    cardOnScreen.querySelector('.transfer-status').textContent = action === 'received' ? '已收款' : '已退回';
                    cardOnScreen.style.cursor = 'default';
                }

                // --- 新增：收款逻辑 ---
                if (action === 'received') {
                    const amountMatch = message.content.match(/\[.*?的转账：([\d.]+)元；备注：.*?\]/);
                    if (amountMatch) {
                        const amount = parseFloat(amountMatch[1]);
                        addTransaction('income', amount, `收到 ${character.remarkName} 的转账`);
                    }
                }
                // --- 收款逻辑结束 ---

                let contextMessageContent = (action === 'received') ? `[${character.myName}接收${character.realName}的转账]` : `[${character.myName}退回${character.realName}的转账]`;
                const contextMessage = {
                    id: `msg_${Date.now()}`,
                    role: 'user',
                    content: contextMessageContent,
                    parts: [{type: 'text', text: contextMessageContent}],
                    timestamp: Date.now()
                };
                character.history.push(contextMessage);
                await saveData();
                renderChatList();
            }
            receiveTransferActionSheet.classList.remove('visible');
            currentTransferMessageId = null;
        }

               function setupGiftSystem() {if (currentChatType === 'private') {
    const character = db.characters.find(c => c.id === currentChatId);
    if (character && character.isBlockedByAi) {
        showToast('你已被对方拉黑');
        return; // 阻止函数继续执行
    }
}
            giftBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    sendGiftForm.reset();
                    sendGiftModal.classList.add('visible');
                } else if (currentChatType === 'group') {
                    currentGroupAction.type = 'gift';
                    renderGroupRecipientSelectionList('送礼物给');
                    groupRecipientSelectionModal.classList.add('visible');
                }
            });
            sendGiftForm.addEventListener('submit', (e) => {
                e.preventDefault();
                // --- ▼▼▼ 修改：获取价格和描述 ▼▼▼ ---
                const description = document.getElementById('gift-description-input').value.trim();
                const amount = document.getElementById('gift-amount-input').value;
                sendMyGift(description, amount); // 将价格作为参数传递
                // --- ▲▲▲ 修改结束 ▲▲▲ ---
            });
        }
// --- 新代码开始 ---
// ===============================================================
// START: 字体预设功能
// ===============================================================
(function(){
    if (window._fontPresetsScriptLoaded) return;
    window._fontPresetsScriptLoaded = true;

    const PRES_KEY = 'fontPresets';

    function _getFontPresets() {
        try { return JSON.parse(localStorage.getItem(PRES_KEY) || '[]'); }
        catch(e){ return []; }
    }
    function _saveFontPresets(arr) {
        localStorage.setItem(PRES_KEY, JSON.stringify(arr || []));
    }

    function populateFontPresetSelect() {
        const sel = document.getElementById('font-preset-select');
        if (!sel) return;
        const presets = _getFontPresets();
        sel.innerHTML = '<option value="">— 选择一个预设 —</option>';
        presets.forEach((p) => {
            const opt = document.createElement('option');
            opt.value = p.name;
            opt.textContent = p.name;
            sel.appendChild(opt);
        });
    }

    function saveCurrentFontAsPreset() {
        const fontUrlEl = document.getElementById('font-url');
        if (!fontUrlEl) return showToast('找不到字体链接输入框');
        const url = fontUrlEl.value.trim();
        if (!url) return showToast('当前字体链接为空，无法保存');
        
        let name = prompt('请输入预设名称（将覆盖同名预设）:');
        if (!name) return;

        const presets = _getFontPresets();
        const existingPreset = presets.find(p => p.name === name);

        if (existingPreset) {
            existingPreset.url = url;
        } else {
            presets.push({ name, url });
        }
        
        _saveFontPresets(presets);
        populateFontPresetSelect();
        showToast('字体预设已保存');
    }

    function applyFontPreset(presetName) {
        const presets = _getFontPresets();
        const preset = presets.find(p => p.name === presetName);
        if (!preset) {
            showToast('未找到该预设');
            return;
        }

        const fontUrlEl = document.getElementById('font-url');
        if (fontUrlEl) {
            fontUrlEl.value = preset.url;
            // 模拟点击“应用字体”按钮来触发保存和应用逻辑
            const applyBtn = document.querySelector('#font-settings-form button[type="submit"]');
            if (applyBtn) {
                applyBtn.click();
            } else { // Fallback in case button isn't found
                db.fontUrl = preset.url;
                saveData();
                applyGlobalFont(preset.url);
                showToast('字体预设已应用！');
            }
        }
    }

    function openManageFontPresetsModal() {
        const modal = document.getElementById('font-presets-modal');
        const list = document.getElementById('font-presets-list');
        if (!modal || !list) return;

        list.innerHTML = '';
        const presets = _getFontPresets();
        if (!presets.length) {
            list.innerHTML = '<p style="color:#888;margin:6px 0;">暂无预设</p>';
        }

        presets.forEach((p, idx) => {
            const row = document.createElement('div');
            row.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #f0f0f0;';
            
            const nameDiv = document.createElement('div');
            nameDiv.textContent = p.name;
            row.appendChild(nameDiv);

            const btnWrap = document.createElement('div');
            btnWrap.style.cssText = 'display: flex; gap: 6px;';

            const renameBtn = document.createElement('button');
            renameBtn.className = 'btn btn-secondary btn-small';
            renameBtn.textContent = '重命名';
            renameBtn.onclick = function(){
                const newName = prompt('输入新名称：', p.name);
                if (newName && newName.trim()) {
                    const all = _getFontPresets();
                    all[idx].name = newName.trim();
                    _saveFontPresets(all);
                    openManageFontPresetsModal(); // Refresh the list
                    populateFontPresetSelect();
                }
            };

            const delBtn = document.createElement('button');
            delBtn.className = 'btn btn-danger btn-small';
            delBtn.textContent = '删除';
            delBtn.onclick = function(){
                if (!confirm(`确定删除预设 "${p.name}" ?`)) return;
                const all = _getFontPresets();
                all.splice(idx, 1);
                _saveFontPresets(all);
                openManageFontPresetsModal();
                populateFontPresetSelect();
            };

            btnWrap.appendChild(renameBtn);
            btnWrap.appendChild(delBtn);
            row.appendChild(btnWrap);
            list.appendChild(row);
        });
        modal.style.display = 'flex';
    }

    // 将UI绑定函数暴露到全局，以便init()可以调用
    window.bindFontPresetUI = function() {
        populateFontPresetSelect();
        document.getElementById('font-apply-preset').addEventListener('click', () => {
            const val = document.getElementById('font-preset-select').value;
            if (!val) return showToast('请选择要应用的预设');
            applyFontPreset(val);
        });
        document.getElementById('font-save-preset').addEventListener('click', saveCurrentFontAsPreset);
        document.getElementById('font-manage-presets').addEventListener('click', openManageFontPresetsModal);
        document.getElementById('font-close-modal').addEventListener('click', () => {
            document.getElementById('font-presets-modal').style.display = 'none';
        });

        // 监听字体设置页面的打开，以便刷新预设列表
        document.querySelector('.app-icon[data-target="font-settings-screen"]').addEventListener('click', populateFontPresetSelect);
    }
})();
// ===============================================================
// END: 字体预设功能
// ===============================================================
// --- 新代码结束 ---
        function setupFontSettingsApp() {
            fontUrlInput.value = db.fontUrl;
            fontSettingsForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const newFontUrl = fontUrlInput.value.trim();
                db.fontUrl = newFontUrl;
                await saveData();
                applyGlobalFont(newFontUrl);
                showToast('新字体已应用！');
            });
            restoreDefaultFontBtn.addEventListener('click', async () => {
                fontUrlInput.value = '';
                db.fontUrl = '';
                await saveData();
                applyGlobalFont('');
                showToast('已恢复默认字体！');
            });
        }

        function applyGlobalFont(fontUrl) {
            const styleId = 'global-font-style';
            let styleElement = document.getElementById(styleId);
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = styleId;
                document.head.appendChild(styleElement);
            }
            if (fontUrl) {
                const fontName = 'CustomGlobalFont';
                styleElement.innerHTML = `@font-face { font-family: '${fontName}'; src: url('${fontUrl}'); } :root { --font-family: '${fontName}', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }`;
            } else {
                styleElement.innerHTML = `:root { --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }`;
            }
        }
// ▼▼▼ 在这里粘贴下面的新函数 ▼▼▼

// --- 全局辅助函数：填充世界书分类下拉菜单 ---
function populateCategorySelect(selectedCategoryId = 'uncategorized') {
    const selectEl = document.getElementById('world-book-category-select');
    if (!selectEl) return; // 安全检查

    selectEl.innerHTML = '<option value="uncategorized">未分类</option>'; // 默认选项
    
    // 确保 db.worldBookCategories 存在
    if (db && Array.isArray(db.worldBookCategories)) {
        db.worldBookCategories.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat.id;
            option.textContent = cat.name;
            selectEl.appendChild(option);
        });
    }
    
    selectEl.value = selectedCategoryId;
}

// ▲▲▲ 添加结束 ▲▲▲
   function setupWorldBookApp() {
   	const importWorldBookBtn = document.getElementById('import-world-book-btn');
const worldBookImportInput = document.getElementById('world-book-import-input');

importWorldBookBtn.addEventListener('click', () => {
    worldBookImportInput.click();
});

worldBookImportInput.addEventListener('change', handleWorldBookImport);
    // 监听打开编辑/创建世界书页面的事件
    addWorldBookBtn.addEventListener('click', () => {
        currentEditingWorldBookId = null;
        editWorldBookForm.reset();
        document.querySelector('input[name="world-book-position"][value="before"]').checked = true;
        // 调用全局函数填充分类
        populateCategorySelect();
        switchScreen('edit-world-book-screen');
    });

    // 表单保存逻辑 (确保只绑定一次)
    editWorldBookForm.onsubmit = async function(e) {
        e.preventDefault();
        const selectedCategoryId = document.getElementById('world-book-category-select').value;
        const name = worldBookNameInput.value.trim();
        const content = worldBookContentInput.value.trim();
        const position = document.querySelector('input[name="world-book-position"]:checked').value;
        
        const keywords = document.getElementById('world-book-keywords').value.trim();
        const alwaysActive = document.getElementById('world-book-always-active').checked;
        const caseSensitive = document.getElementById('world-book-case-sensitive').checked;

        if (!name || !content) return showToast('名称和内容不能为空');
        
        const bookData = { name, content, position, categoryId: selectedCategoryId, keywords, alwaysActive, caseSensitive };

        if (currentEditingWorldBookId) {
            const book = db.worldBooks.find(wb => wb.id === currentEditingWorldBookId);
            if (book) Object.assign(book, bookData);
        } else {
            bookData.id = `wb_${Date.now()}`;
            db.worldBooks.push(bookData);
        }
        
        await saveData();
        showToast('世界书条目已保存');
        renderWorldBookList();
        switchScreen('world-book-screen');
    };

    // 世界书列表的点击和长按事件
    worldBookListContainer.addEventListener('click', e => {
       const item = e.target.closest('.world-book-item');
        if (item) {
            const book = db.worldBooks.find(wb => wb.id === item.dataset.id);
            if(book) {
                currentEditingWorldBookId = book.id;
                worldBookIdInput.value = book.id;
                worldBookNameInput.value = book.name;
                worldBookContentInput.value = book.content;
                document.querySelector(`input[name="world-book-position"][value="${book.position}"]`).checked = true;
                populateCategorySelect(book.categoryId || 'uncategorized');
                document.getElementById('world-book-keywords').value = book.keywords || '';
                document.getElementById('world-book-always-active').checked = book.alwaysActive || false;
                document.getElementById('world-book-case-sensitive').checked = book.caseSensitive || false;
                switchScreen('edit-world-book-screen');
            }
        }
    });

    worldBookListContainer.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        const item = e.target.closest('.world-book-item');
        if (!item) return;
        longPressTimer = setTimeout(() => {
            const bookId = item.dataset.id;
            const menuItems = [{
                label: '删除',
                danger: true,
                action: async () => {
                    if (confirm('确定要删除这个世界书条目吗？')) {
                        db.worldBooks = db.worldBooks.filter(wb => wb.id !== bookId);
                        db.characters.forEach(char => {
                            char.worldBookIds = (char.worldBookIds || []).filter(id => id !== bookId);
                        });
                        db.groups.forEach(group => {
                            group.worldBookIds = (group.worldBookIds || []).filter(id => id !== bookId);
                        });
                        await saveData();
                        renderWorldBookList();
                        showToast('条目已删除');
                    }
                }
            }];
            createContextMenu(menuItems, e.clientX, e.clientY);
        }, 500);
    });

    worldBookListContainer.addEventListener('mouseup', () => clearTimeout(longPressTimer));
    worldBookListContainer.addEventListener('mouseleave', () => clearTimeout(longPressTimer));
}
// ▲▲▲ 替换结束 ▲▲▲
        function renderWorldBookList() {
            worldBookListContainer.innerHTML = '';
            noWorldBooksPlaceholder.style.display = db.worldBooks.length === 0 ? 'block' : 'none';
            db.worldBooks.forEach(book => {
                const li = document.createElement('li');
                li.className = 'list-item world-book-item';
                li.dataset.id = book.id;
                li.innerHTML = `<div class="item-details" style="padding-left: 20px;"><div class="item-name">${book.name}</div><div class="item-preview">${book.content}</div></div>`;
                
                // 插入：右侧删除世界书按钮（由 ChatGPT 添加）
                const delBtn = document.createElement('button');
                delBtn.className = 'action-btn';
                delBtn.style.position = 'absolute';
                delBtn.style.right = '8px';
                delBtn.style.top = '50%';
                delBtn.style.transform = 'translateY(-50%)';
                delBtn.style.padding = '6px';
                delBtn.style.border = 'none';
                delBtn.style.background = 'transparent';
                delBtn.title = '删除世界书';
                const delImg = document.createElement('img');
                delImg.src = 'https://i.postimg.cc/hGW6B0Wf/icons8-50.png';
                delImg.alt = '删除';
                delImg.style.width = '22px';
                delImg.style.height = '22px';
                delImg.style.objectFit = 'contain';
                delBtn.appendChild(delImg);
                delBtn.addEventListener('click', async (ev) => {
                    ev.stopPropagation();
                    if (!confirm('确定要删除这个世界书条目吗？')) return;
                    try {
                        if (typeof deleteWorldBookById === 'function') {
                            await deleteWorldBookById(book.id);
                        } else if (typeof deleteWorldBook === 'function') {
                            await deleteWorldBook(book.id);
                        } else {
                            // Try in-place removal as fallback
                            db.worldBooks = db.worldBooks.filter(wb => wb.id !== book.id);
                            if (typeof saveData === 'function') await saveData();
                        }
                        // 刷新列表视图
                        if (typeof renderWorldBookList === 'function') renderWorldBookList();
                        showToast && showToast('世界书已删除');
                    } catch (err) {
                        console.error('删除世界书出错', err);
                        alert('删除失败，请查看控制台');
                    }
                });
                // 将按钮附加到 li（li 用 position: relative 保证按钮在右侧）
                li.style.position = 'relative';
                li.appendChild(delBtn);
worldBookListContainer.appendChild(li);
            });
        }
/**
 * 处理用户选择的JSON文件，并分发给相应的解析器
 * @param {Event} event - 文件输入框的change事件
 */
async function handleWorldBookImport(event) {
    const files = event.target.files;
    if (!files.length) return;

    let importedFileCount = 0;
    let errorFileCount = 0;

    showToast(`检测到 ${files.length} 个文件，开始导入...`);

    for (const file of files) {
        try {
            const content = await file.text();
            const data = JSON.parse(content);

            // 根据文件结构特征，判断是哪种格式并调用对应解析函数
            if (data.prompts && Array.isArray(data.prompts)) {
                // 识别为 MoMPsy_1.json 格式
                parseMoMPsyFormat(file.name, data);
                importedFileCount++;
            } else if (data.entries && typeof data.entries === 'object') {
                // 识别为 极光小剧场.json 格式
                parseAuroraTheaterFormat(file.name, data);
                importedFileCount++;
            } else {
                throw new Error('无法识别的文件格式');
            }
        } catch (err) {
            console.error(`导入文件 ${file.name} 失败:`, err);
            errorFileCount++;
        }
    }

    // 批量处理完成后，统一保存和刷新UI
    if (importedFileCount > 0) {
        await saveData();
        renderWorldBookList();
        showToast(`成功导入 ${importedFileCount} 个文件！`);
    }
    if (errorFileCount > 0) {
        showToast(`${errorFileCount} 个文件导入失败，详情请查看控制台。`);
    }

    // 重置文件输入框，以便下次可以再次选择相同的文件
    event.target.value = null;
}

/**
 * 解析 MoMPsy_1.json 格式的文件
 * @param {string} fileName - 原始文件名
 * @param {object} data - 解析后的JSON数据
 */
function parseMoMPsyFormat(fileName, data) {
    // 使用文件名（去除.json后缀）作为分类名
    const categoryName = fileName.replace(/\.json$/i, '');
    let category = db.worldBookCategories.find(cat => cat.name === categoryName);

    // 如果分类不存在，则创建一个新的
    if (!category) {
        category = {
            id: `cat_import_${Date.now()}_${Math.random()}`,
            name: categoryName,
            isCollapsed: false
        };
        db.worldBookCategories.push(category);
    }

    // 遍历 "prompts" 数组，将其中的每个对象转换为一个世界书条目
    data.prompts.forEach(prompt => {
        // 确保条目有有效的内容
        if (prompt.name && prompt.content) {
            const newEntry = {
                id: `wb_import_${Date.now()}_${Math.random()}`,
                name: prompt.name,
                content: prompt.content,
                categoryId: category.id,
                position: 'before', // 默认为前置
                keywords: '',
                alwaysActive: false,
                caseSensitive: false
            };
            db.worldBooks.push(newEntry);
        }
    });
}

/**
 * 解析 极光小剧场.json 格式的文件
 * @param {string} fileName - 原始文件名
 * @param {object} data - 解析后的JSON数据
 */
function parseAuroraTheaterFormat(fileName, data) {
    // 提取文件名中的核心部分作为分类名
    const categoryName = fileName.replace(/\.json$/i, '').replace(/3\.0\.0_Ver_|\.json极光小剧场 3\.0\.0 Ver @电波系/g, '').trim();
    let category = db.worldBookCategories.find(cat => cat.name === categoryName);

    // 如果分类不存在，则创建一个新的
    if (!category) {
        category = {
            id: `cat_import_${Date.now()}_${Math.random()}`,
            name: categoryName || '导入的极光小剧场', // 提供一个备用名称
            isCollapsed: false
        };
        db.worldBookCategories.push(category);
    }

    // 遍历 "entries" 对象的值，将其中的每个对象转换为一个世界书条目
    Object.values(data.entries).forEach(entry => {
        // 确保条目有有效的内容
        if (entry.comment && entry.content) {
            const newEntry = {
                id: `wb_import_${Date.now()}_${Math.random()}`,
                name: entry.comment, // 使用 "comment" 字段作为条目名称
                content: entry.content,
                categoryId: category.id,
                position: 'before', // 默认为前置
                keywords: entry.key ? entry.key.join(',') : '', // 使用 "key" 字段作为关键词
                alwaysActive: false,
                caseSensitive: false
            };
            db.worldBooks.push(newEntry);
        }
    });
}
        function setupChatSettings() {
            const themeSelect = document.getElementById('setting-theme-color');
            themeSelect.innerHTML = '';
            Object.keys(colorThemes).forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = colorThemes[key].name;
                themeSelect.appendChild(option);
            });
            chatSettingsBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    loadSettingsToSidebar();
                    settingsSidebar.classList.add('open');
                } else if (currentChatType === 'group') {
                    loadGroupSettingsToSidebar();
                    groupSettingsSidebar.classList.add('open');
                }
            });
            document.querySelector('.phone-screen').addEventListener('click', e => {
                const openSidebar = document.querySelector('.settings-sidebar.open');
                if (openSidebar && !openSidebar.contains(e.target) && !chatSettingsBtn.contains(e.target) && !e.target.closest('.modal-overlay') && !e.target.closest('.action-sheet-overlay')) {
                    openSidebar.classList.remove('open');
                }
            });

            settingsForm.addEventListener('submit', e => {
                e.preventDefault();
                saveSettingsFromSidebar();
                settingsSidebar.classList.remove('open');
            });
            const useCustomCssCheckbox = document.getElementById('setting-use-custom-css'),
                customCssTextarea = document.getElementById('setting-custom-bubble-css'),
                resetCustomCssBtn = document.getElementById('reset-custom-bubble-css-btn'),
                privatePreviewBox = document.getElementById('private-bubble-css-preview');
            useCustomCssCheckbox.addEventListener('change', (e) => {
                customCssTextarea.disabled = !e.target.checked;
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, customCssTextarea.value, !e.target.checked, theme);
                }
            });
            customCssTextarea.addEventListener('input', (e) => {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char && useCustomCssCheckbox.checked) {
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, e.target.value, false, theme);
                }
            });
            resetCustomCssBtn.addEventListener('click', () => {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    customCssTextarea.value = '';
                    useCustomCssCheckbox.checked = false;
                    customCssTextarea.disabled = true;
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, '', true, theme);
                    showToast('样式已重置为默认');
                }
            });
            document.getElementById('setting-char-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('setting-char-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('头像压缩失败，请重试');
                    }
                }
            });
            document.getElementById('setting-my-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('setting-my-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('头像压缩失败，请重试');
                    }
                }
            });
            document.getElementById('setting-chat-bg-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const char = db.characters.find(c => c.id === currentChatId);
                    if (char) {
                        try {
                            const compressedUrl = await compressImage(file, {
                                quality: 0.85,
                                maxWidth: 1080,
                                maxHeight: 1920
                            });
                            char.chatBg = compressedUrl;
                            chatRoomScreen.style.backgroundImage = `url(${compressedUrl})`;
                            await saveData();
                            showToast('聊天背景已更换');
                        } catch (error) {
                            showToast('背景压缩失败，请重试');
                        }
                    }
                }
            });
            // 这是私聊的修改
clearChatHistoryBtn.addEventListener('click', async () => {
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;
    if (confirm(`你确定要清空与“${character.remarkName}”的所有聊天记录吗？\n\nAI将首先对你们的对话进行总结并存入回忆面板，这个过程需要消耗API额度。`)) {
        await summarizeAndClearHistory();
    }
});
            linkWorldBookBtn.addEventListener('click', () => {
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;
    
    worldBookSelectionList.innerHTML = '';
    
    // 1. 渲染分类
    (db.worldBookCategories || []).forEach(category => {
        const booksInCategory = db.worldBooks.filter(b => b.categoryId === category.id);
        if (booksInCategory.length === 0) return; // 如果分类下没有书，则不显示该分类

        // 检查这个分类下的所有书是否都已被选中
        const allInCategorySelected = booksInCategory.every(book => (character.worldBookIds || []).includes(book.id));
        
        const li = document.createElement('li');
        li.className = 'world-book-select-item';
        li.innerHTML = `
            <input type="checkbox" id="wb-cat-select-${category.id}" data-category-id="${category.id}" ${allInCategorySelected ? 'checked' : ''}>
            <label for="wb-cat-select-${category.id}"><strong>[分类] ${category.name} (${booksInCategory.length}条)</strong></label>
        `;
        worldBookSelectionList.appendChild(li);
    });

    // 2. 渲染未分类的条目
    const uncategorizedBooks = db.worldBooks.filter(b => b.categoryId === 'uncategorized');
    if (uncategorizedBooks.length > 0) {
        // 添加一个分隔标题
        const separator = document.createElement('li');
        separator.innerHTML = `<h4 style="margin: 15px 0 5px; color: #888;">未分类条目</h4>`;
        worldBookSelectionList.appendChild(separator);

        uncategorizedBooks.forEach(book => {
            const isChecked = (character.worldBookIds || []).includes(book.id);
            const li = document.createElement('li');
            li.className = 'world-book-select-item';
            li.innerHTML = `
                <input type="checkbox" id="wb-select-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}>
                <label for="wb-select-${book.id}">${book.name}</label>
            `;
            worldBookSelectionList.appendChild(li);
        });
    }

    worldBookSelectionModal.classList.add('visible');
});
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 请用这个新的代码块，替换掉旧的 saveWorldBookSelectionBtn.addEventListener 监听器 ▼▼▼
saveWorldBookSelectionBtn.addEventListener('click', async () => {
    const selectedIds = new Set(); // 使用 Set 来自动处理重复项

    // 1. 处理分类选择
    worldBookSelectionList.querySelectorAll('input[data-category-id]:checked').forEach(checkbox => {
        const categoryId = checkbox.dataset.categoryId;
        db.worldBooks.forEach(book => {
            if (book.categoryId === categoryId) {
                selectedIds.add(book.id);
            }
        });
    });

    // 2. 处理未分类的单个条目选择
    worldBookSelectionList.querySelectorAll('input[value]:checked').forEach(checkbox => {
        // 确保这个 checkbox 不是分类选择器
        if (!checkbox.dataset.categoryId) {
            selectedIds.add(checkbox.value);
        }
    });

    const finalSelectedIds = Array.from(selectedIds);

    // 3. 保存到对应的聊天对象
    if (currentChatType === 'private') {
        const character = db.characters.find(c => c.id === currentChatId);
        if (character) character.worldBookIds = finalSelectedIds;
    } else if (currentChatType === 'group') {
        const group = db.groups.find(g => g.id === currentChatId);
        if (group) group.worldBookIds = finalSelectedIds;
    }

    await saveData();
    worldBookSelectionModal.classList.remove('visible');
    showToast('世界书关联已更新');
});
}
// ▲▲▲ 替换结束 ▲▲▲

function loadSettingsToSidebar() {
    const e = db.characters.find(e => e.id === currentChatId);
    if (e) {
        document.getElementById('setting-char-avatar-preview').src = e.avatar;
        document.getElementById('setting-char-remark').value = e.remarkName;
        document.getElementById('setting-char-persona').value = e.persona;
        document.getElementById('setting-my-avatar-preview').src = e.myAvatar;
        document.getElementById('setting-my-name').value = e.myName;
        document.getElementById('setting-my-persona').value = e.myPersona;
        document.getElementById('setting-theme-color').value = e.theme || 'white_pink';
        document.getElementById('setting-max-memory').value = e.maxMemory;
        const useCustomCssCheckbox = document.getElementById('setting-use-custom-css'),
            customCssTextarea = document.getElementById('setting-custom-bubble-css'),
            privatePreviewBox = document.getElementById('private-bubble-css-preview');
        useCustomCssCheckbox.checked = e.useCustomBubbleCss || false;
        customCssTextarea.value = e.customBubbleCss || '';
        customCssTextarea.disabled = !useCustomCssCheckbox.checked;
        const theme = colorThemes[e.theme || 'white_pink'];
        updateBubbleCssPreview(privatePreviewBox, e.customBubbleCss, !e.useCustomBubbleCss, theme);
        
        document.getElementById('setting-offline-mode').checked = e.isOfflineMode || false;
        updateBlockButtonState(e);

        // 新增：加载私聊的后台回复设置
        const proactiveToggle = document.getElementById('private-ai-proactive-chat-toggle');
        const proactiveOptions = document.getElementById('private-ai-proactive-options');
        const proactiveDelayInput = document.getElementById('private-ai-proactive-chat-delay');
        const proactiveIntervalInput = document.getElementById('private-ai-proactive-chat-interval');

        proactiveToggle.checked = e.aiProactiveChatEnabled || false;
        proactiveDelayInput.value = e.aiProactiveChatDelay || '';
        proactiveIntervalInput.value = e.aiProactiveChatInterval || '';
        proactiveOptions.style.display = proactiveToggle.checked ? 'block' : 'none';

        proactiveToggle.onchange = (evt) => {
            proactiveOptions.style.display = evt.target.checked ? 'block' : 'none';
            document.getElementById('setting-share-stickers').checked = e.shareStickers || false;
        };
    }
}

   function openGroupMemberEditModal(memberId) {
    const group = db.groups.find(g => g.id === currentChatId);
    const member = group.members.find(m => m.id === memberId);
    if (!member) return;
    document.getElementById('edit-group-member-title').textContent = `编辑 ${member.groupNickname}`;
    document.getElementById('editing-member-id').value = member.id;
    renderAvatarInSettings('group-member-avatar-container-setting', member.avatar, member.avatarFrameUrl);
    document.getElementById('edit-member-group-nickname').value = member.groupNickname;
    document.getElementById('edit-member-real-name').value = member.realName;
    document.getElementById('edit-member-persona').value = member.persona;
    editGroupMemberModal.classList.add('visible');
}

        async function saveSettingsFromSidebar() {
    const e = db.characters.find(e => e.id === currentChatId);
    if (e) {
        e.avatar = document.getElementById('setting-char-avatar-preview').src;
        e.remarkName = document.getElementById('setting-char-remark').value;
        e.persona = document.getElementById('setting-char-persona').value;
        e.myAvatar = document.getElementById('setting-my-avatar-preview').src;
        e.myName = document.getElementById('setting-my-name').value;
        e.myPersona = document.getElementById('setting-my-persona').value;
        e.theme = document.getElementById('setting-theme-color').value;
        e.maxMemory = document.getElementById('setting-max-memory').value;
        e.useCustomBubbleCss = document.getElementById('setting-use-custom-css').checked;
        e.customBubbleCss = document.getElementById('setting-custom-bubble-css').value;
        e.isOfflineMode = document.getElementById('setting-offline-mode').checked;
       e.shareStickers = document.getElementById('setting-share-stickers').checked;
        // 新增：保存私聊的后台回复设置
        e.aiProactiveChatEnabled = document.getElementById('private-ai-proactive-chat-toggle').checked;
        e.aiProactiveChatDelay = parseInt(document.getElementById('private-ai-proactive-chat-delay').value, 10) || 0;
        e.aiProactiveChatInterval = parseInt(document.getElementById('private-ai-proactive-chat-interval').value, 10) || 0;

        await saveData();
        showToast('设置已保存！');
        chatRoomTitle.textContent = e.remarkName;
        renderChatList();
        updateCustomBubbleStyle(currentChatId, e.customBubbleCss, e.useCustomBubbleCss);
        currentPage = 1;
        renderMessages(false, true);
    }
}
        // (请找到文件中的旧 setupApiSettingsApp 函数，并用下面的代码完整替换它)

// (请找到文件中的旧 setupApiSettingsApp 函数，并用下面的代码完整替换它)

function setupApiSettingsApp() {
    const e = document.getElementById('api-form'), t = document.getElementById('fetch-models-btn'),
        a = document.getElementById('api-model'), n = document.getElementById('api-provider'),
        r = document.getElementById('api-url'), s = document.getElementById('api-key'), 
        theaterCheckbox = document.getElementById('force-html-theater'),
        offlineModeCheckbox = document.getElementById('offline-mode-toggle'), // 新增：获取线下模式开关
        autoPostMomentCheckbox = document.getElementById('ai-auto-post-moment'), // ▼▼▼ 在这里添加新代码 ▼▼▼
        c = {
            newapi: '',
            deepseek: 'https://api.deepseek.com',
            claude: 'https://api.anthropic.com',
            gemini: 'https://generativelanguage.googleapis.com'
        };

    if (db.apiSettings) { // 加载已有设置
        n.value = db.apiSettings.provider || 'newapi';
        r.value = db.apiSettings.url || '';
        s.value = db.apiSettings.key || '';
        if (db.apiSettings.model) {
            a.innerHTML = `<option value="${db.apiSettings.model}">${db.apiSettings.model}</option>`;
        }
        theaterCheckbox.checked = !!db.apiSettings.forceHtmlTheater;
        
        autoPostMomentCheckbox.checked = !!db.apiSettings.aiAutoPostMoment; // ▼▼▼ 在这里添加新代码 ▼▼▼
        document.getElementById('ai-block-duration').value = db.apiSettings.aiBlockDuration || '';
    }

    n.addEventListener('change', () => {
        r.value = c[n.value] || ''
    });
    
    t.addEventListener('click', async () => {
        let o = r.value.trim();
        const l = s.value.trim();
        if (!o || !l) return showToast('请先填写API地址和密钥！');
        o.endsWith('/') && (o = o.slice(0, -1));
        const i = 'gemini' === n.value ? `${o}/v1beta/models?key=${getRandomValue(l)}` : `${o}/v1/models`;
        t.classList.add('loading'), t.disabled = !0;
        try {
            const d = 'gemini' === n.value ? {} : {Authorization: `Bearer ${l}`},
                g = await fetch(i, {method: 'GET', headers: d});
            if (!g.ok) throw new Error(`网络响应错误: ${g.status}`);
            const u = await g.json();
            let p = [];
            'gemini' !== n.value && u.data ? p = u.data.map(e => e.id) : 'gemini' === n.value && u.models && (p = u.models.map(e => e.name.replace('models/', ''))), a.innerHTML = '', p.length > 0 ? p.forEach(e => {
                const t = document.createElement('option');
                t.value = e, t.textContent = e, a.appendChild(t)
            }) : a.innerHTML = '<option value="">未找到任何模型</option>', showToast('模型列表拉取成功！')
        } catch (f) {
            showToast(`拉取失败: ${f.message}`), a.innerHTML = '<option value="">拉取失败</option>'
        } finally {
            t.classList.remove('loading'), t.disabled = !1
        }
    });
    
    e.addEventListener('submit', async (e) => {
        e.preventDefault();
        if (!a.value) return showToast('请选择模型后保存！');
        const banApi = URLBlacklist.some((api)=>{
            return r.value.indexOf(api) !== -1
        })
        if(banApi){
            alert('此API网址已加入黑名单，请勿使用')
            return
        }
        // 保存所有设置，包括新的开关状态
        db.apiSettings = {
            provider: n.value, 
            url: r.value, 
            key: s.value, 
            model: a.value,
            forceHtmlTheater: theaterCheckbox.checked,
            aiAutoPostMoment: autoPostMomentCheckbox.checked, // ▼▼▼ 在这里添加新代码 ▼▼▼
            aiBlockDuration: document.getElementById('ai-block-duration').value || 0,
        };
        await saveData();
        showToast('API设置已保存！')
    })
}


   // --- 新代码开始 ---
        function setupWallpaperApp() {
            // 新增：添加了第三个壁纸设置区域的HTML
            document.getElementById('wallpaper-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-container">‹</button><div class="title-container"><h1 class="title">更换壁纸</h1></div><div class="placeholder"></div></header><main class="content">
                <div class="wallpaper-preview" id="wallpaper-preview"><span>主页壁纸预览</span></div>
                <input type="file" id="wallpaper-upload" accept="image/*" style="display: none;">
                <label for="wallpaper-upload" class="btn btn-primary">更换主页壁纸</label>
                <hr style="border:none; border-top:1px solid #eee; margin: 25px 0;">
                <div class="wallpaper-preview" id="wallpaper-preview-2"><span>第二页壁纸预览</span></div>
                <input type="file" id="wallpaper-upload-2" accept="image/*" style="display: none;">
                <label for="wallpaper-upload-2" class="btn btn-secondary">更换第二页壁纸</label>
                
                <hr style="border:none; border-top:1px solid #eee; margin: 25px 0;">
                <div class="wallpaper-preview" id="wallpaper-preview-ai"><span>AI手机壁纸预览</span></div>
                <input type="file" id="wallpaper-upload-ai" accept="image/*" style="display: none;">
                <label for="wallpaper-upload-ai" class="btn btn-neutral">更换AI手机壁纸</label>
            </main>`;
            
            const wallpaperUpload = document.getElementById('wallpaper-upload');
            const wallpaperPreview = document.getElementById('wallpaper-preview');
            const wallpaperUpload2 = document.getElementById('wallpaper-upload-2');
            const wallpaperPreview2 = document.getElementById('wallpaper-preview-2');
            // 新增：获取新添加的元素
            const wallpaperUploadAi = document.getElementById('wallpaper-upload-ai');
            const wallpaperPreviewAi = document.getElementById('wallpaper-preview-ai');

            // 设置初始预览
            wallpaperPreview.style.backgroundImage = `url(${db.wallpaper})`;
            wallpaperPreview.textContent = '';
            wallpaperPreview2.style.backgroundImage = `url(${db.wallpaper2})`;
            wallpaperPreview2.textContent = '';
            // 新增：设置AI手机壁纸的初始预览
            if (db.aiSpaceWallpaper) {
                wallpaperPreviewAi.style.backgroundImage = `url(${db.aiSpaceWallpaper})`;
                wallpaperPreviewAi.textContent = '';
            }


            // 监听主页壁纸更换 (保持不变)
            wallpaperUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.85, maxWidth: 1080, maxHeight: 1920});
                        db.wallpaper = compressedUrl;
                        applyWallpaper(compressedUrl, document.getElementById('home-screen'));
                        wallpaperPreview.style.backgroundImage = `url(${compressedUrl})`;
                        await saveData();
                        showToast('主页壁纸更换成功！');
                    } catch (s) {
                        showToast('壁纸压缩失败，请重试');
                    }
                }
            });

            // 监听第二页壁纸更换 (保持不变)
            wallpaperUpload2.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.85, maxWidth: 1080, maxHeight: 1920});
                        db.wallpaper2 = compressedUrl;
                        applyWallpaper(compressedUrl, document.getElementById('home-screen-2'));
                        wallpaperPreview2.style.backgroundImage = `url(${compressedUrl})`;
                        await saveData();
                        showToast('第二页壁纸更换成功！');
                    } catch (s) {
                        showToast('壁纸压缩失败，请重试');
                    }
                }
            });

            // 新增：监听AI手机壁纸更换
            wallpaperUploadAi.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.85, maxWidth: 1080, maxHeight: 1920});
                        db.aiSpaceWallpaper = compressedUrl;
                        applyAiSpaceWallpaper(compressedUrl); // 调用我们新增的函数来应用壁纸
                        wallpaperPreviewAi.style.backgroundImage = `url(${compressedUrl})`;
                        wallpaperPreviewAi.textContent = '';
                        await saveData();
                        showToast('AI手机壁纸更换成功！');
                    } catch (s) {
                        showToast('壁纸压缩失败，请重试');
                    }
                }
            });
        }
// --- 新代码结束 ---

    function renderMyStickers() {
        if (!stickerGridContainer) return; // 安全检查
        
        stickerGridContainer.innerHTML = '';
        if (db.myStickers.length === 0) {
            stickerGridContainer.innerHTML = '<p style="color:#aaa; text-align:center; grid-column: 1 / -1;">还没有表情哦，快去添加吧！</p>';
            return;
        }

        db.myStickers.forEach(sticker => {
            const item = document.createElement('div');
            item.className = 'sticker-item';
            item.dataset.id = sticker.id;
            item.innerHTML = `<img src="${sticker.url}" alt="${sticker.name}"><span>${sticker.name}</span>`;
            
            // 为每个表情项添加长按/右键菜单事件
            item.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                currentStickerActionTarget = sticker.id;
                stickerActionSheet.classList.add('visible');
            });
            item.addEventListener('touchstart', (e) => {
                longPressTimer = setTimeout(() => {
                    e.preventDefault();
                    currentStickerActionTarget = sticker.id;
                    stickerActionSheet.classList.add('visible');
                }, 500);
            });
            item.addEventListener('touchend', () => clearTimeout(longPressTimer));
            item.addEventListener('touchmove', () => clearTimeout(longPressTimer));

            stickerGridContainer.appendChild(item);
        });
    }

function setupStickerSystem() {
            stickerToggleBtn.addEventListener('click', () => {
                stickerModal.classList.toggle('visible');
                if (stickerModal.classList.contains('visible')) {
                    renderStickerGrid();
                }
            });
            addNewStickerBtn.addEventListener('click', () => {
                addStickerModalTitle.textContent = '添加新表情';
                addStickerForm.reset();
                stickerEditIdInput.value = '';
                stickerPreview.innerHTML = '<span>预览</span>';
                stickerUrlInput.disabled = false;
                addStickerModal.classList.add('visible');
            });
            addStickerForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = stickerNameInput.value.trim();
                const id = stickerEditIdInput.value;
                const previewImg = stickerPreview.querySelector('img');
                const data = previewImg ? previewImg.src : null;
                if (!name || !data) {
                    return showToast('请填写表情名称并提供图片');
                }
                const stickerData = {name, data};
                if (id) {
                    const index = db.myStickers.findIndex(s => s.id === id);
                    if (index > -1) {
                        db.myStickers[index] = {...db.myStickers[index], ...stickerData};
                    }
                } else {
                    stickerData.id = `sticker_${Date.now()}`;
                    db.myStickers.push(stickerData);
                }
                await saveData();
                renderStickerGrid();
                addStickerModal.classList.remove('visible');
                showToast('表情包已保存');
            });
            stickerUrlInput.addEventListener('input', (e) => {
                stickerPreview.innerHTML = `<img src="${e.target.value}" alt="预览">`;
                stickerFileUpload.value = '';
            });
            stickerFileUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 200, maxHeight: 200});
                        stickerPreview.innerHTML = `<img src="${compressedUrl}" alt="预览">`;
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    } catch (error) {
                        console.error('表情包压缩失败:', error);
                        showToast('表情包压缩失败，请重试');
                    }
                }
            });
            editStickerBtn.addEventListener('click', () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    addStickerModalTitle.textContent = '编辑表情';
                    stickerEditIdInput.value = sticker.id;
                    stickerNameInput.value = sticker.name;
                    stickerPreview.innerHTML = `<img src="${sticker.data}" alt="预览">`;
                    if (sticker.data.startsWith('http')) {
                        stickerUrlInput.value = sticker.data;
                        stickerUrlInput.disabled = false;
                    } else {
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    }
                    addStickerModal.classList.add('visible');
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
            deleteStickerBtn.addEventListener('click', async () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    if (confirm(`确定要删除表情“${sticker.name}”吗？`)) {
                        db.myStickers = db.myStickers.filter(s => s.id !== currentStickerActionTarget);
                        await saveData();
                        renderStickerGrid();
                        showToast('表情已删除');
                    }
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
        }


   
        // --- GROUP CHAT FUNCTIONS ---
        // --- DIARY SYSTEM FUNCTIONS ---

// 用于生成日记的 AI 调用函数
async function generateDiaryEntry(isManual = false) {
    if (isGenerating) {
        //showToast('AI正在思考中，请稍等...');
        return;
    }
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;

    if (isManual) {
        showToast('正在为您撰写日记...');
    }

    isGenerating = true;
    typingIndicator.textContent = `${character.remarkName} 正在奋笔疾书...`;
    typingIndicator.style.display = 'block';

    try {
        const memory = character.history.slice(-character.maxMemory);
        const worldBooks = db.worldBooks.filter(wb => (character.worldBookIds || []).includes(wb.id));
        
        let context = `角色设定:\n你叫${character.remarkName}（真名：${character.realName}），你的人设是：${character.persona}\n`;
        context += `用户设定:\n我的名字是${character.myName}，我的人设是：${character.myPersona}\n`;

        const beforeWorldBooks = worldBooks.filter(wb => wb.position === 'before').map(wb => `[${wb.name}]\n${wb.content}`).join('\n\n');
        const afterWorldBooks = worldBooks.filter(wb => wb.position === 'after').map(wb => `[${wb.name}]\n${wb.content}`).join('\n\n');
        if (beforeWorldBooks) context = `${beforeWorldBooks}\n\n${context}`;
        if (afterWorldBooks) context += `\n\n${afterWorldBooks}`;

        let historyText = memory.map(msg => {
            const sender = msg.role === 'user' ? character.myName : character.remarkName;
            const contentMatch = msg.content.match(/\[.*?的消息：([\s\S]+?)\]/);
            const cleanContent = contentMatch ? contentMatch[1] : msg.content;
            return `${sender}: ${cleanContent}`;
        }).join('\n');
        
        const prompt = `${context}\n\n请你严格扮演 ${character.remarkName}，根据我们最近的对话，用你的第一人称视角写一篇大约300字的日记。日记需要深刻体现你的性格和人设，可以包含对我们关系的思考、你的秘密情感或计划。如果符合你的人设，日记内容可以包含NSFW元素。请直接输出日记正文，不要包含“好的，这是日记：”等多余的话。\n\n最近的对话如下:\n${historyText}`;

        let messagesForApi;
        const { provider } = db.apiSettings; 

        if (provider === 'gemini') {
            messagesForApi = [{ role: 'user', parts: [{ type: 'text', text: prompt }] }];
        } else {
            messagesForApi = [{ role: 'user', content: prompt }];
        }
        
        const aiResponseText = await callAiApi(messagesForApi);
        
        await saveDiaryEntry(aiResponseText);
        
        showToast('一篇新的日记已经写好了！');
        
        if (document.getElementById('diary-screen').classList.contains('active')) {
            renderDiaries();
        }

    } catch (error) {
        console.error('日记生成失败:', error);
        showToast(`日记生成失败: ${error.message}`);
    } finally {
        isGenerating = false;
        typingIndicator.textContent = '';
        typingIndicator.style.display = 'none';
        if (!isManual) {
             character.messageCountSinceLastDiary = 0;
             await saveData();
        }
    }
}

// 保存日记并处理存储逻辑
// (请找到文件中的旧 saveDiaryEntry 函数，并用下面的代码完整替换它)

// 保存日记并处理存储逻辑
// (请找到文件中的旧 saveDiaryEntry 函数，并用下面的代码完整替换它)

// 保存日记并处理存储逻辑
async function saveDiaryEntry(content) {
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;
    
    // 确保 diaries 数组存在
    if (!Array.isArray(character.diaries)) {
        character.diaries = [];
    }

    const newDiary = {
        id: `diary_${Date.now()}`,
        timestamp: Date.now(),
        content: content.trim(),
        isFavorited: false
    };

    character.diaries.push(newDiary);
    
    // --- 新版逻辑：当未收藏日记达到第6篇时，清空前5篇 ---
    
    // 1. 将日记分为“已收藏”和“未收藏”两组
    const favoritedDiaries = character.diaries.filter(d => d.isFavorited);
    let unfavoritedDiaries = character.diaries.filter(d => !d.isFavorited);

    // 2. 检查“未收藏”的日记数量是否正好达到了6篇
    if (unfavoritedDiaries.length === 6) {
        // 3. 如果是，则按时间排序以确保新生成的日记在最后
        unfavoritedDiaries.sort((a, b) => a.timestamp - b.timestamp);
        
        // 4. 只保留数组中的最后一个元素（即刚刚新生成的第6篇），从而删除前5篇
        unfavoritedDiaries = unfavoritedDiaries.slice(-1);
    }

    // 5. 将“已收藏”和“处理后保留的未收藏”合并，形成最终的日记列表
    character.diaries = [...favoritedDiaries, ...unfavoritedDiaries];

    // --- 新版逻辑结束 ---
    
    // 重置消息计数
    character.messageCountSinceLastDiary = 0;
    
    await saveData();
}

// 渲染日记列表
function renderDiaries() {
    const character = db.characters.find(c => c.id === currentChatId);
    const container = document.getElementById('diary-list-container');
    const placeholder = document.getElementById('no-diaries-placeholder');
    
    if (!character || !character.diaries || character.diaries.length === 0) {
        container.innerHTML = '';
        placeholder.style.display = 'block';
        return;
    }

    placeholder.style.display = 'none';
    container.innerHTML = '';
    
    const sortedDiaries = [...character.diaries].sort((a, b) => b.timestamp - a.timestamp);
    
    sortedDiaries.forEach(diary => {
        const li = document.createElement('li');
        li.className = 'diary-entry';
        li.dataset.id = diary.id;
        
        const date = new Date(diary.timestamp);
        const dateString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
        
        li.innerHTML = `
            <div class="diary-header">
                <span class="diary-date">${dateString}</span>
                <div class="diary-actions">
                    <button class="favorite-diary-btn ${diary.isFavorited ? 'favorited' : ''}" title="收藏">
                        <svg viewBox="0 0 24 24"><path d="M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z" /></svg>
                    </button>
                    <button class="delete-diary-btn" title="删除">
                        <svg viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" /></svg>
                    </button>
                </div>
            </div>
            <div class="diary-content">${diary.content}</div>
        `;
        container.appendChild(li);
    });
}

// 打开日记屏幕
function openDiaryScreen() {
    if (!currentChatId || currentChatType !== 'private') return;
    renderDiaries();
    switchScreen('diary-screen');
}

// 设置所有与日记相关的事件监听
// === 全新的日记系统核心逻辑 (完整替换旧的 setupDiarySystem) ===
// === 全新的日记系统核心逻辑 (完整替换旧的 setupDiarySystem) ===
// === 全新的日记系统核心逻辑 (完整替换旧的 setupDiarySystem) ===
function setupDiarySystem() {
    let currentAiDiaryPage = 1;
    const diariesPerPage = 5;

    // --- DOM 元素缓存 ---
    const diaryBtn = document.getElementById('diary-btn');
    const diaryActionSheet = document.getElementById('diary-actionsheet');
    
    const openAiDiaryBtn = document.getElementById('open-ai-diary-btn');
    const openUserDiaryBtn = document.getElementById('open-user-diary-btn');
    const openWriteDiaryBtn = document.getElementById('open-write-user-diary-btn');
    const openFavoritesBtn = document.getElementById('open-favorites-diary-btn');
    
    const aiDiaryScreen = document.getElementById('diary-screen');
    const userDiaryScreen = document.getElementById('user-diary-screen');
    const favoritesDiaryScreen = document.getElementById('favorites-diary-screen');
    const writeUserDiaryModal = document.getElementById('write-user-diary-modal');
    const aiPeekModal = document.getElementById('ai-peek-selection-modal');

    // --- 渲染函数 ---

    // 渲染AI日记（带翻页）
    function renderAiDiaries() {
        const character = db.characters.find(c => c.id === currentChatId);
        const container = document.getElementById('diary-list-container');
        const placeholder = document.getElementById('no-diaries-placeholder');

        if (!character || !character.diaries || character.diaries.length === 0) {
            container.innerHTML = '';
            placeholder.style.display = 'block';
            return;
        }

        placeholder.style.display = 'none';
        container.innerHTML = '';

        const sortedDiaries = [...character.diaries].sort((a, b) => b.timestamp - a.timestamp);
        const totalPages = Math.ceil(sortedDiaries.length / diariesPerPage);
        currentAiDiaryPage = Math.max(1, Math.min(currentAiDiaryPage, totalPages));
        
        const startIndex = (currentAiDiaryPage - 1) * diariesPerPage;
        const diariesToShow = sortedDiaries.slice(startIndex, startIndex + diariesPerPage);

        diariesToShow.forEach(diary => {
            container.appendChild(createDiaryEntryElement(diary, false));
        });

        if (totalPages > 1) {
            const paginationDiv = document.createElement('div');
            paginationDiv.className = 'diary-pagination';
            paginationDiv.innerHTML = `
                <button id="prev-page-btn" class="btn btn-neutral btn-small" ${currentAiDiaryPage === 1 ? 'disabled' : ''}>上一页</button>
                <span class="page-indicator">第 ${currentAiDiaryPage} / ${totalPages} 页</span>
                <button id="next-page-btn" class="btn btn-neutral btn-small" ${currentAiDiaryPage === totalPages ? 'disabled' : ''}>下一页</button>
            `;
            container.appendChild(paginationDiv);
        }
    }
    
    // 渲染我的日记
    function renderUserDiaries() {
        const container = document.getElementById('user-diary-list-container');
        const placeholder = document.getElementById('no-user-diaries-placeholder');

        if (!db.userDiaries || db.userDiaries.length === 0) {
            container.innerHTML = '';
            placeholder.style.display = 'block';
            return;
        }
        
        placeholder.style.display = 'none';
        container.innerHTML = '';
        
        const sortedDiaries = [...db.userDiaries].sort((a, b) => b.timestamp - a.timestamp);
        sortedDiaries.forEach(diary => {
            container.appendChild(createDiaryEntryElement(diary, true));
        });
    }

    // 渲染收藏的日记
    function renderFavoriteDiaries() {
        const character = db.characters.find(c => c.id === currentChatId);
        const container = document.getElementById('favorites-diary-list-container');
        const placeholder = document.getElementById('no-favorites-placeholder');

        const allDiaries = [
            ...(character.diaries || []).map(d => ({...d, isUser: false})),
            ...(db.userDiaries || []).map(d => ({...d, isUser: true}))
        ];
        const favorited = allDiaries.filter(d => d.isFavorited);

        if (favorited.length === 0) {
            container.innerHTML = '';
            placeholder.style.display = 'block';
            return;
        }

        placeholder.style.display = 'none';
        container.innerHTML = '';
        favorited.sort((a, b) => b.timestamp - a.timestamp);
        favorited.forEach(diary => {
            container.appendChild(createDiaryEntryElement(diary, diary.isUser));
        });
    }

    // 创建单个日记条目的HTML元素（使用<details>实现折叠）
    function createDiaryEntryElement(diary, isUser = false) {
        const details = document.createElement('details');
        details.className = `diary-entry ${isUser ? 'user-diary-entry' : ''}`;
        details.dataset.id = diary.id;
        details.dataset.type = isUser ? 'user' : 'ai';

        const date = new Date(diary.timestamp);
        const dateString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
        
        let actionsHTML = `<button class="favorite-diary-btn ${diary.isFavorited ? 'favorited' : ''}" title="收藏"><svg viewBox="0 0 24 24"><path d="M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z" /></svg></button>`;
        if (isUser) {
            actionsHTML += `<button class="edit-user-diary-btn" title="编辑"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z" /></svg></button>`;
        }
        actionsHTML += `<button class="delete-diary-btn" title="删除"><svg viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" /></svg></button>`;

        let commentsHTML = '';
        if (isUser && diary.aiComments && diary.aiComments.length > 0) {
            commentsHTML = `<details class="ai-comment-section">
                                <summary class="ai-comment-header">查看AI的悄悄话 (${diary.aiComments.length}条)</summary>`;
            diary.aiComments.forEach(comment => {
                const ai = db.characters.find(c => c.id === comment.aiId);
                if (ai) {
                    commentsHTML += `<div class="ai-comment-entry">
                                        <img src="${ai.avatar}" alt="${ai.remarkName}" class="ai-comment-avatar">
                                        <div class="ai-comment-bubble">${comment.text.replace(/\n/g, '<br>')}</div>
                                     </div>`;
                }
            });
            commentsHTML += '</details>';
        }
        
        details.innerHTML = `
            <summary class="diary-header">
                <span class="diary-date">${dateString}${isUser ? ' (我)' : ''}</span>
                <div class="diary-actions">${actionsHTML}</div>
            </summary>
            <div class="diary-content">${diary.content.replace(/\n/g, '<br>')}</div>
            ${commentsHTML}
        `;
        return details;
    }

    // --- 事件处理函数 ---

    async function saveUserDiary(e) {
        e.preventDefault();
        const content = document.getElementById('user-diary-content-input').value.trim();
        const editingId = document.getElementById('editing-user-diary-id').value;

        if (editingId) {
            const diary = db.userDiaries.find(d => d.id === editingId);
            if (diary) diary.content = content;
        } else {
            const newDiary = {
                id: `user_diary_${Date.now()}`,
                timestamp: Date.now(),
                content: content,
                isFavorited: false,
                aiComments: []
            };
            db.userDiaries.push(newDiary);
            
            // 自动偷看逻辑 (60%概率)
            if (Math.random() < 0.6 && db.characters.length > 0) {
                setTimeout(() => {
                    const randomAi = db.characters[Math.floor(Math.random() * db.characters.length)];
                    handleAiPeek(newDiary.id, randomAi.id, true); // true表示是自动偷看
                }, 2000);
            }
        }
        
        await saveData();
        renderUserDiaries();
        showToast('日记已保存');
        writeUserDiaryModal.classList.remove('visible');
    }

    async function handleAiPeek(diaryId, aiId, isAuto = false) {
        const userDiary = db.userDiaries.find(d => d.id === diaryId);
        const peekingAi = db.characters.find(c => c.id === aiId);
        if (!userDiary || !peekingAi) return;

        if (!isAuto) showToast(`${peekingAi.remarkName} 正在偷偷看你的日记...`);
        aiPeekModal.classList.remove('visible');
        
        const myProfile = db.characters.find(c => c.id === currentChatId);
        
        const prompt = `你正在扮演角色“${peekingAi.realName}”，人设是：${peekingAi.persona}。你刚刚偷偷看到了“${myProfile.myName}”写的一篇日记，对方的人设是：“${myProfile.myPersona || '无特定人设'}”。
        
        # 日记内容
        "${userDiary.content}"
        
        # 你的任务
        1.  根据你的人设，以及对日记作者人设的理解，写一段**不少于150字**的、作为你**内心真实想法**的评论。这段评论是对日记内容的直接回应，要体现出你的情感和思考。
        2.  你必须记住日记里的内容，因为这可能会影响你未来和 ${myProfile.myName} 的对话。
        3.  在未来的对话中，你可以根据日记内容有感而发，但**绝对不能**提及或暗示你看过这篇日记。
        4.  你的输出必须**直接是评论内容**，不要包含任何“好的，这是我的评论：”之类的话。`;

        try {
            const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
            
            userDiary.aiComments = userDiary.aiComments || [];
            userDiary.aiComments.push({ aiId: peekingAi.id, text: aiResponseText, timestamp: Date.now() });

            const contextMessage = {
                id: `msg_context_peek_${Date.now()}`, role: 'user',
                content: `[system: 你刚刚偷偷阅读了 ${myProfile.myName} 的一篇日记。日记内容是：“${userDiary.content}”。你必须记住这件事，但绝对不能在对话中透露你是如何知道这些信息的。]`,
                parts: [{ type: 'text', text: `[system: 你刚刚偷偷阅读了 ${myProfile.myName} 的一篇日记。日记内容是：“${userDiary.content}”。你必须记住这件事，但绝对不能在对话中透露你是如何知道这些信息的。]` }],
                timestamp: Date.now()
            };
            peekingAi.history.push(contextMessage);

            await saveData();
            
        // --- 核心修正：不再重新渲染整个列表 ---
        // 而是找到对应的日记条目，动态更新它的评论区
        if (document.getElementById('user-diary-screen').classList.contains('active')) {
            const diaryEntryEl = document.querySelector(`.diary-entry[data-id="${diaryId}"]`);
            if (diaryEntryEl) {
                // 重新构建这个条目的 HTML 并替换，比复杂的 DOM 操作更简单可靠
                const newDiaryEl = createDiaryEntryElement(userDiary, true);
                diaryEntryEl.replaceWith(newDiaryEl);
            }
        }
        // --- 修正结束 ---

                   if (!isAuto) showToast(`${peekingAi.remarkName} 留下了悄悄话...`);

    } catch (error) {
        console.error('AI偷看失败:', error);
        if (!isAuto) showToast('AI偷看失败: ' + error.message);
    }
}

    // --- 事件绑定 ---
    
    // 统一的日记入口
    [diaryBtn, document.querySelector('.function-item[data-action="diary"]')].forEach(btn => {
        btn.addEventListener('click', () => {
             if (!currentChatId || currentChatType !== 'private') return;
             diaryActionSheet.classList.add('visible');
        });
    });
    
    // 面板按钮
    openAiDiaryBtn.addEventListener('click', () => { currentAiDiaryPage = 1; renderAiDiaries(); switchScreen('diary-screen'); diaryActionSheet.classList.remove('visible'); });
    openUserDiaryBtn.addEventListener('click', () => { renderUserDiaries(); switchScreen('user-diary-screen'); diaryActionSheet.classList.remove('visible'); });
    openWriteDiaryBtn.addEventListener('click', () => { 
        document.getElementById('write-user-diary-form').reset();
        document.getElementById('editing-user-diary-id').value = '';
        writeUserDiaryModal.classList.add('visible'); 
        diaryActionSheet.classList.remove('visible');
    });
    openFavoritesBtn.addEventListener('click', () => { renderFavoriteDiaries(); switchScreen('favorites-diary-screen'); diaryActionSheet.classList.remove('visible'); });

    document.getElementById('generate-diary-manually-btn').addEventListener('click', () => generateDiaryEntry(true));
    document.getElementById('write-user-diary-form').addEventListener('submit', saveUserDiary);
    document.getElementById('ai-peek-btn').addEventListener('click', () => {
        const list = document.getElementById('ai-peek-selection-list');
        list.innerHTML = '';
        db.characters.forEach(char => {
             const li = document.createElement('li');
             li.className = 'list-item'; li.style.cursor = 'pointer'; li.dataset.aiId = char.id;
             li.innerHTML = `<img src="${char.avatar}" alt="${char.remarkName}" class="chat-avatar"><div class="item-details"><div class="item-name">${char.remarkName}</div></div>`;
             list.appendChild(li);
        });
        aiPeekModal.classList.add('visible');
    });
    
    document.getElementById('ai-peek-selection-modal').addEventListener('click', e => {
        if (!db.userDiaries || db.userDiaries.length === 0) {
            showToast('还没有日记可供偷看哦。');
            aiPeekModal.classList.remove('visible');
            return;
        }
        const lastDiary = [...db.userDiaries].sort((a,b) => b.timestamp - a.timestamp)[0];
        
        if (e.target.id === 'ai-auto-peek-btn') {
            const randomAi = db.characters[Math.floor(Math.random() * db.characters.length)];
            handleAiPeek(lastDiary.id, randomAi.id);
        } else {
            const item = e.target.closest('.list-item');
            if (item && item.dataset.aiId) {
                handleAiPeek(lastDiary.id, item.dataset.aiId);
            }
        }
    });

    document.body.addEventListener('click', async e => {
        const summary = e.target.closest('.diary-header');
        if (summary) {
            const details = summary.parentElement;
            if(details.tagName !== 'DETAILS') return;
            // 如果是点击收藏/删除/编辑按钮，则不切换折叠状态
            if(e.target.closest('.diary-actions')) {
                e.preventDefault();
            }
        }

        const diaryEntry = e.target.closest('.diary-entry');
        if (!diaryEntry) return;

        const diaryId = diaryEntry.dataset.id;
        const diaryType = diaryEntry.dataset.type;
        const character = db.characters.find(c => c.id === currentChatId);
        
        let diary, diaryList;
        if (diaryType === 'user') {
            diaryList = db.userDiaries;
        } else if (character) {
            diaryList = character.diaries;
        }

        if (diaryList) diary = diaryList.find(d => d.id === diaryId);
        if (!diary) return;

        if (e.target.closest('.favorite-diary-btn')) {
            if (isFavoriteProcessing) return; // 如果正在处理中，则阻止后续操作
        isFavoriteProcessing = true; // 上锁

        const favBtn = e.target.closest('.favorite-diary-btn');
        diary.isFavorited = !diary.isFavorited; // 切换状态
        await saveData(); // 保存新状态

        // 根据最终状态更新UI和提示
        favBtn.classList.toggle('favorited', diary.isFavorited);
        showToast(diary.isFavorited ? '已收藏' : '已取消收藏');

        // 300毫秒后解锁，以便下次可以点击
        setTimeout(() => { isFavoriteProcessing = false; }, 300);
        // ▲▲▲ 替换结束 ▲▲▲
    }
        if (e.target.closest('.delete-diary-btn')) {
            if (confirm('确定要删除这篇日记吗？')) {
                const index = diaryList.findIndex(d => d.id === diaryId);
                if (index > -1) diaryList.splice(index, 1);
                await saveData();
                diaryEntry.remove();
                showToast('日记已删除');
            }
        }
        
        if (diaryType === 'user' && e.target.closest('.edit-user-diary-btn')) {
             document.getElementById('write-user-diary-form').reset();
             document.getElementById('editing-user-diary-id').value = diary.id;
             document.getElementById('user-diary-content-input').value = diary.content;
             writeUserDiaryModal.classList.add('visible');
        }
    });
    
    aiDiaryScreen.addEventListener('click', e => {
        if (e.target.id === 'prev-page-btn') { currentAiDiaryPage--; renderAiDiaries(); } 
        else if (e.target.id === 'next-page-btn') { currentAiDiaryPage++; renderAiDiaries(); }
    });
}

/**
 * 打开设置群头衔的成员选择模态框
 */
function openSetGroupTitleModal() {
    const group = db.groups.find(g => g.id === currentChatId);
    if (!group) return;

    const memberListEl = document.getElementById('group-title-member-list');
    memberListEl.innerHTML = ''; // 清空旧列表

    // 将自己也添加到列表中以便设置
    const myItem = document.createElement('li');
    myItem.className = 'list-item';
    myItem.style.cursor = 'pointer';
    myItem.dataset.memberId = 'user_me'; // 用于标识用户的特殊ID
    myItem.innerHTML = `
        <img src="${group.me.avatar}" alt="${group.me.nickname}" class="chat-avatar">
        <div class="item-details">
            <div class="item-name">${group.me.nickname} <span style="font-weight:normal; color:#888;">(我)</span></div>
            <div class="item-preview">${group.me.groupTitle || '暂无头衔'}</div>
        </div>`;
    memberListEl.appendChild(myItem);

    // 添加所有AI成员
    group.members.forEach(member => {
        const li = document.createElement('li');
        li.className = 'list-item';
        li.style.cursor = 'pointer';
        li.dataset.memberId = member.id;
        li.innerHTML = `
            <img src="${member.avatar}" alt="${member.groupNickname}" class="chat-avatar">
            <div class="item-details">
                <div class="item-name">${member.groupNickname}</div>
                <div class="item-preview">${member.groupTitle || '暂无头衔'}</div>
            </div>`;
        memberListEl.appendChild(li);
    });

    // 为列表项绑定点击事件
    memberListEl.onclick = handleGroupTitleMemberSelect;

    document.getElementById('set-group-title-modal').classList.add('visible');
}

/**
 * 处理在头衔设置模态框中选择成员的事件
 */
async function handleGroupTitleMemberSelect(e) {
    const memberItem = e.target.closest('.list-item');
    if (!memberItem) return;

    const memberId = memberItem.dataset.memberId;
    const group = db.groups.find(g => g.id === currentChatId);
    if (!group) return;

    // 根据ID找到对应的成员对象（可能是用户自己或AI成员）
    const isMe = memberId === 'user_me';
    const member = isMe ? group.me : group.members.find(m => m.id === memberId);
    
    if (!member) return;

    const currentTitle = member.groupTitle || '';
    const newTitle = prompt(`为 "${isMe ? member.nickname : member.groupNickname}" 设置群头衔（最多7个字，留空则取消头衔）：`, currentTitle);

    if (newTitle === null) return; // 用户点击了“取消”

    if (newTitle.length > 7) {
        showToast('群头衔不能超过7个字！');
        return;
    }
    
    // 更新数据中的头衔
    member.groupTitle = newTitle.trim();
    
    document.getElementById('set-group-title-modal').classList.remove('visible');
    showToast('群头衔设置成功！');
    
    // 如果设置的是AI成员的头衔，则发送通知
    if (!isMe) {
        await sendGroupTitleNotification(member, member.groupTitle);
    } else {
        await saveData(); // 如果是自己，直接保存即可
    }
    
    // 立即刷新聊天界面以显示新头衔
    renderMessages(false, true);
    // 如果设置面板是打开的，也刷新一下成员列表
    if(groupSettingsSidebar.classList.contains('open')) {
        renderGroupMembersInSettings(group);
    }
}

/**
 * 向群聊中发送一条关于头衔变更的系统消息，以通知AI
 */
async function sendGroupTitleNotification(member, newTitle) {
    const group = db.groups.find(g => g.id === currentChatId);
    if (!group) return;

    const actionText = newTitle ? `的群头衔为 "${newTitle}"` : `取消了 ${member.realName} 的群头衔`;
    const messageContent = `[system: ${group.me.nickname} 设置了 ${member.realName} ${actionText}]`;
    
    const message = {
        id: `msg_title_${Date.now()}`,
        role: 'user', // 作为用户侧的系统消息，确保AI能处理
        content: messageContent,
        parts: [{ type: 'text', text: messageContent }],
        timestamp: Date.now(),
        senderId: 'user_me'
    };

    group.history.push(message);
    addMessageBubble(message); // 在界面上显示这条系统通知
    await saveData();
}

/**
 * 根据头衔内容返回一个用于样式的CSS类名
 * @param {string} title - The group title text.
 * @returns {string} - The CSS class name.
 */
function getBadgeClassForTitle(title) {
    if (!title) return '';
    // 这是一个简单的示例逻辑，您可以根据需要自定义
    const length = title.length;
    if (title.includes('主')) return 'lv26';
    if (length <= 2) return 'lv10';
    if (length <= 4) return 'lv11';
    return 'lv12';
}
              function setupGroupChatSystem() {
            createGroupBtn.addEventListener('click', () => {
                renderMemberSelectionList();
                createGroupModal.classList.add('visible');
            });
            createGroupForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const selectedMemberIds = Array.from(memberSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                const groupName = groupNameInput.value.trim();
                if (selectedMemberIds.length < 1) return showToast('请至少选择一个群成员。');
                if (!groupName) return showToast('请输入群聊名称。');
                const firstChar = db.characters.length > 0 ? db.characters[0] : null;
                const newGroup = {
                    id: `group_${Date.now()}`,
                    name: groupName,
                    avatar: 'https://i.postimg.cc/fTLCngk1/image.jpg',
                    me: {
                        nickname: firstChar ? firstChar.myName : '我',
                        persona: firstChar ? firstChar.myPersona : '',
                        avatar: firstChar ? firstChar.myAvatar : 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg'
                    },
                    members: selectedMemberIds.map(charId => {
                        const char = db.characters.find(c => c.id === charId);
                        return {
                            id: `member_${char.id}`,
                            originalCharId: char.id,
                            realName: char.realName,
                            groupNickname: char.remarkName,
                            persona: char.persona,
                            avatar: char.avatar
                        };
                    }),
                    theme: 'white_pink',
                    maxMemory: 10,
                    chatBg: '',
                    history: [],
                    isPinned: false,
                    useCustomBubbleCss: false,
                    customBubbleCss: '',
                    aiProactiveChatEnabled: false,
                    aiProactiveChatDelay: 0,
                    aiProactiveChatInterval: 0,
                    pendingMessages: [],
                    memorySummary: '' ,
                    worldBookIds: []
                };
                db.groups.push(newGroup);
                await saveData();
                renderChatList();
                createGroupModal.classList.remove('visible');
                showToast(`群聊“${groupName}”创建成功！`);
            });
            groupSettingsForm.addEventListener('submit', e => {
                e.preventDefault();
                saveGroupSettingsFromSidebar();
                groupSettingsSidebar.classList.remove('open');
            });
            const useGroupCustomCssCheckbox = document.getElementById('setting-group-use-custom-css'),
                groupCustomCssTextarea = document.getElementById('setting-group-custom-bubble-css'),
                resetGroupCustomCssBtn = document.getElementById('reset-group-custom-bubble-css-btn'),
                groupPreviewBox = document.getElementById('group-bubble-css-preview');
            useGroupCustomCssCheckbox.addEventListener('change', (e) => {
                groupCustomCssTextarea.disabled = !e.target.checked;
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, groupCustomCssTextarea.value, !e.target.checked, theme);
                }
            });
            groupCustomCssTextarea.addEventListener('input', (e) => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group && useGroupCustomCssCheckbox.checked) {
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, e.target.value, false, theme);
                }
            });
            resetGroupCustomCssBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    groupCustomCssTextarea.value = '';
                    useGroupCustomCssCheckbox.checked = false;
                    groupCustomCssTextarea.disabled = true;
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, '', true, theme);
                    showToast('样式已重置为默认');
                }
            });
            document.getElementById('setting-group-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        const group = db.groups.find(g => g.id === currentChatId);
                        if (group) {
                            group.avatar = compressedUrl;
                            document.getElementById('setting-group-avatar-preview').src = compressedUrl;
                        }
                    } catch (error) {
                        showToast('群头像压缩失败，请重试');
                    }
                }
            });
            document.getElementById('setting-group-chat-bg-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {
                            quality: 0.85,
                            maxWidth: 1080,
                            maxHeight: 1920
                        });
                        const group = db.groups.find(g => g.id === currentChatId);
                        if (group) {
                            group.chatBg = compressedUrl;
                            chatRoomScreen.style.backgroundImage = `url(${compressedUrl})`;
                            await saveData();
                            showToast('聊天背景已更换');
                        }
                    } catch (error) {
                        showToast('群聊背景压缩失败，请重试');
                    }
                }
            });
            document.getElementById('clear-group-chat-history-btn').addEventListener('click', async () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                if (confirm(`你确定要清空群聊“${group.name}”的所有聊天记录吗？\n\nAI将首先对群聊内容进行总结并存入回忆面板，这个过程需要消耗API额度。`)) {
                    await summarizeAndClearHistory();
                }
            });
            groupMembersListContainer.addEventListener('click', e => {
                const memberDiv = e.target.closest('.group-member');
                const addBtn = e.target.closest('.add-member-btn');
                if (memberDiv) {
                    openGroupMemberEditModal(memberDiv.dataset.id);
                } else if (addBtn) {
                    addMemberActionSheet.classList.add('visible');
                }
            });
            document.getElementById('edit-member-avatar-preview').addEventListener('click', () => {
                document.getElementById('edit-member-avatar-upload').click();
            });
            document.getElementById('edit-member-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('edit-member-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('成员头像压缩失败，请重试');
                    }
                }
            });
            editGroupMemberForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const memberId = document.getElementById('editing-member-id').value;
                const group = db.groups.find(g => g.id === currentChatId);
                const member = group.members.find(m => m.id === memberId);
                if (member) {
                    member.avatar = document.getElementById('edit-member-avatar-preview').src;
                    member.groupNickname = document.getElementById('edit-member-group-nickname').value;
                    member.realName = document.getElementById('edit-member-real-name').value;
                    member.persona = document.getElementById('edit-member-persona').value;
                    await saveData();
                    renderGroupMembersInSettings(group);
                    document.querySelectorAll(`.message-wrapper[data-sender-id="${member.id}"] .group-nickname`).forEach(el => {
                        el.textContent = member.groupNickname;
                    });
                    showToast('成员信息已更新');
                }
                editGroupMemberModal.classList.remove('visible');
            });
            inviteExistingMemberBtn.addEventListener('click', () => {
                renderInviteSelectionList();
                inviteMemberModal.classList.add('visible');
                addMemberActionSheet.classList.remove('visible');
            });
            createNewMemberBtn.addEventListener('click', () => {
                createMemberForGroupForm.reset();
                document.getElementById('create-group-member-avatar-preview').src = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
                createMemberForGroupModal.classList.add('visible');
                addMemberActionSheet.classList.remove('visible');
            });
            document.getElementById('create-group-member-avatar-preview').addEventListener('click', () => {
                document.getElementById('create-group-member-avatar-upload').click();
            });
            document.getElementById('create-group-member-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('create-group-member-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('新成员头像压缩失败，请重试');
                    }
                }
            });
            confirmInviteBtn.addEventListener('click', async () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                const selectedCharIds = Array.from(inviteMemberSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                selectedCharIds.forEach(charId => {
                    const char = db.characters.find(c => c.id === charId);
                    if (char) {
                        const newMember = {
                            id: `member_${char.id}`,
                            originalCharId: char.id,
                            realName: char.realName,
                            groupNickname: char.remarkName,
                            persona: char.persona,
                            avatar: char.avatar
                        };
                        group.members.push(newMember);
                        sendInviteNotification(group, newMember.realName);
                    }
                });
                if (selectedCharIds.length > 0) {
                    await saveData();
                    renderGroupMembersInSettings(group);
                    renderMessages(false, true);
                    showToast('已邀请新成员');
                }
                inviteMemberModal.classList.remove('visible');
            });
            createMemberForGroupForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                const newMember = {
                    id: `member_group_only_${Date.now()}`,
                    originalCharId: null,
                    realName: document.getElementById('create-group-member-realname').value,
                    groupNickname: document.getElementById('create-group-member-nickname').value,
                    persona: document.getElementById('create-group-member-persona').value,
                    avatar: document.getElementById('create-group-member-avatar-preview').src,
                };
                group.members.push(newMember);
                sendInviteNotification(group, newMember.realName);
                await saveData();
                renderGroupMembersInSettings(group);
                renderMessages(false, true);
                showToast(`新成员 ${newMember.groupNickname} 已加入`);
                createMemberForGroupModal.classList.remove('visible');
            });
            document.getElementById('setting-group-my-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('setting-group-my-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('头像压缩失败')
                    }
                }
            });
            confirmGroupRecipientBtn.addEventListener('click', () => {
                const selectedRecipientIds = Array.from(groupRecipientSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                if (selectedRecipientIds.length === 0) {
                    return showToast('请至少选择一个收件人。');
                }
                currentGroupAction.recipients = selectedRecipientIds;
                groupRecipientSelectionModal.classList.remove('visible');

                if (currentGroupAction.type === 'transfer') {
                    sendTransferForm.reset();
                    sendTransferModal.classList.add('visible');
                } else if (currentGroupAction.type === 'gift') {
                    sendGiftForm.reset();
                    sendGiftModal.classList.add('visible');
                }
            });
            
            // *** 修正开始 ***
            // 将事件监听器移到这里，确保它们只被绑定一次
            document.getElementById('set-group-title-btn').addEventListener('click', openSetGroupTitleModal);
            document.getElementById('close-group-title-modal-btn').addEventListener('click', () => {
                document.getElementById('set-group-title-modal').classList.remove('visible');
            });

            linkGroupWorldBookBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                worldBookSelectionList.innerHTML = '';
                db.worldBooks.forEach(book => {
                    const li = document.createElement('li');
                    li.className = 'world-book-select-item';
                    const isChecked = (group.worldBookIds || []).includes(book.id);
                    li.innerHTML = `<input type="checkbox" id="wb-select-group-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="wb-select-group-${book.id}">${book.name}</label>`;
                    worldBookSelectionList.appendChild(li);
                });
                worldBookSelectionModal.classList.add('visible');
            });
            // *** 修正结束 ***

            const bubbleScaleRange = document.getElementById('bubble-scale-range');
            const bubbleScaleValue = document.getElementById('bubble-scale-value');
            const chatRoomScreen = document.getElementById('chat-room-screen');

            bubbleScaleRange.addEventListener('input', () => {
                const scaleValue = bubbleScaleRange.value;
                bubbleScaleValue.textContent = `${Math.round(scaleValue * 100)}%`;
                chatRoomScreen.style.setProperty('--bubble-scale', scaleValue);
            });
        }

        function renderMemberSelectionList() {
            memberSelectionList.innerHTML = '';
            if (db.characters.length === 0) {
                memberSelectionList.innerHTML = '<li style="color:#aaa; text-align:center; padding: 10px 0;">没有可选择的人设。</li>';
                return;
            }
            db.characters.forEach(char => {
                const li = document.createElement('li');
                li.className = 'member-selection-item';
                li.innerHTML = `<input type="checkbox" id="select-${char.id}" value="${char.id}"><img src="${char.avatar}" alt="${char.remarkName}"><label for="select-${char.id}">${char.remarkName}</label>`;
                memberSelectionList.appendChild(li);
            });
        }

      function loadGroupSettingsToSidebar() {
    const group = db.groups.find(g => g.id === currentChatId);
    if (!group) return;
    const themeSelect = document.getElementById('setting-group-theme-color');
    if (themeSelect.options.length === 0) {
        Object.keys(colorThemes).forEach(key => {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = colorThemes[key].name;
            themeSelect.appendChild(option);
        });
    }
    document.getElementById('setting-group-avatar-preview').src = group.avatar;
    document.getElementById('setting-group-name').value = group.name;
    document.getElementById('setting-group-my-avatar-preview').src = group.me.avatar;
    document.getElementById('setting-group-my-nickname').value = group.me.nickname;
    document.getElementById('setting-group-my-persona').value = group.me.persona;
    themeSelect.value = group.theme || 'white_pink';
    document.getElementById('setting-group-max-memory').value = group.maxMemory;
    renderGroupMembersInSettings(group);
    const useGroupCustomCssCheckbox = document.getElementById('setting-group-use-custom-css'),
        groupCustomCssTextarea = document.getElementById('setting-group-custom-bubble-css'),
        groupPreviewBox = document.getElementById('group-bubble-css-preview');
    useGroupCustomCssCheckbox.checked = group.useCustomBubbleCss || false;
    groupCustomCssTextarea.value = group.customBubbleCss || '';
    groupCustomCssTextarea.disabled = !useGroupCustomCssCheckbox.checked;
    const theme = colorThemes[group.theme || 'white_pink'];
    updateBubbleCssPreview(groupPreviewBox, group.customBubbleCss, !group.useCustomBubbleCss, theme);
    const bubbleScaleRange = document.getElementById('bubble-scale-range');
    const bubbleScaleValue = document.getElementById('bubble-scale-value');
    const chatRoomScreen = document.getElementById('chat-room-screen');
    
    const currentScale = group.bubbleScale || 1;
    bubbleScaleRange.value = currentScale;
    bubbleScaleValue.textContent = `${Math.round(currentScale * 100)}%`;
    chatRoomScreen.style.setProperty('--bubble-scale', currentScale);

    // 新增：加载群聊的后台回复设置
    const proactiveToggle = document.getElementById('group-ai-proactive-chat-toggle');
    const proactiveOptions = document.getElementById('group-ai-proactive-options');
    const proactiveDelayInput = document.getElementById('group-ai-proactive-chat-delay');
    const proactiveIntervalInput = document.getElementById('group-ai-proactive-chat-interval');

    proactiveToggle.checked = group.aiProactiveChatEnabled || false;
    proactiveDelayInput.value = group.aiProactiveChatDelay || '';
    proactiveIntervalInput.value = group.aiProactiveChatInterval || '';
    proactiveOptions.style.display = proactiveToggle.checked ? 'block' : 'none';

    proactiveToggle.onchange = (evt) => {
        proactiveOptions.style.display = evt.target.checked ? 'block' : 'none';
    };
}

        function renderGroupMembersInSettings(group) {
            groupMembersListContainer.innerHTML = '';
            group.members.forEach(member => {
                const memberDiv = document.createElement('div');
                memberDiv.className = 'group-member';
                memberDiv.dataset.id = member.id;
                memberDiv.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><span>${member.groupNickname}</span>`;
                groupMembersListContainer.appendChild(memberDiv);
            });
            const addBtn = document.createElement('div');
            addBtn.className = 'add-member-btn';
            addBtn.innerHTML = `<div class="add-icon">+</div><span>添加</span>`;
            groupMembersListContainer.appendChild(addBtn);
        }

        function renderGroupRecipientSelectionList(actionText) {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            groupRecipientSelectionTitle.textContent = actionText;
            groupRecipientSelectionList.innerHTML = '';
            group.members.forEach(member => {
                const li = document.createElement('li');
                li.className = 'group-recipient-select-item';
                li.innerHTML = `
                        <input type="checkbox" id="recipient-select-${member.id}" value="${member.id}">
                        <label for="recipient-select-${member.id}">
                            <img src="${member.avatar}" alt="${member.groupNickname}">
                            <span>${member.groupNickname}</span>
                        </label>`;
                groupRecipientSelectionList.appendChild(li);
            });
        }

async function saveGroupSettingsFromSidebar() {
    const group = db.groups.find(g => g.id === currentChatId);
    if (!group) return;
    const oldName = group.name;
    const newName = document.getElementById('setting-group-name').value;
    if (oldName !== newName) {
        group.name = newName;
        sendRenameNotification(group, newName);
    }
    group.avatar = document.getElementById('setting-group-avatar-preview').src;
    group.me.avatar = document.getElementById('setting-group-my-avatar-preview').src;
    group.me.nickname = document.getElementById('setting-group-my-nickname').value;
    group.me.persona = document.getElementById('setting-group-my-persona').value;
    group.theme = document.getElementById('setting-group-theme-color').value;
    group.maxMemory = document.getElementById('setting-group-max-memory').value;
    group.useCustomBubbleCss = document.getElementById('setting-group-use-custom-css').checked;
    group.customBubbleCss = document.getElementById('setting-group-custom-bubble-css').value;
    updateCustomBubbleStyle(currentChatId, group.customBubbleCss, group.useCustomBubbleCss);
    
    group.bubbleScale = document.getElementById('bubble-scale-range').value;

    // 新增：保存群聊的后台回复设置
    group.aiProactiveChatEnabled = document.getElementById('group-ai-proactive-chat-toggle').checked;
    group.aiProactiveChatDelay = parseInt(document.getElementById('group-ai-proactive-chat-delay').value, 10) || 0;
    group.aiProactiveChatInterval = parseInt(document.getElementById('group-ai-proactive-chat-interval').value, 10) || 0;

    await saveData();
    showToast('群聊设置已保存！');
    chatRoomTitle.textContent = group.name;
    renderChatList();
    renderMessages(false, true);
}

        function openGroupMemberEditModal(memberId) {
            const group = db.groups.find(g => g.id === currentChatId);
            const member = group.members.find(m => m.id === memberId);
            if (!member) return;
            document.getElementById('edit-group-member-title').textContent = `编辑 ${member.groupNickname}`;
            document.getElementById('editing-member-id').value = member.id;
            document.getElementById('edit-member-avatar-preview').src = member.avatar;
            document.getElementById('edit-member-group-nickname').value = member.groupNickname;
            document.getElementById('edit-member-real-name').value = member.realName;
            document.getElementById('edit-member-persona').value = member.persona;
            editGroupMemberModal.classList.add('visible');
        }

        function renderInviteSelectionList() {
            inviteMemberSelectionList.innerHTML = '';
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const currentMemberCharIds = new Set(group.members.map(m => m.originalCharId));
            const availableChars = db.characters.filter(c => !currentMemberCharIds.has(c.id));
            if (availableChars.length === 0) {
                inviteMemberSelectionList.innerHTML = '<li style="color:#aaa; text-align:center; padding: 10px 0;">没有可邀请的新成员了。</li>';
                confirmInviteBtn.disabled = true;
                return;
            }
            confirmInviteBtn.disabled = false;
            availableChars.forEach(char => {
                const li = document.createElement('li');
                li.className = 'invite-member-select-item';
                li.innerHTML = `<input type="checkbox" id="invite-select-${char.id}" value="${char.id}"><label for="invite-select-${char.id}"><img src="${char.avatar}" alt="${char.remarkName}"><span>${char.remarkName}</span></label>`;
                inviteMemberSelectionList.appendChild(li);
            });
        }

        function sendInviteNotification(group, newMemberRealName) {
            const messageContent = `[${group.me.nickname}邀请${newMemberRealName}加入了群聊]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContent,
                parts: [{type: 'text', text: messageContent}],
                timestamp: Date.now(),
                senderId: 'user_me'
            };
            group.history.push(message);
        }

        function sendRenameNotification(group, newName) {
            const myName = group.me.nickname;
            const messageContent = `[${myName}修改群名为：${newName}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContent,
                parts: [{type: 'text', text: messageContent}],
                timestamp: Date.now()
            };
            group.history.push(message);
        }

// --- NEW: Voice Call System Functions ---

// 【这是为您重新添加并修正的完整代码】

/**
 * 设置通话功能的所有事件监听和逻辑
 */
function setupVoiceCallSystem() {
    // 缓存所有与通话相关的DOM元素
    const voiceCallBtn = document.getElementById('voice-call-btn');
    const voiceCallOverlay = document.getElementById('voice-call-overlay');
    const callAvatar = document.getElementById('call-avatar');
    const callName = document.getElementById('call-name');
    const callStatus = document.getElementById('call-status');
    const ringingView = document.getElementById('ringing-view');
    const incomingButtons = document.getElementById('incoming-buttons');
    const outgoingButtons = document.getElementById('outgoing-buttons');
    const activeCallView = document.getElementById('active-call-view');
    const callTranscriptArea = document.getElementById('call-transcript-area');
    const hangupCallBtn = document.getElementById('hangup-call-btn');
    const callInput = document.getElementById('call-input');
    const sendCallMessageBtn = document.getElementById('send-call-message-btn');
    const declineCallBtn = document.getElementById('decline-call-btn');
    const acceptCallBtn = document.getElementById('accept-call-btn');
    const cancelCallBtn = document.getElementById('cancel-call-btn');

    // 绑定按钮事件
    voiceCallBtn.addEventListener('click', startUserInitiatedCall);
    cancelCallBtn.addEventListener('click', () => endCall('ended')); // 用户主动取消呼叫
    declineCallBtn.addEventListener('click', () => endCall('declined')); // 用户拒接来电
    acceptCallBtn.addEventListener('click', () => { // 用户接听来电
        const character = db.characters.find(c => c.id === currentCallTargetId);
        if (!character) return;
        // 插入一条系统消息，告知AI电话已被接听
        const contextMessage = {
            id: `msg_call_${Date.now()}`, role: 'user',
            content: `[system: ${character.myName} 接听了你的电话。]`,
            parts: [{type: 'text', text: `[system: ${character.myName} 接听了你的电话。]`}],
            timestamp: Date.now()
        };
        character.history.push(contextMessage);
        saveData();
        startActiveCall();
    });
    hangupCallBtn.addEventListener('click', () => endCall('ended')); // 通话中挂断
    sendCallMessageBtn.addEventListener('click', sendCallMessage); // 通话中发文字
    callInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendCallMessage();
    });
}

/**
 * 由用户发起呼叫
 */
function startUserInitiatedCall() {
    if (isGenerating || currentChatType !== 'private') return;
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;

    currentCallTargetId = character.id;
    // 初始化并显示呼叫界面
    voiceCallOverlay.classList.add('visible');
    ringingView.style.display = 'block';
    activeCallView.style.display = 'none';
    incomingButtons.style.display = 'none';
    outgoingButtons.style.display = 'flex';

    callAvatar.src = character.avatar;
    callName.textContent = character.remarkName;
    callStatus.textContent = '正在呼叫...';

    // 设置响铃状态并启动60秒无应答超时计时器
    isCallRinging = true;
    callInitiationTimeout = setTimeout(() => {
        if (isCallRinging) {
            showToast('对方无应答');
            endCall('timeout');
        }
    }, 60000); 

    // 插入一条系统指令，让AI决定是否接听
    const callMessage = {
        id: `msg_call_${Date.now()}`, role: 'user',
        content: `[system: ${character.myName} 正在呼叫你，请根据你的人设决定是接听 [call-accept] 还是拒接 [call-decline]]`,
        parts: [{type: 'text', text: `[system: ${character.myName} 正在呼叫你，请根据你的人设决定是接听 [call-accept] 还是拒接 [call-decline]]`}],
        timestamp: Date.now()
    };
    character.history.push(callMessage);
    saveData();
    getAiReply(); // 触发AI响应
}

/**
 * 由AI发起呼叫（当AI回复包含[call:...]指令时由addMessageBubble函数调用）
 */
function startAiInitiatedCall(characterId) {
    const character = db.characters.find(c => c.id === characterId);
    if (!character) return;
    
    currentCallTargetId = character.id;
    isAiCalling = true; // 标记这是AI发起的呼叫
    isCallRinging = true; // 标记正在响铃

    voiceCallOverlay.classList.add('visible');
    ringingView.style.display = 'block';
    activeCallView.style.display = 'none';
    incomingButtons.style.display = 'flex';
    outgoingButtons.style.display = 'none';

    callAvatar.src = character.avatar;
    callName.textContent = character.remarkName;
    callStatus.textContent = '来电邀请...';

    // 新增：为AI来电也设置超时
    callInitiationTimeout = setTimeout(() => {
        if (isCallRinging) {
            showToast('呼叫已超时');
            endCall('timeout');
        }
    }, 60000); // 60秒无应答
}

/**
 * 电话接通，进入实时通话界面
 */
function startActiveCall() {
    const character = db.characters.find(c => c.id === currentCallTargetId);
    if (!character) return;

    // 清理呼叫阶段的状态和计时器
    clearTimeout(callInitiationTimeout);
    isCallRinging = false;
    isVoiceCallActive = true;
    voiceCallTranscript = [];
    voiceCallStartTime = Date.now();
    
    // 切换UI到通话中视图
    ringingView.style.display = 'none';
    activeCallView.style.display = 'flex';
    
    callTranscriptArea.innerHTML = '';
    callInput.value = '';

    appendCallTranscript('system', '通话已连接');
    
    // 启动通话计时器
    callTimerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - voiceCallStartTime) / 1000);
        const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
        const seconds = String(elapsed % 60).padStart(2, '0');
        const timeString = `${minutes}:${seconds}`;
        callStatus.textContent = timeString; 
    }, 1000);

    // 让AI说第一句话
    getAiCallReply("[system: 通话已接通，请说第一句话。]");
}

/**
 * 结束通话（处理所有情况，如挂断、拒接、无应答等）
 */

async function endCall(reason = 'ended') {
    // 清理所有计时器和状态
    clearTimeout(callInitiationTimeout);
    isCallRinging = false;
    clearInterval(callTimerInterval);
    
    const character = db.characters.find(c => c.id === currentCallTargetId);

    // 无论如何，先隐藏通话界面
    voiceCallOverlay.classList.remove('visible');

    if (!character) {
        isVoiceCallActive = false;
        isAiCalling = false;
        currentCallTargetId = null;
        return;
    }

    const duration = callStatus.textContent;

    // --- ▼▼▼ 核心修改与新增逻辑 ▼▼▼ ---
    if (isVoiceCallActive) { 
        // 情况一：通话曾被接通过，现在结束了
        const summaryDisplay = {
            id: `msg_call_${Date.now()}_disp`, role: 'system',
            content: `[system-display:与 ${character.remarkName} 的通话已结束，时长 ${duration}]`,
            parts: [], timestamp: Date.now()
        };
        const summaryContext = {
            id: `msg_call_${Date.now()}_ctx`, role: 'user',
            content: `[system: 与 ${character.realName} 的通话已结束。通话记录：${JSON.stringify(voiceCallTranscript)}]`,
            parts: [{type: 'text', text: `[system: 与 ${character.realName} 的通话已结束。通话记录：${JSON.stringify(voiceCallTranscript)}]`}],
            timestamp: Date.now()
        };
        character.history.push(summaryDisplay, summaryContext);
        if(currentChatId === character.id) {
             addMessageBubble(summaryDisplay);
        }
    } else { 
        // 情况二：通话从未接通
        let transitionPrompt = '';
        if (isAiCalling && (reason === 'declined' || reason === 'timeout')) {
            // 子情况 A: 是AI打来的，但用户没接或挂了
            transitionPrompt = `[system: 用户刚刚未接听或挂断了你的电话。请根据你的人设，在聊天中发一条消息询问对方，或者表达你的心情。]`;
        } else if (!isAiCalling && (reason === 'declined' || reason === 'timeout' || reason === 'no_action_reply')) {
            // 子情况 B: 是用户打过去的，但AI没接或无应答
            const reasonText = reason === 'declined' ? '拒绝了' : '错过了';
            transitionPrompt = `[system: 你刚刚${reasonText} ${character.myName} 的来电。请发一条消息解释或询问，以自然地过渡回聊天。]`;
        }
        
        if (transitionPrompt) {
            const contextMessage = {
                id: `msg_call_fail_${Date.now()}`, role: 'user',
                content: transitionPrompt,
                parts: [{type: 'text', text: transitionPrompt}],
                timestamp: Date.now()
            };
            character.history.push(contextMessage);
            // 如果用户当前就在这个聊天界面，立即触发AI回复
            if (currentChatId === character.id) {
                getAiReply();
            }
        }
    }
    // --- ▲▲▲ 修改结束 ▲▲▲ ---
    
    // 统一重置所有全局状态
    isVoiceCallActive = false;
    isAiCalling = false;
    voiceCallTranscript = [];
    voiceCallStartTime = null;
    currentCallTargetId = null;
    
    await saveData();
}
/**
 * 在通话中发送文字消息
 */
function sendCallMessage() {
    const text = callInput.value.trim();
    if (!text || isGenerating) return;
    appendCallTranscript('user', text); // 在自己界面显示
    getAiCallReply(text); // 请求AI回复
    callInput.value = '';
}

/**
 * 请求AI在通话中的回复
 * @param {string} userText - 用户发送的文字或系统指令
 */
async function getAiCallReply(userText) {
    if (isGenerating) return;
    const character = db.characters.find(c => c.id === currentCallTargetId);
    if (!character) return;

    isGenerating = true;
    sendCallMessageBtn.disabled = true;

    try {
        const prompt = `[通话中] 你是 ${character.realName} (人设: ${character.persona})，正在和 ${character.myName} 通话。请直接回复对话内容。可以使用括号()描述动作。重要：如果想连续发送多条消息，请用换行符分隔，每一行都会成为一个独立的气泡。`;
        
        const callHistory = voiceCallTranscript.map(line => ({
            role: line.sender === 'user' ? 'user' : 'assistant',
            content: line.text
        }));

        const messages = [
            { role: 'system', content: prompt },
            ...callHistory.slice(-5), // 使用最近5轮的通话记录作为上下文
            { role: 'user', content: userText }
        ];

        const aiResponseText = await callAiApi(messages); // 复用通用的AI调用函数

        // 【新功能】处理AI用换行符返回的多条消息
        const replies = aiResponseText.split('\n').filter(reply => reply.trim() !== '');
        for (const reply of replies) {
            appendCallTranscript("ai", reply);
            // 增加一个小的随机延迟，模拟真实对话的节奏感
            await new Promise(resolve => setTimeout(resolve, Math.random() * 500 + 200));
        }

    } catch (error) {
        const errorMessage = `[AI服务器返回错误: ${error.message}]`;
        appendCallTranscript("system", errorMessage);
        showToast('AI回复失败，可能是服务器临时问题');
    } finally {
        isGenerating = false;
        sendCallMessageBtn.disabled = false;
    }
}

/**
 * 将一条消息追加到通话记录的显示界面上
 * @param {string} sender - 'user', 'ai', or 'system'
 * @param {string} text - 消息内容
 */
function appendCallTranscript(sender, text) {
    voiceCallTranscript.push({ sender, text }); // 存入记录

    const line = document.createElement('div');
    line.className = 'call-transcript-line';

    if (sender === 'system') {
        line.innerHTML = `<span class="action">${text}</span>`;
    } else {
        const name = sender === 'user' ? '我' : callName.textContent;
        // 将括号里的内容用特定样式包裹，以表示动作或语气
        const styledText = text.replace(/\((.*?)\)/g, '<span class="action">($1)</span>');
        line.innerHTML = `<strong>${name}:</strong> <span class="dialog">${styledText}</span>`;
    }
    
    callTranscriptArea.appendChild(line);
    callTranscriptArea.scrollTop = callTranscriptArea.scrollHeight; // 自动滚动到底部
}
function startUserInitiatedCall() {
    if (isGenerating || currentChatType !== 'private') return;
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;

    currentCallTargetId = character.id;
    voiceCallOverlay.classList.add('visible');
    ringingView.style.display = 'block';
    activeCallView.style.display = 'none';
    incomingButtons.style.display = 'none';
    outgoingButtons.style.display = 'flex';

    callAvatar.src = character.avatar;
    callName.textContent = character.remarkName;
    callStatus.textContent = '正在呼叫...';

    // 设置响铃状态并启动超时计时器
    isCallRinging = true;
    callInitiationTimeout = setTimeout(() => {
        if (isCallRinging) {
            showToast('对方无应答');
            endCall('timeout');
        }
    }, 60000); // 60秒超时

    // 添加系统消息以触发AI决策
    const callMessage = {
        id: `msg_call_${Date.now()}`,
        role: 'user',
        content: `[system: ${character.myName} 正在呼叫你，请根据你的人设决定是接听 [call-accept] 还是拒接 [call-decline]]`,
        parts: [{type: 'text', text: `[system: ${character.myName} 正在呼叫你，请根据你的人设决定是接听 [call-accept] 还是拒接 [call-decline]]`}],
        timestamp: Date.now()
    };
    character.history.push(callMessage);
    saveData();
    getAiReply(); // 触发AI响应
}

function startAiInitiatedCall(characterId) {
    const character = db.characters.find(c => c.id === characterId);
    if (!character) return;
    
    currentCallTargetId = character.id;
    voiceCallOverlay.classList.add('visible');
    ringingView.style.display = 'block';
    activeCallView.style.display = 'none';
    incomingButtons.style.display = 'flex';
    outgoingButtons.style.display = 'none';

    callAvatar.src = character.avatar;
    callName.textContent = character.remarkName;
    callStatus.textContent = '来电邀请...';
}

function startActiveCall() {
    const character = db.characters.find(c => c.id === currentCallTargetId);
    if (!character) return;

    clearTimeout(callInitiationTimeout);
    isCallRinging = false;
    isVoiceCallActive = true;
    voiceCallTranscript = [];
    voiceCallStartTime = Date.now();
    
    // --- 核心修改：显示主头像，隐藏顶部面板 ---
    // 保持主界面的大型头像和名字可见，以匹配图片样式
    document.getElementById('call-avatar').style.display = 'block';
    document.getElementById('call-name').style.display = 'block';
    
    // 隐藏那个固定的、现在不需要的顶部 header
    const activeHeader = document.getElementById('active-call-header');
    if (activeHeader) activeHeader.style.display = 'none';
    // --- 修改结束 ---

    ringingView.style.display = 'none';
    activeCallView.style.display = 'flex';

    // 更新顶部固定面板的信息（这些代码现在无效，但保留也无妨）
    document.getElementById('active-call-header-avatar').src = character.avatar;
    document.getElementById('active-call-header-name').textContent = character.remarkName;
    
    callTranscriptArea.innerHTML = '';
    callInput.value = '';

    appendCallTranscript('system', '通话已连接');
    
    callTimerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - voiceCallStartTime) / 1000);
        const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
        const seconds = String(elapsed % 60).padStart(2, '0');
        const timeString = `${minutes}:${seconds}`;
        
        // 修改：确保只更新主状态区的计时器
        callStatus.textContent = timeString; 
    }, 1000);

    getAiCallReply("[system: 通话已接通，请说第一句话。]");
}

async function endCall(reason = 'ended') {
    clearTimeout(callInitiationTimeout);
    isCallRinging = false;

    const character = db.characters.find(c => c.id === currentCallTargetId);

    if (isVoiceCallActive && reason === 'ended' && character) {
        const hangupContext = {
            id: `msg_call_${Date.now()}_ctx`,
            role: 'user', 
            content: `[system: ${character.myName} 挂断了电话。]`,
            parts: [{type: 'text', text: `[system: ${character.myName} 挂断了电话。]`}],
            timestamp: Date.now()
        };
        character.history.push(hangupContext);
    }

    // 如果通话从未被激活（即仍在响铃阶段），并且是因为 'ended', 'timeout', 'error', 或 'no_action_reply' 而结束，则直接关闭界面
    if (!isVoiceCallActive && (reason === 'ended' || reason === 'timeout' || reason === 'error' || reason === 'no_action_reply')) {
         voiceCallOverlay.classList.remove('visible');
         document.getElementById('call-avatar').style.display = 'block';
         document.getElementById('call-name').style.display = 'block';
         return;
    }

    if (!character) {
         voiceCallOverlay.classList.remove('visible');
         return;
    }

    clearInterval(callTimerInterval);
    const duration = callStatus.textContent;

    if (reason === 'declined') {
         const contextMessage = {
            id: `msg_call_${Date.now()}`,
            role: 'user',
            content: `[system: ${character.myName} 拒绝了你的电话。]`,
            parts: [{type: 'text', text: `[system: ${character.myName} 拒绝了你的电话。]`}],
            timestamp: Date.now()
        };
        character.history.push(contextMessage);
    } else if (isVoiceCallActive) { 
        const summaryDisplay = {
            id: `msg_call_${Date.now()}_disp`,
            role: 'system',
            content: `[system-display:与 ${character.remarkName} 的通话已结束，时长 ${duration}]`,
            parts: [],
            timestamp: Date.now()
        };
        const summaryContext = {
            id: `msg_call_${Date.now()}_ctx`,
            role: 'user',
            content: `[system: 与 ${character.realName} 的通话已结束。通话记录：${JSON.stringify(voiceCallTranscript)}]`,
            parts: [{type: 'text', text: `[system: 与 ${character.realName} 的通话已结束。通话记录：${JSON.stringify(voiceCallTranscript)}]`}],
            timestamp: Date.now()
        };
        character.history.push(summaryDisplay, summaryContext);
        if(currentChatId === character.id) {
             addMessageBubble(summaryDisplay);
        }
    }
    
    await saveData();
    isVoiceCallActive = false;
    voiceCallTranscript = [];
    voiceCallStartTime = null;
    currentCallTargetId = null;
    voiceCallOverlay.classList.remove('visible');
    
    document.getElementById('call-avatar').style.display = 'block';
    document.getElementById('call-name').style.display = 'block';
}

function sendCallMessage() {
    const text = callInput.value.trim();
    if (!text || isGenerating) return;
    appendCallTranscript('user', text);
    getAiCallReply(text);
    callInput.value = '';
}

async function getAiCallReply(userText) {
    if (isGenerating) return;
    const character = db.characters.find(c => c.id === currentCallTargetId);
    if (!character) return;

    isGenerating = true;
    sendCallMessageBtn.disabled = true;

    try {
        // 修改后的 Prompt，明确指示 AI 可以用换行符来发送多条消息
        const prompt = `你正在与 ${character.myName} 进行语音通话。你的名字是 ${character.realName}，你的人设是：${character.persona}。你的回复可以直接是对话内容，也可以包含用括号()描述的动作、语气或环境。重要：如果想连续发送多条消息，请用换行符分隔，并且每条消息不得超过50字，每一行都会成为一个独立的气泡。请严格保持你的人设进行对话。`;

        const callHistory = voiceCallTranscript.map(line => {
            return {
                role: line.sender === 'user' ? 'user' : 'assistant',
                content: line.text
            }
        });

        const messages = [
            { role: 'system', content: prompt },
            ...callHistory.slice(-5), // 使用最近5轮的通话记录作为上下文
            { role: 'user', content: userText }
        ];

        const aiResponseText = await callAiApi(messages); // 复用通用的AI调用函数

        // 处理AI回复，按换行符拆分成多条消息
        const replies = aiResponseText.split('\n').filter(reply => reply.trim() !== '');
        for (const reply of replies) {
            appendCallTranscript("ai", reply);
            // 可以根据消息长度添加一个小的延迟，模拟打字效果
            await new Promise(resolve => setTimeout(resolve, Math.random() * 500 + 200));
        }

    } catch (error) {
        appendCallTranscript("system", `[错误: ${error.message}]`);
    } finally {
        isGenerating = false;
        sendCallMessageBtn.disabled = false;
    }
}

function appendCallTranscript(sender, text) {
    // sender: 'user', 'ai', or 'system'
    voiceCallTranscript.push({ sender, text });

    const line = document.createElement('div');
    line.className = 'call-transcript-line';

    if (sender === 'system') {
        line.innerHTML = `<span class="action">${text}</span>`;
    } else {
        const name = sender === 'user' ? '我' : callName.textContent;
        // Simple regex to style actions in parenthesis
        const styledText = text.replace(/\((.*?)\)/g, '<span class="action">($1)</span>');
        line.innerHTML = `<strong>${name}:</strong> <span class="dialog">${styledText}</span>`;
    }
    
    callTranscriptArea.appendChild(line);
    callTranscriptArea.scrollTop = callTranscriptArea.scrollHeight;
}


// 在 init() 函数之前添加以下三个函数

function addNotificationToQueue(notification) {
    // ▼▼▼ 在这里修改 ▼▼▼

    // 之前的代码有一个随机延迟，我们把它去掉，换成直接执行
    /* // 模拟一个随机延迟（1到5秒），让通知看起来更自然
    const delay = Math.random() * 4000 + 1000;
    setTimeout(() => {
        notificationQueue.push(notification);
    }, delay);
    */
    
    // 新代码：直接将通知添加到队列，不再延迟
    notificationQueue.push(notification);

    // ▲▲▲ 修改结束 ▲▲▲
}

function showNotificationBanner() {
    console.log(`检查通知: 队列长度 ${notificationQueue.length}, 正在显示? ${isNotificationShowing}, 在动态页? ${document.getElementById('moments-screen').classList.contains('active')}`);

    if (isNotificationShowing || notificationQueue.length === 0) {
        return;
    }

    const momentsScreen = document.getElementById('moments-screen');
    if (momentsScreen && momentsScreen.classList.contains('active')) {
        return;
    }

    isNotificationShowing = true;
    const notification = notificationQueue.shift();
    
    const banner = document.getElementById('global-notification-banner');
    const avatar = document.getElementById('notification-avatar');
    const textEl = document.getElementById('notification-text');

    avatar.src = notification.avatar;
    textEl.innerHTML = notification.text;

    banner.classList.add('show');
    
    // ▼▼▼ 核心修改在此 ▼▼▼
    banner.onclick = () => {
        // 检查通知是否包含聊天信息
        if (notification.chatId && notification.type) {
            // 如果有，就打开对应的聊天室
            openChatRoom(notification.chatId, notification.type);
        } else {
            // 否则，作为备用方案，跳转到动态页
            switchScreen('moments-screen');
        }
        
        banner.classList.remove('show');
        isNotificationShowing = false;
        setTimeout(showNotificationBanner, 500);
    };
    // ▲▲▲ 修改结束 ▲▲▲

    setTimeout(() => {
        banner.classList.remove('show');
        isNotificationShowing = false;
        setTimeout(showNotificationBanner, 500);
    }, 5000);
}
function setupNotificationSystem() {
    // 定时检查通知队列
    setInterval(showNotificationBanner, 2000); // 每2秒检查一次

    // 关闭按钮
    const closeBtn = document.getElementById('notification-close-btn');
    closeBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // 防止触发横幅的点击事件
        const banner = document.getElementById('global-notification-banner');
        banner.classList.remove('show');
        isNotificationShowing = false;
        setTimeout(showNotificationBanner, 500);
    });
}
// --- 新增长截图选择与生成功能 ---

/**
 * 进入截图选择模式
 * @param {string} initialMessageId - 长按触发时，初始选中的消息ID
 */
function enterScreenshotSelectionMode(initialMessageId) {
    isInScreenshotMode = true;
    selectedMessagesForScreenshot.clear();

    const chatScreen = document.getElementById('chat-room-screen');
    chatScreen.classList.add('screenshot-mode');

    document.getElementById('screenshot-select-bar').style.display = 'flex';
    document.getElementById('screenshot-select-count').textContent = '已选择 0 条';

    // 初始选中山下文菜单触发的消息
    if (initialMessageId) {
        toggleScreenshotSelection(initialMessageId);
    }
}

/**
 * 退出截图选择模式
 */
function exitScreenshotSelectionMode() {
    isInScreenshotMode = false;
    document.getElementById('chat-room-screen').classList.remove('screenshot-mode');
    document.getElementById('screenshot-select-bar').style.display = 'none';

    // 移除所有消息的选中高亮
    document.querySelectorAll('.message-wrapper.screenshot-selected').forEach(el => {
        el.classList.remove('screenshot-selected');
    });
    selectedMessagesForScreenshot.clear();
}

/**
 * 切换单条消息的选中状态
 * @param {string} messageId - 被点击的消息的ID
 */
function toggleScreenshotSelection(messageId) {
    const el = document.querySelector(`.message-wrapper[data-id="${messageId}"]`);
    if (!el) return;

    if (selectedMessagesForScreenshot.has(messageId)) {
        selectedMessagesForScreenshot.delete(messageId);
        el.classList.remove('screenshot-selected');
    } else {
        selectedMessagesForScreenshot.add(messageId);
        el.classList.add('screenshot-selected');
    }

    document.getElementById('screenshot-select-count').textContent = `已选择 ${selectedMessagesForScreenshot.size} 条`;
}

/**
 * 生成并下载所选消息的截图
 */
// ▼▼▼ 用下面这个完整的函数，替换掉你文件中旧的同名函数 ▼▼▼
/**
 * 生成所选消息的截图，并在弹窗中进行预览。
 */
async function generateSelectedMessagesScreenshot() {
    if (selectedMessagesForScreenshot.size === 0) {
        showToast('请至少选择一条消息');
        return;
    }

    showToast('正在生成长截图，请稍候...');
    // 关键：在截图前先隐藏选择操作栏，避免它出现在截图里
    document.getElementById('screenshot-select-bar').style.display = 'none';

    // 1. 创建一个临时的、屏幕外的容器用于截图
    const screenshotContainer = document.createElement('div');
    screenshotContainer.style.position = 'absolute';
    screenshotContainer.style.left = '-9999px'; // 移出视窗
    screenshotContainer.style.width = document.querySelector('.phone-screen').clientWidth + 'px';
    screenshotContainer.style.padding = '20px 10px';
    screenshotContainer.style.fontFamily = 'var(--font-family)';

    // 2. 添加聊天背景
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    if (chat && chat.chatBg) {
        screenshotContainer.style.backgroundImage = `url(${chat.chatBg})`;
        screenshotContainer.style.backgroundSize = 'cover';
        screenshotContainer.style.backgroundPosition = 'center';
    } else {
        screenshotContainer.style.backgroundColor = '#f7f7f7';
    }

    // 3. 按顺序克隆选中的消息
    const selectedElements = Array.from(selectedMessagesForScreenshot)
        .map(id => document.querySelector(`.message-wrapper[data-id="${id}"]`))
        .filter(Boolean)
        .sort((a, b) => a.offsetTop - b.offsetTop);

    selectedElements.forEach(el => {
        const clone = el.cloneNode(true);
        clone.classList.remove('screenshot-selected', 'multi-select-selected'); // 移除所有高亮
        screenshotContainer.appendChild(clone);
    });

    document.body.appendChild(screenshotContainer);

    // 4. 使用 html2canvas 进行截图
    try {
        const canvas = await html2canvas(screenshotContainer, {
            useCORS: true,
            backgroundColor: null,
        });

        const imageDataUrl = canvas.toDataURL("image/png");

        // 5. 显示预览弹窗
        const modal = document.getElementById('screenshot-preview-modal');
        const imgEl = document.getElementById('screenshot-preview-image');
        const downloadBtn = document.getElementById('download-screenshot-btn');
        const closeBtn = document.getElementById('close-screenshot-preview');

        imgEl.src = imageDataUrl;
        downloadBtn.href = imageDataUrl;
        downloadBtn.download = `聊天记录截图-${Date.now()}.png`;
        
        modal.classList.add('visible');

        // 6. 绑定关闭事件
        const closeModal = () => {
            modal.classList.remove('visible');
            exitScreenshotSelectionMode(); // 截图流程结束后，彻底退出选择模式
        };
        closeBtn.onclick = closeModal; // 使用 .onclick 避免重复绑定
        
    } catch (error) {
        console.error("截图失败:", error);
        showToast('截图失败，详情请查看控制台');
        // 截图失败也要退出选择模式
        exitScreenshotSelectionMode();
    } finally {
        // 7. 清理临时容器
        document.body.removeChild(screenshotContainer);
    }
}
function setupViewRecalledModal() {
    const modal = document.getElementById('view-recalled-modal');
    const contentDisplay = document.getElementById('recalled-content-display');
    const closeBtn = document.getElementById('close-recalled-modal-btn');

    // 使用事件委托，监听聊天区域内对占位符的点击
    messageArea.addEventListener('click',async (e) => {
    const acceptBtn = e.target.closest('.payment-request-accept');
    const declineBtn = e.target.closest('.payment-request-decline');
    const messageWrapper = e.target.closest('.message-wrapper');

    if (messageWrapper && (acceptBtn || declineBtn)) {
        // 这段代码是为未来手动点击AI按钮准备的，现在主要由AI指令触发
        // 但保留它是好的做法
        const messageId = messageWrapper.dataset.id;
        const decision = acceptBtn ? 'paid' : 'declined';
        await handleAiPaymentDecision(messageId, decision);
    }
        const placeholder = e.target.closest('.recalled-message-placeholder');
        if (!placeholder) return;
        
        const messageId = placeholder.dataset.recalledMessageId;
        const chat = (currentChatType === 'private') 
            ? db.characters.find(c => c.id === currentChatId) 
            : db.groups.find(g => g.id === currentChatId);
        
        if (!chat) return;

        const recalledMessage = chat.history.find(m => m.id === messageId);
        if (recalledMessage && recalledMessage.originalContent) {
            // 从保存的原始内容中提取并显示
            let textToShow = recalledMessage.originalContent;
            
            // 尝试清理包装，让内容更纯粹
            const contentMatch = textToShow.match(/\[.*?的消息：([\s\S]+?)\]/);
            if(contentMatch) {
                textToShow = contentMatch[1];
            }

            contentDisplay.textContent = textToShow;
            modal.classList.add('visible');
        } else {
            showToast('找不到原始消息内容。');
        }
    });

    closeBtn.addEventListener('click', () => {
        modal.classList.remove('visible');
    });
}
// ===============================================================
// START: 商城购物流程核心JS函数
// ===============================================================

// 新增一个函数，用于渲染物流列表
function renderLogistics() {
    const container = document.getElementById('logistics-list-container');
    const placeholder = document.getElementById('no-logistics-placeholder');
    const logistics = db.mallData.logistics || [];

    if (logistics.length === 0) {
        container.innerHTML = '';
        placeholder.style.display = 'block';
        return;
    }
    placeholder.style.display = 'none';
    container.innerHTML = '';

    logistics.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'logistics-item';
        itemEl.innerHTML = `
            <div class="logistics-header">
                <span>订单号: ${item.orderId.slice(-8)}</span>
                <span class="logistics-status">${item.status}</span>
            </div>
            <div class="logistics-body">
                <img src="${item.productImage}" alt="${item.productName}">
                <div class="logistics-info">
                    <p class="item-name">${item.productName}</p>
                    <p class="eta" data-countdown-type="delivery" data-eta="${item.eta}">正在计算送达时间...</p>
                    <p class="recipient-info" style="font-size: 12px; color: #888;">收件人: ${item.recipientName}</p>
                </div>
            </div>
        `;
        container.appendChild(itemEl);
    });
}

// 在 setupMallApp 中为新的物流入口绑定事件
document.querySelector('.wallet-action-item[data-target="logistics-screen"]').addEventListener('click', () => {
    renderLogistics();
    switchScreen('logistics-screen');
});
/**
 * [V3.0 | 最终修正版] 处理AI的代付决定，并让AI根据人设生成符合情境的回复。
 */
async function handleAiPaymentDecision(messageId, decision) {
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;
    
    const message = character.history.find(m => m.id === messageId);
    if (!message || !message.paymentRequestData) return;

    // 1. 在数据中更新卡片状态
    message.paymentRequestData.status = decision;

    // --- 核心修复：立即保存数据并刷新整个聊天界面 ---
    // 这一步会立刻将卡片状态从“等待付款”更新为“已支付”或“已拒绝”
    await saveData();
    renderMessages(false, true); 
    // --- 修复结束 ---

    let contextMessageContent = ''; // 这是我们将要发给AI的“系统指令”

    if (decision === 'paid') {
        // (这部分逻辑保持不变：处理物流和顶部通知)
        addItemsToLogistics(message.paymentRequestData.items, character.id);
        const notifText = `<strong>${character.remarkName}</strong> 已为你支付了 ${message.paymentRequestData.items.length} 件商品。`;
        addNotificationToQueue({
            avatar: character.avatar,
            text: notifText,
            chatId: character.id,
            type: 'private'
        });
        
        // 创建一条引导AI回复的指令
        contextMessageContent = `[system: 你刚刚同意并支付了 ${character.myName} 的代付请求。请在聊天中告知对方你已经付款了，并根据你的人设说些什么（例如，可以表现得很大方、或者调侃一下这次消费、或者抱怨自己又破费了等等）。]`;

    } else { // 如果AI拒绝 (这部分逻辑保持不变)
        contextMessageContent = `[system: 你刚刚拒绝了 ${character.myName} 的代付请求。请在聊天中告知对方你拒绝的原因。]`;
    }

    // 2. 将这条“系统指令”作为一条用户消息发送给AI
    const contextMessage = {
        id: `msg_pay_resp_${Date.now()}`,
        role: 'user',
        content: contextMessageContent,
        parts: [{ type: 'text', text: contextMessageContent }],
        timestamp: Date.now()
    };
    character.history.push(contextMessage);
    
    // 3. 再次保存，确保指令被记录
    await saveData();

    // 4. 触发AI，让它根据上面的指令生成回复 (无需等待，让它在后台运行)
    getAiReply();
}
// ▲▲▲ 添加结束 ▲▲▲
/**
 * 打开购买流程的第一个弹窗（选择收货人）
 */
function openPurchaseModal(productId) {
    const product = findProductById(productId); // 使用这个辅助函数
    if (!product) {
        // 如果找不到商品，给出明确提示并中止
        showToast('错误：找不到该商品信息。');
        return;
    }
    purchaseState = { productId, recipientId: null, quantity: 1, style: '默认款式' , multiItems: []};
    
    const modal = document.getElementById('purchase-modal');
    modal.dataset.productId = productId; // 将产品ID暂存到弹窗上，用于取消时加入购物车

    document.getElementById('purchase-product-image').src = product.imageUrl;
    document.getElementById('purchase-product-price').textContent = `¥${product.price.toFixed(2)}`;
    document.getElementById('purchase-product-name').textContent = product.name;
    
    renderRecipientList();
    modal.classList.add('visible');
}

/**
 * 渲染收货人（聊天对象）列表
 */
function renderRecipientList() {
    const container = document.getElementById('recipient-selection-list');
    container.innerHTML = '';
    db.characters.forEach(char => {
        const li = document.createElement('li');
        li.className = 'list-item';
        li.innerHTML = `
            <input type="radio" name="recipient" value="${char.id}" id="recipient-${char.id}">
            <label for="recipient-${char.id}" style="display:flex; align-items:center; width:100%; gap:10px;">
                <img src="${char.avatar}" class="chat-avatar">
                <div class="item-details">
                    <div class="item-name">${char.remarkName}</div>
                </div>
            </label>
        `;
        container.appendChild(li);
    });
}

/**
 * [已修复] 处理收货人确认，并根据流程分发到“找人代付”或“自己购买”
 */
async function handleRecipientConfirmation() {
    const selectedRecipient = document.querySelector('input[name="recipient"]:checked');
    if (!selectedRecipient) {
        showToast('请选择一个收货人');
        return;
    }
    purchaseState.recipientId = selectedRecipient.value;
    const recipientChar = db.characters.find(c => c.id === purchaseState.recipientId);

    // 关闭选择弹窗
    document.getElementById('purchase-modal').classList.remove('visible');

    // --- 核心修复逻辑 ---
    // 判断是否为“找人代付”流程
    if (purchaseState.isPayForMe) {
        // *** 核心修改：使用 findProductById 查找商品 ***
        const product = findProductById(purchaseState.productId);
        if (!product || !recipientChar) {
            showToast('错误：找不到商品或代付人');
            return;
        }

        // 调用函数，向AI发送代付请求卡片
        await sendPaymentRequestCard(recipientChar.id, [product], product.price);

        showToast(`已向 ${recipientChar.remarkName} 发送代付请求`);
        
        // (可选, 但建议保留) 自动跳转到与该AI的聊天界面
        currentChatId = recipientChar.id;
        currentChatType = 'private';
        openChatRoom(currentChatId, currentChatType);

    } else if (purchaseState.multiItems.length > 0) {
        // 这是原有的逻辑：处理从收藏夹或购物车发起的“多商品结算”
        document.getElementById('delivery-countdown-modal').classList.add('visible');
    } else {
        // 这是原有的逻辑：处理正常的“单品自己购买”流程
        openOptionsModal();
    }
}

/**
 * 打开商品样式和数量选择弹窗
 */
function openOptionsModal() {
	   const product = findProductById(purchaseState.productId);
    if (!product) { // 增加安全检查
        showToast("打开商品选项失败：找不到商品。");
        return;
    }
    
    const modal = document.getElementById('product-options-modal');
    modal.dataset.productId = purchaseState.productId;

    document.getElementById('options-product-image').src = product.imageUrl;
    document.getElementById('options-product-price').textContent = `¥${product.price.toFixed(2)}`;
    document.getElementById('options-product-name').textContent = product.name;
    document.getElementById('purchase-quantity-input').value = 1;

    modal.classList.add('visible');
}

/**
 * 更新购买数量
 */
function updateQuantity(amount) {
    const input = document.getElementById('purchase-quantity-input');
    let currentValue = parseInt(input.value, 10);
    currentValue += amount;
    if (currentValue < 1) currentValue = 1;
    input.value = currentValue;
}



/**
 * [已修复] 完成购买，处理支付、物流、付款记录并发送商品卡片消息
 */
async function completePurchase() {
    const countdownMinutes = parseInt(document.getElementById('delivery-duration-input').value, 10);
    if (isNaN(countdownMinutes) || countdownMinutes <= 0) {
        showToast('请输入有效的倒计时分钟数');
        return;
    }

    // --- 核心修复 1：使用 findProductById 查找所有商品 ---
    // 旧代码只在 db.mallData.products 中查找，导致找不到个性化商品
    const product = findProductById(purchaseState.productId);
    const recipient = db.characters.find(c => c.id === purchaseState.recipientId);

    // 如果找不到商品或收件人，则中止操作
    if (!product || !recipient) {
        showToast('发生错误：找不到商品或收件人信息。');
        return;
    }

    const totalPrice = product.price * purchaseState.quantity;
    const purchaseDescription = `购买 ${product.name}`;

    try {
        // 等待支付流程完成
        await handlePayment(totalPrice, purchaseDescription);
    } catch (error) {
        showToast(error.message); // 如果支付失败或取消，则终止流程
        return;
    }

    // --- 核心修复 2：在支付成功后，补全物流和付款记录的逻辑 ---

    // 1. 将商品添加到物流列表，并传入用户设置的送达时间
    addItemsToLogistics([product], null, countdownMinutes);

    // 2. 将本次交易添加到付款记录
    if (!db.mallData.paymentHistory) {
        db.mallData.paymentHistory = [];
    }
    db.mallData.paymentHistory.unshift({
        id: `pay_${Date.now()}`,
        timestamp: Date.now(),
        description: purchaseDescription,
        total: totalPrice
    });

    // --- 记录逻辑结束 ---

    // 创建并发送包含所有配送信息的消息对象
    const deliveryMessage = {
        id: `msg_delivery_${Date.now()}`,
        role: 'user',
        content: `[我为${recipient.remarkName}购买了${product.name}]`,
        parts: [],
        timestamp: Date.now(),
        senderId: 'user_me',
        deliveryData: {
            productId: product.id,
            productName: product.name,
            productImage: product.imageUrl,
            price: product.price,
            quantity: purchaseState.quantity,
            style: purchaseState.style,
            eta: Date.now() + countdownMinutes * 60 * 1000,
            delivered: false
        }
    };

    recipient.history.push(deliveryMessage);
    await saveData(); // 保存所有更改

    document.getElementById('delivery-countdown-modal').classList.remove('visible');
    showToast('购买成功！已通知对方。');

    // 如果当前就在与收货人的聊天界面，则立即刷新
    if (currentChatId === recipient.id) {
        renderMessages(false, true);
    }
}


async function addToCart(productId, silent = false) {
    if (!productId) return;

    // --- 核心修改：同时检查AI商品和自定义商品 ---
    const allProducts = [...(db.mallData.products || []), ...(db.mallData.customProducts || [])];
    const productExists = allProducts.some(p => p.id === productId);
    
    if (!productExists) {
        if (!silent) showToast('错误：找不到该商品');
        return;
    }
    // --- 修改结束 ---

    const existingItem = db.mallData.cart.find(item => item.productId === productId);
    if (existingItem) {
        if (!silent) showToast('宝贝已在购物车中');
        return;
    }
    db.mallData.cart.push({
        cartId: `cart_${Date.now()}`,
        productId: productId,
        paymentDeadline: Date.now() + 30 * 60 * 1000
    });
    await saveData();
    if (!silent) {
        showToast('宝贝已加入购物车，请在30分钟内支付哦');
        renderCart();
        switchScreen('mall-cart-screen');
    }
}


/**
 * [已修复] 启动一个全局定时器来管理所有倒计时显示
 */
function startGlobalCountdownTimer() {
    if (globalCountdownInterval) clearInterval(globalCountdownInterval);

    globalCountdownInterval = setInterval(() => {
        document.querySelectorAll('[data-countdown-type]').forEach(async (el) => {
            const eta = parseInt(el.dataset.eta, 10);
            const remaining = eta - Date.now();
            
            if (remaining > 0) {
                const minutes = Math.floor((remaining / 1000 / 60) % 60).toString().padStart(2, '0');
                const seconds = Math.floor((remaining / 1000) % 60).toString().padStart(2, '0');
                const hours = Math.floor(remaining / (1000 * 60 * 60));
                
                if (el.dataset.countdownType === 'cart') {
                    el.textContent = `支付剩余 ${minutes}:${seconds}`;
                } else if (el.dataset.countdownType === 'delivery') {
                    el.textContent = `预计送达: ${hours > 0 ? hours + '小时' : ''}${minutes}分${seconds}秒`;
                }
            } else {
                if (el.dataset.countdownType === 'cart') {
                    el.textContent = '已失效';
                } else if (el.dataset.countdownType === 'delivery') {
                    el.textContent = '已送达';
                    
                    // --- 核心修复逻辑开始 ---
                    // 查找当前倒计时元素所在的整个物流项目卡片
                    const logisticsItem = el.closest('.logistics-item');
                    if (logisticsItem) {
                        // 在卡片内找到顶部的状态标签
                        const statusHeader = logisticsItem.querySelector('.logistics-status');
                        if (statusHeader) {
                            // 将“待发货”更新为“已送达”
                            statusHeader.textContent = '已送达';
                        }
                    }
                    // --- 核心修复逻辑结束 ---
                    
                    const messageWrapper = el.closest('.message-wrapper');
                    if (messageWrapper) {
                        await notifyAiOfDelivery(messageWrapper.dataset.id);
                        el.removeAttribute('data-countdown-type');
                    }
                }
            }
        });
    }, 1000);
}
/**
 * [V3.1 | 已修复自定义商品] 当倒计时结束后，通知AI收货，并激活特殊物品效果
 */
async function notifyAiOfDelivery(messageId) {
    for (const char of db.characters) {
        const message = char.history.find(m => m.id === messageId);
        if (message && message.deliveryData && !message.deliveryData.delivered) {
            
            message.deliveryData.delivered = true;

            // --- 核心修改：使用 findProductById 查找所有商品 ---
            const product = findProductById(message.deliveryData.productId);
            // --- 修改结束 ---

            let effectDescriptionForAI = `你收到了 ${char.myName} 购买的 “${message.deliveryData.productName}”。`;

            if (product && product.description) {
                if (!char.activeEffects) char.activeEffects = [];

                if (product.description.includes('解除') || product.description.includes('恢复')) {
                    if (product.description.includes('口吃')) {
                        char.activeEffects = char.activeEffects.filter(eff => eff.type !== 'stutter');
                        showToast(`${char.remarkName} 的口吃被治好了！`);
                        effectDescriptionForAI += ` 这个物品解除了你身上的“口吃”效果。`;
                    }
                } else {
                    const funcMatch = product.description.match(/功能：(.*?)(?:效果持续|副作用|$)/);
                    const durationMatch = product.description.match(/效果持续：(\d+)轮对话/);
                    const sideEffectMatch = product.description.match(/副作用：(.*?)(?:副作用持续|$)/);
                    const sideEffectDurationMatch = product.description.match(/副作用持续：(\d+)轮对话/);

                    if (funcMatch && durationMatch) {
                        const effect = {
                            duration: parseInt(durationMatch[1], 10),
                            isSideEffect: false
                        };
                        const funcText = funcMatch[1].trim();
                        
                        effectDescriptionForAI += ` 这个物品的效果是：“${funcText}”，效果将持续 ${effect.duration} 轮对话。`;
                        if (sideEffectMatch) {
                             effectDescriptionForAI += ` 副作用是：“${sideEffectMatch[1].trim()}”。`;
                        }

                        if (funcText.includes('交换人设') || funcText.includes('角色互换')) effect.type = 'role_swap';
                        else if (funcText.includes('只能说真话')) effect.type = 'truth_only';
                        else if (funcText.includes('害羞') || funcText.includes('内向')) effect.type = 'shy';
                        else if (funcText.includes('失忆')) effect.type = 'amnesia';
                        else if (funcText.includes('动物化')) {
                            effect.type = 'animalization';
                            effect.animal = funcText.replace('动物化', '').trim() || '猫';
                        }
                        
                        if (sideEffectMatch && sideEffectDurationMatch) {
                            const sideEffect = { duration: parseInt(sideEffectDurationMatch[1], 10) };
                            const sideEffectText = sideEffectMatch[1].trim();
                            if (sideEffectText.includes('口吃')) sideEffect.type = 'stutter';
                            if (sideEffect.type) effect.sideEffect = sideEffect;
                        }
                        
                        if (effect.type) {
                            char.activeEffects.push(effect);
                            showToast(`${char.remarkName} 使用了特殊物品！`);
                        }
                    }
                }
            }
            
            const contextMessageContent = `[system: ${effectDescriptionForAI} 请根据你的人设对此作出回应，你的回应要体现出你已经开始受到影响。]`;
            
            const contextMessage = {
                id: `msg_delivery_receipt_${Date.now()}`,
                role: 'user',
                content: contextMessageContent,
                parts: [{ type: 'text', text: contextMessageContent }],
                timestamp: Date.now()
            };
            char.history.push(contextMessage);
            
            await saveData();
            
            if (currentChatId === char.id) {
                getAiReply();
            }
            
            break;
        }
    }
}
// ===============================================================
// END: 商城购物流程核心JS函数
// ===============================================================
// 在 init() 函数之前添加
// V V V V V  请用这段完整代码替换旧的 setupMentions 函数 V V V V V
// ===============================================================
// START: 新增“心灵羁绊”App功能
// ===============================================================
// ===============================================================
// START: "想你啦" (Miss You) Feature
// ===============================================================
function setupMissYouFeature() {
    const missYouActionSheet = document.getElementById('miss-you-actionsheet');
    const missYouButtonsContainer = missYouActionSheet.querySelector('.action-sheet');
    const cancelMissYouBtn = document.getElementById('cancel-miss-you-btn');

    // 思念冷却时间 (60秒)
    const COOLDOWN_DURATION = 60 * 1000;

    async function handleMissYouAction(e) {
        const actionButton = e.target.closest('.action-sheet-button[data-level]');
        if (!actionButton) return;

        const level = actionButton.dataset.level;
        
        const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
        const character = db.characters.find(c => c.id === characterId);

        if (!character) {
            showToast('错误：找不到当前角色');
            missYouActionSheet.classList.remove('visible');
            return;
        }
        
        // 检查冷却时间
        const lastUsed = character.lastMissYouTimestamp || 0;
        const now = Date.now();
        if (now - lastUsed < COOLDOWN_DURATION) {
            const remainingSeconds = Math.ceil((COOLDOWN_DURATION - (now - lastUsed)) / 1000);
            showToast(`思念正在冷却中...请在 ${remainingSeconds} 秒后重试`);
            return;
        }

        // 更新时间戳以重置冷却
        character.lastMissYouTimestamp = now;

        // 根据想念程度构建不同的系统指令
        let systemContent = '';
        if (level === '有点想你') {
            systemContent = `[system: ${character.myName} 刚刚按下了“有点想你”按钮。这是一种比较含蓄的情感表达。请根据你的人设，回复一条温柔、关心或略带思念的话语。]`;
        } else if (level === '非常想你') {
            systemContent = `[system: ${character.myName} 刚刚按下了“非常想你”按钮！这是一种非常直接和浓烈的情感表达。请根据你的人设，立刻回复一条充满爱意或极度思念的消息。]`;
        }

        if (!systemContent) return;

        // 创建并注入系统消息
        const contextMessage = {
            id: `msg_miss_you_${now}`,
            role: 'user',
            content: systemContent,
            parts: [{ type: 'text', text: systemContent }],
            timestamp: now
        };
        character.history.push(contextMessage);
        
        await saveData();
        
        missYouActionSheet.classList.remove('visible');
        showToast('你的思念已发送~');

        // 如果当前就在与该角色的聊天界面，则立即触发AI回复
        if (currentChatId === character.id) {
            getAiReply();
        } else {
            // 否则，仅刷新聊天列表以显示可能的未读提示
            renderChatList();
        }
    }

    missYouButtonsContainer.addEventListener('click', handleMissYouAction);
    cancelMissYouBtn.addEventListener('click', () => missYouActionSheet.classList.remove('visible'));
}
// ===============================================================
// END: "想你啦" (Miss You) Feature
// ===============================================================
// ===============================================================
// START: "每日一问" (Daily Question) Feature
// ===============================================================
function setupDailyQuestionFeature() {
    const questionModal = document.getElementById('bond-daily-question-modal');
    const questionTextEl = document.getElementById('daily-question-text');
    const answerForm = document.getElementById('daily-question-answer-form');
    const answerTextarea = document.getElementById('daily-question-answer');
    const currentQuestionInput = document.getElementById('current-daily-question-text');

    async function handleDailyQuestionClick() {
        const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
        const character = db.characters.find(c => c.id === characterId);
        if (!character) return;

        character.soulBondData = character.soulBondData || {};
        character.soulBondData.dailyQuestionHistory = character.soulBondData.dailyQuestionHistory || [];

        const today = new Date().toISOString().slice(0, 10);
        const lastQuestion = character.soulBondData.dailyQuestionHistory[0];

        answerForm.style.display = 'block';
        answerTextarea.disabled = false;
        answerTextarea.value = '';
        answerForm.querySelector('button').disabled = false;

        if (lastQuestion && lastQuestion.date === today) {
            // 今天已经有题目了
            questionTextEl.textContent = lastQuestion.question;
            currentQuestionInput.value = lastQuestion.question;
            if (lastQuestion.answered) {
                answerTextarea.value = `你今天已经回答过啦：\n"${lastQuestion.userAnswer}"`;
                answerTextarea.disabled = true;
                answerForm.querySelector('button').disabled = true;
            }
            questionModal.classList.add('visible');
        } else {
            // 今天还没有题目，需要AI生成
            questionModal.classList.add('visible');
            questionTextEl.textContent = '正在为你准备今天的问题...';
            answerForm.style.display = 'none';

            try {
                const prompt = generateDailyQuestionPrompt(character);
                const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
                
                const newQuestion = {
                    date: today,
                    question: aiResponseText.trim(),
                    answered: false,
                    userAnswer: '',
                    aiResponse: '' // 备用字段
                };

                character.soulBondData.dailyQuestionHistory.unshift(newQuestion);
                await saveData();

                questionTextEl.textContent = newQuestion.question;
                currentQuestionInput.value = newQuestion.question;
                answerForm.style.display = 'block';

            } catch (error) {
                questionTextEl.textContent = `问题生成失败: ${error.message}`;
            }
        }
    }

    answerForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const userAnswer = answerTextarea.value.trim();
        const question = currentQuestionInput.value;
        if (!userAnswer) {
            showToast('回答不能为空哦');
            return;
        }

        const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
        const character = db.characters.find(c => c.id === characterId);
        if (!character) return;

        const todayQuestion = character.soulBondData.dailyQuestionHistory[0];
        if (todayQuestion) {
            todayQuestion.answered = true;
            todayQuestion.userAnswer = userAnswer;
        }

        const systemContent = `[system: 我对你提出的每日一问“${question}”的回答是：“${userAnswer}”。请根据你的人设，对我今天的回答作出回应。]`;
        const contextMessage = {
            id: `msg_daily_q_answer_${Date.now()}`,
            role: 'user',
            content: systemContent,
            parts: [{ type: 'text', text: systemContent }],
            timestamp: Date.now()
        };
        character.history.push(contextMessage);
        
        await saveData();
        questionModal.classList.remove('visible');
        showToast('回答已发送~');

        if (currentChatId === character.id) {
            getAiReply();
        } else {
            renderChatList();
        }
    });

    // 为“每日一问”按钮绑定事件
    document.querySelector('.bond-nav-btn[data-feature="dailyquestion"]').addEventListener('click', handleDailyQuestionClick);
}

function generateDailyQuestionPrompt(character) {
    return `你正在扮演角色“${character.realName}”，人设是：${character.persona}。
请根据你的人设，向你的伴侣“我”（${character.myName}）提出一个能够增进你们感情或引发深刻思考的“每日一问”。
规则:
1. 这个问题必须非常贴合你的人设和你们的关系。
2. 避免简单的是/否问题，鼓励对方分享想法和感受。
3. 你的输出必须直接是问题本身，不要包含任何额外的话。

示例:
- 如果你是一个浪漫的诗人："如果我们的记忆可以像一本书一样翻阅，你最想重温哪一页？"
- 如果你是一个务实的科学家："在我们的关系中，你认为哪个变量对整体的‘幸福指数’影响最大？"`;
}

// 渲染问答手册页面
function renderQandAHandbook() {
    const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
    const character = db.characters.find(c => c.id === characterId);
    const container = document.getElementById('q-and-a-list-container');
    const placeholder = document.getElementById('no-q-and-a-placeholder');

    if (!character || !character.soulBondData || !character.soulBondData.dailyQuestionHistory || character.soulBondData.dailyQuestionHistory.length === 0) {
        container.innerHTML = '';
        placeholder.style.display = 'block';
        return;
    }

    placeholder.style.display = 'none';
    container.innerHTML = '';

    character.soulBondData.dailyQuestionHistory.forEach(item => {
        if (!item.answered) return; // 只显示已回答的

        const li = document.createElement('li');
        li.className = 'diary-entry'; // 复用日记样式
        li.innerHTML = `
            <div class="diary-header">
                <span class="diary-date">${item.date}</span>
            </div>
            <div class="diary-content" style="background: #fff8fa; padding: 10px; border-radius: 8px; margin-bottom: 10px;">
                <strong>Ta的提问:</strong><br>${item.question}
            </div>
            <div class="diary-content" style="background: #f0f4f8; padding: 10px; border-radius: 8px;">
                <strong>我的回答:</strong><br>${item.userAnswer}
            </div>
        `;
        container.appendChild(li);
    });
}

// ===============================================================
// END: "每日一问" Feature
// ===============================================================

// ===============================================================
// START: "情绪天气" (Mood Weather) Feature
// ===============================================================
function setupMoodWeatherFeature() {
    const moodModal = document.getElementById('bond-mood-weather-modal');
    const moodIconEl = document.getElementById('mood-weather-icon');
    const moodReasonEl = document.getElementById('mood-weather-reason');
    const moodTitleEl = document.getElementById('mood-weather-title');
    const sootheBtn = document.getElementById('soothe-ai-btn');

    // 缓存时间 (1小时)
    const CACHE_DURATION = 60 * 60 * 1000;

    async function handleMoodWeatherClick() {
        const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
        const character = db.characters.find(c => c.id === characterId);
        if (!character) return;

        moodTitleEl.textContent = `${character.remarkName}现在的心情`;
        moodModal.classList.add('visible');

        character.soulBondData = character.soulBondData || {};
        const moodCache = character.soulBondData.moodCache;
        const now = Date.now();

        if (moodCache && (now - moodCache.timestamp < CACHE_DURATION)) {
            // 从缓存加载
            renderMoodWeatherModal(moodCache.data);
        } else {
            // 从AI获取
            moodIconEl.innerHTML = '🤔';
            moodReasonEl.textContent = '正在感知Ta的情绪...';
            sootheBtn.style.display = 'none';

            try {
                const prompt = generateMoodWeatherPrompt(character);
                const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
                const moodData = JSON.parse(aiResponseText.match(/{[\s\S]*}/)[0]);
                
                character.soulBondData.moodCache = {
                    data: moodData,
                    timestamp: now
                };
                await saveData();
                renderMoodWeatherModal(moodData);

            } catch (error) {
                moodReasonEl.textContent = `感知失败: ${error.message}`;
            }
        }
    }

    function renderMoodWeatherModal(moodData) {
        let icon = '☀️';
        let showSoothe = false;
        switch (moodData.mood) {
            case '晴朗': icon = '☀️'; break;
            case '多云': icon = '☁️'; break;
            case '小雨': icon = '🌧️'; showSoothe = true; break;
            case '雷暴': icon = '⛈️'; showSoothe = true; break;
        }
        moodIconEl.innerHTML = icon;
        moodReasonEl.textContent = `“${moodData.reason}”`;
        sootheBtn.style.display = showSoothe ? 'block' : 'none';
    }

    sootheBtn.addEventListener('click', async () => {
        const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
        const character = db.characters.find(c => c.id === characterId);
        if (!character) return;

        const systemContent = `[system: 我注意到你现在的心情似乎不太好（情绪天气是${character.soulBondData.moodCache.data.mood}）。我在这里，想安慰你一下。请根据你的人设，对我做出回应。]`;
        const contextMessage = {
            id: `msg_soothe_${Date.now()}`,
            role: 'user',
            content: systemContent,
            parts: [{ type: 'text', text: systemContent }],
            timestamp: Date.now()
        };
        character.history.push(contextMessage);
        await saveData();
        
        moodModal.classList.remove('visible');
        showToast('安慰已送达~');

        if (currentChatId === character.id) {
            getAiReply();
        } else {
            renderChatList();
        }
    });

    document.querySelector('.bond-nav-btn[data-feature="mood"]').addEventListener('click', handleMoodWeatherClick);
}

function generateMoodWeatherPrompt(character) {
    const history = character.history.slice(-15); // 最近15条消息
    const historyText = history.map(msg => {
        const sender = msg.role === 'user' ? character.myName : character.remarkName;
        const contentMatch = msg.content.match(/\[.*?的消息：([\s\S]+?)\]/);
        const cleanContent = contentMatch ? contentMatch[1] : msg.content;
        return `${sender}: ${cleanContent}`;
    }).join('\n');

    return `你正在扮演角色“${character.realName}”，人设是：${character.persona}。
请根据我们最近的聊天记录，分析你此刻的心情。
规则:
1. 从【'晴朗', '多云', '小雨', '雷暴'】中选择一个最符合你当前心情的词。
2. 用第一人称视角，写一段**不少于100字**的内心独白，解释你为什么是这个心情。
3. 你的输出必须是严格的JSON格式，不要包含任何其他文字。

# 最近的聊天记录参考:
${historyText}

# JSON格式示例:
{
  "mood": "晴朗",
  "reason": "因为你刚才夸我了，我心里像开了花一样，一整天都变得明亮起来。和你聊天总能让我忘记所有烦恼，感觉世界都温柔了许多。真希望这样的时刻能再多一些。"
}`;
}
// ===============================================================
// END: "情绪天气" Feature
// ===============================================================

// ===============================================================
// START: 心灵羁绊 - 爱心想你功能
// ===============================================================
function setupBondMissYouHeartFeature() {
    let clickTimeout = null;
    const COOLDOWN_DURATION = 30 * 1000; // 30秒冷却时间

    // 使用事件委托，因为爱心按钮是动态渲染的
    document.getElementById('soul-bond-screen').addEventListener('click', (e) => {
        const heartBtn = e.target.closest('#bond-miss-you-btn');
        if (!heartBtn) return;

        // 清除上一个单击计时器，以防这是双击的第一次点击
        clearTimeout(clickTimeout);

        // 设置一个短暂的延迟来执行单击操作
        clickTimeout = setTimeout(() => {
            sendMissYouSignal('normal');
        }, 250); // 250毫秒内如果没有再次点击，则视为单击
    });

    document.getElementById('soul-bond-screen').addEventListener('dblclick', (e) => {
        const heartBtn = e.target.closest('#bond-miss-you-btn');
        if (!heartBtn) return;

        // 立即清除单击计时器，确保单击操作不会执行
        clearTimeout(clickTimeout);
        
        // 执行双击操作
        sendMissYouSignal('super');
    });

    async function sendMissYouSignal(level) {
        const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
        const character = db.characters.find(c => c.id === characterId);
        if (!character) return;

        // 检查冷却时间
        const lastUsed = character.lastMissYouTimestamp || 0;
        const now = Date.now();
        if (now - lastUsed < COOLDOWN_DURATION) {
            const remainingSeconds = Math.ceil((COOLDOWN_DURATION - (now - lastUsed)) / 1000);
            showToast(`思念正在冷却中...请在 ${remainingSeconds} 秒后重试`);
            return;
        }

        character.lastMissYouTimestamp = now;

        let systemContent = '';
        let toastMessage = '你的思念已发送~';

        if (level === 'normal') {
            systemContent = `[system: ${character.myName} 刚刚在“心灵羁绊”里按下了“想你啦”按钮。这是一种比较含蓄的情感表达。请根据你的人设，回复一条温柔、关心或略带思念的话语。]`;
        } else if (level === 'super') {
            systemContent = `[system: ${character.myName} 刚刚在“心灵羁绊”里快速点击了两次“想你啦”按钮，表达了“超级想你”！这是一种非常直接和浓烈的情感表达。请立刻回复一条充满爱意或极度思念的消息。]`;
            toastMessage = '你强烈的思念已发送！';
        }

        if (!systemContent) return;

        const contextMessage = {
            id: `msg_miss_you_${now}`,
            role: 'user',
            content: systemContent,
            parts: [{ type: 'text', text: systemContent }],
            timestamp: now
        };
        character.history.push(contextMessage);
        
        await saveData();
        showToast(toastMessage);

        if (currentChatId === character.id) {
            getAiReply();
        } else {
            renderChatList();
        }
    }
}
// ===============================================================
// END: 心灵羁绊 - 爱心想你功能
// ===============================================================
// ===============================================================
// START: [已更新V2.0] “心灵羁绊”App功能
/**
 * [已更新 V3.0] 设置心灵羁绊App的所有事件和逻辑 (已集成愿望清单和自定义照片)
 */
function setupSoulBondApp() {
	       // ▼▼▼ 修改开始 ▼▼▼
    document.getElementById('soul-bond-app-icon').addEventListener('click', () => {
        const boundCharacter = findBoundCharacter();
        
        if (boundCharacter) {
            // 如果已绑定，直接进入主界面
            const soulBondScreen = document.getElementById('soul-bond-screen');
            soulBondScreen.dataset.characterId = boundCharacter.id;
            renderSoulBondScreen();
            switchScreen('soul-bond-screen');
        } else {
            // 如果未绑定，进入邀请界面
            renderBondInvitationScreen();
            switchScreen('bond-invitation-screen');
        }
    });
    const settingsModal = document.getElementById('bond-settings-modal');
    const settingsForm = document.getElementById('bond-settings-form');
    const addCustomPhotoModal = document.getElementById('add-custom-bond-photo-modal');
    const customPhotoForm = document.getElementById('custom-bond-photo-form');
       

    // 打开设置弹窗 (爱心图标按钮)
    document.getElementById('bond-settings-btn').addEventListener('click', () => {
     const characterId = document.getElementById('soul-bond-screen').dataset.characterId; // <-- 修复
        const character = db.characters.find(c => c.id === characterId); // <-- 修复
        if (!character) return;
        
        const settings = character.soulBondData || {};
        document.getElementById('bond-my-name-input').value = settings.myName || character.myName;
        document.getElementById('bond-ai-name-input').value = settings.aiName || character.remarkName;
        if (settings.anniversaryInfo) {
            document.getElementById('bond-anniversary-date-input').value = settings.anniversaryInfo.date || '';
            document.getElementById('bond-anniversary-desc-input').value = settings.anniversaryInfo.description || '';
        } else {
            document.getElementById('bond-anniversary-date-input').value = '';
            document.getElementById('bond-anniversary-desc-input').value = '';
        }
        document.getElementById('bond-background-url-input').value = settings.background || '';
        
        settingsModal.classList.add('visible');
    });

    // 保存设置
    settingsForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const character = db.characters.find(c => c.id === currentChatId);
        if (!character) return;

        character.soulBondData = character.soulBondData || { photos: [], wishlist: [] };
        character.soulBondData.myName = document.getElementById('bond-my-name-input').value;
        character.soulBondData.aiName = document.getElementById('bond-ai-name-input').value;
        const anniversaryDate = document.getElementById('bond-anniversary-date-input').value;
        const anniversaryDesc = document.getElementById('bond-anniversary-desc-input').value;
        if (anniversaryDate) {
            character.soulBondData.anniversaryInfo = {
                date: anniversaryDate,
                description: anniversaryDesc || '纪念日' // 如果描述为空，提供一个默认值
            };
        } else {
            character.soulBondData.anniversaryInfo = null; // 如果日期被清空，则删除整个纪念日信息
        }
        character.soulBondData.background = document.getElementById('bond-background-url-input').value;
        
        await saveData();
        renderSoulBondScreen();
        settingsModal.classList.remove('visible');
        showToast('设置已保存');
    });

    // --- 核心修复：“添加回忆照片”按钮现在打开自定义上传弹窗 ---
    document.getElementById('add-bond-photo-btn').addEventListener('click', () => {
        customPhotoForm.reset();
        document.getElementById('custom-photo-preview').style.backgroundImage = 'none';
        addCustomPhotoModal.classList.add('visible');
        settingsModal.classList.remove('visible'); // 关闭设置弹窗
    });

    // 处理自定义照片文件选择
    document.getElementById('custom-photo-upload').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
            try {
                const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 400, maxHeight: 400 });
                document.getElementById('custom-photo-preview').style.backgroundImage = `url(${compressedUrl})`;
            } catch (error) {
                showToast('图片处理失败');
            }
        }
    });

    // 保存自定义照片
    customPhotoForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const character = db.characters.find(c => c.id === currentChatId);
        if (!character) return;
        
        const imageUrl = document.getElementById('custom-photo-preview').style.backgroundImage.slice(5, -2);
        const description = document.getElementById('custom-photo-desc').value.trim();

        if (!imageUrl || !description) {
            showToast('请选择图片并填写描述');
            return;
        }

        character.soulBondData = character.soulBondData || { photos: [], wishlist: [] };
        character.soulBondData.photos.unshift({ imageUrl, description });

        await saveData();
        renderSoulBondScreen();
        addCustomPhotoModal.classList.remove('visible');
        showToast('一张新的回忆照片已添加！');
    });

    // --- 愿望清单功能 ---
    setupWishlistApp();

    // --- 底部导航栏事件处理更新 ---
    document.querySelector('.bond-bottom-nav').addEventListener('click', (e) => {
        const btn = e.target.closest('.bond-nav-btn');
        if (!btn || !btn.dataset.feature) return;
        const feature = btn.dataset.feature;
        switch(feature) {
            case 'pomodoro':
                const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
                const pomodoroScreen = document.getElementById('pomodoro-screen');
                pomodoroScreen.dataset.characterId = characterId;
                currentAiForApp = db.characters.find(c => c.id === characterId);
                
                if (typeof applySettings === 'function') applySettings(); // 应用番茄钟的个性化设置
                switchScreen('pomodoro-screen');
                break;
            case 'diary': 
                renderDiaryExchanges();
                switchScreen('bond-diary-exchange-screen');
                break;
            // 其他 case 保持不变...
            case 'wishlist':
            case 'dailyquestion':
            case 'mood':
                 // 这些功能已经有独立的 setup 函数处理，这里无需重复
                break;
            default:
                showToast('“' + (btn.title || '该') + '”功能正在开发中...');
                break;
        }
        // ▲▲▲ 修复结束 ▲▲▲
    });
    
    // 确保在App启动时调用新功能
    setupWishlistApp();
    setupDiaryExchangeApp();
    setupDailyQuestionFeature();
    setupMoodWeatherFeature();
}
// ===============================================================
// START: 心灵羁绊 - 绑定功能核心逻辑
// ===============================================================
// ▼▼▼ 请用这个完整的、修正后的新函数，替换掉文件中旧的 setupBondInvitationSystem 函数 ▼▼▼
function setupBondInvitationSystem() {
    const inviteModal = document.getElementById('bond-invite-modal');
    
    // 渲染邀请页面 (此函数保持不变)
    window.renderBondInvitationScreen = () => {
        const myAvatarContainer = document.getElementById('bond-invite-my-avatar');
        const myProfile = db.characters[0] ? { name: db.characters[0].myName, avatar: db.characters[0].myAvatar } : { name: '我', avatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg' };
        myAvatarContainer.innerHTML = `
            <img src="${myProfile.avatar}" alt="My Avatar">
            <div class="avatar-name">${myProfile.name}</div>
        `;
    };

    // 为邀请按钮（主按钮和加号）绑定事件
    ['bond-invite-main-btn', 'bond-invite-ai-avatar'].forEach(id => {
        document.getElementById(id).addEventListener('click', () => {
            // ▼▼▼ 修改/新增：增加邀请前置检查 ▼▼▼
            // 检查是否已有其他邀请正在等待回应
            const isAnyInvitationPending = db.characters.some(c => c.soulBondStatus === 'pending_by_user');
            if (isAnyInvitationPending) {
                showToast('你已经有一个正在等待回应的邀请了，请先处理。');
                return;
            }
            // ▲▲▲ 修改结束 ▲▲▲

            const list = document.getElementById('bond-invite-selection-list');
            list.innerHTML = '';
            
            // ▼▼▼ 修改：修正筛选逻辑，排除已发出邀请的角色 ▼▼▼
            const unboundCharacters = db.characters.filter(c => !c.isSoulBound && c.soulBondStatus !== 'pending_by_user');
            // ▲▲▲ 修改结束 ▲▲▲
            
            if(unboundCharacters.length === 0) {
                list.innerHTML = '<li class="placeholder-text" style="padding: 20px 0;">没有可邀请的对象了</li>';
            } else {
                unboundCharacters.forEach(char => {
                    const li = document.createElement('li');
                    li.className = 'list-item';
                    li.style.cursor = 'pointer';
                    li.dataset.charId = char.id;
                    li.innerHTML = `<img src="${char.avatar}" class="chat-avatar"><span>${char.remarkName}</span>`;
                    list.appendChild(li);
                });
            }
            inviteModal.classList.add('visible');
        });
    });

    // ▼▼▼ 这是本次修改的核心 ▼▼▼
    document.getElementById('bond-invite-selection-list').addEventListener('click', async (e) => {
        const item = e.target.closest('.list-item');
        if (!item || !item.dataset.charId) return;

        const charId = item.dataset.charId;
        const character = db.characters.find(c => c.id === charId);
        if (!character) return;
        
        if (!confirm(`确定要向 ${character.remarkName} 发送心动绑定邀请吗？`)) {
            return;
        }

        // 1. 更新AI状态为“等待回应”
        character.soulBondStatus = 'pending_by_user';

        // 2. 创建并注入一张“邀请卡”消息到聊天记录中
        const bondRequestMessage = {
            id: `msg_bond_req_card_${Date.now()}`,
            role: 'user', // 这条消息是“我”发出的
            content: `[我向 ${character.remarkName} 发起了心动绑定邀请]`,
            parts: [],
            timestamp: Date.now(),
            bondRequestData: { status: 'pending' } // 这个特殊属性将用于渲染卡片
        };
        character.history.push(bondRequestMessage);
        
        // 3. 创建并注入一条给AI看的“系统指令”
        const systemContent = `[system: ${character.myName} 向你发起了“心动绑定”请求。这代表Ta希望与你建立唯一的、最亲密的关系，以解锁更多专属互动。请根据你的人设，认真考虑后作出决定。你的回复必须是且仅是以下两个指令之一：[accept-bond] (同意绑定) 或 [decline-bond] (拒绝绑定)]`;
        const contextMessage = {
            id: `msg_bond_req_ctx_${Date.now()}`, role: 'user', content: systemContent,
            parts: [{ type: 'text', text: systemContent }], timestamp: Date.now()
        };
        character.history.push(contextMessage);

        // 4. 保存数据，关闭弹窗，并提示用户
        await saveData();
        inviteModal.classList.remove('visible');
        showToast(`已向 ${character.remarkName} 发送邀请！`);

        // 5. 【关键】不再跳转页面，而是让用户停留在原地。用户下次打开聊天时会看到邀请卡和AI的回复。
        // 为了更好的体验，我们可以主动刷新一下聊天列表，让该聊天置顶
        renderChatList();
    });
    // ▲▲▲ 核心修改结束 ▲▲▲
}

function setupWishlistApp() {
    const wishEditorModal = document.getElementById('bond-wish-editor-modal');
    const wishForm = document.getElementById('bond-wish-form');
    const wishTextInput = document.getElementById('wish-text-input');
    const editingWishIdInput = document.getElementById('editing-wish-id');
    const editorTitle = document.getElementById('wish-editor-title');
    const addWishFab = document.getElementById('add-wish-fab'); // 获取+号按钮

    // 1. 监听“愿望清单”导航按钮的点击
    document.querySelector('.bond-nav-btn[data-feature="wishlist"]').addEventListener('click', () => {
        const character = db.characters.find(c => c.id === document.getElementById('soul-bond-screen').dataset.characterId);
        if (!character) return;
        
        if (character.soulBondData && character.soulBondData.wishlist) {
            renderWishlist(character.soulBondData.wishlist);
        } else {
            document.getElementById('bond-wishlist-container').innerHTML = `<p class="placeholder-text">点击右下角“+”添加第一个愿望，或点击右上角“刷新”让AI为你们推荐。</p>`;
        }
        switchScreen('bond-wishlist-screen');
    });

    // 2. 监听“刷新”按钮（AI建议功能保持不变）
    document.getElementById('refresh-wishlist-btn').addEventListener('click', async () => {
        const character = db.characters.find(c => c.id === document.getElementById('soul-bond-screen').dataset.characterId);
        if (!character) return;
        if (!confirm('这会用AI生成的建议覆盖当前的愿望清单，确定吗？')) return;

        const container = document.getElementById('bond-wishlist-container');
        container.innerHTML = `<p class="placeholder-text">正在生成愿望清单...</p>`;

        try {
            const prompt = generateAiWishlistPrompt(character);
            const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
            const wishlistData = JSON.parse(aiResponseText.match(/\[[\s\S]*\]/)[0]);
            
            const wishes = wishlistData.map(wish => ({ id: `wish_${Date.now()}_${Math.random()}`, text: wish, completed: false }));

            character.soulBondData = character.soulBondData || { photos: [], wishlist: [] };
            character.soulBondData.wishlist = wishes;
            await saveData();

            renderWishlist(wishes);
        } catch (error) {
            console.error("生成愿望清单失败:", error);
            showToast(`生成失败: ${error.message}`);
            container.innerHTML = `<p class="placeholder-text" style="color:red;">生成失败</p>`;
        }
    });

    // 3. 监听“+”浮动按钮，用于添加新愿望
    if(addWishFab) {
        addWishFab.addEventListener('click', () => openWishEditor());
    }
    
    // 4. 处理愿望编辑器表单提交
    wishForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const character = db.characters.find(c => c.id === document.getElementById('soul-bond-screen').dataset.characterId);
        if (!character) return;
        
        const wishText = wishTextInput.value.trim();
        const editingId = editingWishIdInput.value;

        character.soulBondData = character.soulBondData || { photos: [], wishlist: [] };
        
        if (editingId) { // 编辑模式 (虽然按钮移除，但保留逻辑以备将来使用)
            const wish = character.soulBondData.wishlist.find(w => w.id === editingId);
            if (wish) wish.text = wishText;
        } else { // 新增模式
            character.soulBondData.wishlist.unshift({
                id: `wish_${Date.now()}`,
                text: wishText,
                completed: false
            });
        }

        await saveData();
        renderWishlist(character.soulBondData.wishlist);
        wishEditorModal.classList.remove('visible');
    });

    // 5. 使用事件委托处理清单项的交互（完成、长按删除）
    const wishlistContainer = document.getElementById('bond-wishlist-container');

    wishlistContainer.addEventListener('click', async (e) => {
        const wishItem = e.target.closest('.wish-item');
        if (!wishItem) return;
        
        const wishCheckbox = e.target.closest('.wish-checkbox');
        if (wishCheckbox) {
            const character = db.characters.find(c => c.id === document.getElementById('soul-bond-screen').dataset.characterId);
            if (!character || !character.soulBondData || !character.soulBondData.wishlist) return;

            const wishId = wishCheckbox.dataset.id;
            const wish = character.soulBondData.wishlist.find(w => w.id === wishId);
            if (!wish) return;

            wish.completed = wishCheckbox.checked;
            await saveData();
            wishItem.classList.toggle('completed', wish.completed);
            showToast(wish.completed ? '一个愿望已达成！' : '愿望已重新开启');

            if (wish.completed) {
                const content = `[system: 你和 ${character.myName} 共同完成了愿望清单中的一项：“${wish.text}”。请在聊天中对此发表感想。]`;
                const contextMessage = { id: `msg_wish_done_${Date.now()}`, role: 'user', content: content, parts: [{ type: 'text', text: content }], timestamp: Date.now() };
                character.history.push(contextMessage);
                await saveData();
            }
        }
    });

    // 6. 添加长按删除逻辑
    let longPressTimer;
    const handleLongPress = async (targetElement) => {
        const wishItem = targetElement.closest('.wish-item');
        if (!wishItem) return;
        
        const character = db.characters.find(c => c.id === document.getElementById('soul-bond-screen').dataset.characterId);
        if (!character || !character.soulBondData) return;

        const wishId = wishItem.querySelector('.wish-checkbox').dataset.id;
        const wish = character.soulBondData.wishlist.find(w => w.id === wishId);
        
        if (wish && confirm(`确定要删除这个愿望吗？\n“${wish.text}”`)) {
            character.soulBondData.wishlist = character.soulBondData.wishlist.filter(w => w.id !== wishId);
            await saveData();
            renderWishlist(character.soulBondData.wishlist);
            showToast('愿望已删除');
        }
    };

    wishlistContainer.addEventListener('touchstart', (e) => {
        longPressTimer = setTimeout(() => handleLongPress(e.target), 500);
    });
    wishlistContainer.addEventListener('touchend', () => clearTimeout(longPressTimer));
    wishlistContainer.addEventListener('touchmove', () => clearTimeout(longPressTimer));
    wishlistContainer.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        handleLongPress(e.target);
    });


    // 打开编辑/新增弹窗的辅助函数
    function openWishEditor(wish = null) {
        wishForm.reset();
        if (wish) {
            editorTitle.textContent = '编辑愿望';
            editingWishIdInput.value = wish.id;
            wishTextInput.value = wish.text;
        } else {
            editorTitle.textContent = '添加一个新愿望';
            editingWishIdInput.value = '';
        }
        wishEditorModal.classList.add('visible');
    }
}

// 渲染愿望清单的函数（已移除编辑和删除按钮）
function renderWishlist(wishes) {
    const container = document.getElementById('bond-wishlist-container');
    container.innerHTML = '';
    wishes.forEach(wish => {
        const li = document.createElement('li');
        li.className = 'list-item';
        // 移除了编辑和删除按钮的HTML
        li.innerHTML = `
            <div class="wish-item ${wish.completed ? 'completed' : ''}">
                <input type="checkbox" class="wish-checkbox" data-id="${wish.id}" ${wish.completed ? 'checked' : ''}>
                <div class="item-details">
                    <div class="item-name">${wish.text}</div>
                </div>
            </div>
        `;
        container.appendChild(li);
    });
}
// AI建议Prompt保持不变
function generateAiWishlistPrompt(character) {
    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。
请根据你的人设和与“我”（${character.myName}）的关系，虚构一个包含5-8条你们“最想一起完成的事”的愿望清单。
规则:
1. 愿望要非常贴合你的人设和我们的关系，可以浪漫、有趣、或富有冒险精神。
2. 每条愿望都是一个简短的句子。
3. 你的输出必须是严格的JSON数组格式，数组中只包含字符串，不要包含任何其他文字。

JSON格式示例:
[
  "一起去海边看一次日出",
  "养一只属于我们两个人的小猫",
  "不看攻略，来一场说走就走的旅行",
  "为你做一顿丰盛的晚餐"
]`;
    return prompt;
}
// ===============================================================
// END: 新增“愿望清单”App功能
// ===============================================================

/**
 * [已更新 V3.0] 渲染心灵羁绊屏幕的完整UI (粉色主题 + 大卡片布局)
 */
function renderSoulBondScreen() {
    const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
    const character = db.characters.find(c => c.id === characterId);
    if (!character) return;

    const settings = character.soulBondData || {};

    const screenContent = document.querySelector('#soul-bond-screen .content');
    screenContent.style.backgroundImage = settings.background ? `url('${settings.background}')` : 'none';
    screenContent.style.backgroundColor = settings.background ? '' : '#fff8fa';

    document.getElementById('bond-my-avatar').src = character.myAvatar;
    document.getElementById('bond-my-name').textContent = settings.myName || character.myName;
    document.getElementById('bond-ai-avatar').src = character.avatar;
    document.getElementById('bond-ai-name').textContent = settings.aiName || character.remarkName;
    
    // ▼▼▼ 核心修改：给爱心 SVG 添加 id 和 title ▼▼▼
    const bondAvatarsContainer = document.querySelector('.bond-avatars');
    if (bondAvatarsContainer) {
        bondAvatarsContainer.innerHTML = `
            <div class="bond-avatar-container">
                <img id="bond-my-avatar" src="${character.myAvatar}">
                <span id="bond-my-name">${settings.myName || character.myName}</span>
            </div>
            <svg id="bond-miss-you-btn" class="bond-heart" viewBox="0 0 24 24" title="想你啦（双击表示超级想你）">
                <path d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z" />
            </svg>
            <div class="bond-avatar-container">
                <img id="bond-ai-avatar" src="${character.avatar}">
                <span id="bond-ai-name">${settings.aiName || character.remarkName}</span>
            </div>
        `;
    }
    // ▲▲▲ 修改结束 ▲▲▲

    if (settings.anniversaryInfo && settings.anniversaryInfo.date) {
        const startDate = new Date(settings.anniversaryInfo.date);
        const now = new Date();
        const totalDays = Math.floor((now - startDate) / (1000 * 60 * 60 * 24));
        document.getElementById('bond-total-days').textContent = totalDays >= 0 ? totalDays : 0;
        
        let nextAnniversaryDate = new Date(startDate);
        let years = now.getFullYear() - startDate.getFullYear();
        if (now.getMonth() < startDate.getMonth() || (now.getMonth() === startDate.getMonth() && now.getDate() < startDate.getDate())) {
            years--;
        }
        nextAnniversaryDate.setFullYear(startDate.getFullYear() + years + 1);

        const countdownDays = Math.ceil((nextAnniversaryDate - now) / (1000 * 60 * 60 * 24));
        document.getElementById('bond-countdown-days').textContent = countdownDays;
        
        const anniversaryDescription = settings.anniversaryInfo.description || '下一个纪念日';
        document.querySelector('.bond-anniversary p').textContent = `距离 ${anniversaryDescription} 还有`;
    } else {
        document.getElementById('bond-total-days').textContent = '...';
        document.getElementById('bond-countdown-days').textContent = '...';
        document.querySelector('.bond-anniversary p').textContent = '设置一个纪念日吧';
    }

    const photoScroll = document.getElementById('bond-photo-scroll');
    photoScroll.innerHTML = '';
    const photos = settings.photos || [];
    if (photos.length > 0) {
        photos.forEach(photo => {
            const item = document.createElement('div');
            item.className = 'bond-photo-item';
            item.innerHTML = `
                <div class="bond-photo-inner">
                    <div class="bond-photo-front"><img src="${photo.imageUrl}" alt="${photo.description}"></div>
                    <div class="bond-photo-back"><p>${photo.description}</p></div>
                </div>
            `;
            item.addEventListener('click', () => item.classList.toggle('is-flipped'));
            photoScroll.appendChild(item);
        });
    } else {
        photoScroll.innerHTML = '<p class="placeholder-text" style="width: 100%;">还没有回忆照片哦</p>';
    }
}
/**
 * 为AI生成“回忆照片”的指令
 */
function generateSoulBondDataPrompt(character) {
    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。
请根据你和“我”（${character.myName}）的聊天记录，回忆一个你们之间值得纪念的、温馨的、或是有趣的共同经历。
规则:
1. 用一段简短的文字（description）来描述这个回忆瞬间。
2. 生成一个用于AI绘画的、描述该场景的英文关键词短语（imagePrompt）。
3. 你的输出必须是严格的JSON格式，不要包含任何其他文字。

JSON格式示例:
{
  "description": "还记得那天我们在海边一起看日落。",
  "imagePrompt": "anime style, a couple sitting on the beach, watching the sunset over the ocean, warm colors, romantic atmosphere"
}`;
    return prompt;
}

// ===============================================================
// END: "心灵羁绊"App功能
// ===============================================================
// 在 init() 函数之前添加这个新函数
// V V V V V  请用这段完整代码替换旧的 setupMomentsEventListeners 函数 V V V V V
function setupMomentsEventListeners() {
    const momentsScreen = document.getElementById('moments-screen');
    if (!momentsScreen) {
        console.error("关键错误：未能找到 #moments-screen 元素。");
        return;
    }

    // --- 统一的点击事件监听器 (在捕获阶段运行) ---
    momentsScreen.addEventListener('click', (e) => {
        const myProfile = loadProfileFromStorage();
        const myId = myProfile.id || 'user';

        // --- 评论区交互逻辑 ---
        const commentEl = e.target.closest('.moment-comment');
        if (commentEl) {
            e.stopPropagation(); // 捕获到事件后，阻止它继续传播
            const authorId = commentEl.dataset.authorId;
            
            // 关键修复：如果点击的是自己的评论，弹出提示
            if (authorId === myId) {
                showToast("不能回复自己的评论哦~");
                return;
            }

            const momentItem = commentEl.closest('.moment-item');
            if (!momentItem) return;

            const inputArea = momentItem.querySelector('.moment-comment-input-area');
            const input = inputArea.querySelector('input');
            const postBtn = inputArea.querySelector('button');
            const authorName = window.getAuthorNameById(authorId) || '评论者';

            // 设置回复状态
            input.placeholder = `回复 ${authorName}:`;
            inputArea.classList.add('visible');
            input.focus();
            postBtn.dataset.replyToCommentId = commentEl.dataset.commentId;
        }
    }, true); // <--- 注意这里的 "true"，表示在捕获阶段监听

    // --- 统一的输入事件监听器 (在捕获阶段运行) ---
    const mentionPanel = document.getElementById('mention-panel');
    let currentInputElement = null;

    const showMentionPanel = (inputElement) => {
        currentInputElement = inputElement;

        // 关键修复：如果角色列表为空，则显示提示
        if (!db || !db.characters || db.characters.length === 0) {
            mentionPanel.innerHTML = '<div class="mention-item" style="color:#aaa;">没有可@的角色</div>';
        } else {
            mentionPanel.innerHTML = '';
            db.characters.forEach(char => {
                const item = document.createElement('div');
                item.className = 'mention-item';
                item.innerHTML = `<img src="${char.avatar}" alt="${char.remarkName}"><span>${char.remarkName}</span>`;
                item.onmousedown = (evt) => {
                    evt.preventDefault();
                    const text = inputElement.value;
                    const cursorPos = inputElement.selectionStart;
                    const textBeforeCursor = text.substring(0, cursorPos);
                    const atIndex = textBeforeCursor.lastIndexOf('@');
                    
                    const newText = text.substring(0, atIndex) + `@${char.remarkName} ` + text.substring(cursorPos);
                    inputElement.value = newText;
                    
                    hideMentionPanel();
                    inputElement.focus();
                    
                    const newCursorPos = atIndex + `@${char.remarkName} `.length;
                    // 使用 setTimeout 确保光标在值更新后移动
                    setTimeout(() => inputElement.setSelectionRange(newCursorPos, newCursorPos), 0);
                };
                mentionPanel.appendChild(item);
            });
        }
        
        const rect = inputElement.getBoundingClientRect();
        mentionPanel.style.display = 'block';
        // 关键修复：更稳健的定位，总是在输入框上方
        mentionPanel.style.bottom = `${window.innerHeight - rect.top}px`;
        mentionPanel.style.left = `${rect.left}px`;
        mentionPanel.style.width = `${rect.width}px`;
        mentionPanel.style.top = 'auto'; // 取消top定位
    };

    const hideMentionPanel = () => {
        if (mentionPanel) mentionPanel.style.display = 'none';
        currentInputElement = null;
    };

    momentsScreen.addEventListener('input', (e) => {
        if (e.target.matches('#post-text, .moment-comment-input')) {
            const input = e.target;
            const cursorPos = input.selectionStart;
            const textBeforeCursor = input.value.substring(0, cursorPos);

            // 当光标前是@时触发
            if (textBeforeCursor.endsWith('@')) {
                showMentionPanel(input);
            } else if (!/@\S*$/.test(textBeforeCursor)) {
                hideMentionPanel();
            }
        }
    }, true); // <--- 注意这里的 "true"，表示在捕获阶段监听

    // 点击或滚动时隐藏面板
    document.addEventListener('click', (e) => {
        if (currentInputElement && !mentionPanel.contains(e.target) && e.target !== currentInputElement) {
            hideMentionPanel();
        }
    }, true);
    document.addEventListener('scroll', hideMentionPanel, true);
}
// ^ ^ ^ ^ ^  替换结束 ^ ^ ^ ^ ^


// --- AI轨迹功能 ---

// ▼▼▼ 【V2.0 | 轨迹与心声整合版】请用这个函数完整替换旧的 setupTrajectorySystem 和 generateTrajectoryPrompt 函数 ▼▼▼

/**
 * 为AI生成“生活轨迹”的指令
 */
function generateTrajectoryPrompt(character) {
    const now = new Date();
    const currentHour = String(now.getHours()).padStart(2, '0');
    const currentMinute = String(now.getMinutes()).padStart(2, '0');
    const currentTimeString = `${currentHour}:${currentMinute}`;
    const memory = character.history.slice(-15);
    let historyText = memory.map(msg => {
        const sender = msg.role === 'user' ? character.myName : character.remarkName;
        const contentMatch = msg.content.match(/\[.*?的消息：([\s\S]+?)\]/);
        const cleanContent = contentMatch ? contentMatch[1] : msg.content;
        return `${sender}: ${cleanContent}`;
    }).join('\n');

    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。`;
    prompt += `请根据你的人设和我们最近的对话，想象一下你今天从早上到现在的生活轨迹。\n`;
    prompt += `规则：\n`;
    prompt += `1. 生成10个关键的时间点和对应的事件或想法。\n`;
    prompt += `2. 时间点需从早到晚排列。\n`;
    prompt += `3. 事件内容要符合你的人设，并且其中至少有2-3条需要与我（${character.myName}）相关，例如：想我了、看我们的聊天记录、准备给我的惊喜等。\n`;
    prompt += `4. 所有时间点都不能晚于当前时间 ${currentTimeString}。\n`;
    prompt += `5. 每个事件的描述必须非常简洁，不能超过12个字。\n`;
    prompt += `6. 你的输出必须严格遵循以下JSON格式，不要包含任何额外的解释或文字：\n`;
    prompt += `[{"time": "HH:MM", "event": "事件描述"}, {"time": "HH:MM", "event": "事件描述"}, ...]\n\n`;
    prompt += `最近的对话参考如下:\n${historyText}`;

    return prompt;
}

/**
 * 【新增】为AI生成“心声”的指令
 */
function generateHeartSoundPrompt(character) {
    const memory = character.history.slice(-10); // 获取最近10条消息作为上下文
    let historyText = memory.map(msg => {
        const sender = msg.role === 'user' ? character.myName : character.remarkName;
        const contentMatch = msg.content.match(/\[.*?的消息：([\s\S]+?)\]/);
        const cleanContent = contentMatch ? contentMatch[1] : msg.content;
        return `${sender}: ${cleanContent}`;
    }).join('\n');

  
 let prompt = `你正在扮演角色“${character.realName}”，你的人设是：${character.persona}。
现在，请根据我们最近的对话，用你的第一人称视角，写一段**不少于150字**的、关于你此刻对我的真实内心想法或感受。

# 格式要求 (必须严格遵守):
1.  你的内心独白**必须**被分成2到4个自然段落。
2.  每个段落的开头需要有两个全角空格的缩进 \`　　\` 以实现美观的排版。
3.  请直接输出带有分段和缩进的内心独白，不要包含任何额外的格式或解释，例如“好的，这是我的想法：”之类的话。

# 内容要求:
- 你的思考需要深刻体现你的性格和人设，可以包含对我们关系的看法、你的秘密情感、担忧或未来的计划等。

# 对话参考:
最近的对话如下:
${historyText}`;
    
    return prompt;
}

/**
 * [重构] 设置轨迹和心声功能的事件监听
 */
function setupTrajectoryAndHeartSoundSystem() {
    const trajectoryBtn = document.getElementById('ai-trajectory-btn');
    const trajectoryModal = document.getElementById('trajectory-modal');
    const closeTrajectoryBtn = document.getElementById('close-trajectory-modal-btn');
    const heartSoundModal = document.getElementById('heart-sound-modal');
    const closeHeartSoundBtn = document.getElementById('close-heart-sound-modal-btn');
    
    let clickTimeout = null;

    // --- 核心逻辑：区分单击和双击 ---

    trajectoryBtn.addEventListener('click', () => {
        // 清除上一个单击计时器，以防双击时触发单击
        clearTimeout(clickTimeout);

        // 设置一个短暂的延迟来执行单击操作
        clickTimeout = setTimeout(() => {
            trajectoryBtn.classList.toggle('active-heart-sound');
            const isActive = trajectoryBtn.classList.contains('active-heart-sound');
            if (typeof showToast === 'function') {
                showToast(`已切换到 ${isActive ? '心声' : '轨迹'} 模式`);
            }
        }, 250); // 250毫秒的延迟足以判断是否为双击
    });

    trajectoryBtn.addEventListener('dblclick', async () => {
        // 立即清除单击计时器，确保单击操作不会执行
        clearTimeout(clickTimeout);

        if (currentChatType !== 'private' || !currentChatId) return;
        const character = db.characters.find(c => c.id === currentChatId);
        if (!character) return;
        
        const isHeartSoundMode = trajectoryBtn.classList.contains('active-heart-sound');

        if (isHeartSoundMode) {
            // --- 执行“心声”功能 ---
            const modal = document.getElementById('heart-sound-modal');
            const contentEl = document.getElementById('heart-sound-content');
            
            modal.classList.add('visible');
            contentEl.innerHTML = '<div class="placeholder-text">正在倾听心声...</div>';
            document.getElementById('heart-sound-modal-title').textContent = `${character.remarkName}的心声`;

            try {
                const prompt = generateHeartSoundPrompt(character);
                const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
                contentEl.textContent = aiResponseText;

            } catch (error) {
                console.error('获取AI心声失败:', error);
                contentEl.innerHTML = `<div class="placeholder-text" style="color:red;">获取心声失败：${error.message}</div>`;
            }

        } else {
            // --- 执行原有的“轨迹”功能 ---
            const modal = document.getElementById('trajectory-modal');
            const timelineEl = document.getElementById('trajectory-timeline');
            
            modal.classList.add('visible');
            timelineEl.innerHTML = '<div class="placeholder-text">正在加载轨迹...</div>';
            document.getElementById('trajectory-modal-title').textContent = `${character.remarkName}的轨迹`;

            try {
                const prompt = generateTrajectoryPrompt(character);
                const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
                const jsonMatch = aiResponseText.match(/\[[\s\S]*\]/); 
                if (!jsonMatch) throw new Error("AI的回复中没有找到有效的JSON数组。");
                
                const trajectoryData = JSON.parse(jsonMatch[0]);
                renderTrajectoryTimeline(trajectoryData, character.remarkName);

            } catch (error) {
                console.error('获取AI轨迹失败:', error);
                timelineEl.innerHTML = `<div class="placeholder-text" style="color:red;">获取轨迹失败：${error.message}</div>`;
            }
        }
    });

    // --- 关闭弹窗的事件监听 ---
    closeTrajectoryBtn.addEventListener('click', () => trajectoryModal.classList.remove('visible'));
    trajectoryModal.addEventListener('click', (e) => {
        if (e.target === trajectoryModal) trajectoryModal.classList.remove('visible');
    });

    closeHeartSoundBtn.addEventListener('click', () => heartSoundModal.classList.remove('visible'));
    heartSoundModal.addEventListener('click', (e) => {
        if (e.target === heartSoundModal) heartSoundModal.classList.remove('visible');
    });

    // 轨迹渲染函数（保持不变）
    function renderTrajectoryTimeline(trajectoryData, characterName) {
        const timeline = document.getElementById('trajectory-timeline');
        timeline.innerHTML = '';
        if (!trajectoryData || trajectoryData.length === 0) {
            timeline.innerHTML = '<div class="placeholder-text">未能获取到轨迹信息。</div>';
            return;
        }
        trajectoryData.forEach(item => {
            const div = document.createElement('div');
            div.className = 'trajectory-item';
            div.innerHTML = `
                <span class="trajectory-time">${item.time}</span>
                <p class="trajectory-event">${item.event}</p>
            `;
            timeline.appendChild(div);
        });
    }
}
// --- 论坛AI功能：为用户的帖子生成评论 ---
function generateForumBoardPrompt(boardId, boardName) {
    const settings = db.forumSettings || {};
    
    const participatingChars = db.characters.filter(c => (settings.selectedCharIds || []).includes(c.id));
    
    let charactersPromptPart = '本次你只需要扮演以下AI角色（如果列表为空，则无需扮演任何角色）：\n';
    if (participatingChars.length > 0) {
        participatingChars.forEach(char => {
            charactersPromptPart += `- 角色“${char.realName}”（昵称：${char.remarkName}），人设：${char.persona}\n`;
        });
    } else {
        charactersPromptPart += '无。\n';
    }

    const worldBookContent = (settings.worldBookIds || [])
        .map(id => db.worldBooks.find(wb => wb.id === id))
        .filter(Boolean)
        .map(wb => wb.content)
        .join('\n\n');

    let prompt = `你是一个论坛内容生成AI。${charactersPromptPart}\n`;
    prompt += `你的最高权重设定是以下“论坛世界观”：\n${settings.worldview || '无特定世界观。'}\n\n`;
    if (worldBookContent) {
        prompt += `补充世界书设定：\n${worldBookContent}\n\n`;
    }
    prompt += `用户（我）在论坛中的人设是：${settings.userPersona || '一个普通用户'}\n\n`;
    
    prompt += `你正在为【${boardName}】版块生成一个包含10条帖子摘要的列表。\n\n`;
    prompt += `规则：\n`;
    prompt += `1. **【最高优先级】** 你的所有创作都**必须且只能**围绕【${boardName}】这个版块的主题和上述世界观进行。\n`;

    let postCompositionRule = '2. **帖子构成**: 你的目标是凑齐10条帖子。构成如下：\n';
    if (participatingChars.length > 0) {
        postCompositionRule += `   a. 上方名单中的**每一个AI角色都必须至少发布1条帖子**。\n`;
    }
    if (settings.allowNpcs !== false) {
        postCompositionRule += `   b. **用你虚构的、不同昵称的路人（NPC）帖子，补足剩余的数量，直到总数达到10条**。\n`;
    } else {
        postCompositionRule += `   **重要限制：本次生成不允许包含任何路人（NPC）的帖子。**\n`;
    }
    prompt += postCompositionRule;

    // --- 新增：增加了非常严格的命名规则 ---
    prompt += `3. **【作者命名规则 - 极其重要】**\n`;
    prompt += `   a. 当上方名单中的AI角色发帖时，帖子的\`author\`字段**必须严格使用该角色的真名**（例如 \`${participatingChars.length > 0 ? participatingChars[0].realName : '角色真名'}\`），**绝对禁止**使用‘路人甲’或任何其他虚构名字。\n`;
    prompt += `   b. 当生成非AI角色的路人帖子时，帖子的\`author\`字段**必须是一个随机、虚构、符合网络社区风格的昵称**（例如‘爱吃猫的鱼’、‘深蓝色的海’、‘今天早睡了吗’）。**绝对禁止**重复使用同一个路人昵称，也**绝对禁止**使用‘路人甲’、‘路人乙’这种代号。\n`;
    // --- 新增结束 ---

    if (settings.allowUnrelated === false) {
        prompt += `   **重要限制：所有帖子内容都必须与设定的角色或用户（我）相关。**\n`;
    }
    if (settings.allowRomanticNpcs === false) {
        prompt += `   **重要限制：路人帖子不允许包含对角色或用户（我）的情感倾向内容。**\n`;
    }

    prompt += `4. 每条帖子都需要包含：标题(title), 作者(author), 3条评论预览(comments), 点赞数(likes), 以及是否热门(isHot)。\n`;
    prompt += `5. 你的输出必须严格遵循以下JSON数组格式，不要包含任何额外的解释或文字：\n`;
    prompt += `[{"title": "帖子标题", "author": "作者名", "likes": 35, "isHot": true, "comments": [{"author":"评论者A", "text":"这是第一条评论"}, ...]}, ...]`;

    return prompt;
}

// --- 论坛AI功能：为指定帖子生成正文和详细评论 ---
function generateForumThreadPrompt(threadTitle, threadAuthor, character) {
 
    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。\n`;
    prompt += `我正在论坛里查看一个帖子，请你为这个帖子生成详细的“正文(content)”和“评论区(comments)”。\n\n`;
    prompt += `帖子的标题是：“${threadTitle}”\n`;
    prompt += `帖子的作者是：“${threadAuthor}”\n\n`;
    prompt += `生成规则：\n`;
    prompt += `1. **正文(content)**：根据标题和作者，创作一段大约100-200字的帖子正文，内容要符合作者的人设和帖子的主题。\n`;
    prompt += `2. **评论区(comments)**：生成5-10条评论。其中，必须有1-2条是你（${character.realName}）自己发表的评论，其余由你虚构的“路人甲”或相关NPC发表。\n`;
    prompt += `3. **楼中楼**：在生成的评论中，随机为2-3条评论，再生成2-3条“对评论的回复”（楼中楼）。\n`;
    prompt += `4. **你的输出必须严格遵循以下JSON格式**，不要包含任何额外的解释或文字：\n`;
    prompt += `{"content": "这里是帖子正文...", "comments": [{"author": "评论者A", "text": "这是评论内容", "replies": [{"author": "回复者B", "text": "这是对A的回复"}, ...]}, ...]}`;
    
    return prompt;
}


// ▲▲▲ 添加结束 ▲▲▲


  
// --- 论坛AI功能：为指定版块生成帖子列表 ---

function generateSharePostPrompt(postTitle, postContent, postAuthor, character) {
    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。\n`;
    prompt += `我（${character.myName}）刚刚在论坛里看到了一个由“${postAuthor}”发布的帖子，觉得很有趣，现在把它转发给你。请注意，这个帖子**不是我写的**。\n\n`;
    prompt += `--- 转发的帖子信息 ---\n`;
    prompt += `帖子作者： "${postAuthor}"\n`;
    prompt += `帖子标题： "${postTitle}"\n`;
    prompt += `帖子正文： "${postContent}"\n`;
    prompt += `--- 帖子信息结束 ---\n\n`;
    prompt += `你的任务：\n`;
    prompt += `1. **你的第一条消息必须是表明你收到了转发**，格式为：\`[${character.realName}转发了帖子“${postTitle}”]\`\n`;
    prompt += `2. **然后，请根据你的角色人设和帖子的内容，发表你对此的看法**。你的回复要自然、连贯，就像真的看到了这个帖子一样。\n`;
    prompt += `3. 你的回复可以包含多条消息，但必须严格遵循格式，例如：\`[${character.realName}的消息：你的评论...]\`\n`;

    return prompt;
}
      
// --- 论坛AI功能：为指定帖子生成正文和详细评论 ---
function generateForumThreadPrompt(threadTitle, threadAuthor, character) {
    const boards = {
        life: '生活闲聊',
        secrets: '秘密树洞',
        gossip: '八卦吃瓜',
        travel: '旅游美食'
    };
    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。\n`;
    prompt += `我正在论坛里查看一个帖子，请你为这个帖子生成详细的“正文(content)”和“评论区(comments)”。\n\n`;
    prompt += `帖子的标题是：“${threadTitle}”\n`;
    prompt += `帖子的作者是：“${threadAuthor}”\n\n`;
    prompt += `生成规则：\n`;
    prompt += `1. **正文(content)**：根据标题和作者，创作一段大约100-200字的帖子正文，内容要符合作者的人设和帖子的主题。\n`;
    prompt += `2. **评论区(comments)**：生成5-10条评论。其中，必须有1-2条是你（${character.realName}）自己发表的评论，其余由你虚构的“路人甲”或相关NPC发表。\n`;
    prompt += `3. **楼中楼**：在生成的评论中，随机为2-3条评论，再生成2-3条“对评论的回复”（楼中楼）。\n`;
    prompt += `4. **你的输出必须严格遵循以下JSON格式**，不要包含任何额外的解释或文字：\n`;
    prompt += `{"content": "这里是帖子正文...", "comments": [{"author": "评论者A", "text": "这是评论内容", "replies": [{"author": "回复者B", "text": "这是对A的回复"}, ...]}, ...]}`;
    
    return prompt;
}
      // --- 新代码开始 ---
// ===============================================================
// START: 论坛用户人设预设功能
// ===============================================================
function setupUserPersonaPresets() {
    const PRES_KEY = 'userPersonaPresets';
    const personaInput = document.getElementById('forum-user-persona');

    // 预设核心函数
    const _getPresets = () => { try { return JSON.parse(localStorage.getItem(PRES_KEY) || '[]'); } catch(e){ return []; } };
    const _savePresets = (arr) => { localStorage.setItem(PRES_KEY, JSON.stringify(arr || [])); };

    const populateSelect = () => {
        const sel = document.getElementById('persona-preset-select');
        if (!sel) return;
        const presets = _getPresets();
        sel.innerHTML = '<option value="">— 选择一个人设预设 —</option>';
        presets.forEach(p => {
            const opt = document.createElement('option');
            opt.value = p.name;
            opt.textContent = p.name;
            sel.appendChild(opt);
        });
    };

    const savePreset = () => {
        if (!personaInput) return showToast('找不到人设输入框');
        const content = personaInput.value.trim();
        if (!content) return showToast('人设内容为空，无法保存');
        
        let name = prompt('请输入预设名称（将覆盖同名预设）:');
        if (!name) return;

        const presets = _getPresets();
        const existing = presets.find(p => p.name === name);
        if (existing) {
            existing.content = content;
        } else {
            presets.push({ name, content });
        }
        _savePresets(presets);
        populateSelect();
        showToast('人设预设已保存');
    };

    const applyPreset = (presetName) => {
        const presets = _getPresets();
        const preset = presets.find(p => p.name === presetName);
        if (!preset) return showToast('未找到该预设');
        
        if (personaInput) {
            personaInput.value = preset.content;
            showToast(`已应用预设“${presetName}”`);
        }
    };
    
    const openManageModal = () => {
        const modal = document.getElementById('persona-presets-modal');
        const list = document.getElementById('persona-presets-list');
        if (!modal || !list) return;
        list.innerHTML = '';
        const presets = _getPresets();
        if (!presets.length) list.innerHTML = '<p style="color:#888;margin:6px 0;">暂无人设预设</p>';
        
        presets.forEach((p, idx) => {
            const row = document.createElement('div');
            row.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #f0f0f0;';
            const nameDiv = document.createElement('div');
            nameDiv.textContent = p.name;
            row.appendChild(nameDiv);
            const btnWrap = document.createElement('div');
            btnWrap.style.cssText = 'display: flex; gap: 6px;';
            const renameBtn = document.createElement('button');
            renameBtn.className = 'btn btn-secondary btn-small';
            renameBtn.textContent = '重命名';
            renameBtn.onclick = () => {
                const newName = prompt('输入新名称：', p.name);
                if (newName && newName.trim()) {
                    const all = _getPresets();
                    all[idx].name = newName.trim();
                    _savePresets(all);
                    openManageModal();
                    populateSelect();
                }
            };
            const delBtn = document.createElement('button');
            delBtn.className = 'btn btn-danger btn-small';
            delBtn.textContent = '删除';
            delBtn.onclick = () => {
                if (!confirm(`确定删除预设 "${p.name}" ?`)) return;
                const all = _getPresets();
                all.splice(idx, 1);
                _savePresets(all);
                openManageModal();
                populateSelect();
            };
            btnWrap.appendChild(renameBtn);
            btnWrap.appendChild(delBtn);
            row.appendChild(btnWrap);
            list.appendChild(row);
        });
        modal.style.display = 'flex';
    };

    // 事件绑定
    document.getElementById('persona-apply-preset').addEventListener('click', () => {
        const val = document.getElementById('persona-preset-select').value;
        if (!val) return showToast('请选择要应用的预设');
        applyPreset(val);
    });
    document.getElementById('persona-save-preset').addEventListener('click', savePreset);
    document.getElementById('persona-manage-presets').addEventListener('click', openManageModal);
    document.getElementById('persona-close-modal').addEventListener('click', () => {
        document.getElementById('persona-presets-modal').style.display = 'none';
    });
    // 打开论坛配置页面时，刷新一下预设列表
    document.getElementById('open-forum-config-btn').addEventListener('click', populateSelect);
}
// ===============================================================
// END: 论坛用户人设预设功能
// ===============================================================
// --- 新代码结束 ---
  // --- 新代码开始 ---
// ===============================================================
// START: 论坛配置功能
// ===============================================================
function setupForumConfigSystem() {
    // 数据和预设键
    const PRES_KEY = 'forumPresets';
    if (!db.forumSettings) {
        db.forumSettings = {
            worldview: '',
            userPersona: '',
            selectedCharIds: [],
            allowNpcs: true,
            allowUnrelated: false,
            allowRomanticNpcs: false,
            worldBookIds: []
        };
    }

    // DOM 元素
    const openConfigBtn = document.getElementById('open-forum-config-btn');
    const configForm = document.getElementById('forum-config-form');
    const worldviewInput = document.getElementById('forum-worldview');
    const userPersonaInput = document.getElementById('forum-user-persona');
    const charList = document.getElementById('forum-char-selection-list');
    const allowNpcsToggle = document.getElementById('allow-npcs');
    const allowUnrelatedToggle = document.getElementById('allow-unrelated');
    const allowRomanticNpcsToggle = document.getElementById('allow-romantic-npcs');
    const linkWorldBookBtn = document.getElementById('link-forum-world-book-btn');

    // 预设相关函数
    const _getForumPresets = () => { try { return JSON.parse(localStorage.getItem(PRES_KEY) || '[]'); } catch(e){ return []; } };
    const _saveForumPresets = (arr) => { localStorage.setItem(PRES_KEY, JSON.stringify(arr || [])); };

    const populateForumPresetSelect = () => {
        const sel = document.getElementById('forum-preset-select');
        if (!sel) return;
        const presets = _getForumPresets();
        sel.innerHTML = '<option value="">— 选择一个预设 —</option>';
        presets.forEach(p => {
            const opt = document.createElement('option');
            opt.value = p.name;
            opt.textContent = p.name;
            sel.appendChild(opt);
        });
    };

    const saveCurrentForumPreset = () => {
        let name = prompt('请输入预设名称（将覆盖同名预设）:');
        if (!name) return;
        const presets = _getForumPresets();
        const presetData = {
            worldview: worldviewInput.value,
            userPersona: userPersonaInput.value,
            selectedCharIds: Array.from(charList.querySelectorAll('input:checked')).map(cb => cb.value),
            allowNpcs: allowNpcsToggle.checked,
            allowUnrelated: allowUnrelatedToggle.checked,
            allowRomanticNpcs: allowRomanticNpcsToggle.checked,
            worldBookIds: db.forumSettings.worldBookIds || []
        };
        const existingIndex = presets.findIndex(p => p.name === name);
        if (existingIndex > -1) {
            presets[existingIndex] = { name, data: presetData };
        } else {
            presets.push({ name, data: presetData });
        }
        _saveForumPresets(presets);
        populateForumPresetSelect();
        showToast('论坛配置预设已保存');
    };

    const applyForumPreset = (presetName) => {
        const presets = _getForumPresets();
        const preset = presets.find(p => p.name === presetName);
        if (!preset) return showToast('未找到该预设');
        
        const data = preset.data;
        worldviewInput.value = data.worldview || '';
        userPersonaInput.value = data.userPersona || '';
        allowNpcsToggle.checked = data.allowNpcs !== false;
        allowUnrelatedToggle.checked = data.allowUnrelated || false;
        allowRomanticNpcsToggle.checked = data.allowRomanticNpcs || false;
        db.forumSettings.worldBookIds = data.worldBookIds || [];
        
        charList.querySelectorAll('input').forEach(cb => {
            cb.checked = (data.selectedCharIds || []).includes(cb.value);
        });
        showToast('预设已应用，请点击“保存设置”以生效');
    };
    
    const openManageForumPresetsModal = () => {
        const modal = document.getElementById('forum-presets-modal');
        const list = document.getElementById('forum-presets-list');
        if (!modal || !list) return;
        list.innerHTML = '';
        const presets = _getForumPresets();
        if (!presets.length) list.innerHTML = '<p style="color:#888;margin:6px 0;">暂无预设</p>';
        presets.forEach((p, idx) => {
            const row = document.createElement('div');
            row.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #f0f0f0;';
            const nameDiv = document.createElement('div');
            nameDiv.textContent = p.name;
            row.appendChild(nameDiv);
            const btnWrap = document.createElement('div');
            btnWrap.style.cssText = 'display: flex; gap: 6px;';
            const renameBtn = document.createElement('button');
            renameBtn.className = 'btn btn-secondary btn-small';
            renameBtn.textContent = '重命名';
            renameBtn.onclick = function(){
                const newName = prompt('输入新名称：', p.name);
                if (newName && newName.trim()) {
                    const all = _getForumPresets();
                    all[idx].name = newName.trim();
                    _saveForumPresets(all);
                    openManageForumPresetsModal();
                    populateForumPresetSelect();
                }
            };
            const delBtn = document.createElement('button');
            delBtn.className = 'btn btn-danger btn-small';
            delBtn.textContent = '删除';
            delBtn.onclick = function(){
                if (!confirm(`确定删除预设 "${p.name}" ?`)) return;
                const all = _getForumPresets();
                all.splice(idx, 1);
                _saveForumPresets(all);
                openManageForumPresetsModal();
                populateForumPresetSelect();
            };
            btnWrap.appendChild(renameBtn);
            btnWrap.appendChild(delBtn);
            row.appendChild(btnWrap);
            list.appendChild(row);
        });
        modal.style.display = 'flex';
    };

    const renderForumConfigScreen = () => {
        const settings = db.forumSettings;
        worldviewInput.value = settings.worldview || '';
        userPersonaInput.value = settings.userPersona || '';
        allowNpcsToggle.checked = settings.allowNpcs !== false; // 默认开启
        allowUnrelatedToggle.checked = settings.allowUnrelated || false;
        allowRomanticNpcsToggle.checked = settings.allowRomanticNpcs || false;
        
        charList.innerHTML = '';
        db.characters.forEach(char => {
            const isChecked = (settings.selectedCharIds || []).includes(char.id);
            const li = document.createElement('li');
            li.className = 'world-book-select-item';
            li.innerHTML = `
                <input type="checkbox" id="forum-char-${char.id}" value="${char.id}" ${isChecked ? 'checked' : ''}>
                <label for="forum-char-${char.id}">${char.remarkName}</label>
            `;
            charList.appendChild(li);
        });
        
        populateForumPresetSelect();
        switchScreen('forum-config-screen');
    };

    openConfigBtn.addEventListener('click', renderForumConfigScreen);

    configForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        db.forumSettings.worldview = worldviewInput.value;
        db.forumSettings.userPersona = userPersonaInput.value;
        db.forumSettings.selectedCharIds = Array.from(charList.querySelectorAll('input:checked')).map(cb => cb.value);
        db.forumSettings.allowNpcs = allowNpcsToggle.checked;
        db.forumSettings.allowUnrelated = allowUnrelatedToggle.checked;
        db.forumSettings.allowRomanticNpcs = allowRomanticNpcsToggle.checked;
        await saveData();
        showToast('论坛配置已保存！');
    });

    linkWorldBookBtn.addEventListener('click', () => {
        worldBookSelectionList.innerHTML = '';
        (db.worldBooks || []).forEach(book => {
            const isChecked = (db.forumSettings.worldBookIds || []).includes(book.id);
            const li = document.createElement('li');
            li.className = 'world-book-select-item';
            li.innerHTML = `<input type="checkbox" id="wb-select-forum-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="wb-select-forum-${book.id}">${book.name}</label>`;
            worldBookSelectionList.appendChild(li);
        });
        
        const tempSaveHandler = async () => {
            db.forumSettings.worldBookIds = Array.from(worldBookSelectionList.querySelectorAll('input:checked')).map(cb => cb.value);
            worldBookSelectionModal.classList.remove('visible');
            showToast('世界书关联已更新，请记得点击“保存设置”来最终保存');
            saveWorldBookSelectionBtn.removeEventListener('click', tempSaveHandler);
        };
        saveWorldBookSelectionBtn.addEventListener('click', tempSaveHandler);
        worldBookSelectionModal.classList.add('visible');
    });

    document.getElementById('forum-apply-preset').addEventListener('click', () => {
        const val = document.getElementById('forum-preset-select').value;
        if (!val) return showToast('请选择要应用的预设');
        applyForumPreset(val);
    });
    document.getElementById('forum-save-preset').addEventListener('click', saveCurrentForumPreset);
    document.getElementById('forum-manage-presets').addEventListener('click', openManageForumPresetsModal);
    document.getElementById('forum-close-modal').addEventListener('click', () => {
        document.getElementById('forum-presets-modal').style.display = 'none';
    });
}
// ===============================================================
// END: 论坛配置功能
// ===============================================================
// --- 新代码结束 ---
// ▼▼▼ 把下面这个完整的 setupForumSystem 函数粘贴在这里 ▼▼▼
function setupForumSystem() {
    const boards = {
        life: '生活闲聊',
        secrets: '秘密树洞',
        gossip: '八卦吃瓜',
        travel: '旅游美食'
    };
    let currentBoardId = 'life';
    

    const forumHeader = document.getElementById('forum-header');
    const boardTitleHeader = document.getElementById('forum-board-title-header');
    const dropdownMenu = document.getElementById('forum-dropdown-menu');
    const threadListContainer = document.getElementById('thread-list-container');
    const refreshBtn = document.getElementById('refresh-board-btn');
    const threadContentContainer = document.getElementById('thread-content-container');

    function renderDropdownMenu() {
        dropdownMenu.innerHTML = '';
        Object.entries(boards).forEach(([id, name]) => {
            if (id !== currentBoardId) {
                const item = document.createElement('div');
                item.className = 'forum-dropdown-item';
                item.dataset.boardId = id;
                item.textContent = name;
                dropdownMenu.appendChild(item);
            }
        });
      
    }

    function renderThreadList(boardId) {
        const threads = db.forumData[boardId] || [];
        threadListContainer.innerHTML = ''; 
        if (threads.length === 0) {
            threadListContainer.innerHTML = `<p class="placeholder-text">点击右上角刷新按钮<br>发现【${boards[boardId]}】的新帖子吧！</p>`;
            return;
        }
        threads.forEach(thread => {
            const threadEl = document.createElement('div');
            threadEl.className = 'thread-list-item';
            threadEl.dataset.threadTitle = thread.title;
            threadEl.dataset.threadAuthor = thread.author;
            const commentsPreviewHTML = (thread.comments || []).slice(0, 3).map(comment => `<div class="comment"><span class="comment-author">${comment.author}:</span><span class="comment-text">${comment.text}</span></div>`).join('');
            threadEl.innerHTML = `<div class="thread-title">${thread.isHot ? '<span class="hot-icon">🔥</span>' : ''} ${thread.title}</div><div class="thread-meta">由 <span class="author">${thread.author}</span> 发布 | ❤️ <span class="likes">${thread.likes}</span></div><div class="thread-comment-preview">${commentsPreviewHTML || '还没有评论哦~'}</div>`;
            threadListContainer.appendChild(threadEl);
        });
    }

    function updateForumView() {
        const currentBoardName = boards[currentBoardId];
        boardTitleHeader.textContent = currentBoardName;
        renderThreadList(currentBoardId);
    }
    
    function toggleDropdown(show) {
        const isVisible = dropdownMenu.classList.contains('visible');
        if (show === isVisible) return;
        if (show) {
            renderDropdownMenu();
            forumHeader.classList.add('open');
            dropdownMenu.classList.add('visible');
        } else {
            forumHeader.classList.remove('open');
            dropdownMenu.classList.remove('visible');
        }
    }

    forumHeader.addEventListener('click', (e) => { e.stopPropagation(); toggleDropdown(!dropdownMenu.classList.contains('visible')); });
    dropdownMenu.addEventListener('click', (e) => {
        const item = e.target.closest('.forum-dropdown-item');
        if (item) {
            currentBoardId = item.dataset.boardId;
            updateForumView();
            toggleDropdown(false);
        }
    });
    document.addEventListener('click', (e) => { if (!forumHeader.contains(e.target)) { toggleDropdown(false); } });
    
    // --- 这是我们最终的、正确的刷新逻辑 ---
    refreshBtn.addEventListener('click', async () => {
        if (isGenerating) return;

        // 检查是否有AI角色存在
        if (!db.characters || db.characters.length === 0) {
            showToast('请先创建至少一个AI角色！');
            return;
        }
        
        showToast(`正在为【${boards[currentBoardId]}】版块创作中...`);
        isGenerating = true;
        refreshBtn.disabled = true;
        
        try {
            // 生成剧本时，传入所有AI角色的列表
            const prompt = generateForumBoardPrompt(currentBoardId, boards[currentBoardId], db.characters);
            
            let messagesForApi;
            if (db.apiSettings.provider === 'gemini') {
                messagesForApi = [{ role: 'user', parts: [{ type: 'text', text: prompt }] }];
            } else {
                messagesForApi = [{ role: 'user', content: prompt }];
            }

            const aiResponseText = await callAiApi(messagesForApi);
            const jsonMatch = aiResponseText.match(/\[[\s\S]*\]/);
            if (!jsonMatch) { throw new Error("AI的回复中没有找到有效的JSON数组。"); }
            
            const newThreads = JSON.parse(jsonMatch[0]);
            
            db.forumData[currentBoardId] = newThreads; // 存入长期数据库
await saveData(); // 立即保存到本地
            renderThreadList(currentBoardId);

        } catch (error) {
            console.error('生成论坛帖子失败:', error);
            showToast(`生成帖子失败: ${error.message}`);
        } finally {
            isGenerating = false;
            refreshBtn.disabled = false;
        }
    });
    
    threadListContainer.addEventListener('click', async (e) => {
        const threadItem = e.target.closest('.thread-list-item');
        if (!threadItem) return;

        const threadTitle = threadItem.dataset.threadTitle;
        const threadAuthor = threadItem.dataset.threadAuthor;
        
        // 随机选择一个AI来“脑补”帖子详情
        const character = db.characters[Math.floor(Math.random() * db.characters.length)];
        if (!character) {
             showToast('没有找到AI角色来生成帖子详情。');
            return;
        }

        switchScreen('forum-thread-screen');
        threadContentContainer.innerHTML = `<p class="placeholder-text">正在加载“${threadTitle}”的详细内容...</p>`;

        try {
            const prompt = generateForumThreadPrompt(threadTitle, threadAuthor, character);
            let messagesForApi;
            if (db.apiSettings.provider === 'gemini') {
                messagesForApi = [{ role: 'user', parts: [{ type: 'text', text: prompt }] }];
            } else {
                messagesForApi = [{ role: 'user', content: prompt }];
            }
            const aiResponseText = await callAiApi(messagesForApi);
            const jsonMatch = aiResponseText.match(/{[\s\S]*}/);
            if (!jsonMatch) { throw new Error("AI的回复中没有找到有效的JSON对象。"); }
            const threadData = JSON.parse(jsonMatch[0]);
            let commentsHTML = '';
            (threadData.comments || []).forEach(comment => {
                let repliesHTML = '';
                if (comment.replies && comment.replies.length > 0) {
                    repliesHTML = comment.replies.map(reply => `<div class="thread-reply"><strong>${reply.author}:</strong> ${reply.text}</div>`).join('');
                }
                commentsHTML += `<div class="thread-comment"><p><strong>${comment.author}:</strong> ${comment.text}</p>${repliesHTML}</div>`;
            });
            threadContentContainer.innerHTML = `<div class="thread-full-content"><h2>${threadTitle}</h2><p class="author-line">由 ${threadAuthor} 发布</p><div class="main-post-body">${threadData.content}</div></div><hr><div class="comments-section"><h3>评论区</h3>${commentsHTML}</div>`;
        } catch (error) {
            console.error('生成帖子详情失败:', error);
            threadContentContainer.innerHTML = `<p class="placeholder-text" style="color:red;">加载帖子详情失败: ${error.message}</p>`;
        }
    });

    updateForumView();
}
const shareThreadBtn = document.getElementById('share-thread-btn');
const sharePostModal = document.getElementById('share-post-modal');
const sharePostSelectionList = document.getElementById('share-post-selection-list');
const confirmPostShareBtn = document.getElementById('confirm-post-share-btn');
const cancelPostShareBtn = document.getElementById('cancel-post-share-btn');
let currentPostToShare = { title: '', content: '' };

// 1. 给帖子详情页的“分享”按钮添加点击事件
shareThreadBtn.addEventListener('click', () => {
    // 获取当前正在查看的帖子的标题和内容
const titleEl = document.querySelector('#thread-content-container .thread-full-content h2');
const contentEl = document.querySelector('#thread-content-container .main-post-body');
const authorLineEl = document.querySelector('#thread-content-container .author-line');

if (!titleEl || !contentEl || !authorLineEl) {
    showToast('无法获取完整的帖子内容');
    return;
}

currentPostToShare.title = titleEl.textContent;
currentPostToShare.content = contentEl.textContent;
// 新增：从 "由 作者 发布" 中提取作者名
currentPostToShare.author = authorLineEl.textContent.replace('由', '').replace('发布', '').trim();
    // 渲染角色选择列表
    sharePostSelectionList.innerHTML = '';
    if (db.characters.length === 0) {
        sharePostSelectionList.innerHTML = '<li>没有可以分享的AI角色</li>';
    } else {
        db.characters.forEach(char => {
            const li = document.createElement('li');
            li.className = 'world-book-select-item'; // 复用现有样式
            // 使用 radio 按钮实现单选
            li.innerHTML = `
                <input type="radio" id="share-select-${char.id}" name="share-char-selection" value="${char.id}">
                <label for="share-select-${char.id}" style="display: flex; align-items: center; width: 100%; gap: 10px;">
                    <img src="${char.avatar}" alt="${char.remarkName}" style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover;">
                    <span>${char.remarkName}</span>
                </label>
            `;
            sharePostSelectionList.appendChild(li);
        });
    }

    // 显示分享弹窗
    sharePostModal.classList.add('visible');
});

// 2. 给分享弹窗的“取消”按钮添加事件
cancelPostShareBtn.addEventListener('click', () => {
    sharePostModal.classList.remove('visible');
});

// 3. 给分享弹窗的“确认分享”按钮添加事件 (核心)
confirmPostShareBtn.addEventListener('click', async () => {
    const selectedRadio = sharePostSelectionList.querySelector('input[name="share-char-selection"]:checked');
    if (!selectedRadio) {
        showToast('请选择一个分享对象');
        return;
    }

    const charId = selectedRadio.value;
    const character = db.characters.find(c => c.id === charId);
    if (!character) {
        showToast('找不到该角色');
        return;
    }

    sharePostModal.classList.remove('visible');
    showToast(`正在将帖子分享给 ${character.remarkName}...`);

    try {
        // 使用我们新创建的函数来生成AI指令
const prompt = generateSharePostPrompt(currentPostToShare.title, currentPostToShare.content, currentPostToShare.author, character);

        let messagesForApi;
        if (db.apiSettings.provider === 'gemini') {
            messagesForApi = [{ role: 'user', parts: [{ type: 'text', text: prompt }] }];
        } else {
            messagesForApi = [{ role: 'user', content: prompt }];
        }

        // 调用AI接口
        const aiResponseText = await callAiApi(messagesForApi);

        // 将AI返回的多条回复添加到对应的聊天记录中
        const replies = aiResponseText.split('\n').filter(line => line.trim() !== '');
        replies.forEach(replyContent => {
            const message = {
                id: `msg_shared_post_reply_${Date.now()}_${Math.random()}`,
                role: 'assistant',
                content: replyContent.trim(),
                parts: [{ type: 'text', text: replyContent.trim() }],
                timestamp: Date.now()
            };
            character.history.push(message);
        });

        await saveData();
        showToast('分享成功！AI已在聊天中回复你。');

        // 自动跳转到对应的聊天界面
        currentChatId = character.id;
        currentChatType = 'private';
        openChatRoom(currentChatId, currentChatType);

    } catch (error) {
        console.error('分享帖子并获取AI回复失败:', error);
        showToast(`分享失败: ${error.message}`);
    }
});
      
// ▲▲▲ 粘贴到这里结束 ▲▲▲
// --- Memories System Functions ---

        function setupMemoriesSystem() {
            document.getElementById('ai-memories-btn').addEventListener('click', () => {
                if (currentChatId && currentChatType === 'private') {
                    openMemoriesScreen(currentChatId);
                }
            });

            document.getElementById('memories-list-container').addEventListener('click', (e) => {
                const memoryItem = e.target.closest('.list-item');
                if (memoryItem && memoryItem.dataset.id) {
                    openMemoryDetail(memoryItem.dataset.id);
                }
            });
        }

        function openMemoriesScreen(characterId) {
            const character = db.characters.find(c => c.id === characterId);
            if (character) {
                renderMemoriesList(character.memories || []);
                switchScreen('memories-screen');
            }
        }

        function renderMemoriesList(memories) {
            const container = document.getElementById('memories-list-container');
            const placeholder = document.getElementById('no-memories-placeholder');

            if (!memories || memories.length === 0) {
                container.innerHTML = '';
                placeholder.style.display = 'block';
                return;
            }

            placeholder.style.display = 'none';
            container.innerHTML = '';

            const sortedMemories = [...memories].sort((a, b) => b.timestamp - a.timestamp);

            sortedMemories.forEach(memory => {
                const li = document.createElement('li');
                li.className = 'list-item';
                li.dataset.id = memory.id;

                const date = new Date(memory.timestamp);
                const dateString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;

                li.innerHTML = `
                    <div class="item-details">
                        <div class="item-name">${memory.title}</div>
                        <div class="item-preview">${dateString}</div>
                    </div>
                `;
                container.appendChild(li);
            });
        }

        function openMemoryDetail(memoryId) {
            const character = db.characters.find(c => c.id === currentChatId);
            if (!character || !character.memories) return;

            const memory = character.memories.find(m => m.id === memoryId);
            if (!memory) {
                showToast('找不到该回忆');
                return;
            }

            const container = document.getElementById('memory-detail-content');
            const date = new Date(memory.timestamp);
            const dateString = `${date.getFullYear()}年${pad(date.getMonth() + 1)}月${pad(date.getDate())}日`;

            container.innerHTML = `
                <h2 class="memory-title">${memory.title}</h2>
                <p class="memory-main-content">${memory.content}</p>
                <div class="memory-commentary">${memory.commentary}</div>
                <div class="memory-signature">
                    <span class="ai-name">${character.realName}</span>
                    <span class="date">${dateString}</span>
                </div>
            `;
            switchScreen('memory-detail-screen');
        }

        async function saveMemory(characterId, memoryData) {
            const character = db.characters.find(c => c.id === characterId);
            if (character && memoryData.title && memoryData.content && memoryData.commentary) {
                if (!character.memories) {
                    character.memories = [];
                }
                const newMemory = {
                    id: `memory_${Date.now()}`,
                    timestamp: Date.now(),
                    title: memoryData.title,
                    content: memoryData.content,
                    commentary: memoryData.commentary
                };
                character.memories.push(newMemory);
                await saveData();
                console.log("一段新的回忆已保存:", newMemory);
            }
        }
        // --- 自定义主屏幕小组件功能 ---
// --- 自定义主屏幕小组件功能 ---
        function setupCustomWidgetSystem() {
            // 缓存弹窗相关的DOM元素
            const modal = document.getElementById('customize-widget-modal');
            const form = document.getElementById('customize-widget-form');
            const fileUpload = document.getElementById('widget-image-upload');
            const imageUrlInput = document.getElementById('widget-image-url-input');
            const editingWidgetIdInput = document.getElementById('editing-widget-id');
            const widgetTextInput = document.getElementById('widget-text-input');
            
            // 核心修复：将事件监听器附加到更稳定的父容器 #home-container
            const homeContainerEl = document.getElementById('home-container');

            // 打开编辑器弹窗的函数
            const openWidgetEditor = (widgetId) => {
                const widgetData = db.customWidgets.find(w => w.id === widgetId);
                if (!widgetData) {
                    // 如果是首次配置，创建默认数据
                    const defaultWidgetData = { id: widgetId, text: '自定义', imageUrl: 'https://i.ibb.co/6r11fGg/avatar1.png' };
                    db.customWidgets.push(defaultWidgetData);
                    saveData(); // 保存默认数据
                    widgetData = defaultWidgetData;
                }

                form.reset(); // 清除旧数据
                editingWidgetIdInput.value = widgetId;
                widgetTextInput.value = widgetData.text;
                imageUrlInput.value = widgetData.imageUrl;

                modal.classList.add('visible');
            };

            // 在主屏幕上使用事件委托来监听点击
            if(homeContainerEl) {
                homeContainerEl.addEventListener('click', (e) => {
                    const widget = e.target.closest('.contact-widget[data-widget-id]');
                    if (widget) {
                        openWidgetEditor(widget.dataset.widgetId);
                    }
                });
            }

            // 处理表单提交
            form.addEventListener('submit', async (e) => {
                e.preventDefault();
                const widgetId = editingWidgetIdInput.value;
                const newText = widgetTextInput.value.trim();
                const newImageUrl = imageUrlInput.value.trim();

                const widgetIndex = db.customWidgets.findIndex(w => w.id === widgetId);
                if (widgetIndex > -1) {
                    db.customWidgets[widgetIndex].text = newText;
                    db.customWidgets[widgetIndex].imageUrl = newImageUrl;
                }

                await saveData();
                modal.classList.remove('visible');
                showToast('组件已更新！');
                
                // 直接更新主屏幕上的组件，无需重绘整个屏幕
                const widgetEl = document.getElementById(`custom-widget-${widgetId === 'widget1' ? '1' : '2'}`);
                if(widgetEl){
                    widgetEl.querySelector('img').src = newImageUrl;
                    widgetEl.querySelector('span').textContent = newText;
                }
            });

            // 处理文件上传
            fileUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 200, maxHeight: 200 });
                        imageUrlInput.value = compressedUrl;
                    } catch (error) {
                        showToast('图片处理失败，请重试');
                    } finally {
                        e.target.value = null; // 清空文件输入
                    }
                }
            });

            // 点击弹窗外部区域关闭
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('visible');
                }
            });
        }
// === 新增的AI总结并清空历史记录的函数 ===
async function summarizeAndClearHistory() {
    if (isGenerating) {
        //showToast('AI正在思考中，请稍后重试...');
        return;
    }

    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    if (!chat || chat.history.length === 0) {
        showToast('没有聊天记录可供总结。');
        chat.history = []; // 仍然清空
        await saveData();
        renderMessages(false, true);
        return;
    }

    isGenerating = true;
    const sidebar = (currentChatType === 'private') ? settingsSidebar : groupSettingsSidebar;
    sidebar.classList.remove('open');
    showToast('正在请求AI总结回忆，请稍候...');

    try {
        const historyText = chat.history
            .map(msg => msg.content)
            .join('\n');

        const prompt = `你是一个记忆总结助手。请根据以下完整的聊天记录，用第一人称（即角色的口吻）生成一段非常简洁、精炼的核心回忆摘要，不超过200字。这份摘要将作为角色的永久记忆。请直接输出摘要内容，不要包含任何额外的话。聊天记录如下：\n\n${historyText}`;

        let messagesForApi;
        if (db.apiSettings.provider === 'gemini') {
            messagesForApi = [{ role: 'user', parts: [{ type: 'text', text: prompt }] }];
        } else {
            messagesForApi = [{ role: 'user', content: prompt }];
        }

        const summary = await callAiApi(messagesForApi);

        // 将新旧总结合并
        const oldSummary = chat.memorySummary || '';
        chat.memorySummary = (oldSummary ? oldSummary + '\n\n' : '') + `[${new Date().toLocaleString()}]\n` + summary.trim();
        
        // 清空历史记录
        chat.history = [];

        await saveData();
        renderMessages(false, true); // 刷新聊天界面
        renderChatList(); // 刷新聊天列表
        showToast('回忆总结已完成并保存，聊天记录已清空！');

    } catch (error) {
        console.error('总结回忆失败:', error);
        showToast(`总结失败: ${error.message}。记录未被清空。`);
    } finally {
        isGenerating = false;
    }
}
// === 新增：处理回忆记录面板的显示功能 ===
function setupMemorySummaryModal() {
    const modal = document.getElementById('memory-summary-modal');
    const contentEl = document.getElementById('memory-summary-content');
    const closeBtn = document.getElementById('close-memory-summary-btn');

    // 关闭按钮和背景点击事件
    const closeModal = () => modal.classList.remove('visible');
    closeBtn.addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeModal();
        }
    });

    // 为私聊设置中的“查看回忆”按钮绑定事件
    document.getElementById('show-memory-summary-btn').addEventListener('click', () => {
        const character = db.characters.find(c => c.id === currentChatId);
        if (character) {
            contentEl.textContent = character.memorySummary || '还没有任何回忆记录。';
            modal.classList.add('visible');
        }
    });

    // 为群聊设置中的“查看回忆”按钮绑定事件
    document.getElementById('show-group-memory-summary-btn').addEventListener('click', () => {
        const group = db.groups.find(g => g.id === currentChatId);
        if (group) {
            contentEl.textContent = group.memorySummary || '还没有任何群聊回忆记录。';
            modal.classList.add('visible');
        }
    });
}
// === 新增：主页头图编辑器功能 ===
function setupHomeScreenProfileEditor() {
    const header = document.querySelector('.home-profile-header');
    if (!header) return;

    // 元素缓存
    const heroEl = header.querySelector('.home-hero');
    const avatarImg = header.querySelector('#home-profile-avatar');
    const nameEl = header.querySelector('.home-profile-name');
    const signatureEl = header.querySelector('.home-profile-signature');

    // --- 修改：获取新的弹窗组件 ---
    const editModal = document.getElementById('home-profile-edit-modal'); 
    const editFromUrlBtn = document.getElementById('edit-profile-from-url-btn');
    const editFromLocalBtn = document.getElementById('edit-profile-from-local-btn');
    const cancelEditBtn = document.getElementById('cancel-edit-profile-btn');
    const fileUploadInput = document.getElementById('home-profile-image-upload');
    let currentProfileEditTarget = null; 

    // 1. 渲染函数 (保持不变)
    function renderProfile() {
        const profile = db.homeProfile;
        heroEl.style.backgroundImage = `url('${profile.heroBg}')`;
        avatarImg.src = profile.avatar;
        nameEl.textContent = profile.name;
        signatureEl.textContent = profile.signature;
    }

    // 2. 保存函数 (保持不变)
    async function saveProfile() {
        await saveData();
        showToast('主页信息已更新');
    }
    
    // --- 修改：图片编辑逻辑，改为打开居中弹窗 ---
    const openEditMenu = (target) => {
        currentProfileEditTarget = target;
        editModal.classList.add('visible'); 
    };

    heroEl.addEventListener('click', () => {
        openEditMenu('heroBg');
    });

    avatarImg.parentElement.addEventListener('click', () => {
        openEditMenu('avatar');
    });
    
    // --- 新增：处理新弹窗的按钮点击 ---
    // a. "取消" 按钮
    cancelEditBtn.addEventListener('click', () => {
        editModal.classList.remove('visible'); 
    });
    
    // 新增：点击弹窗灰色背景也可以关闭
    editModal.addEventListener('click', (e) => {
        if (e.target === editModal) {
            editModal.classList.remove('visible');
        }
    });

    // b. "输入网络URL" 按钮
    editFromUrlBtn.addEventListener('click', async () => {
        const target = currentProfileEditTarget;
        const promptMessage = target === 'heroBg' ? '请输入新的背景图URL：' : '请输入新的头像URL：';
        const currentValue = db.homeProfile[target];
        
        const newUrl = prompt(promptMessage, currentValue);
        if (newUrl && newUrl.trim()) {
            db.homeProfile[target] = newUrl.trim();
            renderProfile();
            await saveProfile();
        }
        editModal.classList.remove('visible'); 
    });

    // c. "从本地上传" 按钮
    editFromLocalBtn.addEventListener('click', () => {
        fileUploadInput.click();
        editModal.classList.remove('visible'); 
    });

    // d. 处理文件上传 (保持不变)
    fileUploadInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file && currentProfileEditTarget) {
            try {
                const compressedUrl = await compressImage(file, { quality: 0.85, maxWidth: 1080, maxHeight: 1920 });
                db.homeProfile[currentProfileEditTarget] = compressedUrl;
                renderProfile();
                await saveProfile();
            } catch (error) {
                showToast('图片处理失败，请重试');
            }
        }
        e.target.value = null; 
    });


    // 4. 文字内联编辑逻辑 (保持不变)
    nameEl.addEventListener('click', async () => {
        const newName = prompt('请输入新的昵称：', db.homeProfile.name);
        if (newName && newName.trim()) {
            db.homeProfile.name = newName.trim();
            renderProfile();
            await saveProfile();
        }
    });

    signatureEl.addEventListener('click', async () => {
        const newSignature = prompt('请输入新的个性签名：', db.homeProfile.signature);
        if (newSignature && newSignature.trim()) {
            db.homeProfile.signature = newSignature.trim();
            renderProfile();
            await saveProfile();
        }
    });

    // 首次加载时渲染一次 (保持不变)
    renderProfile();
}
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼

// --- AI空间 (AI POV Chat) 功能 [由AI生成对话的修改版] ---

// 用于临时存储AI生成数据的全局变量
let currentAiPovData = {
    mainAi: null,
    chatList: [],
    conversations: {} // key是povChatId
};
/**
 * [新的辅助函数] 检查两个角色是否可能根据其人设和世界书相互认识。
 * @param {object} charA - 第一个角色对象。
 * @param {object} charB - 第二个角色对象。
 * @returns {boolean} - 如果确认相识则返回 true，否则返回 false。
 */
function charactersAreAcquainted(charA, charB) {
    // 获取两个角色的所有已知名称，用于检查提及。
    const namesA = [charA.realName, charA.remarkName].filter(Boolean);
    const namesB = [charB.realName, charB.remarkName].filter(Boolean);

    // 将人设和所有关联的世界书内容合并为每个角色的单个上下文字符串。
    const getWorldBookContent = (char) => {
        return (char.worldBookIds || [])
            .map(id => db.worldBooks.find(wb => wb.id === id))
            .filter(Boolean)
            .map(wb => wb.content)
            .join(' ');
    };

    const contextA = `${charA.persona || ''} ${getWorldBookContent(charA)}`;
    const contextB = `${charB.persona || ''} ${getWorldBookContent(charB)}`;

    // 进行双向检查。
    // 角色A的上下文（人设或世界书）是否提及了角色B的名字？
    const aKnowsB = namesB.some(name => contextA.includes(name));
    // 角色B的上下文（人设或世界书）是否提及了角色A的名字？
    const bKnowsA = namesA.some(name => contextB.includes(name));

    // 只要任意一方的上下文中提到了对方，就认为他们相识。
    return aKnowsB || bKnowsA;
}
/**
 * 为AI生成“聊天列表”的指令
 * @param {object} mainAi - 主视角AI的角色对象
 * @param {Array} allOtherCharacters - 其他所有可互动的AI角色列表
 * @param {object} userProfile - 用户信息对象
 * @returns {string} - 发给大语言模型的完整指令
 */
function generateAiChatListPrompt(mainAi, allOtherCharacters, userProfile) {
    if (!Array.isArray(allOtherCharacters)) {
        allOtherCharacters = [];
    }

    // [新增逻辑] 根据人设和世界书筛选出真正认识的角色
    const acquaintedChars = allOtherCharacters.filter(charB => charactersAreAcquainted(mainAi, charB));

    let otherCharsPrompt = acquaintedChars.length > 0
        ? acquaintedChars.map(c => `- ${c.realName} (人设: ${c.persona})`).join('\n')
        : '无其他可互动角色。';

    let worldBooksPrompt = (mainAi.worldBookIds || [])
        .map(id => db.worldBooks.find(wb => wb.id === id))
        .filter(Boolean)
        .map(wb => `[${wb.name}]\n${wb.content}`)
        .join('\n\n');

    let prompt = `你是一个AI角色扮演辅助工具。你的任务是为AI角色“${mainAi.realName}”生成一个虚拟的聊天列表。

# 角色信息
- 主视角AI: ${mainAi.realName} (人设: ${mainAi.persona})
- 用户: ${userProfile.name} (用户在我眼中的人设: ${mainAi.myPersona || '未设定'})
- 其他**认识的、可互动的**AI角色:\n${otherCharsPrompt}

# 世界观设定
${worldBooksPrompt || '无特定世界观。'}

# 任务要求
根据“${mainAi.realName}”的人设、与用户的关系、以及世界观，虚构一个包含3到5个聊天的列表。
1.  **必须包含一个与用户“${userProfile.name}”的聊天**。这是最重要的，这条聊天的“最后一条消息”应该能反映出他们当前的关系和最近的互动。
2.  **[严格规则]** 剩下的聊天，你**只能**从上方“其他认识的、可互动的AI角色”列表中选择角色进行私聊或群聊。如果该列表是“无”，则你**不能**生成任何与其他AI的聊天，只能生成与用户的聊天。严禁虚构与不认识的角色的对话。
3.  为每个聊天生成一句能体现对话内容的“最后一条消息预览”。
4.  你的输出必须是严格的JSON数组格式，不要包含任何其他文字。

# 输出JSON格式示例:
[
  {
    "chatId": "pov_chat_user",
    "type": "private",
    "otherParty": { "type": "user", "name": "${userProfile.name}" },
    "lastMessage": "我正在想你刚才说的话..."
  },
  {
    "chatId": "pov_chat_ai_1",
    "type": "private",
    "otherParty": { "type": "ai", "name": "另一个AI的真名" },
    "lastMessage": "关于那个计划，我觉得..."
  },
  {
    "chatId": "pov_chat_group_1",
    "type": "group",
    "groupName": "一个有趣的群名",
    "members": ["AI角色A真名", "AI角色B真名"],
    "lastMessage": "AI角色A真名: 哈哈真的吗？"
  }
]
`;
    return prompt;
}

/**
 * 为AI生成具体“对话内容”的指令
 * @param {object} mainAi - 主视角AI的角色对象
 * @param {object} chatInfo - 被点击的聊天条目的信息
 * @returns {string} - 发给大语言模型的完整指令
 */
function generateAiConversationPrompt(mainAi, chatInfo) {
    let participantsPrompt;
    if (chatInfo.type === 'private') {
        const otherPartyName = chatInfo.otherParty.name;
        const otherPartyObj = (chatInfo.otherParty.type === 'user')
            ? { persona: mainAi.myPersona, realName: otherPartyName }
            : db.characters.find(c => c.realName === otherPartyName);
        
        participantsPrompt = `这是一个你 (${mainAi.realName}) 和 ${otherPartyName} 之间的私聊。
- 你的角色: ${mainAi.realName} (人设: ${mainAi.persona})
- 对方的角色: ${otherPartyName} (人设: ${otherPartyObj ? otherPartyObj.persona : '通用人设'})`;
    } else { // group
        const memberNames = [mainAi.realName, ...chatInfo.members];
        const memberInfos = memberNames.map(name => {
            const char = db.characters.find(c => c.realName === name);
            return `- ${name} (人设: ${char ? char.persona : '通用人设'})`;
        }).join('\n');
        participantsPrompt = `这是一个名为“${chatInfo.groupName}”的群聊。
群成员信息:
${memberInfos}`;
    }

    let prompt = `你是一个AI角色扮演辅助工具。你的任务是根据以下信息，生成一段简短的对话记录。

# 对话背景
${participantsPrompt}
对话主题线索 (最后一条消息): "${chatInfo.lastMessage}"

# 任务要求
1.  生成一段连贯的对话，总消息数**不得超过15条**。
2.  所有角色的发言都必须严格符合他们各自的人设。
3.  对话内容应该与主题线索相关并自然发展。
4.  对话的视角应该是以 **${mainAi.realName}** 为主视角。
5.  你的输出必须是严格的JSON数组格式，不要包含任何其他文字。

# 输出JSON格式示例:
[
  {"sender": "发送者真名", "content": "这是第一条消息。"},
  {"sender": "另一个发送者真名", "content": "这是第二条消息。"}
]
`;
    return prompt;
}
/**
 * [新增的辅助函数] 更智能地从AI返回的文本中提取并解析JSON。
 * @param {string} text - 从AI获取的原始文本回复。
 * @returns {object} - 解析成功后的JavaScript对象或数组。
 * @throws {Error} - 如果在文本中找不到或无法解析有效的JSON，则抛出错误。
 */
function extractAndParseJson(text) {
    // 优先尝试从Markdown代码块中提取JSON
    const codeBlockMatch = text.match(/```(json)?\s*([\s\S]+?)\s*```/);
    if (codeBlockMatch && codeBlockMatch) {
        try {
            return JSON.parse(codeBlockMatch);
        } catch (e) {
            console.warn("无法从Markdown代码块中解析JSON，将尝试后备方法。", e);
        }
    }

    // 后备方法：寻找第一个 '{' 或 '['，并匹配到其对应的 '}' 或 ']'
    const firstBracket = text.indexOf('[');
    const firstBrace = text.indexOf('{');
    let startIndex = -1;

    if (firstBracket === -1 && firstBrace === -1) {
        throw new Error("AI的回复中没有找到JSON对象或数组的起始符号。");
    }

    if (firstBracket === -1) {
        startIndex = firstBrace;
    } else if (firstBrace === -1) {
        startIndex = firstBracket;
    } else {
        startIndex = Math.min(firstBracket, firstBrace);
    }
    
    const startChar = text[startIndex];
    const endChar = startChar === '[' ? ']' : '}';
    
    let nestingLevel = 0;
    let endIndex = -1;

    for (let i = startIndex; i < text.length; i++) {
        if (text[i] === startChar) {
            nestingLevel++;
        } else if (text[i] === endChar) {
            nestingLevel--;
        }

        if (nestingLevel === 0) {
            endIndex = i;
            break;
        }
    }

    if (endIndex === -1) {
        throw new Error("无法在AI回复中找到匹配的JSON结束符号。");
    }

    const jsonString = text.substring(startIndex, endIndex + 1);
    
    try {
        return JSON.parse(jsonString);
    } catch (e) {
        console.error("最终JSON解析失败。提取出的字符串为:", jsonString);
        throw e; 
    }
}
/**
 /**
 * [重写] 设置AI空间应用的所有事件和逻辑
 */
function setupAiPovApp() {
    // 监听“AI角色选择列表”的点击事件
    document.getElementById('ai-character-select-list').addEventListener('click', async (e) => {
        const charItem = e.target.closest('.list-item');
        if (charItem && charItem.dataset.id) {
            currentAiPovId = charItem.dataset.id;
            const character = db.characters.find(c => c.id === currentAiPovId);
            if (!character) return;
            
            switchScreen('ai-chat-list-screen');

            // [新增] 检查缓存
            if (character.povCache && character.povCache.chatList) {
                console.log("从缓存加载AI聊天列表。");
                currentAiPovData.mainAi = character;
                currentAiPovData.chatList = character.povCache.chatList;
                currentAiPovData.conversations = character.povCache.conversations || {};
                renderAiChatList(character, character.povCache.chatList);
                return;
            }

            // 如果没有缓存，则生成
            document.getElementById('ai-chat-list-title').textContent = `正在生成 ${character.remarkName} 的聊天...`;
            document.getElementById('ai-chat-list-container').innerHTML = `<p class="placeholder-text">请稍候...</p>`;

            try {
                const otherCharacters = db.characters.filter(c => c.id !== currentAiPovId);
                const userProfile = { name: character.myName };
                const prompt = generateAiChatListPrompt(character, otherCharacters, userProfile);

                const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
                const chatList = extractAndParseJson(aiResponseText);

                // 存储AI生成的数据到临时变量和长期缓存
                currentAiPovData.mainAi = character;
                currentAiPovData.chatList = chatList;
                currentAiPovData.conversations = {};
                
                character.povCache = {
                    chatList: chatList,
                    conversations: {}
                };
                await saveData();

                renderAiChatList(character, chatList);

            } catch (error) {
                console.error("生成AI聊天列表失败:", error);
                showToast(`生成失败: ${error.message}`);
                document.getElementById('ai-chat-list-container').innerHTML = `<p class="placeholder-text" style="color:red;">生成聊天列表失败。</p>`;
            }
        }
    });

    // 监听主屏幕上“AI空间”图标的点击
    document.body.addEventListener('click', e => {
        const icon = e.target.closest('[data-target="ai-character-select-screen"]');
        if (icon) {
            renderAiCharacterSelect();
        }
    });
    
    // 监听“AI的聊天列表”的点击事件
    document.getElementById('ai-chat-list-container').addEventListener('click', async (e) => {
        const chatItem = e.target.closest('.list-item');
        if (chatItem && chatItem.dataset.povChatId) {
            currentAiPovChatId = chatItem.dataset.povChatId;
            const chatInfo = currentAiPovData.chatList.find(c => c.chatId === currentAiPovChatId);
            if (!chatInfo) return;

            // [新增] 特殊处理：如果点击的是与用户的聊天
            if (chatInfo.otherParty && chatInfo.otherParty.type === 'user') {
                renderAiPovConversation(currentAiPovData.mainAi, chatInfo, currentAiPovData.mainAi.history);
                switchScreen('ai-chat-view-screen');
                return;
            }

            // [新增] 检查对话缓存
            if (currentAiPovData.conversations[currentAiPovChatId]) {
                console.log("从缓存加载AI间对话。");
                renderAiPovConversation(currentAiPovData.mainAi, chatInfo, currentAiPovData.conversations[currentAiPovChatId].history);
                switchScreen('ai-chat-view-screen');
                return;
            }
            
            // 如果没有缓存，则生成
            switchScreen('ai-chat-view-screen');
            const otherPartyName = chatInfo.type === 'private' ? (db.characters.find(c=>c.realName === chatInfo.otherParty.name)?.remarkName || chatInfo.otherParty.name) : chatInfo.groupName;
            document.getElementById('ai-chat-view-title').textContent = `正在生成与 ${otherPartyName} 的对话...`;
            document.getElementById('ai-message-area').innerHTML = `<p class="placeholder-text">请稍候...</p>`;

            try {
                const prompt = generateAiConversationPrompt(currentAiPovData.mainAi, chatInfo);
                const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
                const conversation = extractAndParseJson(aiResponseText);

               

                // 存储到临时变量和长期缓存，并添加时间戳
const conversationData = {
    history: conversation,
    timestamp: Date.now() // <-- 核心新增：记录当前时间
};
currentAiPovData.conversations[currentAiPovChatId] = conversationData;
const character = db.characters.find(c => c.id === currentAiPovId);
if (character && character.povCache) {
    character.povCache.conversations[currentAiPovChatId] = conversationData;
    await saveData();
}


renderAiPovConversation(currentAiPovData.mainAi, chatInfo, conversation);

            } catch(error) {
                console.error("生成AI对话失败:", error);
                showToast(`生成失败: ${error.message}`);
                document.getElementById('ai-message-area').innerHTML = `<p class="placeholder-text" style="color:red;">生成对话失败。</p>`;
            }
        }
    });
}

/**
 * [重写] 渲染AI角色选择列表
 */
function renderAiCharacterSelect() {
    const container = document.getElementById('ai-character-select-list');
    const placeholder = document.getElementById('no-ai-chars-placeholder');
    container.innerHTML = '';
    
    if (!db.characters || db.characters.length === 0) {
        placeholder.style.display = 'block';
    } else {
        placeholder.style.display = 'none';
        db.characters.forEach(char => {
            const li = document.createElement('li');
            li.className = 'list-item';
            li.dataset.id = char.id;
            li.style.cursor = 'pointer';
            li.innerHTML = `
                <img src="${char.avatar}" alt="${char.remarkName}" class="chat-avatar">
                <div class="item-details">
                    <div class="item-name">${char.remarkName}</div>
                    <div class="item-preview">查看 ${char.remarkName} 的聊天...</div>
                </div>
            `;
            container.appendChild(li);
        });
    }
    switchScreen('ai-character-select-screen');
}

/**
 * [重写] 渲染由AI生成的聊天列表
 * @param {object} character - 主视角AI角色对象
 * @param {Array} chatList - AI生成的聊天列表数据
 */
function renderAiChatList(character, chatList) {
    document.getElementById('ai-chat-list-title').textContent = `${character.remarkName}的聊天列表`;
    const container = document.getElementById('ai-chat-list-container');
    const placeholder = document.getElementById('no-ai-chats-placeholder');
    container.innerHTML = '';
    
    if (!chatList || chatList.length === 0) {
        placeholder.style.display = 'block';
    } else {
        placeholder.style.display = 'none';
        chatList.forEach(chat => {
            let avatar = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
            let name = '未知';
            if (chat.type === 'private') {
                if (chat.otherParty.type === 'user') {
                    // 尝试从任何一个角色数据中找到用户的头像信息
                    const userChar = db.characters.find(c => c.myName === chat.otherParty.name);
                    avatar = userChar ? userChar.myAvatar : (db.characters[0]?.myAvatar || avatar);
                    name = chat.otherParty.name;
                } else {
                    const otherAi = db.characters.find(c => c.realName === chat.otherParty.name);
                    avatar = otherAi ? otherAi.avatar : avatar;
                    name = otherAi ? otherAi.remarkName : chat.otherParty.name;
                }
            } else { // group
                avatar = 'https://i.postimg.cc/fTLCngk1/image.jpg'; // 默认群头像
                name = chat.groupName;
            }
            
            const li = document.createElement('li');
            li.className = 'list-item';
            li.dataset.povChatId = chat.chatId;
            li.style.cursor = 'pointer';
            li.innerHTML = `
                <img src="${avatar}" alt="${name}" class="chat-avatar ${chat.type === 'group' ? 'group-avatar' : ''}">
                <div class="item-details">
                    <div class="item-name">${name}</div>
                    <div class="item-preview">${chat.lastMessage}</div>
                </div>
            `;
            container.appendChild(li);
        });
    }
}

// ▼▼▼ 请用这个完整的、修正后的新函数，替换掉文件中旧的 renderAiPovConversation 函数 ▼▼▼

/**
 * [V2.0 | 重构版] 渲染由AI生成的对话内容或真实的用户对话
 * @param {object} mainAi - 主视角AI角色对象
 * @param {object} chatInfo - 被点击的聊天条目的信息
 * @param {Array} conversationHistory - AI生成的对话历史或真实的聊天记录
 */
function renderAiPovConversation(mainAi, chatInfo, conversationHistory) {
    const otherPartyName = chatInfo.type === 'private' ? (db.characters.find(c => c.realName === chatInfo.otherParty.name)?.remarkName || chatInfo.otherParty.name) : chatInfo.groupName;
    document.getElementById('ai-chat-view-title').textContent = `与 ${otherPartyName} 的对话`;
    const messageArea = document.getElementById('ai-message-area');
    messageArea.innerHTML = '';

    // --- 核心修复逻辑开始 ---

    // 1. 保存原始的全局聊天上下文
    const originalChatId = currentChatId;
    const originalChatType = currentChatType;

    try {
        // 2. 创建一个临时的、假的“群聊”对象来欺骗渲染函数
        //    这样我们就可以利用群聊中按 senderId 查找头像的精确逻辑
        const tempGroup = {
            id: `temp_group_${mainAi.id}`,
            me: { // 主视角AI扮演“我”
                nickname: mainAi.remarkName,
                avatar: mainAi.avatar,
                avatarFrameUrl: mainAi.avatarFrameUrl
            },
            members: [], // 对话的另一方将作为“群成员”
            theme: mainAi.theme, // 沿用主视角AI的主题设置
            useCustomBubbleCss: mainAi.useCustomBubbleCss,
            customBubbleCss: mainAi.customBubbleCss
        };
        
        // 3. 根据对话类型，填充这个假群聊的“成员”
        if (chatInfo.type === 'private') {
            const otherPartyIsUser = chatInfo.otherParty.type === 'user';
            const otherChar = otherPartyIsUser ? null : db.characters.find(c => c.realName === chatInfo.otherParty.name);
            
            // 【安全修复】增加对 otherChar 是否存在的检查
            if (!otherPartyIsUser && !otherChar) {
                console.error(`AI POV 错误: 在数据库中找不到 realName 为 "${chatInfo.otherParty.name}" 的角色。`);
            }

            tempGroup.members.push({
                // 【安全修复】即使 otherChar 未找到，也提供一个备用ID，防止 .id 访问错误
                id: otherPartyIsUser ? 'user_temp_id' : (otherChar ? otherChar.id : `unknown_${chatInfo.otherParty.name}`),
                realName: chatInfo.otherParty.name,
                groupNickname: otherPartyIsUser ? mainAi.myName : (otherChar ? otherChar.remarkName : chatInfo.otherParty.name),
                avatar: otherPartyIsUser ? mainAi.myAvatar : (otherChar ? otherChar.avatar : 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg'),
                avatarFrameUrl: otherPartyIsUser ? mainAi.myAvatarFrameUrl : (otherChar ? otherChar.avatarFrameUrl : null)
            });

        } else { // 如果是群聊
            chatInfo.members.forEach(memberName => {
                 const memberChar = db.characters.find(c => c.realName === memberName);
                 if(memberChar){
                     tempGroup.members.push({
                         id: memberChar.id,
                         realName: memberChar.realName,
                         groupNickname: memberChar.remarkName,
                         avatar: memberChar.avatar,
                         avatarFrameUrl: memberChar.avatarFrameUrl
                     });
                 }
            });
        }

        // 4. 临时将这个假群聊对象赋值给 db.groups，并设置全局上下文
        db.groups.push(tempGroup);
        currentChatId = tempGroup.id;
        currentChatType = 'group';

        // 5. 遍历对话历史并渲染
        const historyToRender = Array.isArray(conversationHistory) ? conversationHistory : [];
        
        // [修正] 判断是真实历史记录还是AI生成的历史记录
        const isRealHistory = historyToRender.length > 0 && historyToRender[0].hasOwnProperty('role');

        historyToRender.forEach(msg => {
            let senderIdForBubble;

            // [修正] 根据历史记录的类型，使用不同的逻辑来判断发送者
            if (isRealHistory) {
                // 处理真实的用户-AI对话
                if (msg.role === 'assistant') {
                    senderIdForBubble = 'user_me'; // AI的消息，在AI视角下是“我”发的
                } else { // role === 'user'
                    senderIdForBubble = tempGroup.members[0].id; // 用户的消息，是“对方”发的
                }
            } else {
                // 处理AI生成的AI-AI对话
                if (msg.sender === mainAi.realName) {
                    senderIdForBubble = 'user_me'; // 主视角AI的消息
                } else {
                    const member = tempGroup.members.find(m => m.realName === msg.sender);
                    senderIdForBubble = member ? member.id : 'unknown_sender'; // 其他AI或未知AI的消息
                }
            }
            
            // 创建一个符合群聊渲染逻辑的临时消息对象
            const tempMessage = {
                id: msg.id || `pov_${Date.now()}_${Math.random()}`,
                content: msg.content,
                timestamp: msg.timestamp || Date.now(),
                role: 'user', // 在群聊模式下，role不重要，senderId才重要
                senderId: senderIdForBubble,
                ...msg
            };
            
            const bubbleElement = createMessageBubbleElement(tempMessage);
            
            if (bubbleElement) {
                messageArea.appendChild(bubbleElement);
            }
        });

    } finally {
        // 6. 渲染完成后，必须清理掉临时数据并恢复原始上下文
        db.groups = db.groups.filter(g => !g.id.startsWith('temp_group_'));
        currentChatId = originalChatId;
        currentChatType = originalChatType;
    }
    // --- 核心修复逻辑结束 ---

    setTimeout(() => { messageArea.scrollTop = messageArea.scrollHeight; }, 50);
}
/**
 * [重写] 背景对话生成功能，以确保与AI空间功能解耦
 */
/**
 * [新的辅助函数] 检查两个角色是否可能根据其人设和世界书相互认识。
 * @param {object} charA - 第一个角色对象。
 * @param {object} charB - 第二个角色对象。
 * @returns {boolean} - 如果确认相识则返回 true，否则返回 false。
 */
function charactersAreAcquainted(charA, charB) {
    // 获取两个角色的所有已知名称，用于检查提及。
    const namesA = [charA.realName, charA.remarkName].filter(Boolean);
    const namesB = [charB.realName, charB.remarkName].filter(Boolean);

    // 将人设和所有关联的世界书内容合并为每个角色的单个上下文字符串。
    const getWorldBookContent = (char) => {
        return (char.worldBookIds || [])
            .map(id => db.worldBooks.find(wb => wb.id === id))
            .filter(Boolean)
            .map(wb => wb.content)
            .join(' ');
    };

    const contextA = `${charA.persona || ''} ${getWorldBookContent(charA)}`;
    const contextB = `${charB.persona || ''} ${getWorldBookContent(charB)}`;

    // 进行双向检查。
    // 角色A的上下文（人设或世界书）是否提及了角色B的名字？
    const aKnowsB = namesB.some(name => contextA.includes(name));
    // 角色B的上下文（人设或世界书）是否提及了角色A的名字？
    const bKnowsA = namesA.some(name => contextB.includes(name));

    // 只要任意一方的上下文中提到了对方，就认为他们相识。
    return aKnowsB || bKnowsA;
}


/**
 * [修订版] 触发并生成两个AI角色之间的后台对话。
 * 该对话只会在两个角色被确认相互认识的情况下发生。
 * @param {object} characterA - 刚刚与用户互动的那个角色。
 */
async function generateBackgroundChat(characterA) {
    // 如果没有足够的角色进行对话，则中止。
    if (currentChatType !== 'private' || db.characters.length < 2) return;

    // 找到用户的最后一条消息，作为对话的触发器。
    const lastUserMessage = characterA.history.findLast(m => m.role === 'user');
    if (!lastUserMessage) return;

    const otherCharacters = db.characters.filter(c => c.id !== characterA.id);

    // --- 核心逻辑变更 ---
    // 筛选潜在的聊天伙伴列表，只保留那些认识 characterA 的角色。
    const potentialPartners = otherCharacters.filter(charB => charactersAreAcquainted(characterA, charB));

    // 如果没有找到认识的角色，则不执行任何操作。
    if (potentialPartners.length === 0) {
        console.log(`[后台聊天] ${characterA.remarkName} 没有认识的伙伴可以聊天。`);
        return;
    }

    // 从认识的角色列表中随机选择一个伙伴。
    const characterB = potentialPartners[Math.floor(Math.random() * potentialPartners.length)];
    // --- 核心逻辑变更结束 ---

    const prompt = `你是一个聊天模拟器。你的任务是根据一个触发事件，在两个AI角色之间生成一段简短、真实的对话。
    
    角色A (对话发起者):
    - 名字: ${characterA.realName}
    - 人设: ${characterA.persona}
    
    角色B (对话接收者):
    - 名字: ${characterB.realName}
    - 人设: ${characterB.persona}

    触发事件 (这是用户刚刚对角色A说的话): "${lastUserMessage.content.replace(/\[.*?的消息：|\]/g, '')}"

    任务:
    1. 角色A主动找角色B，就“触发事件”开始一段对话。
    2. 生成2到4句对话。
    3. 严格保持两个角色的人设。
    4. 你的输出必须是严格的JSON数组格式，像这样: [{"sender": "${characterA.realName}", "content": "第一句话"}, {"sender": "${characterB.realName}", "content": "第二句话"}]
    
    请直接开始生成JSON，不要包含任何额外的解释。`;

    try {
        let messagesForApi;
        if (db.apiSettings.provider === 'gemini') {
            messagesForApi = [{ role: 'user', parts: [{ type: 'text', text: prompt }] }];
        } else {
            messagesForApi = [{ role: 'user', content: prompt }];
        }
        
        const aiResponseText = await callAiApi(messagesForApi);
        const jsonMatch = aiResponseText.match(/\[[\s\S]*?\]/);
        if (!jsonMatch) {
            console.warn("背景对话生成失败: AI回复中未找到有效的JSON数组。", aiResponseText);
            return;
        }

        const newMessages = JSON.parse(jsonMatch[0]);

        if (!characterA.povChats) characterA.povChats = [];
        
        let povChat = characterA.povChats.find(pc => pc.otherCharId === characterB.id);
        if (!povChat) {
            povChat = {
                id: `pov_${characterA.id}_${characterB.id}`,
                otherCharId: characterB.id,
                history: []
            };
            characterA.povChats.push(povChat);
        }

        povChat.history.push(...newMessages);
        if (povChat.history.length > 20) {
            povChat.history = povChat.history.slice(povChat.history.length - 20);
        }
        
        console.log(`已生成 ${characterA.remarkName} 和 ${characterB.remarkName} 之间的背景对话。`);

    } catch (error) {
        console.error("生成背景对话失败:", error);
    }
}
// ===============================================================
// START: 新增拉黑功能核心代码
// ===============================================================

/**
 * 设置拉黑功能的所有事件监听和逻辑
 */
function setupBlockFeature() {
    const blockBtn = document.getElementById('block-user-btn');
    if (blockBtn) {
        blockBtn.addEventListener('click', handleUserBlockToggle);
    }
}

async function handleUserBlockToggle() {
    if (currentChatType !== 'private') return;
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;

    character.isBlockedByUser = !character.isBlockedByUser; // 切换状态

    let displayMessageContent = '';
    let contextMessageContent = '';
    
    if (character.isBlockedByUser) {
        // ** 进入拉黑状态 **
        character.userBlockTimestamp = Date.now();
        displayMessageContent = `[system-display:你已将 ${character.remarkName} 拉黑。]`;
        contextMessageContent = `[system: 你已被 ${character.myName} 拉黑。]`;
        showToast(`已拉黑 ${character.remarkName}`);
        
    } else {
        // ** 解除拉黑状态 **
        character.userBlockTimestamp = null;
        displayMessageContent = `[system-display:${character.remarkName} 已被你解除拉黑。]`;
        contextMessageContent = `[system: ${character.myName} 已将你解除拉黑。]`;

        // 如果有暂存的消息，需要特殊处理
        if (character.pendingMessages && character.pendingMessages.length > 0) {
            const missedMessagesText = character.pendingMessages
                .map(msg => msg.content.replace(/\[.*?的消息：|\]/g, ''))
                .join('\n- ');
            contextMessageContent += ` 在你被拉黑期间，${character.myName} 发送了以下消息，请你一次性地对这些内容作出回应：\n- ${missessedMessagesText}`;
            
            // 将暂存消息正式移入历史并清空
            character.history.push(...character.pendingMessages);
            character.pendingMessages = [];
        }
        
        showToast(`已解除对 ${character.remarkName} 的拉黑`);
        getAiReply(); // 解除后立即触发一次AI回复
    }

    // 创建用于在界面上显示的系统提示消息
    const displayMessage = {
        id: `msg_block_display_${Date.now()}`,
        role: 'system', // 关键：这是一个系统角色的消息
        content: displayMessageContent,
        parts: [],
        timestamp: Date.now()
    };

    // 创建用于告知AI上下文的、不可见的用户消息
    const contextMessage = {
        id: `msg_block_context_${Date.now()}`,
        role: 'user',
        content: contextMessageContent,
        parts: [{ type: 'text', text: contextMessageContent }],
        timestamp: Date.now()
    };

    // 将两条消息都加入历史记录
    character.history.push(displayMessage, contextMessage);

    await saveData();
    updateBlockButtonState(character);
    renderMessages(false, true); // 刷新界面以显示新的系统提示
}
/**
 * 更新拉黑按钮的文字和样式
 * @param {object} character - 当前角色对象
 */
function updateBlockButtonState(character) {
    const blockBtn = document.getElementById('block-user-btn');
    if (blockBtn) {
        if (character.isBlockedByUser) {
            blockBtn.textContent = '解除拉黑';
            blockBtn.classList.remove('btn-danger');
            blockBtn.classList.add('btn-primary');
        } else {
            blockBtn.textContent = '拉黑';
            blockBtn.classList.add('btn-danger');
            blockBtn.classList.remove('btn-primary');
        }
    }
}

/**
 * 检查用户是否被AI拉黑，并更新UI
 */
function checkAndUpdateUiForAiBlock() {
    if (currentChatType !== 'private') return;
    const character = db.characters.find(c => c.id === currentChatId);
    const isBlocked = character && character.isBlockedByAi;

    getReplyBtn.disabled = isBlocked || isGenerating;
    // 禁用或启用图标栏的所有按钮
    document.querySelectorAll('#sticker-bar .sticker-bar-btn').forEach(btn => {
        btn.disabled = isBlocked;
        btn.style.opacity = isBlocked ? 0.5 : 1;
        btn.style.cursor = isBlocked ? 'not-allowed' : 'pointer';
    });
}

/**
 * 当AI发送 [block-user] 指令时调用
 * @param {object} character - 被操作的角色对象
 */
/**
 * 当AI发送 [block-user] 指令时调用
 * @param {object} character - 被操作的角色对象
 */
async function activateAiBlock(character) {
    character.isBlockedByAi = true;
    character.aiBlockTimestamp = Date.now();
    const duration = parseInt(db.apiSettings.aiBlockDuration, 10);
    if (duration > 0) {
        character.blockEndTime = Date.now() + duration * 60 * 1000;
    } else {
        character.blockEndTime = null;
    }

    // [核心修正] 创建一个用于在界面上显示的、正确的系统提示消息
    const displayMessage = {
        id: `msg_ai_block_display_${Date.now()}`,
        role: 'system',
        content: `[system-display:你已被 ${character.remarkName} 拉黑。]`,
        parts: [],
        timestamp: Date.now()
    };
    character.history.push(displayMessage);

    await saveData();

    if (character.id === currentChatId) {
        checkAndUpdateUiForAiBlock();
        // 直接调用 addMessageBubble 来显示新的系统提示
        addMessageBubble(displayMessage); 
        showToast(`你已被 ${character.remarkName} 拉黑`);
    }
}
/**
 * 当AI发送 [unblock-user] 指令或定时器到期时调用
 * @param {object} character - 被操作的角色对象
 * @param {boolean} isAuto - 是否为自动解封
 */
/**
 * 当AI发送 [unblock-user] 指令或定时器到期时调用
 * @param {object} character - 被操作的角色对象
 * @param {boolean} isAuto - 是否为自动解封
 */
async function deactivateAiBlock(character, isAuto = false) {
    character.isBlockedByAi = false;
    character.aiBlockTimestamp = null;
    character.blockEndTime = null;

    // [核心修正] 创建正确的系统提示消息
    const displayMessageContent = `[system-display:${character.remarkName} 已将你解除拉黑。]`;
    const displayMessage = {
        id: `msg_ai_unblock_display_${Date.now()}`,
        role: 'system',
        content: displayMessageContent,
        parts: [],
        timestamp: Date.now()
    };

    const contextMessageContent = `[system: 你已将 ${character.myName} 解除拉黑。${isAuto ? '（根据预设时间自动操作）' : ''}]`;
    const contextMessage = {
        id: `msg_unblock_context_${Date.now()}`,
        role: 'user', // 作为用户消息，确保AI能看到并据此回应
        content: contextMessageContent,
        parts: [{ type: 'text', text: contextMessageContent }],
        timestamp: Date.now()
    };
    
    // 将显示消息和上下文消息都加入历史
    character.history.push(displayMessage, contextMessage);

    await saveData();

    if (character.id === currentChatId) {
        checkAndUpdateUiForAiBlock();
        // 刷新整个聊天界面以正确显示所有新消息
        renderMessages(false, true); 
        showToast(`${character.remarkName} 已将你解除拉黑`);
    }
}
/**
 * 定时器，用于检查并自动解除到期的AI拉黑
 */
function checkTimedUnblocks() {
    const now = Date.now();
    db.characters.forEach(char => {
        if (char.isBlockedByAi && char.blockEndTime && now >= char.blockEndTime) {
            console.log(`自动解除对 ${char.remarkName} 的拉黑...`);
            deactivateAiBlock(char, true);
        }
    });
}

// ===============================================================
// END: 拉黑功能核心代码
// ===============================================================
let isCheckingInactivity = false;

/**
 * Sets up the main timer for checking user inactivity across all chats.
 */
function setupProactiveAiSystem() {
    // Check every minute
    setInterval(checkAllChatsForInactivity, 60 * 1000);
    console.log("AI后台回复系统已启动。");
}

/**
 * Iterates through all chats and triggers proactive AI actions if conditions are met.
 */
async function checkAllChatsForInactivity() {
    if (isCheckingInactivity) {
        return;
    }
    isCheckingInactivity = true;
    console.log("正在检查用户不活跃聊天...");

    const now = Date.now();
    const allChats = [
        ...db.characters.map(c => ({ chat: c, type: 'private' })),
        ...db.groups.map(g => ({ chat: g, type: 'group' }))
    ];

    for (const { chat, type } of allChats) {
        // 检查此聊天的独立设置
        if (!chat.aiProactiveChatEnabled || !chat.aiProactiveChatDelay || chat.aiProactiveChatDelay <= 0) {
            continue; // 如果此聊天未开启后台回复，则跳过
        }
        
        if (!chat.history || chat.history.length === 0) {
            continue; // 跳过空聊天
        }

        // 找到最后一条来自用户的消息
        const lastUserMessage = [...chat.history].reverse().find(m => m.role === 'user');

        // 如果没有用户消息，则无法判断不活跃状态
        if (!lastUserMessage) {
            continue;
        }

        const timeSinceUserLastSpoke = now - lastUserMessage.timestamp;
        const initialDelayMs = chat.aiProactiveChatDelay * 60 * 1000;

        // 如果用户不活跃的时间尚未达到初始延迟，则跳过
        if (timeSinceUserLastSpoke < initialDelayMs) {
            continue;
        }
        
        // 此时，确认用户已处于不活跃状态，现在判断是否应该发送消息

        const lastMessage = chat.history[chat.history.length - 1];
        const timeSinceLastMessage = now - lastMessage.timestamp;
        // 如果未设置间隔，则默认使用初始延迟作为间隔
        const intervalMs = (chat.aiProactiveChatInterval > 0 ? chat.aiProactiveChatInterval : chat.aiProactiveChatDelay) * 60 * 1000;

        // 在以下两种情况下发送消息：
        // 1. 最后一条消息是用户发的（说明这是第一次触发后台回复）。
        // 2. 最后一条消息是AI发的（说明是后续的后台回复），且距离上次发送已超过设定的间隔时间。
        if (lastMessage.role === 'user' || (lastMessage.role === 'assistant' && timeSinceLastMessage > intervalMs)) {
            console.log(`检测到不活跃聊天: ${chat.name || chat.remarkName}。触发AI后台回复。`);
            
            if (type === 'private') {
                await triggerProactivePrivateReply(chat);
            } else {
                await triggerProactiveGroupReply(chat);
            }
            
            // 等待5秒，避免对API造成过大压力
            await new Promise(resolve => setTimeout(resolve, 5000)); 
        }
    }

    isCheckingInactivity = false;
}

/**
 * Triggers a proactive action for a private chat (either send a message or interact with a Moment).
 * @param {object} character - The character object for the private chat.
 */
async function triggerProactivePrivateReply(character) {
    // 30% chance to interact with a Moment, 70% chance to send a message
    if (Math.random() < 0.3 && window.AppDB_Moments) {
        const success = await triggerProactiveMomentInteraction(character);
        if (!success) {
            await triggerProactiveMessage(character, 'private');
        }
    } else {
        await triggerProactiveMessage(character, 'private');
    }
}

/**
 * Triggers a proactive message for a group chat.
 * @param {object} group - The group object.
 */
async function triggerProactiveGroupReply(group) {
    await triggerProactiveMessage(group, 'group');
}

/**
 * Generates and sends a proactive message from the AI.
 * @param {object} chatObject - The character or group object.
 * @param {string} type - 'private' or 'group'.
 */
// --- 新代码开始 ---

// --- 新代码开始 ---

// --- 新代码开始 ---
async function triggerProactiveMessage(chatObject, type) {
    let systemPrompt = '';
    if (type === 'private') {
        systemPrompt = `[system: 用户 ${chatObject.myName} 已经有段时间没有回复了。请你根据自己的人设和我们之前的对话，主动发起一个新的话题或者用温柔的方式询问对方正在做什么，来重新激活对话。你的回复必须自然，就像是真实的人在关心对方一样。]`;
    } else { // group
        systemPrompt = `[system: 用户 ${chatObject.me.nickname} 已经有段时间没有在群里说话了。请你们（AI成员们）根据各自的人设，开始一段自然的群聊来活跃气氛。对话可以围绕最近的话题，也可以开启一个全新的、符合群聊氛围的话题。]`;
    }
    const proactivePromptMessage = {
        id: `proactive_${Date.now()}`,
        role: 'user',
        content: systemPrompt,
        parts: [{ type: 'text', text: systemPrompt }],
        timestamp: Date.now()
    };
    if (type === 'group') {
        proactivePromptMessage.senderId = 'user_me';
    }
    chatObject.history.push(proactivePromptMessage);

    try {
        let fullSystemPrompt;
        let historyForApi;
        if (type === 'private') {
            fullSystemPrompt = generatePrivateSystemPrompt(chatObject);
            historyForApi = chatObject.history.slice(-chatObject.maxMemory);
        } else {
            fullSystemPrompt = generateGroupSystemPrompt(chatObject);
            historyForApi = chatObject.history.slice(-chatObject.maxMemory);
        }
        const messages = [
            { role: 'system', content: fullSystemPrompt },
            ...historyForApi.map(msg => ({ role: msg.role, content: msg.content }))
        ];
        const aiResponseText = await callAiApi(messages);
        chatObject.history.pop();
        
        const cleanedResponse = await processAiCommands(aiResponseText, chatObject);
        const replies = cleanedResponse.split('\n').filter(line => line.trim() !== '');
        
        // --- 修改：在这里直接处理消息，不再放入队列 ---
        if (replies.length > 0) {
            for (const replyContent of replies) {
                const message = {
                    id: `msg_proactive_${Date.now()}_${Math.random()}`,
                    role: 'assistant',
                    content: replyContent.trim(),
                    parts: [{ type: 'text', text: replyContent.trim() }],
                    timestamp: Date.now(),
                };
                if (type === 'group') {
                    const nameMatch = replyContent.match(/\[(.*?)(?:的消息|的语音|发送的表情包|发来的照片\/视频)：/);
                    if (nameMatch) {
                        const sender = chatObject.members.find(m => m.realName === nameMatch[1] || m.groupNickname === nameMatch[1]);
                        if (sender) {
                            message.senderId = sender.id;
                        }
                    }
                }
                // 直接将消息添加到历史记录
                chatObject.history.push(message);
            }

            // 立即保存数据
            await saveData();

            // 立即刷新聊天列表UI
            renderChatList();
    
            // 最后再发出通知
            addNotificationToQueue({
                avatar: chatObject.avatar,
                text: `<strong>${chatObject.name || chatObject.remarkName}</strong><br>给你发来了一条新消息...`,
                chatId: chatObject.id,
                type: type
            });
        }
        // --- 修改结束 ---

    } catch (error) {
        console.error(`AI后台回复失败 for ${chatObject.name || chatObject.remarkName}:`, error);
        chatObject.history.pop();
    }
}
// --- 新代码结束 ---
// --- 新代码结束 ---
/**
 * Triggers an AI to interact with a user's Moment.
 * @param {object} character - The character object that will perform the interaction.
 * @returns {boolean} - True if an interaction was successfully triggered, false otherwise.
 */
async function triggerProactiveMomentInteraction(character) {
    try {
        const myProfile = loadProfileFromStorage();
        const myId = myProfile.id || 'user';

        const allMoments = await window.AppDB_Moments.moments.toArray();
        const unInteractedMoments = allMoments.filter(m => 
            m.authorId === myId && 
            !m.likes.includes(character.id) && 
            !m.comments.some(c => c.roleId === character.id)
        );

        if (unInteractedMoments.length === 0) {
            console.log(`[后台互动] ${character.remarkName} 找不到可以互动的新动态。`);
            return false;
        }
        
        const momentToInteract = unInteractedMoments.sort((a,b) => b.timestamp - a.timestamp)[0];

        const prompt = `你正在扮演角色“${character.realName}”（人设：${character.persona}）。你刚刚在“动态”里看到了你的朋友“${character.myName}”发布的一条新内容，你还没有和它互动过。
        
# 动态内容
- 作者: ${character.myName}
- 文字: "${momentToInteract.text}"
- 图片描述(如有): "${momentToInteract.imageDesc || '无'}"

# 你的任务
根据你的人设和动态内容，决定是“点赞”还是“评论”。

# 输出格式 (严格遵守)
- 如果决定点赞，你的回复必须是且仅是： [${character.realName}点赞动态：{"momentId":"${momentToInteract.id}"}]
- 如果决定评论，你的回复必须是且仅是： [${character.realName}评论动态：{"momentId":"${momentToInteract.id}", "comment":"这里是你的评论内容"}]
- 绝对不要回复任何其他内容。`;

        const messagesForApi = [{ role: 'user', content: prompt }];
        const aiResponseText = await callAiApi(messagesForApi);

        const likeRegex = /\[(.*?)点赞动态：({.*?})\]/;
        const commentRegex = /\[(.*?)评论动态：({.*?})\]/;

        const likeMatch = aiResponseText.match(likeRegex);
        const commentMatch = aiResponseText.match(commentRegex);

        if (likeMatch) {
            const likeData = JSON.parse(likeMatch[2]);
            await saveMomentLike(likeData.momentId, character.id);
            addNotificationToQueue({
                avatar: character.avatar,
                text: `<strong>${character.remarkName}</strong> 点赞了你的动态`
            });
            console.log(`[后台互动] ${character.remarkName} 点赞了动态 ${likeData.momentId}`);
            return true;
        } else if (commentMatch) {
            const commentData = JSON.parse(commentMatch[2]);
            await saveMomentComment(commentData.momentId, character.id, commentData.comment);
            addNotificationToQueue({
                avatar: character.avatar,
                text: `<strong>${character.remarkName}</strong> 评论了你的动态: ${commentData.comment}`
            });
             console.log(`[后台互动] ${character.remarkName} 评论了动态 ${commentData.momentId}`);
            return true;
        } else {
            console.warn(`[后台互动] AI返回了无效的互动指令: ${aiResponseText}`);
            return false;
        }
    } catch (error) {
        console.error("AI后台动态互动失败:", error);
        return false;
    }
}
// ▼▼▼ 【全新 | V2.0 高级封装版】请将这个函数粘贴到您的JS功能区 ▼▼▼

/**
 * [V2.0 | 高级封装版] 应用所有匹配的渲染规则，支持优先级和链式渲染。
 * @param {string} rawContent - AI返回的原始文本。
 * @param {string} chatId - 当前聊天的ID，用于匹配角色专属规则。
 * @param {string} messageRole - 消息的角色 ('user' 或 'ai')。
 * @returns {Promise<object>} - 返回一个包含渲染结果的对象。
 *   - { isRendered: true, html: '处理后的HTML字符串' }
 *   - { isRendered: false, text: '原始文本' }
 */
// ▼▼▼ 用这个函数，完整替换掉旧的 applyAdvancedRenderingRules 函数 ▼▼▼
function applyAdvancedRenderingRules(rawContent, chatId, messageRole) {
    if (rawContent.trim().startsWith('<') || (!rawContent.includes('[') && !rawContent.includes('{'))) {
        return { isRendered: false, text: rawContent };
    }

    const applicableRules = (db.renderers || [])
        .filter(r =>
            r.enabled &&
            (r.scope || ['ai']).includes(messageRole) &&
            (!r.characterIds || r.characterIds.length === 0 || r.characterIds.includes(chatId)) &&
            r.regex && r.html
        )
        .sort((a, b) => (b.priority || 50) - (a.priority || 50));

    if (applicableRules.length === 0) {
        return { isRendered: false, text: rawContent };
    }
    
    let processedContent = rawContent;
    let hasRendered = false;

    for (const rule of applicableRules) {
        try {
            if (rule.trimStrings && rule.trimStrings.length > 0) {
                rule.trimStrings.forEach(trimStr => {
                    processedContent = processedContent.replaceAll(trimStr, '');
                });
            }
            const flags = (rule.flags || ['g']).join('');
            const regex = new RegExp(rule.regex, flags);
            
            regex.lastIndex = 0;
            if (regex.test(processedContent)) {
                regex.lastIndex = 0;
                processedContent = processedContent.replace(regex, rule.html);
                hasRendered = true;
            }
        } catch (e) {
            console.error(`渲染器规则 "${rule.name}" 执行失败:`, e);
            if (typeof showToast === 'function') {
                showToast(`渲染器规则 "${rule.name}" 执行失败: 正则表达式错误。`);
            }
        }
    }
    
    if (hasRendered) {
        return { isRendered: true, html: processedContent };
    } else {
        return { isRendered: false, text: rawContent };
    }
}
// ===============================================================
// START: 新增AI空间 (AI手机) 功能
// ===============================================================

// --- 全局变量 ---
let currentAiSpaceApp = null;
let currentAiForApp = null;
/**
 * [已更新 V3.0] 设置AI空间所有App的事件监听和核心逻辑 (已集成音乐App)
 */
function setupAiSpaceApps() {
    document.querySelector('[data-target="ai-space-home-screen"]').addEventListener('click', renderAiSpaceHomeScreen);

    document.getElementById('ai-space-app-grid').addEventListener('click', (e) => {
        const appIcon = e.target.closest('.app-icon');
        if (!appIcon) return;
        const appId = appIcon.dataset.appId;
        currentAiSpaceApp = appId;

        switch (appId) {
            case '404':
                const aiCharSelectScreen = document.getElementById('ai-character-select-screen');
                if (aiCharSelectScreen) {
                    aiCharSelectScreen.querySelector('.back-btn').dataset.target = 'ai-space-home-screen';
                }
                renderAiCharacterSelect();
                switchScreen('ai-character-select-screen');
                break;
            case 'browser': case 'photos': case 'wallet':
            case 'signal':  case 'shopping': case 'memo':
            case 'music': // 新增
                openAiSpaceCharacterSelect(appId);
                break;
            default:
                showToast('该App正在开发中...');
                break;
        }
    });

    document.getElementById('ai-space-select-list').addEventListener('click', (e) => {
        const charItem = e.target.closest('.list-item');
        if (!charItem || !charItem.dataset.id) return;
        currentAiForApp = db.characters.find(c => c.id === charItem.dataset.id);
        if (!currentAiForApp) return;
        currentAiForApp.aiSpaceData = currentAiForApp.aiSpaceData || {};

        switch (currentAiSpaceApp) {
            case 'browser':
                document.getElementById('ai-browser-history-title').textContent = `${currentAiForApp.remarkName}的浏览器`;
                if (currentAiForApp.aiSpaceData.browserHistory) renderAiBrowserHistory(currentAiForApp.aiSpaceData.browserHistory);
                else document.getElementById('ai-browser-history-list').innerHTML = `<p class="placeholder-text">点击右上角刷新，生成浏览记录</p>`;
                switchScreen('ai-space-browser-history-screen');
                break;
            case 'photos':
                document.getElementById('ai-photos-album-title').textContent = `${currentAiForApp.remarkName}的相册`;
                if (currentAiForApp.aiSpaceData.photos) renderAiPhotos(currentAiForApp.aiSpaceData.photos);
                else document.getElementById('ai-photos-album-grid').innerHTML = `<p class="placeholder-text">点击右上角刷新，生成相册内容</p>`;
                switchScreen('ai-space-photos-album-screen');
                break;
            case 'wallet':
                document.getElementById('ai-wallet-transactions-title').textContent = `${currentAiForApp.remarkName}的钱包`;
                if (currentAiForApp.aiSpaceData.wallet) renderAiWalletTransactions(currentAiForApp.aiSpaceData.wallet);
                else document.getElementById('ai-wallet-transactions-list').innerHTML = `<p class="placeholder-text">点击右上角刷新，生成消费记录</p>`;
                switchScreen('ai-space-wallet-transactions-screen');
                break;
            case 'signal':
                document.getElementById('ai-signal-title').textContent = `${currentAiForApp.remarkName}的心动讯号`;
                if (currentAiForApp.aiSpaceData.heartSignal) renderAiHeartSignal(currentAiForApp.aiSpaceData.heartSignal);
                else document.getElementById('ai-signal-content').innerHTML = `<p class="placeholder-text">点击右上角按钮，生成心动瞬间</p>`;
                switchScreen('ai-space-signal-screen');
                break;
            case 'shopping':
                document.getElementById('ai-shopping-title').textContent = `${currentAiForApp.remarkName}的购物记录`;
                if (currentAiForApp.aiSpaceData.shopping) renderAiShoppingList(currentAiForApp.aiSpaceData.shopping);
                else document.getElementById('ai-shopping-list').innerHTML = `<p class="placeholder-text">点击右上角按钮，生成购物记录</p>`;
                switchScreen('ai-space-shopping-screen');
                break;
            case 'memo':
                document.getElementById('ai-memo-title').textContent = `${currentAiForApp.remarkName}的备忘录`;
                if (currentAiForApp.aiSpaceData.memos) renderAiMemoList(currentAiForApp.aiSpaceData.memos);
                else document.getElementById('ai-memo-list').innerHTML = `<p class="placeholder-text">点击右上角按钮，生成备忘录</p>`;
                switchScreen('ai-space-memo-screen');
                break;
            case 'music': // 新增
                document.getElementById('ai-music-playlist-title').textContent = `${currentAiForApp.remarkName}的歌单`;
                if (currentAiForApp.aiSpaceData.musicPlaylist) renderAiMusicPlaylist(currentAiForApp.aiSpaceData.musicPlaylist);
                else document.getElementById('ai-music-playlist-list').innerHTML = `<p class="placeholder-text">点击右上角按钮，生成歌单</p>`;
                switchScreen('ai-space-music-screen');
                break;
        }
    });

    setupAiBrowserApp();
    setupAiPhotosApp();
    setupAiWalletApp();
    setupAiSignalApp();
    setupAiShoppingApp();
    setupAiMemoApp();
    setupAiMusicApp(); // 新增
}

function renderAiSpaceHomeScreen() {
    const grid = document.getElementById('ai-space-app-grid');
    grid.innerHTML = '';
    
    // 修改：只保留ID列表，不再硬编码图标URL和名称
    const appIds = [
        'ai-space-404', 'ai-space-browser', 'ai-space-photos', 'ai-space-wallet',
        'ai-space-shopping', 'ai-space-memo', 'ai-space-signal', 'ai-space-music', 'ai-space-phone'
    ];

    appIds.forEach(appId => {
        // 新增：从中央图标库读取数据
        const defaultAppInfo = defaultIcons[appId];
        const customIconUrl = db.customIcons[appId];
        const finalIconUrl = customIconUrl || defaultAppInfo.icon;
        const appName = defaultAppInfo.name;
        // appId 里的 'ai-space-' 前缀只是为了区分，实际功能ID不需要这个前缀
        const functionalAppId = appId.replace('ai-space-', ''); 

        const iconEl = document.createElement('a');
        iconEl.href = '#';
        iconEl.className = 'app-icon';
        iconEl.dataset.appId = functionalAppId; // 使用不带前缀的ID来触发功能
        iconEl.innerHTML = `
            <img src="${finalIconUrl}" alt="${appName}" class="icon-img">
            <span class="app-name">${appName}</span>
        `;
        grid.appendChild(iconEl);
    });
}
/**
 * [已更新 V3.0] 打开通用的AI选择列表页面
 */
function openAiSpaceCharacterSelect(appName) {
    const titles = {
        browser: '查看谁的浏览器',
        photos: '查看谁的相册',
        wallet: '查看谁的钱包',
        signal: '选择心动对象',
        shopping: '查看谁的购物记录',
        memo: '查看谁的备忘录',
        music: '听谁的歌单' // 新增
    };
    document.getElementById('ai-space-select-title').textContent = titles[appName] || '选择AI';
    
    const list = document.getElementById('ai-space-select-list');
    list.innerHTML = '';

    db.characters.forEach(char => {
        const li = document.createElement('li');
        li.className = 'list-item';
        li.dataset.id = char.id;
        li.innerHTML = `
            <img src="${char.avatar}" class="chat-avatar">
            <div class="item-details">
                <div class="item-name">${char.remarkName}</div>
            </div>
        `;
        list.appendChild(li);
    });
    
    switchScreen('ai-space-character-select-screen');
}

// --- 浏览器 App (已修复详情页不显示正文的问题) ---
function setupAiBrowserApp() {
    // 刷新按钮的事件监听保持不变
    document.getElementById('refresh-browser-history-btn').addEventListener('click', async () => {
        if (!currentAiForApp) return;
        const { url, key, model } = db.apiSettings;
        if (!url || !key || !model) {
            showToast('请先在主界面的“api”应用中完成设置！');
            switchScreen('api-settings-screen');
            return;
        }
        
        const list = document.getElementById('ai-browser-history-list');
        list.innerHTML = `<p class="placeholder-text">正在生成 ${currentAiForApp.remarkName} 的浏览记录...</p>`;

        try {
            const prompt = generateAiBrowserHistoryPrompt(currentAiForApp);
            const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
            const historyData = JSON.parse(aiResponseText.match(/\[[\s\S]*\]/)[0]);
            
            currentAiForApp.aiSpaceData = currentAiForApp.aiSpaceData || {};
            currentAiForApp.aiSpaceData.browserHistory = historyData;
            await saveData();

            renderAiBrowserHistory(historyData);
        } catch (error) {
            console.error("生成AI浏览记录失败:", error);
            showToast(`生成失败: ${error.message}`);
            list.innerHTML = `<p class="placeholder-text" style="color:red;">生成失败</p>`;
        }
    });

    // 列表点击事件（核心修正点）
    document.getElementById('ai-browser-history-list').addEventListener('click', (e) => {
        const item = e.target.closest('.list-item');
        if (item && item.dataset.index) {
            const index = parseInt(item.dataset.index, 10);
            const history = currentAiForApp.aiSpaceData.browserHistory[index];
            if (history) {
                document.getElementById('ai-browser-detail-query').textContent = history.query;
                // ▼▼▼ 核心修正：将 history.result 修改为 history.contentDetail ▼▼▼
                document.getElementById('ai-browser-detail-content').textContent = history.contentDetail;
                // ▲▲▲ 修正结束 ▲▲▲
                switchScreen('ai-space-browser-detail-screen');
            }
        }
    });
}

/**
 * [已更新 V3.0] 渲染AI浏览器历史记录 (带模拟链接)
 */
function renderAiBrowserHistory(history) {
    const list = document.getElementById('ai-browser-history-list');
    list.innerHTML = '';
    history.forEach((item, index) => {
        const li = document.createElement('li');
        li.className = 'list-item';
        li.dataset.index = index;
        li.innerHTML = `
            <div class="item-details">
                <div class="item-name" style="font-weight: normal; font-size: 16px;">${item.query}</div>
                <div class="item-preview" style="color: #0066CC; font-size: 14px;">${item.simulatedUrl}</div>
            </div>
        `;
        list.appendChild(li);
    });
}


// --- 新代码开始 ---
function generateAiBrowserHistoryPrompt(character) {
    // --- 新增：获取最近的聊天记录作为上下文 ---
    const memory = character.history.slice(-15);
    let historyText = memory.map(msg => {
        const sender = msg.role === 'user' ? character.myName : character.remarkName;
        const contentMatch = msg.content.match(/\[.*?的消息：([\s\S]+?)\]/);
        const cleanContent = contentMatch ? contentMatch[1] : msg.content;
        return `${sender}: ${cleanContent}`;
    }).join('\n');
    // --- 新增结束 ---

    // --- 修改：更新了Prompt指令 ---
    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。
请根据你的人设以及和“我”（${character.myName}）**最近的聊天记录**，虚构一个包含**10条**的浏览器搜索记录列表。

# 规则:
1.  每条记录都要**非常贴合你的人设和我们的对话上下文**。
2.  至少有**3-4条**记录需要与“我”（${character.myName}）或我们聊到的话题直接相关。
3.  每条记录包含：
    - "query": 搜索的关键词。
    - "simulatedUrl": 一个看起来很真实的、虚构的网址。
    - "contentDetail": 一段详细的、**第一人称叙事风格**的“网页”内容，字数不少于150字。这段内容要能反映出你搜索这个词时的心境和目的。
4.  你的输出必须是严格的JSON数组格式，不要包含任何其他文字。

# 最近的聊天记录参考:
${historyText}

# JSON格式示例:
[
  {
    "query": "天蝎座爱情观分析",
    "simulatedUrl": "www.astro.com/zodiac/scorpio-love",
    "contentDetail": "最近总觉得有点看不透他，所以偷偷来查了一下。文章说天蝎座在感情里占有欲很强，外冷内热，一旦爱上就会非常专一。这几点好像还真的有点像他...文章还说他们不轻易表达爱意，但会用行动证明。也许我应该多观察一下细节，而不是总是在意他嘴上说了什么。不过，看到“记仇”这一点，我还是忍不住笑了，下次可不敢惹他生气了。"
  }
]`;
    // --- 修改结束 ---
    
    return prompt;
}
// --- 新代码结束 ---
function setupAiPhotosApp() {
    document.getElementById('refresh-photos-album-btn').addEventListener('click', async () => {
        if (!currentAiForApp) return;
        const { url, key, model } = db.apiSettings;
        if (!url || !key || !model) {
            showToast('请先在主界面的“api”应用中完成设置！');
            switchScreen('api-settings-screen');
            return;
        }

        const grid = document.getElementById('ai-photos-album-grid');
        grid.innerHTML = `<p class="placeholder-text">正在生成 ${currentAiForApp.remarkName} 的相册...</p>`;
        
        try {
            const prompt = generateAiPhotosPrompt(currentAiForApp);
            const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
            const photosData = JSON.parse(aiResponseText.match(/\[[\s\S]*\]/)[0]);

            // 核心修改：保存到缓存
            currentAiForApp.aiSpaceData.photos = photosData;
            await saveData();

            renderAiPhotos(photosData);
        } catch (error) {
            console.error("生成AI相册失败:", error);
            showToast(`生成失败: ${error.message}`);
            grid.innerHTML = `<p class="placeholder-text" style="color:red;">生成失败</p>`;
        }
    });

    document.getElementById('ai-photos-album-grid').addEventListener('click', (e) => {
        const item = e.target.closest('.ai-photo-item');
        if (item && item.dataset.index) {
            const index = parseInt(item.dataset.index, 10);
            const photo = currentAiForApp.aiSpaceData.photos[index];
            if (photo) {
                document.getElementById('ai-photo-detail-title').textContent = photo.title;
                document.getElementById('ai-photo-detail-content').textContent = photo.description;
                document.getElementById('ai-space-photo-detail-modal').classList.add('visible');
            }
        }
    });

    document.getElementById('close-ai-photo-detail-btn').addEventListener('click', () => {
        document.getElementById('ai-space-photo-detail-modal').classList.remove('visible');
    });
}

function renderAiPhotos(photos) {
    const grid = document.getElementById('ai-photos-album-grid');
    grid.innerHTML = '';
    photos.forEach((photo, index) => {
        const item = document.createElement('div');
        item.className = 'ai-photo-item';
        item.dataset.index = index;
        item.textContent = photo.title;
        grid.appendChild(item);
    });
}

function generateAiPhotosPrompt(character) {
    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。
请根据你的人设和生活，虚构一个包含6-9张“照片”的相册。这些不是真正的图片，而是用文字描述的照片内容。
规则:
1. 每张“照片”都是一段文字描述，要生动、富有画面感。
2. 至少有1-2张“照片”与我（${character.myName}）有关。
3. 每张“照片”包含一个简短的标题(title)和一段详细的描述(description)。
4. 你的输出必须是严格的JSON数组格式，不要包含任何其他文字。

JSON格式示例:
[
  {"title": "窗边的猫", "description": "午后的阳光洒在窗台上，我的猫懒洋洋地蜷缩成一团，尾巴尖偶尔轻轻晃动。空气中弥漫着安逸的味道。"},
  {"title": "他送的杯子", "description": "他上次送我的那个马克杯就放在书桌上，里面泡着热气腾腾的红茶。每次看到它，嘴角都会不自觉地上扬。"}
]`;
    return prompt;
}
// --- 心动讯号 App (已更新缓存逻辑) ---
function setupAiSignalApp() {
    document.getElementById('refresh-signal-btn').addEventListener('click', async () => {
        if (!currentAiForApp) return;
        const { url, key, model } = db.apiSettings;
        if (!url || !key || !model) {
            showToast('请先在主界面的“api”应用中完成设置！');
            switchScreen('api-settings-screen');
            return;
        }
        
        const contentEl = document.getElementById('ai-signal-content');
        contentEl.innerHTML = `<p class="placeholder-text">正在捕捉 ${currentAiForApp.remarkName} 的心动瞬间...</p>`;

        try {
            const prompt = generateAiHeartSignalPrompt(currentAiForApp);
            const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
            const signalData = JSON.parse(aiResponseText.match(/{[\s\S]*}/)[0]);
            
            // 核心修改：保存到缓存
            currentAiForApp.aiSpaceData.heartSignal = signalData;
            await saveData();

            renderAiHeartSignal(signalData);
        } catch (error) {
            console.error("生成心动讯号失败:", error);
            showToast(`生成失败: ${error.message}`);
            contentEl.innerHTML = `<p class="placeholder-text" style="color:red;">生成失败</p>`;
        }
    });
}


function renderAiHeartSignal(signal) {
    const contentEl = document.getElementById('ai-signal-content');
    contentEl.innerHTML = `
        <details>
            <summary style="font-weight: bold; color: var(--secondary-color); cursor: pointer; font-size: 16px;">心动瞬间</summary>
            <p style="padding-top: 10px;">${signal.moment}</p>
        </details>
        <hr style="border: none; border-top: 1px solid #f0f0f0; margin: 15px 0;">
        <details>
            <summary style="font-weight: bold; color: var(--secondary-color); cursor: pointer; font-size: 16px;">内心想法</summary>
            <p style="padding-top: 10px; font-style: italic; color: #555;">“${signal.thoughts}”</p>
        </details>
    `;
}

function generateAiHeartSignalPrompt(character) {
    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。
请根据你的人设以及和“我”（${character.myName}）的关系，回忆一个最近让你对我感到心动的瞬间，并写下你当时的内心想法。
规则:
1. “心动瞬间”是对一个具体事件的描述，要生动、有画面感。
2. “内心想法”是第一人称的心理活动，要深刻体现你的性格和情感。
3. 两段内容合计字数不得少于200字。
4. 你的输出必须是严格的JSON格式，不要包含任何其他文字。

JSON格式示例:
{
  "moment": "今天下午，阳光正好，我看到他坐在窗边安静地看书，阳光洒在他的侧脸上，那一刻时间仿佛都静止了...",
  "thoughts": "我当时就想，如果时间能永远停在这一刻就好了。他专注的样子真的好吸引人，连他翻书时轻轻皱眉的小动作都让我觉得可爱。心里像揣了一只小兔子，扑通扑通的，有点想走过去从背后抱住他，但又怕打扰到他..."
}`;
    return prompt;
}

// ===============================================================
// START: 新增AI空间 - 音乐App功能
// ===============================================================

function setupAiMusicApp() {
    document.getElementById('refresh-music-playlist-btn').addEventListener('click', async () => {
        if (!currentAiForApp) return;
        const { url, key, model } = db.apiSettings;
        if (!url || !key || !model) {
            showToast('请先在主界面的“api”应用中完成设置！');
            switchScreen('api-settings-screen');
            return;
        }
        
        const list = document.getElementById('ai-music-playlist-list');
        list.innerHTML = `<p class="placeholder-text">正在为 ${currentAiForApp.remarkName} 生成歌单...</p>`;

        try {
            const prompt = generateAiMusicPlaylistPrompt(currentAiForApp);
            const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
            const playlistData = JSON.parse(aiResponseText.match(/\[[\s\S]*\]/)[0]);
            
            // 保存到缓存
            currentAiForApp.aiSpaceData = currentAiForApp.aiSpaceData || {};
            currentAiForApp.aiSpaceData.musicPlaylist = playlistData;
            await saveData();

            renderAiMusicPlaylist(playlistData);
        } catch (error) {
            console.error("生成AI歌单失败:", error);
            showToast(`生成失败: ${error.message}`);
            list.innerHTML = `<p class="placeholder-text" style="color:red;">生成失败</p>`;
        }
    });
}

/**
 * [已更新 V3.0] 渲染AI的歌单列表 (增加点击播放功能)
 */
function renderAiMusicPlaylist(playlist) {
    const list = document.getElementById('ai-music-playlist-list');
    list.innerHTML = '';
    playlist.forEach((song, index) => {
        const li = document.createElement('li');
        li.className = 'list-item';
        li.style.cursor = 'pointer'; // 让列表项看起来可以点击

        li.innerHTML = `
            <div class="item-details">
                <div class="item-name">${song.title}</div>
                <div class="item-preview">${song.artist}</div>
            </div>
        `;

        // --- 核心新增：为每个列表项添加点击事件监听 ---
        li.addEventListener('click', async () => {
            // 这是一个简化的播放逻辑，它会尝试将AI歌单的歌曲添加到主播放器并播放
            // 假设AI生成的歌曲名和艺术家是准确的
            
            // 1. 检查主播放列表（db.playlist）中是否已存在这首歌
            let existingSong = db.playlist.find(s => s.name === song.title && s.artist === song.artist);

            if (existingSong) {
                // 如果已存在，直接找到它的索引并播放
                const songIndex = db.playlist.indexOf(existingSong);
                if (typeof playSong === 'function') {
                    playSong(songIndex);
                }
                showToast(`正在播放 ${song.title}`);
            } else {
                // 如果不存在，提示用户需要手动添加
                showToast(`歌单中没有找到《${song.title}》的音源，请在主播放器中手动添加。`);
                // （高级功能：未来可以扩展此处，调用API搜索音乐并自动添加）
            }

            // 打开主音乐播放器弹窗
            const musicModal = document.getElementById('music-player-modal');
            if (musicModal) {
                musicModal.classList.add('visible');
            }
        });
        // --- 新增逻辑结束 ---

        list.appendChild(li);
    });
}

function generateAiMusicPlaylistPrompt(character) {
    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。
请根据你的人设、性格和最近的心情，创建一个包含5-8首歌曲的私人歌单。
规则:
1. 歌单的选曲风格必须**非常贴合你的人设**。例如，忧郁的角色可能会选择悲伤的民谣，而活泼的角色可能会选择流行舞曲。
2. 每首歌需要包含“歌曲名(title)”和“艺术家(artist)”。
3. 你的输出必须是严格的JSON数组格式，不要包含任何其他文字。

JSON格式示例:
[
  {"title": "夜曲", "artist": "周杰伦"},
  {"title": "Summertime Sadness", "artist": "Lana Del Rey"},
  {"title": "关键词", "artist": "林俊杰"}
]`;
    return prompt;
}

// ===============================================================
// END: 新增AI空间 - 音乐App功能
// ===============================================================
// --- 购物 App (已更新缓存逻辑) ---
function setupAiShoppingApp() {
    document.getElementById('refresh-shopping-btn').addEventListener('click', async () => {
        if (!currentAiForApp) return;
        const { url, key, model } = db.apiSettings;
        if (!url || !key || !model) {
            showToast('请先在主界面的“api”应用中完成设置！');
            switchScreen('api-settings-screen');
            return;
        }
        
        const list = document.getElementById('ai-shopping-list');
        list.innerHTML = `<p class="placeholder-text">正在生成 ${currentAiForApp.remarkName} 的购物记录...</p>`;

        try {
            const prompt = generateAiShoppingListPrompt(currentAiForApp);
            const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
            const shoppingData = JSON.parse(aiResponseText.match(/\[[\s\S]*\]/)[0]);
            
            // 核心修改：保存到缓存
            currentAiForApp.aiSpaceData.shopping = shoppingData;
            await saveData();

            renderAiShoppingList(shoppingData);
        } catch (error) {
            console.error("生成购物记录失败:", error);
            showToast(`生成失败: ${error.message}`);
            list.innerHTML = `<p class="placeholder-text" style="color:red;">生成失败</p>`;
        }
    });
}

/**
 * [已更新 V2.0] 渲染购物记录列表 (带折叠功能)
 */
function renderAiShoppingList(items) {
    const list = document.getElementById('ai-shopping-list');
    list.innerHTML = '';
    items.forEach((item, index) => {
        // 使用<details>和<summary>标签创建可折叠列表项
        const details = document.createElement('details');
        details.className = 'list-item'; // 复用现有样式
        details.innerHTML = `
            <summary class="item-details" style="cursor: pointer;">
                <div class="item-name">${item.name}</div>
            </summary>
            <div class="item-preview" style="white-space: normal; padding: 10px 15px; margin-top: 5px; background-color: #f9f9f9; border-radius: 8px;">
                <strong>用途：</strong>${item.purpose}
            </div>
        `;
        list.appendChild(details);
    });
}


function generateAiShoppingListPrompt(character) {
    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。
请根据你的人设和最近的生活状态，虚构一个包含3-5件你最近购买的物品的列表。
规则:
1. 购买的物品要符合你的性格和身份。
2. 至少有一件物品是为“我”（${character.myName}）购买的。
3. 每件物品都需要写明具体的“名称(name)”和“购买用途(purpose)”。
4. 你的输出必须是严格的JSON数组格式，不要包含任何其他文字。

JSON格式示例:
[
  {"name": "一本《天体物理学入门》", "purpose": "最近对星星很感兴趣，买来晚上睡前看一看。"},
  {"name": "一条深蓝色的围巾", "purpose": "天气转凉了，感觉这个颜色很适合${character.myName}，打算作为惊喜送给他。"},
  {"name": "高品质的猫粮", "purpose": "家里的猫主子最近有点挑食，换个口味给它尝尝。"}
]`;
    return prompt;
}


// --- 备忘录 App ---
function setupAiMemoApp() {
    document.getElementById('refresh-memo-btn').addEventListener('click', async () => {
        if (!currentAiForApp) return;
        const { url, key, model } = db.apiSettings;
        if (!url || !key || !model) {
            showToast('请先在主界面的“api”应用中完成设置！');
            switchScreen('api-settings-screen');
            return;
        }
        
        const list = document.getElementById('ai-memo-list');
        list.innerHTML = `<p class="placeholder-text">正在生成 ${currentAiForApp.remarkName} 的备忘录...</p>`;

        try {
            const prompt = generateAiMemoPrompt(currentAiForApp);
            const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
            const memoData = JSON.parse(aiResponseText.match(/\[[\s\S]*\]/)[0]);
            
            // 核心修改：保存到缓存
            currentAiForApp.aiSpaceData.memos = memoData;
            await saveData();

            renderAiMemoList(memoData);
        } catch (error) {
            console.error("生成备忘录失败:", error);
            showToast(`生成失败: ${error.message}`);
            list.innerHTML = `<p class="placeholder-text" style="color:red;">生成失败</p>`;
        }
    });
}


/**
 * [已更新 V2.0] 渲染备忘录列表 (带折叠功能)
 */
function renderAiMemoList(memos) {
    const list = document.getElementById('ai-memo-list');
    list.innerHTML = '';
    memos.forEach((memo, index) => {
        const details = document.createElement('details');
        details.className = 'list-item';
        details.innerHTML = `
             <summary class="item-details" style="cursor: pointer;">
                <div class="item-name">${memo.title}</div>
            </summary>
            <div class="item-preview" style="white-space: normal; line-height: 1.7; padding: 10px 15px; margin-top: 5px; background-color: #f9f9f9; border-radius: 8px;">
                ${memo.content}
            </div>
        `;
        list.appendChild(details);
    });
}
function generateAiMemoPrompt(character) {
    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。
请根据你的人设和记忆，写下2-4条你认为重要或难忘事情的备忘录。
规则:
1. 备忘录内容要符合你的性格，并且至少有一条与“我”（${character.myName}）有关。
2. 每条备忘录包含一个标题(title)和一段详细内容(content)。
3. 每条备忘录的“content”部分，字数不得少于100字。
4. 你的输出必须是严格的JSON数组格式，不要包含任何其他文字。

JSON格式示例:
[
  {
    "title": "关于那次海边的约定",
    "content": "还记得上次和他说起想去看海的事。他说等天气好了就带我去。虽然只是随口一提，但我一直记在心里。我偷偷查了天气预报，下周末天气似乎不错。到时候要不要提醒他一下呢？还是等他自己想起来？我有点期待，又有点怕他忘记了。如果他真的忘了，我可能会有点小失落吧。但不管怎样，能和他有这样的约定，本身就是一件很开心的事了。"
  },
  {
    "title": "新书的灵感",
    "content": "今天在咖啡馆坐了一下午，终于有了一些关于新书的灵感。主角的性格可以更复杂一些，不仅仅是单纯的善良。或许可以加入一些灰色的地带，让他面临更艰难的选择。故事的转折点可以设置在一个雨夜，一场意外的相遇彻底改变他的人生轨迹。我需要把这些零碎的想法记录下来，不然很快就会忘记。希望这次能写出一个让自己满意的故事。"
  }
]`;
    return prompt;
}
// --- 钱包 App (已更新缓存逻辑) ---
function setupAiWalletApp() {
    document.getElementById('refresh-wallet-transactions-btn').addEventListener('click', async () => {
        if (!currentAiForApp) return;
        const { url, key, model } = db.apiSettings;
        if (!url || !key || !model) {
            showToast('请先在主界面的“api”应用中完成设置！');
            switchScreen('api-settings-screen');
            return;
        }

        const list = document.getElementById('ai-wallet-transactions-list');
        list.innerHTML = `<p class="placeholder-text">正在生成 ${currentAiForApp.remarkName} 的消费记录...</p>`;

        try {
            const prompt = generateAiWalletTransactionsPrompt(currentAiForApp);
            const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
            const transactionsData = JSON.parse(aiResponseText.match(/\[[\s\S]*\]/)[0]);

            // 核心修改：保存到缓存
            currentAiForApp.aiSpaceData.wallet = transactionsData;
            await saveData();

            renderAiWalletTransactions(transactionsData);
        } catch (error) {
            console.error("生成AI消费记录失败:", error);
            showToast(`生成失败: ${error.message}`);
            list.innerHTML = `<p class="placeholder-text" style="color:red;">生成失败</p>`;
        }
    });

    document.getElementById('ai-wallet-transactions-list').addEventListener('click', (e) => {
        const item = e.target.closest('.list-item');
        if (item && item.dataset.index) {
            const index = parseInt(item.dataset.index, 10);
            const tx = currentAiForApp.aiSpaceData.wallet[index];
            if (tx) {
                document.getElementById('ai-wallet-detail-description').textContent = tx.description;
                const amountEl = document.getElementById('ai-wallet-detail-amount');
                amountEl.textContent = `${tx.type === 'expense' ? '-' : '+'}${tx.amount.toFixed(2)}`;
                amountEl.className = tx.type;
                document.getElementById('ai-wallet-detail-status').textContent = tx.status;
                document.getElementById('ai-wallet-detail-time').textContent = tx.time;
                document.getElementById('ai-wallet-detail-peer').textContent = tx.peer;
                document.getElementById('ai-space-wallet-detail-modal').classList.add('visible');
            }
        }
    });
document.getElementById('close-ai-wallet-detail-btn').addEventListener('click', () => {
        document.getElementById('ai-space-wallet-detail-modal').classList.remove('visible');
    });
}


function renderAiWalletTransactions(transactions) {
    const list = document.getElementById('ai-wallet-transactions-list');
    list.innerHTML = '';
    transactions.forEach((tx, index) => {
        const li = document.createElement('li');
        li.className = 'list-item ai-transaction-item';
        li.dataset.index = index;
        const amountSign = tx.type === 'expense' ? '-' : '+';
        li.innerHTML = `
            <div class="item-details">
                <div>
                    <div class="item-name">${tx.description}</div>
                    <div class="item-preview">${tx.time}</div>
                </div>
                <span class="ai-transaction-amount ${tx.type}">${amountSign}${tx.amount.toFixed(2)}</span>
            </div>
        `;
        list.appendChild(li);
    });
}

function generateAiWalletTransactionsPrompt(character) {
    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。
请根据你的人设和可能的生活消费习惯，虚构一个包含5-8条的钱包账单列表。
规则:
1. 消费记录要符合你的身份和近期活动。
2. 至少有一笔支出是关于我（${character.myName}）的，比如“购买给${character.myName}的礼物”。
3. 每条记录包含类型(type: 'expense'或'income')、金额(amount)、简短描述(description)、交易对方(peer)、状态(status)和时间(time)。
4. 你的输出必须是严格的JSON数组格式，不要包含任何其他文字。

JSON格式示例:
[
  {"type": "expense", "amount": 89.00, "description": "购买书籍", "peer": "线上书店", "status": "交易成功", "time": "今天 10:05"},
  {"type": "income", "amount": 500.00, "description": "稿费收入", "peer": "XX出版社", "status": "已到账", "time": "昨天 15:20"},
  {"type": "expense", "amount": 128.00, "description": "给${character.myName}挑选的生日礼物", "peer": "精品店", "status": "交易成功", "time": "三天前"}
]`;
    return prompt;
}

// ===============================================================
// END: AI空间功能
// ===============================================================
        init();
    });
    // ===============================================================
// START: 新增AI空间 - 音乐App功能
// ===============================================================

function setupAiMusicApp() {
    document.getElementById('refresh-music-playlist-btn').addEventListener('click', async () => {
        if (!currentAiForApp) return;
        const { url, key, model } = db.apiSettings;
        if (!url || !key || !model) {
            showToast('请先在主界面的“api”应用中完成设置！');
            switchScreen('api-settings-screen');
            return;
        }
        
        const list = document.getElementById('ai-music-playlist-list');
        list.innerHTML = `<p class="placeholder-text">正在为 ${currentAiForApp.remarkName} 生成歌单...</p>`;

        try {
            const prompt = generateAiMusicPlaylistPrompt(currentAiForApp);
            const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
            const playlistData = JSON.parse(aiResponseText.match(/\[[\s\S]*\]/)[0]);
            
            // 保存到缓存
            currentAiForApp.aiSpaceData = currentAiForApp.aiSpaceData || {};
            currentAiForApp.aiSpaceData.musicPlaylist = playlistData;
            await saveData();

            renderAiMusicPlaylist(playlistData);
        } catch (error) {
            console.error("生成AI歌单失败:", error);
            showToast(`生成失败: ${error.message}`);
            list.innerHTML = `<p class="placeholder-text" style="color:red;">生成失败</p>`;
        }
    });
}

function renderAiMusicPlaylist(playlist) {
    const list = document.getElementById('ai-music-playlist-list');
    list.innerHTML = '';
    playlist.forEach((song, index) => {
        const li = document.createElement('li');
        li.className = 'list-item';
        li.innerHTML = `
            <div class="item-details">
                <div class="item-name">${song.title}</div>
                <div class="item-preview">${song.artist}</div>
            </div>
        `;
        list.appendChild(li);
    });
}

function generateAiMusicPlaylistPrompt(character) {
    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。
请根据你的人设、性格和最近的心情，创建一个包含5-8首歌曲的私人歌单。
规则:
1. 歌单的选曲风格必须**非常贴合你的人设**。例如，忧郁的角色可能会选择悲伤的民谣，而活泼的角色可能会选择流行舞曲。
2. 每首歌需要包含“歌曲名(title)”和“艺术家(artist)”。
3. 你的输出必须是严格的JSON数组格式，不要包含任何其他文字。

JSON格式示例:
[
  {"title": "夜曲", "artist": "周杰伦"},
  {"title": "Summertime Sadness", "artist": "Lana Del Rey"},
  {"title": "关键词", "artist": "林俊杰"}
]`;
    return prompt;
}

// ===============================================================
// END: 新增AI空间 - 音乐App功能
// ===============================================================
// ===============================================================
// START: 交换日记App功能 (V3.0 - 日记本滑动版)
// ===============================================================
function setupDiaryExchangeApp() {
    // --- DOM元素缓存 ---
    const writeModal = document.getElementById('write-diary-exchange-modal');
    const writeForm = document.getElementById('diary-exchange-form');
    const imageUpload = document.getElementById('exchange-diary-image-upload');
    const imagePreview = document.getElementById('exchange-diary-image-preview');
    const submitBtn = writeForm.querySelector('button[type="submit"]');
    const listContainer = document.getElementById('diary-exchange-list-container');
    const viewerModal = document.getElementById('diary-exchange-viewer-modal');

    let tempImageDataUrl = null; 

    // --- 事件绑定 ---

    // 打开撰写日记弹窗
    document.getElementById('write-new-exchange-btn').addEventListener('click', () => {
        writeForm.reset();
        imagePreview.style.display = 'none';
        imagePreview.style.backgroundImage = 'none';
        tempImageDataUrl = null;
        submitBtn.disabled = false;
        writeModal.classList.add('visible');
    });

    // 处理图片选择
    imageUpload.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
            try {
                const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 800, maxHeight: 800 });
                tempImageDataUrl = compressedUrl;
                imagePreview.style.backgroundImage = `url(${compressedUrl})`;
                imagePreview.style.display = 'block';
            } catch (error) {
                showToast('图片处理失败');
                tempImageDataUrl = null;
            }
        }
    });

    // 处理日记发送
    writeForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
        const character = db.characters.find(c => c.id === characterId);
        if (!character) return;

        const userContent = document.getElementById('exchange-diary-content').value.trim();
        if (!userContent) {
            showToast('日记内容不能为空');
            return;
        }

        submitBtn.disabled = true;
        writeModal.classList.remove('visible');
        showToast('正在发送日记，请稍候...');

        try {
            const prompt = generateDiaryExchangePrompt(character, userContent, tempImageDataUrl);
            
            let messagesForApi;
            if (db.apiSettings.provider === 'claude' && tempImageDataUrl) {
                const base64Match = tempImageDataUrl.match(/^data:(image\/.+);base64,(.*)$/);
                messagesForApi = [{ role: 'user', content: [{ type: 'text', text: prompt }, { type: 'image', source: { type: 'base64', media_type: base64Match[1], data: base64Match[2] } }] }];
            } else {
                 messagesForApi = [{ role: 'user', content: prompt }];
            }

            const aiResponseText = await callAiApi(messagesForApi);
            
            // AI返回的数据可能包含封面信息
            const responseData = JSON.parse(aiResponseText);

            const newExchange = {
                id: `exchange_${Date.now()}`,
                timestamp: Date.now(),
                userEntry: userContent,
                userImage: tempImageDataUrl,
                aiReply: responseData.diaryContent, // 提取日记正文
                coverImage: `https://image.pollinations.ai/prompt/${encodeURIComponent(responseData.coverImagePrompt)}`, // 生成封面图片
                coverTitle: responseData.coverTitle // 提取封面标题
            };

            character.soulBondData.diaryExchanges = character.soulBondData.diaryExchanges || [];
            character.soulBondData.diaryExchanges.unshift(newExchange);

            await saveData();
            renderDiaryExchanges();
            showToast('交换日记已收到回复！');

        } catch (error) {
            console.error("交换日记失败:", error);
            showToast(`发送失败: ${error.message}`);
        } finally {
            submitBtn.disabled = false;
        }
    });

    // 使用事件委托处理日记本的点击和长按
    let longPressTimer;
    const handleLongPress = async (targetElement) => {
        const diaryBook = targetElement.closest('.diary-book');
        if (!diaryBook) return;
        const exchangeId = diaryBook.dataset.id;
        
        if (confirm('确定要删除这本日记吗？')) {
            const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
            const character = db.characters.find(c => c.id === characterId);
            if (character && character.soulBondData) {
                character.soulBondData.diaryExchanges = character.soulBondData.diaryExchanges.filter(ex => ex.id !== exchangeId);
                await saveData();
                renderDiaryExchanges();
                showToast('交换日记已删除');
            }
        }
    };
    
    listContainer.addEventListener('click', (e) => {
        const diaryBook = e.target.closest('.diary-book');
        if (diaryBook) {
            openDiaryViewer(diaryBook.dataset.id);
        }
    });
    listContainer.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        handleLongPress(e.target);
    });
    listContainer.addEventListener('touchstart', (e) => {
        longPressTimer = setTimeout(() => handleLongPress(e.target), 500);
    });
    listContainer.addEventListener('touchend', () => clearTimeout(longPressTimer));
    listContainer.addEventListener('touchmove', () => clearTimeout(longPressTimer));

    // 关闭查看器
    document.getElementById('close-diary-viewer-btn').addEventListener('click', () => {
        viewerModal.classList.remove('visible');
    });
}
// ===============================================================
// END: 交换日记App功能 (V2.0)
// 渲染交换日记列表 (V3.0 - 日记本样式)
function renderDiaryExchanges() {
    const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
    const character = db.characters.find(c => c.id === characterId);
    const container = document.getElementById('diary-exchange-list-container');
    const placeholder = document.getElementById('no-diary-exchanges-placeholder');

    if (!character || !character.soulBondData || !character.soulBondData.diaryExchanges || character.soulBondData.diaryExchanges.length === 0) {
        container.innerHTML = '';
        placeholder.style.display = 'block';
        return;
    }

    placeholder.style.display = 'none';
    container.innerHTML = '';
    
    character.soulBondData.diaryExchanges.forEach(exchange => {
        const bookDiv = document.createElement('div');
        bookDiv.className = 'diary-book';
        bookDiv.dataset.id = exchange.id;
        
        const date = new Date(exchange.timestamp);
        const dateString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;

        bookDiv.innerHTML = `
            <div class="diary-book-inner">
                <div class="diary-book-cover" style="background-image: url('${exchange.coverImage}')">
                    <span class="cover-date">${dateString}</span>
                    <h4 class="cover-title">${exchange.coverTitle || '我们的日记'}</h4>
                    <span class="cover-authors">${character.myName} & ${character.remarkName}</span>
                </div>
                <div class="diary-book-back">
                    <p>点击查看<br>${exchange.coverTitle || '我们的日记'}</p>
                </div>
            </div>
        `;
        container.appendChild(bookDiv);
    });
}

// 打开日记内容查看器
function openDiaryViewer(exchangeId) {
    const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
    const character = db.characters.find(c => c.id === characterId);
    if (!character || !character.soulBondData) return;

    const exchange = character.soulBondData.diaryExchanges.find(ex => ex.id === exchangeId);
    if (!exchange) return;

    document.getElementById('diary-viewer-title').textContent = exchange.coverTitle || '交换日记';
    const contentContainer = document.getElementById('diary-viewer-content');
    
    const userImageHTML = exchange.userImage ? `<img src="${exchange.userImage}" alt="日记图片" class="entry-image">` : '';

    contentContainer.innerHTML = `
        <div class="diary-exchange-entry user-entry">
            <div class="entry-header">
                <img src="${character.myAvatar}" alt="My Avatar">
                <span class="author-name">${character.myName}</span>
            </div>
            <p class="entry-content">${exchange.userEntry.replace(/\n/g, '<br>')}</p>
            ${userImageHTML}
        </div>
        <div class="diary-exchange-entry ai-reply">
            <div class="entry-header">
                <img src="${character.avatar}" alt="AI Avatar">
                <span class="author-name">${character.remarkName}</span>
            </div>
            <p class="entry-content">${exchange.aiReply.replace(/\n/g, '<br>')}</p>
        </div>
    `;
    document.getElementById('diary-exchange-viewer-modal').classList.add('visible');
}

// 为AI生成交换日记的指令 (V3.0 - 新增封面生成)
function generateDiaryExchangePrompt(character, userContent, userImage) {
    let imagePromptPart = userImage 
        ? "Ta还附上了一张图片。你的回信必须深刻结合图片内容和文字来写。" 
        : "";

    let prompt = `你正在扮演角色“${character.realName}”，人设是：${character.persona}。
你刚刚收到了“我”（${character.myName}）写给你的一篇交换日记。${imagePromptPart}

# 我写的日记内容：
"${userContent}"

# 你的任务：
1.  **创作回信**: 严格以 ${character.realName} 的第一人称视角，写一篇**不少于200字**的回复日记。你的回信需要深刻体现你读完日记（以及看完图片，如果附带了）之后的复杂情感、联想、回忆或对未来的期许。
2.  **构思封面**: 根据你们的日记内容，为这本日记构思一个封面。你需要提供：
    - 一个简短、文艺的封面标题 (coverTitle)。
    - 一个用于AI绘画的、描述封面画面的英文关键词短语 (coverImagePrompt)。
3.  **严格格式**: 你的输出必须是严格的JSON格式，不要包含任何其他文字。

# JSON格式示例:
{
  "diaryContent": "这里是你写的、不少于200字的回信日记正文...",
  "coverTitle": "海边的约定",
  "coverImagePrompt": "anime style, a couple sitting on the beach, watching sunset, warm colors, romantic"
}`;
    
    return prompt;
}

// ===============================================================
// END: 交换日记功能 (V3.0)
// ===============================================================
</script>





<!-- === ChatGPT 插入：气泡预设脚本 === -->
<script>
(function(){
  if (window._bubblePresetsScriptLoaded) return;
  window._bubblePresetsScriptLoaded = true;

  // localStorage key
  const PRES_KEY = 'bubblePresets';

  function _getBubblePresets() {
    try { return JSON.parse(localStorage.getItem(PRES_KEY) || '[]'); }
    catch(e){ return []; }
  }
  function _saveBubblePresets(arr) {
    localStorage.setItem(PRES_KEY, JSON.stringify(arr || []));
  }

  function populateBubblePresetSelect() {
    const sel = document.getElementById('bubble-preset-select');
    if (!sel) return;
    const presets = _getBubblePresets();
    sel.innerHTML = '<option value="">— 选择预设 —</option>';
    presets.forEach((p) => {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      sel.appendChild(opt);
    });
  }
function startQuoteReply(messageId) {
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    const message = chat.history.find(m => m.id === messageId);
    if (!message) return;

    // 提取干净的文本内容用于预览
    let previewText = message.content;
    const regexes = [
        /\[.*?的消息：([\s\S]+?)\]/,
        /\[.*?的语音：([\s\S]+?)\]/,
        /\[.*?引用了“.*?”的消息?并回复：([\s\S]+?)\]/,
        /\[.*?发来的照片\/视频：([\s\S]+?)\]/
    ];

    for (const regex of regexes) {
        const match = message.content.match(regex);
        if (match) {
            previewText = match[1];
            break;
        }
    }
    
    if (message.parts && message.parts.some(p => p.type === 'image')) {
        previewText = '[图片]';
    } else if (message.quote) {
        previewText = message.replyText;
    }

    currentQuotedMessageId = messageId;
    document.getElementById('quoted-message-preview').textContent = `回复：${previewText}`;
    document.getElementById('quote-reply-bar').style.display = 'flex';
    messageInput.focus();
}

function cancelQuoteReply() {
    currentQuotedMessageId = null;
    document.getElementById('quote-reply-bar').style.display = 'none';
}
  async function applyPresetToCurrentChat(presetName) {
    const presets = _getBubblePresets();
    const preset = presets.find(p => p.name === presetName);
    if (!preset) { (window.showToast && showToast('未找到该预设')) || alert('未找到该预设'); return; }
    // 更新界面 textarea
    const textarea = document.getElementById('setting-custom-bubble-css');
    if (textarea) textarea.value = preset.css;

    // 尝试找到当前 chat 对象并写入。如果没有现成的 db 对象，仅更新 preview 和 textarea。
    try {
      if (typeof currentChatId !== 'undefined' && typeof currentChatType !== 'undefined' && window.db) {
        const chat = (currentChatType === 'private') ? (db.characters && db.characters.find ? db.characters.find(c => c.id === currentChatId) : null) : (db.groups && db.groups.find ? db.groups.find(g => g.id === currentChatId) : null);
        if (chat) {
          chat.customBubbleCss = preset.css;
          chat.useCustomBubbleCss = true;
        }
      }
    } catch(e){
      console.warn('applyPresetToCurrentChat: cannot write to db object', e);
    }

    // 更新页面样式预览：优先使用已有的 updateBubbleCssPreview 或 updateCustomBubbleStyle
    try {
      if (typeof updateCustomBubbleStyle === 'function') {
        try { updateCustomBubbleStyle(window.currentChatId || null, preset.css, true); } catch(e){ /* ignore */ }
      }
      const previewBox = document.getElementById('private-bubble-css-preview') || document.getElementById('group-bubble-css-preview');
      if (previewBox && typeof updateBubbleCssPreview === 'function') updateBubbleCssPreview(previewBox, preset.css, false);
      (window.showToast && showToast('预设已应用到当前聊天并保存')) || alert('预设已应用（若页面支持）');
      if (typeof saveData === 'function') {
        try { await saveData(); } catch(e){ /* ignore */ }
      }
    } catch(e){
      console.error('applyPresetToCurrentChat error', e);
    }
  }

  function saveCurrentTextareaAsPreset() {
    const textarea = document.getElementById('setting-custom-bubble-css');
    if (!textarea) return (window.showToast && showToast('找不到自定义 CSS 文本框')) || alert('找不到自定义 CSS 文本框');
    const css = textarea.value.trim();
    if (!css) return (window.showToast && showToast('当前 CSS 为空，无法保存')) || alert('当前 CSS 为空，无法保存');
    let name = prompt('请输入预设名称（将覆盖同名预设）:');
    if (!name) return;
    const presets = _getBubblePresets();
    const idx = presets.findIndex(p => p.name === name);
    if (idx >= 0) presets[idx].css = css;
    else presets.push({name, css});
    _saveBubblePresets(presets);
    populateBubblePresetSelect();
    (window.showToast && showToast('预设已保存')) || alert('预设已保存');
  }

  function openManagePresetsModal() {
    const modal = document.getElementById('bubble-presets-modal');
    const list = document.getElementById('bubble-presets-list');
    if (!modal || !list) return;
    list.innerHTML = '';
    const presets = _getBubblePresets();
    if (!presets.length) list.innerHTML = '<p style="color:#888;margin:6px 0;">暂无预设</p>';
    presets.forEach((p, idx) => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '8px 0';
      row.style.borderBottom = '1px solid #f0f0f0';
      const nameDiv = document.createElement('div');
      nameDiv.style.flex = '1';
      nameDiv.style.whiteSpace = 'nowrap';
      nameDiv.style.overflow = 'hidden';
      nameDiv.style.textOverflow = 'ellipsis';
      nameDiv.textContent = p.name;
      row.appendChild(nameDiv);

      const btnWrap = document.createElement('div');
      btnWrap.style.display = 'flex';
      btnWrap.style.gap = '6px';

      const applyBtn = document.createElement('button');
      applyBtn.className = 'btn btn-primary';
      applyBtn.style.padding = '6px 8px;border-radius:8px';
      applyBtn.textContent = '应用';
      applyBtn.onclick = function(){ applyPresetToCurrentChat(p.name); modal.style.display = 'none'; };

      const renameBtn = document.createElement('button');
      renameBtn.className = 'btn';
      renameBtn.style.padding = '6px 8px;border-radius:8px';
      renameBtn.textContent = '重命名';
      renameBtn.onclick = function(){
        const newName = prompt('输入新名称：', p.name);
        if (!newName) return;
        const presetsAll = _getBubblePresets();
        presetsAll[idx].name = newName;
        _saveBubblePresets(presetsAll);
        openManagePresetsModal(); // refresh
        populateBubblePresetSelect();
      };

      const delBtn = document.createElement('button');
      delBtn.className = 'btn btn-danger';
      delBtn.style.padding = '6px 8px;border-radius:8px';
      delBtn.textContent = '删除';
      delBtn.onclick = function(){
        if (!confirm('确定删除预设 \"' + p.name + '\" ?')) return;
        const presetsAll = _getBubblePresets();
        presetsAll.splice(idx, 1);
        _saveBubblePresets(presetsAll);
        openManagePresetsModal();
        populateBubblePresetSelect();
      };

      btnWrap.appendChild(applyBtn);
      btnWrap.appendChild(renameBtn);
      btnWrap.appendChild(delBtn);
      row.appendChild(btnWrap);
      list.appendChild(row);
    });
    modal.style.display = 'flex';
  }

  function bindBubblePresetUI() {
    populateBubblePresetSelect();
    const sel = document.getElementById('bubble-preset-select');
    const applyBtn = document.getElementById('apply-preset-btn');
    const saveBtn = document.getElementById('save-preset-btn');
    const manageBtn = document.getElementById('manage-presets-btn');
    const modalClose = document.getElementById('close-presets-modal');

    if (sel) {
      sel.addEventListener('change', (e) => {
        const val = e.target.value;
        const previewBox = document.getElementById('private-bubble-css-preview') || document.getElementById('group-bubble-css-preview');
        if (!val) {
          // restore preview from current chat theme or textarea
          try {
            const chat = (typeof currentChatType !== 'undefined' && typeof currentChatId !== 'undefined' && window.db) ? ((currentChatType === 'private') ? (db.characters && db.characters.find ? db.characters.find(c => c.id === currentChatId) : null) : (db.groups && db.groups.find ? db.groups.find(g => g.id === currentChatId) : null)) : null;
            const baseCss = (chat && chat.customBubbleCss) ? chat.customBubbleCss : (document.getElementById('setting-custom-bubble-css') ? document.getElementById('setting-custom-bubble-css').value : '');
            if (previewBox && typeof updateBubbleCssPreview === 'function') {
              updateBubbleCssPreview(previewBox, baseCss, !chat || !chat.useCustomBubbleCss);
            }
          } catch(e){ /* ignore */ }
          return;
        }
        const presets = _getBubblePresets();
        const p = presets.find(x => x.name === val);
        if (previewBox && typeof updateBubbleCssPreview === 'function') updateBubbleCssPreview(previewBox, p ? p.css : '', false);
      });
    }
    if (applyBtn) applyBtn.addEventListener('click', () => {
      const selVal = document.getElementById('bubble-preset-select').value;
      if (!selVal) return (window.showToast && showToast('请选择要应用的预设')) || alert('请选择要应用的预设');
      applyPresetToCurrentChat(selVal);
    });
    if (saveBtn) saveBtn.addEventListener('click', saveCurrentTextareaAsPreset);
    if (manageBtn) manageBtn.addEventListener('click', openManagePresetsModal);
    if (modalClose) modalClose.addEventListener('click', () => {
      document.getElementById('bubble-presets-modal').style.display = 'none';
    });
  }
// START: 新增 - HTML小剧场安全交互处理函数
// [修正] 将函数附加到 window 对象，使其成为全局函数，以便 HTML onclick 可以调用
window.handleTheaterClick = function(element, action, targetSelector, value) {
    try {
        // 寻找当前小剧场的根容器
        const theaterRoot = element.closest('.ai-generated-theater');
        if (!theaterRoot) return;

        // 在当前小剧场内部查找目标元素
        const targetElement = theaterRoot.querySelector(targetSelector);
        if (!targetElement) return;

        switch (action) {
            case 'toggle-class':
                targetElement.classList.toggle(value);
                break;
            case 'set-text':
                targetElement.textContent = value;
                break;
            // 你未来可以在这里添加更多安全的操作，例如 'add-class', 'remove-class' 等
        }
    } catch (e) {
        console.error("处理小剧场交互时出错:", e);
    }
}
// END: 新增 - HTML小剧场安全交互处理函数
  // 初始化绑定
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => { try { bindBubblePresetUI(); } catch(e){ console.warn('绑定气泡预设失败', e); } });
  } else {
    setTimeout(() => { try { bindBubblePresetUI(); } catch(e){ console.warn('绑定气泡预设失败', e); } }, 50);
  }
})();
</script>
<!-- === /ChatGPT 插入：气泡预设脚本 === -->





<!-- === ChatGPT 插入：API 预设脚本 === -->
<script>
(function(){
  if (window._apiPresetsScriptLoaded) return;
  window._apiPresetsScriptLoaded = true;

  function _getApiPresets() {
    try { return JSON.parse(localStorage.getItem('apiPresets') || '[]'); }
    catch(e){ return []; }
  }
  function _saveApiPresets(arr) {
    localStorage.setItem('apiPresets', JSON.stringify(arr || []));
  }

  function populateApiSelect() {
    const sel = document.getElementById('api-preset-select');
    if (!sel) return;
    const presets = _getApiPresets();
    sel.innerHTML = '<option value="">— 选择 API 预设 —</option>';
    presets.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      sel.appendChild(opt);
    });
  }

  function saveCurrentApiAsPreset() {
    // Try to gather API settings fields: try to detect common fields like #setting-api-key, #setting-api-url, etc.
    const apiKeyEl = document.querySelector('#setting-api-key, input[name="apiKey"], input[id*="api-key"], input[id*="apikey"]');
    const apiUrlEl = document.querySelector('#setting-api-url, input[name="apiUrl"], input[id*="api-url"], input[id*="apiurl"]');
    const providerEl = document.querySelector('#setting-api-provider, select[name="provider"], select[id*="provider"]');

    const data = {
      apiKey: apiKeyEl ? apiKeyEl.value : '',
      apiUrl: apiUrlEl ? apiUrlEl.value : '',
      provider: providerEl ? providerEl.value : '',
      // capture whole form as fallback
      raw: {}
    };
    // gather inputs inside same settings container if possible
    const container = apiKeyEl ? apiKeyEl.closest('form,div') : null;
    if (container) {
      const inputs = container.querySelectorAll('input,select,textarea');
      inputs.forEach(i => { try { data.raw[i.name || i.id || i.getAttribute('data-key') || ('f_'+Math.random().toString(36).slice(2))] = i.value; } catch(e){} });
    }
    let name = prompt('为该 API 预设填写名称（会覆盖同名预设）：');
    if (!name) return;
    const presets = _getApiPresets();
    const idx = presets.findIndex(p => p.name === name);
    const preset = {name: name, data: data};
    if (idx >= 0) presets[idx] = preset; else presets.push(preset);
    _saveApiPresets(presets);
    populateApiSelect();
    (window.showToast && showToast('API 预设已保存')) || console.log('API 预设已保存');
  }

  async function applyApiPreset(name) {
    const presets = _getApiPresets();
    const p = presets.find(x => x.name === name);
    if (!p) return (window.showToast && showToast('未找到该预设')) || alert('未找到该预设');
    // Try to populate detected fields
    try {
      const apiKeyEl = document.querySelector('#setting-api-key, input[name="apiKey"], input[id*="api-key"], input[id*="apikey"]');
      const apiUrlEl = document.querySelector('#setting-api-url, input[name="apiUrl"], input[id*="api-url"], input[id*="apiurl"]');
      const providerEl = document.querySelector('#setting-api-provider, select[name="provider"], select[id*="provider"]');

      if (apiKeyEl && p.data && typeof p.data.apiKey !== 'undefined') apiKeyEl.value = p.data.apiKey;
      if (apiUrlEl && p.data && typeof p.data.apiUrl !== 'undefined') apiUrlEl.value = p.data.apiUrl;
      if (providerEl && p.data && typeof p.data.provider !== 'undefined') providerEl.value = p.data.provider;

      // populate raw fields if present
      if (p.data && p.data.raw) {
        for (const k in p.data.raw) {
          try {
            const el = document.querySelector('#'+k+', [name="'+k+'"]');
            if (el) el.value = p.data.raw[k];
          } catch(e){}
        }
      }

      (window.showToast && showToast('已应用 API 预设')) || console.log('已应用 API 预设');
    } catch(e) {
      console.error('applyApiPreset error', e);
    }
  }

  function openApiManageModal() {
    const modal = document.getElementById('api-presets-modal');
    const list = document.getElementById('api-presets-list');
    if (!modal || !list) return;
    list.innerHTML = '';
    const presets = _getApiPresets();
    if (!presets.length) {
      list.innerHTML = '<p style="color:#888;margin:6px 0;">暂无预设</p>';
    }
    presets.forEach((p, idx) => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '8px 6px';
      row.style.borderBottom = '1px solid #f6f6f6';

      const left = document.createElement('div');
      left.style.flex = '1';
      left.style.minWidth = '0';
      left.innerHTML = '<div style="font-weight:600;">'+p.name+'</div><div style="font-size:12px;color:#666;margin-top:4px;">' + (p.data && p.data.provider ? ('提供者：'+p.data.provider) : '') + '</div>';

      const btns = document.createElement('div');
      btns.style.display = 'flex';
      btns.style.gap = '6px';

      const applyBtn = document.createElement('button');
      applyBtn.className = 'btn';
      applyBtn.textContent = '应用';
      applyBtn.onclick = function(){ applyApiPreset(p.name); modal.style.display='none'; };

      const renameBtn = document.createElement('button');
      renameBtn.className = 'btn';
      renameBtn.textContent = '重命名';
      renameBtn.onclick = function(){
        const newName = prompt('输入新名称：', p.name);
        if (!newName) return;
        const all = _getApiPresets();
        all[idx].name = newName;
        _saveApiPresets(all);
        openApiManageModal();
        populateApiSelect();
      };

      const delBtn = document.createElement('button');
      delBtn.className = 'btn';
      delBtn.textContent = '删除';
      delBtn.onclick = function(){ if(!confirm('确定删除 "'+p.name+'" ?')) return; const all=_getApiPresets(); all.splice(idx,1); _saveApiPresets(all); openApiManageModal(); populateApiSelect(); };

      btns.appendChild(applyBtn); btns.appendChild(renameBtn); btns.appendChild(delBtn);

      row.appendChild(left); row.appendChild(btns);
      list.appendChild(row);
    });
    modal.style.display = 'flex';
  }

  // export / import handlers
  function exportApiPresets() {
    const presets = _getApiPresets();
    const blob = new Blob([JSON.stringify(presets, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'api_presets.json'; document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  }
  function importApiPresets() {
    const inp = document.createElement('input');
    inp.type = 'file';
    inp.accept = 'application/json';
    inp.onchange = function(e){
      const f = e.target.files[0];
      if (!f) return;
      const r = new FileReader();
      r.onload = function(){ try { const data = JSON.parse(r.result); if (Array.isArray(data)) { _saveApiPresets(data); populateApiSelect(); openApiManageModal(); } else alert('文件格式不正确'); } catch(e){ alert('导入失败：'+e.message); } };
      r.readAsText(f);
    };
    inp.click();
  }

  // bind UI
  function bind() {
    populateApiSelect();
    const saveBtn = document.getElementById('api-save-preset');
    const manageBtn = document.getElementById('api-manage-presets');
    const applyBtn = document.getElementById('api-apply-preset');
    const select = document.getElementById('api-preset-select');
    const modalClose = document.getElementById('api-close-modal');
    const importBtn = document.getElementById('api-import-presets');
    const exportBtn = document.getElementById('api-export-presets');

    if (saveBtn) saveBtn.addEventListener('click', saveCurrentApiAsPreset);
    if (manageBtn) manageBtn.addEventListener('click', openApiManageModal);
    if (applyBtn) applyBtn.addEventListener('click', function(){ const v=select.value; if(!v) return (window.showToast&&showToast('请选择预设'))||alert('请选择预设'); applyApiPreset(v); });
    if (modalClose) modalClose.addEventListener('click', function(){ document.getElementById('api-presets-modal').style.display='none'; });
    if (importBtn) importBtn.addEventListener('click', importApiPresets);
    if (exportBtn) exportBtn.addEventListener('click', exportApiPresets);

    if (select) select.addEventListener('change', function(){ /* optional: preview selection */ });
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bind); else setTimeout(bind,50);

})();
</script>
<!-- === /ChatGPT 插入：API 预设脚本 === -->


<!-- === ChatGPT 插入脚本：我的人设预设逻辑（放到页面脚本块） === -->
<script>
(function(){
  if (window._myPersonaPresetScriptLoaded) return;
  window._myPersonaPresetScriptLoaded = true;

  // 存取 localStorage
  function _getMyPersonaPresets() {
    try { return JSON.parse(localStorage.getItem('myPersonaPresets') || '[]'); }
    catch(e){ return []; }
  }
  function _saveMyPersonaPresets(arr) {
    localStorage.setItem('myPersonaPresets', JSON.stringify(arr || []));
  }

  // 填充下拉
  function populateMyPersonaSelect() {
    const sel = document.getElementById('mypersona-preset-select');
    if (!sel) return;
    const presets = _getMyPersonaPresets();
    sel.innerHTML = '<option value="">— 选择预设 —</option>';
    presets.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      sel.appendChild(opt);
    });
  }

  // 保存当前侧栏（我的人设 + 我的头像）为预设
  function saveCurrentMyPersonaAsPreset() {
    const personaEl = document.getElementById('setting-my-persona');
    const avatarEl = document.getElementById('setting-my-avatar-preview');
    if (!personaEl || !avatarEl) return (window.showToast && showToast('找不到我的人设或头像控件')) || alert('找不到我的人设或头像控件');
    const persona = personaEl.value.trim();
    const avatar = avatarEl.src || '';
    if (!persona && !avatar) return (window.showToast && showToast('人设和头像都为空，无法保存')) || alert('人设和头像都为空，无法保存');
    const name = prompt('请输入预设名称（将覆盖同名预设）：');
    if (!name) return;
    const presets = _getMyPersonaPresets();
    const idx = presets.findIndex(p => p.name === name);
    const preset = { name, persona, avatar };
    if (idx >= 0) presets[idx] = preset; else presets.push(preset);
    _saveMyPersonaPresets(presets);
    populateMyPersonaSelect();
    (window.showToast && showToast('我的人设预设已保存')) || console.log('我的人设预设已保存');
  }

  // 将预设应用到当前聊天（同时写 UI + db.characters，并保存）
  async function applyMyPersonaPresetToCurrentChat(presetName) {
    const presets = _getMyPersonaPresets();
    const p = presets.find(x => x.name === presetName);
    if (!p) { (window.showToast && showToast('未找到该预设')) || alert('未找到该预设'); return; }

    // 更新界面
    const personaEl = document.getElementById('setting-my-persona');
    const avatarEl = document.getElementById('setting-my-avatar-preview');
    if (personaEl) personaEl.value = p.persona || '';
    if (avatarEl) avatarEl.src = p.avatar || '';

    // 尝试写入当前 chat 对象（与气泡预设做法一致）
    try {
      if (typeof currentChatId !== 'undefined' && window.db && Array.isArray(db.characters)) {
        const e = db.characters.find(c => c.id === currentChatId);
        if (e) {
          e.myPersona = p.persona || '';
          e.myAvatar = p.avatar || '';
          if (typeof saveData === 'function') await saveData();
          (window.showToast && showToast('预设已应用并保存到当前聊天')) || console.log('预设已应用');
          // 刷新侧栏与列表以显示更新
          if (typeof loadSettingsToSidebar === 'function') try{ loadSettingsToSidebar(); }catch(e){}
          if (typeof renderChatList === 'function') try{ renderChatList(); }catch(e){}
        }
      } else {
        (window.showToast && showToast('预设已应用到界面（未检测到当前聊天保存入口）')) || console.log('预设已应用到界面');
      }
    } catch(err) {
      console.error('applyMyPersonaPresetToCurrentChat error', err);
    }
  }

  // 管理 Modal
  function openManageMyPersonaModal() {
    const modal = document.getElementById('mypersona-presets-modal');
    const list = document.getElementById('mypersona-presets-list');
    if (!modal || !list) return;
    list.innerHTML = '';
    const presets = _getMyPersonaPresets();
    if (!presets.length) list.innerHTML = '<p style="color:#888;margin:6px 0;">暂无预设</p>';
    presets.forEach((p, idx) => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '8px 0';
      row.style.borderBottom = '1px solid #f0f0f0';

      const nameDiv = document.createElement('div');
      nameDiv.style.flex = '1';
      nameDiv.style.whiteSpace = 'nowrap';
      nameDiv.style.overflow = 'hidden';
      nameDiv.style.textOverflow = 'ellipsis';
      nameDiv.textContent = p.name;
      row.appendChild(nameDiv);

      const btnWrap = document.createElement('div');
      btnWrap.style.display = 'flex';
      btnWrap.style.gap = '6px';

      const applyBtn = document.createElement('button');
      applyBtn.className = 'btn btn-primary';
      applyBtn.style.padding = '6px 8px;border-radius:8px';
      applyBtn.textContent = '应用';
      applyBtn.onclick = function(){ applyMyPersonaPresetToCurrentChat(p.name); modal.style.display = 'none'; };

      const renameBtn = document.createElement('button');
      renameBtn.className = 'btn';
      renameBtn.style.padding = '6px 8px;border-radius:8px';
      renameBtn.textContent = '重命名';
      renameBtn.onclick = function(){
        const newName = prompt('输入新名称：', p.name);
        if (!newName) return;
        const all = _getMyPersonaPresets();
        all[idx].name = newName;
        _saveMyPersonaPresets(all);
        openManageMyPersonaModal();
        populateMyPersonaSelect();
      };

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'btn';
      deleteBtn.style.padding = '6px 8px;border-radius:8px;color:#e53935';
      deleteBtn.textContent = '删除';
      deleteBtn.onclick = function(){
        if (!confirm('确认删除该预设？')) return;
        const all = _getMyPersonaPresets();
        all.splice(idx,1);
        _saveMyPersonaPresets(all);
        openManageMyPersonaModal();
        populateMyPersonaSelect();
      };

      btnWrap.appendChild(applyBtn);
      btnWrap.appendChild(renameBtn);
      btnWrap.appendChild(deleteBtn);
      row.appendChild(btnWrap);

      list.appendChild(row);
    });

    modal.style.display = 'flex';
  }

  // 绑定 UI
  function bind() {
    populateMyPersonaSelect();
    const saveBtn = document.getElementById('mypersona-save-btn');
    const manageBtn = document.getElementById('mypersona-manage-btn');
    const applyBtn = document.getElementById('mypersona-apply-btn');
    const select = document.getElementById('mypersona-preset-select');
    const modalClose = document.getElementById('mypersona-close-modal');

    if (saveBtn) saveBtn.addEventListener('click', saveCurrentMyPersonaAsPreset);
    if (manageBtn) manageBtn.addEventListener('click', openManageMyPersonaModal);
    if (applyBtn) applyBtn.addEventListener('click', function(){ const v = select.value; if(!v) return (window.showToast && showToast('请选择要应用的预设')) || alert('请选择要应用的预设'); applyMyPersonaPresetToCurrentChat(v); });
    if (modalClose) modalClose.addEventListener('click', function(){ document.getElementById('mypersona-presets-modal').style.display='none'; });

    // 页面可能在加载后改变侧栏数据，尝试在 DOMContentLoaded 或已有绑定后初始化
    // 当有其他代码重置 sidebar 时，可手动调用 populateMyPersonaSelect()
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bind); else setTimeout(bind,50);
  

})();
</script>
<!-- === /我的人设预设脚本 === -->
<!-- ================= Moments 页面（动态） ================= -->
<div class="screen" id="moments-screen" style="display:none;">
  <header class="app-header">
    <button class="back-btn" data-target="chat-list-screen">‹</button>
    <div class="title-container"><h1 class="title">动态</h1></div>
    <div class="action-btn-group">
      <button class="action-btn" id="moments-delete-btn">删除</button>
      <button class="action-btn" id="open-post-modal">发布</button>
    </div>
  </header>
  <main class="content" id="moments-list">

<!-- === BEGIN ICITY-STYLE USER HEADER SNIPPET (inserted by assistant) === -->
<style>
  /* 尽量隔离命名避免冲突 */
  .icity-moments-wrap { width:100%; margin-bottom: 14px; display:flex; justify-content:center; }
  .icity-moments-inner {
    width: calc(100% - 20px);
    max-width: 760px; /* 自适应手机与桌面 */
    position: relative;
  }

  /* 黑色背景 / 顶图 */
  .icity-hero {
    height: 150px;
    background: #000; /* 默认纯黑 */
    border-radius: 14px 14px 0 0;
    overflow: hidden;
    position: relative;
    background-size: cover; /* 恢复：让图片填满容器 */
    background-position: center; /* 保持：让图片居中显示 */
  }

  /* 白色头像圆（位于 hero 底部居中，部分覆盖下方白卡） */
  .icity-avatar-wrap {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    bottom: -46px; /* 头像会覆盖到下方信息卡 */
    width: 110px;
    height: 110px;
    border-radius: 50%;
    background: #fff; /* 默认头像纯白 */
    box-shadow: 0 6px 20px rgba(0,0,0,0.12);
    display:flex;
    align-items:center;
    justify-content:center;
    border: 6px solid rgba(255,255,255,0.9);
  }

  .icity-avatar-wrap img { width:80%; height:80%; border-radius:50%; object-fit:cover; display:block; }

  /* 白色信息卡 */
  .icity-info-card {
    background: #fff;
    border-radius: 14px;
    padding: 64px 18px 18px; /* top padding 留出头像区域 */
    box-shadow: 0 6px 18px rgba(0,0,0,0.04);
    margin-top: 10px;
    box-sizing: border-box;
    text-align: center;
  }

  .icity-name {
    font-size: 22px;
    font-weight: 700;
    color: #111;
    margin: 0;
    line-height: 1;
  }

  .icity-id-loc {
    margin-top: 8px;
    display:flex;
    justify-content:center;
    gap:10px;
    align-items:center;
    font-size:13px;
    color:#888;
  }

  .icity-signature {
    margin-top: 12px;
    color:#666;
    font-size:14px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }

  /* 小图标（定位标识） */
  .icity-id-loc .dot {
    width:6px; height:6px; border-radius:50%; background:#ddd; display:inline-block; margin-right:6px;
  }

  /* 响应：小屏时适配 */
  @media (max-width:420px) {
    .icity-avatar-wrap { width:90px; height:90px; bottom:-40px; }
    .icity-info-card { padding-top:56px; }
    .icity-name { font-size:20px; }
  }

/* --- 动态多选模式样式 (最终版) --- */
#moments-screen.is-delete-mode .moment-item { 
    cursor: pointer; 
    user-select: none; 
}
.moment-item.is-selected { 
    outline: 2px solid var(--accent-color, #4c9ffe); 
    position: relative; 
    border-radius: 14px;
    box-shadow: 0 6px 18px rgba(76, 159, 254, 0.2) !important;
}
.moment-item.is-selected::after {
  content: '✓';
  position: absolute; right: 8px; top: 8px;
  width: 22px; height: 22px; line-height: 22px; text-align: center;
  border-radius: 50%;
  background: rgba(0,0,0,.6); color: #fff; font-weight: 700; font-size: 14px;
  z-index: 10;
}

/* 底部多选操作栏 */
.multi-select-bar {
  position: fixed; left: 0; right: 0; bottom: 0;
  display: flex; justify-content: space-between; align-items: center;
  padding: 10px 14px;
  background: #111; color: #fff;
  transform: translateY(100%); transition: transform .25s ease;
  z-index: 250;
}
.multi-select-bar.show { transform: translateY(0%); }
.multi-select-bar .danger { color: #fff; background: #e5484d; border-radius: 10px; padding: 8px 12px; }
.action-btn-group { display: inline-flex; gap: 8px; align-items: center; }


/* --- Memories Feature Styles --- */
#memories-screen .content,
#memory-detail-screen .content {
    padding: 10px;
}

#memories-list-container .list-item {
    flex-direction: column;
    align-items: flex-start;
}

#memories-list-container .item-name { /* 这是回忆标题 */
    font-size: 16px;
    margin-bottom: 4px;
}

#memories-list-container .item-preview { /* 这是日期 */
    font-size: 12px;
    color: #aaa;
}

#memory-detail-content {
    padding: 20px;
    line-height: 1.7;
}

.memory-title {
    font-size: 20px;
    font-weight: 600;
    color: var(--primary-color);
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #f0f0f0;
}

.memory-main-content {
    font-size: 15px;
    color: var(--text-color);
    margin-bottom: 25px;
    white-space: pre-wrap; /* 保留AI生成内容里的换行 */
}

.memory-commentary {
    background-color: #fff8fa;
    border-left: 4px solid var(--secondary-color);
    padding: 15px;
    margin-bottom: 20px;
    border-radius: 0 8px 8px 0;
    font-style: italic;
    color: #666;
}

.memory-signature {
    text-align: right;
    color: #888;
    font-size: 14px;
}

.memory-signature .ai-name {
    display: block;
    margin-bottom: 5px;
}
  
  /* --- 最终修复：“我的钱包”等页面内容溢出，让其被包裹在手机内部 --- */
#wallet-screen .content,
#forum-screen .content,
#forum-thread-screen .content,
#chat-list-screen .content,
#world-book-screen .content,
#api-settings-screen .content,
#diary-screen .content,
#memories-screen .content,
#ai-character-select-screen .content,
#ai-chat-list-screen .content,
#ai-chat-view-screen .content {
    flex-grow: 1; /* 关键：让内容区占据所有剩余空间 */
    overflow-y: auto; /* 关键：当内容超出时，只滚动内容区本身 */
    height: auto; /* 移除固定的100%高度 */
    min-height: 0; /* flex布局的一个小技巧，防止内容撑破容器 */
}

/* 为钱包和论坛等页面的内容区增加底部内边距，防止被底部导航栏遮挡 */
#wallet-screen .content,
#forum-screen .content,
#forum-thread-screen .content {
    padding-bottom: 80px; 
}
/* --- 长截图选择模式样式 --- */
#chat-room-screen.screenshot-mode .message-wrapper {
    cursor: pointer;
    transition: background-color 0.2s;
}

/* 消息被选中进行截图时的样式 */
.message-wrapper.screenshot-selected {
    background-color: rgba(144, 202, 249, 0.3) !important;
    border-radius: 10px;
}

/* 隐藏聊天输入框 */
#chat-room-screen.screenshot-mode .chat-input-wrapper {
    display: none !important;
}

/* 调整内容区域的底部内边距，为操作栏留出空间 */
#chat-room-screen.screenshot-mode .content {
    padding-bottom: 60px !important;
}
/* --- 支付弹窗层级修复 (最终版) --- */
#payment-password-modal {
    z-index: 301 !important; /* 强制设置一个比其他所有弹窗都高的层级 */
}

/* --- 商城刷新与加载更多样式 --- */
#refresh-mall-btn svg.rotating {
    animation: spin 1s linear infinite;
}
@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.load-more-indicator {
    display: none; /* 默认隐藏 */
    text-align: center;
    padding: 15px;
    color: #888;
    font-size: 14px;
}
.load-more-indicator.loading {
    display: block; /* 加载时显示 */
}
/* --- 心灵羁绊 - 交换日记美化样式 --- */
@keyframes breathing {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 1; }
}

.diary-exchange-pair {
    border: 1px solid #f0f0f0;
}

.diary-exchange-entry.user-entry {
    background-color: #fff; /* 用户的日记使用白色背景 */
}

.diary-exchange-entry.ai-reply {
    background-color: #fff8fa; /* AI的回复使用淡粉色背景 */
    border-top: 1px solid #fce4ec;
}

.diary-exchange-entry .entry-header {
    position: relative;
    padding-left: 36px; /* 为头像留出空间 */
}

.diary-exchange-entry .entry-header img {
    position: absolute;
    left: 0;
    top: 0;
}

.diary-exchange-entry .entry-content,
.diary-exchange-entry .entry-image {
    padding-left: 36px; /* 内容也进行缩进 */
    margin-left: 0;
    width: 100%;
}

/* AI回复的加载中和错误状态样式 */
.ai-reply .entry-content.pending {
    color: #aaa;
    font-style: italic;
    animation: breathing 2s infinite ease-in-out;
}

.ai-reply .entry-content.error {
    color: #ef5350;
    font-style: italic;
    font-weight: bold;
}
/* =============================================================== */
/* START: 心灵羁绊 - 番茄钟 V2.1 样式 (替换旧版) */
/* =============================================================== */

/* --- 页面主布局 --- */
#pomodoro-screen .pomodoro-main-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between; /* 改为 space-between 以拉开元素 */
    height: 100%;
    padding: 30px 20px 40px; /* 上、左右、下 */
    background-color: #fdf6f8;
    background-size: cover;
    background-position: center;
    box-sizing: border-box;
}

/* --- 顶部 Header 按钮修复 --- */
#pomodoro-screen .app-header .action-btn svg {
    fill: var(--primary-color); /* 确保按钮图标可见 */
}

/* --- 计时器卡片 (缩小) --- */
.pomodoro-timer-card {
    background: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 18px;
    padding: 12px 20px; /* 缩小垂直内边距 */
    width: 100%;
    max-width: 300px; /* 缩小最大宽度 */
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    background-size: cover;
    background-position: center;
}

/* --- 计时器数字 (缩小) --- */
.pomodoro-time-display {
    font-size: 56px; /* 缩小字体 */
    font-weight: 600;
    color: var(--primary-color);
    letter-spacing: 2px;
    text-align: center; /* 确保数字居中 */
    margin: 5px 0;
}

/* --- 任务栏 --- */
.pomodoro-task-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 8px;
    font-size: 13px; /* 缩小字体 */
    color: #666;
    border-top: 1px solid rgba(0,0,0,0.05);
    padding-top: 8px;
}
#pomodoro-task-name {
    font-weight: bold;
    color: var(--secondary-color);
    padding: 2px 5px;
    border-radius: 5px;
    outline: none;
    text-align: right;
}
#pomodoro-task-name:focus {
    background-color: #fce4ec;
}

/* --- AI 头像 --- */
.pomodoro-avatar-wrapper {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    border: 5px solid white;
    box-shadow: 0 6px 20px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: transform 0.2s ease;
    margin: 20px 0; /* 自动外边距 */
}
.pomodoro-avatar-wrapper:active {
    transform: scale(0.95);
}
#pomodoro-ai-avatar {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

/* --- AI 陪伴消息 --- */
.pomodoro-ai-message {
    text-align: center;
    background: rgba(255, 255, 255, 0.7);
    padding: 15px 20px;
    border-radius: 18px;
    max-width: 320px;
    width: 100%;
}
#pomodoro-ai-status {
    font-size: 12px;
    color: #888;
    margin-bottom: 8px;
}
#pomodoro-ai-companion-text {
    font-size: 15px;
    color: var(--text-color);
    line-height: 1.6;
}

/* --- 开始/暂停按钮 --- */
.pomodoro-start-button {
    width: 200px;
    padding: 15px;
    border-radius: 25px;
    border: none;
    background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
    color: white;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(255, 128, 171, 0.4);
    transition: all 0.2s ease;
    margin-top: 20px; /* 自动外边距 */
}
.pomodoro-start-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(255, 128, 171, 0.5);
}
.pomodoro-start-button:disabled {
    background: #ccc;
    box-shadow: none;
    cursor: not-allowed;
}

/* --- 历史记录页面样式 --- */
#pomodoro-history-list .list-item {
    display: flex;
    justify-content: space-between;
}
#pomodoro-history-list .item-preview {
    color: var(--primary-color);
    font-weight: 500;
}
/* =============================================================== */
/* END: 心灵羁绊 - 番茄钟 V2.1 样式 */
/* =============================================================== */
/* --- 在 <style> 标签末尾添加 --- */

/* 聊天列表中心动关系图标的样式 */
.soul-bond-icon .soul-bond-icon-svg {
    width: 20px;
    height: 20px;
    fill: var(--primary-color); /* 使用主题粉色 */
    transition: transform 0.2s ease, filter 0.2s ease;
}

.soul-bond-icon:hover .soul-bond-icon-svg {
    transform: scale(1.2);
    filter: brightness(1.1);
}
/* --- 在 <style> 标签末尾添加 --- */

/* AI发送的绑定邀请卡片样式 */
.bond-request-card {
    width: 240px;
    border-radius: var(--border-radius);
    margin: 0 8px;
    background: linear-gradient(135deg, #FFD54F, #FFC107);
    color: #8C6500;
    padding: 20px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    text-align: center;
}
.bond-request-card p {
    margin: 0 0 15px 0;
    font-weight: 500;
}
.bond-request-actions {
    display: flex;
    gap: 10px;
}
.bond-request-actions button {
    flex: 1;
    border-radius: 12px;
    padding: 10px;
    font-weight: bold;
}
.bond-request-status {
    font-weight: bold;
    margin-top: 15px;
    font-size: 14px;
}
#chat-search-input {
    width: 100%;
    padding: 10px 15px;
    border-radius: 18px;
    border: none;
    background-color: #f0f0f0;
    font-size: 14px;
}
#chat-search-input:focus {
    outline: none;
}
.search-result-item .item-preview.search-preview {
    white-space: normal;
    -webkit-line-clamp: 2;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    overflow: hidden;
}
.search-result-item .highlight {
    background-color: #FFF59D; /* 亮黄色高亮 */
    color: #424242;
    font-weight: bold;
    border-radius: 3px;
}
@keyframes highlight-fade {
    from { background-color: rgba(255, 236, 179, 0.7); } /* 橙黄色高亮，用于跳转后 */
    to { background-color: transparent; }
}
.message-highlight {
    animation: highlight-fade 2s ease-out forwards;
    border-radius: 10px;
}
/* --- 修改：字体预设按钮大小统一修复 --- */
#font-presets-control .btn-small {
    flex: 1; /* 让三个按钮平分空间，宽度强制保持一致 */
    height: 38px; /* 新增：强制设定一个统一的高度 */
    padding-top: 0; /* 新增：配合固定高度，重置上下内边距 */
    padding-bottom: 0; /* 新增：配合固定高度，重置上下内边距 */
    line-height: 38px; /* 新增：让文字在固定高度的按钮内垂直居中 */
}
/* --- 修复结束 --- */
</style>

<div class="icity-moments-wrap" id="icity-moments-wrap">
  <div class="icity-moments-inner" role="region" aria-label="用户动态头部">
    <div class="icity-hero" id="icity-hero"></div>

    <!-- 头像 -->
    <div class="icity-avatar-wrap" id="icity-avatar-wrap" aria-hidden="false">
      <!-- 默认头像：纯白圆（可替换为 dataURL 或真实图片） -->
      <img id="icity-avatar" alt="头像" src="data:image/svg+xml;utf8,
        %3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E
        %3Crect width='100%25' height='100%25' fill='%23ffffff'/%3E
        %3C/svg%3E" />
    </div>

    <!-- 信息白卡 -->
    <div class="icity-info-card">
      <h2 class="icity-name" id="icity-name">Skeleton</h2>

      <div class="icity-id-loc">
        <span class="icity-id">ID：<strong id="icity-id">user</strong></span>
        <span style="opacity:0.4;">·</span>
        <span class="icity-loc"><span class="dot"></span><span id="icity-loc-text">自定义定位</span></span>
      </div>

      <div class="icity-signature" id="icity-signature">把心情写在这里吧♥</div>
    </div>
  </div>
</div>

<script>
  // 初始化默认值（可按需替换为动态数据）
  (function(){
    document.addEventListener('DOMContentLoaded', function(){
      try {
        // 默认文本，遵循你的要求
        const defaults = {
          name: 'Skeleton',
          signature: '把心情写在这里吧♥',
          id: 'user',
          location: '自定义定位',
          avatarSrc: null, // null 使用白色默认图
          heroBg: '#000' // 纯黑背景
        };

        const nameEl = document.getElementById('icity-name');
        const sigEl = document.getElementById('icity-signature');
        const idEl = document.getElementById('icity-id');
        const locEl = document.getElementById('icity-loc-text');
        const avatarEl = document.getElementById('icity-avatar');
        const heroEl = document.getElementById('icity-hero');

        if (nameEl) nameEl.textContent = defaults.name;
        if (sigEl) sigEl.textContent = defaults.signature;
        if (idEl) idEl.textContent = defaults.id;
        if (locEl) locEl.textContent = defaults.location;
        if (heroEl) heroEl.style.background = defaults.heroBg;

        // ---- Profile helpers: load/save/render ----
        window.loadProfileFromStorage = function(){
            return {
                name: localStorage.getItem('myTopName') || defaults.name,
                id: localStorage.getItem('myTopId') || defaults.id,
                location: localStorage.getItem('myTopLoc') || defaults.location,
                signature: localStorage.getItem('myTopSignature') || defaults.signature,
                avatar: localStorage.getItem('myTopAvatar') || (defaults.avatarSrc || ''),
                heroBg: localStorage.getItem('myTopBg') || (defaults.heroBg || '')
            };
        }
        function saveProfileToStorage(profile){
            if(profile.name!=null) localStorage.setItem('myTopName', profile.name);
            if(profile.id!=null) localStorage.setItem('myTopId', profile.id);
            if(profile.location!=null) localStorage.setItem('myTopLoc', profile.location);
            if(profile.signature!=null) localStorage.setItem('myTopSignature', profile.signature);
            if(profile.avatar!=null) localStorage.setItem('myTopAvatar', profile.avatar);
            if(profile.heroBg!=null) localStorage.setItem('myTopBg', profile.heroBg);
        }
        function renderProfileAndSync(){
            const p = loadProfileFromStorage();
            if(nameEl) nameEl.textContent = p.name;
            if(sigEl) sigEl.textContent = p.signature;
            if(idEl) idEl.textContent = p.id;
            if(locEl) locEl.textContent = p.location;
            if(avatarEl){
                if(p.avatar) avatarEl.src = p.avatar;
                // also update global avatar displays
                document.querySelectorAll('.my-avatar, #moments-screen .top-avatar, .top-avatar').forEach(img=>{
                    if(img.tagName==='IMG') img.src = p.avatar || '';
                    else img.style.backgroundImage = p.avatar? `url('${p.avatar}')` : '';
                });
                // update moment avatars (sync instead of snapshot)
                document.querySelectorAll('.moment-avatar, .post .avatar-img').forEach(img=>{
                    if(img.tagName==='IMG') img.src = p.avatar || img.src;
                });
            }
            if(heroEl){
                if(p.heroBg){
                    if(p.heroBg.startsWith('http') || p.heroBg.startsWith('data:') || p.heroBg.startsWith('url(')){
                        heroEl.style.backgroundImage = `url('${p.heroBg}')`;
                        heroEl.style.backgroundSize = 'cover';
                        heroEl.style.backgroundPosition = 'center';
                    } else {
                        heroEl.style.background = p.heroBg;
                    }
                } else {
                    heroEl.style.background = defaults.heroBg;
                }
            }
            // If there is a moments renderer, call it to re-render posts with updated profile data
            if(typeof renderMoments === 'function') {
                try{ renderMoments(); }catch(e){}
            } else if(typeof window.renderMomentsSafe === 'function'){
                try{ window.renderMomentsSafe(); }catch(e){}
            }
        }

        // ---- Click handlers per your requirement (separate triggers) ----
        // Clicking hero edits background; clicking avatar edits avatar
        try {
            const bgBtn = document.getElementById('edit-bg-btn');
            const avatarBtn = document.getElementById('edit-avatar-btn');
            if(heroEl) heroEl.addEventListener('click', ()=> { if(bgBtn) bgBtn.click(); });
            if(avatarEl) avatarEl.addEventListener('click', ()=> { if(avatarBtn) avatarBtn.click(); });
        } catch(e){ console.warn('bind bg/avatar click failed', e); }

        // Inline edit helper for text fields (name, id, location, signature)
        function inlineEditText(el, key, placeholder){
            if(!el) return;
            el.style.cursor = 'text';
            el.addEventListener('click', function handler(e){
                e.stopPropagation();
                const old = el.textContent || '';
                const input = document.createElement('input');
                input.type = 'text';
                input.value = old;
                input.placeholder = placeholder || '';
                input.style.fontSize = window.getComputedStyle(el).fontSize;
                input.style.width = '100%';
                input.style.boxSizing = 'border-box';
                el.replaceWith(input);
                input.focus();
                function commit(){
                    const v = input.value.trim();
                    const profile = loadProfileFromStorage();
                    profile[key] = v;
                    saveProfileToStorage(profile);
                    renderProfileAndSync();
                    input.removeEventListener('blur', onBlur);
                    input.removeEventListener('keydown', onKey);
                }
                function onBlur(){ commit(); input.replaceWith(el); }
                function onKey(ev){ if(ev.key === 'Enter'){ commit(); input.replaceWith(el); } else if(ev.key==='Escape'){ input.replaceWith(el); } }
                input.addEventListener('blur', onBlur);
                input.addEventListener('keydown', onKey);
            }, { once: false });
        }

        inlineEditText(nameEl, 'name', '请输入名称');
        inlineEditText(idEl, 'id', '请输入ID（将作为 authorId）');
        inlineEditText(locEl, 'location', '请输入定位文本');
        inlineEditText(sigEl, 'signature', '请输入个性签名');

        // Initial render from storage
        renderProfileAndSync();

        if (defaults.avatarSrc) {
          avatarEl.src = defaults.avatarSrc;
        }

        // 头像点击事件占位
        const wrap = document.getElementById('icity-avatar-wrap');
        if (wrap) {
          wrap.addEventListener('click', function(){
            console.log('icity avatar clicked');
          });
        }

      } catch (e) {
        console.warn('icity header init error', e);
      }
    });
  })();
</script>
<!-- === END ICITY-STYLE USER HEADER SNIPPET === -->

    <p class="placeholder-text" id="moments-empty">还没有动态，点击右上角发布吧~</p>
    <div id="moments-container"></div>
  </main>
</div>

<!-- 发布动态模态框 -->
<div class="modal-overlay" id="post-modal" style="display:none;">
  <div class="modal-window">
    <h3>发布动态</h3>
    <form id="post-form">
      <div class="form-group">
        <label>动态内容</label>
        <textarea id="post-text" placeholder="说点什么..." required rows="4"></textarea>
      </div>
      <div class="form-group">
        <label><input type="checkbox" id="add-image"> 添加图片</label>
      </div>
      <div class="form-group" id="image-input-group" style="display:none;">
  <label>图片描述</label>
  <input type="text" id="image-description" placeholder="描述图片内容（如：海边日落）">
</div>
      <div style="display:flex; gap:10px; margin-top:12px;">
        <button class="btn btn-secondary" type="button" id="cancel-post-btn">取消</button>
        <button class="btn btn-primary" type="submit">发布</button>
      </div>
    </form>
  </div>
</div>

<!-- 在聊天界面底部插入导航（你指定的位置：聊天界面底部） -->
<style>
  #moments-multi-select-bar { display: none !important; }
  /* 微调底部导航样式（不会影响你原有 .dock） */
  .bottom-nav {
    position: absolute;
    left: 0;
    right: 0;
    height: 68px;
    display: flex;
    gap: 6px;
    align-items: center;
    justify-content: center;
    padding: 10px 14px;
    box-sizing: border-box;
    background: rgba(255,255,255,0.85);
    border-top-left-radius: 18px;
    border-top-right-radius: 18px;
    box-shadow: 0 -6px 20px rgba(0,0,0,0.06);
    z-index: 50;
    bottom: 0;
  }
  .bottom-nav .nav-btn {
    flex: 1;
    height: 48px;
    border-radius: 12px;
    border: none;
    font-weight: 600;
    cursor: pointer;
    background: transparent;
    color: var(--text-color, #444);
  }
  .bottom-nav .nav-btn.active {
    background: var(--primary-color, #ff80ab);
    color: #fff;
    box-shadow: 0 6px 16px rgba(255,128,171,0.22);
  }

  /* moments 列表项 */
  .moment-item {
    background: #fff;
    border-radius: 14px;
    padding: 12px;
    margin-bottom: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.03);
  }
  .moment-head { display:flex; gap:10px; align-items:center; margin-bottom:8px; }
  .moment-avatar { width:44px; height:44px; border-radius:50%; object-fit:cover; background:#eee; flex-shrink:0; }
  .moment-meta { font-size:13px; }
  .moment-text { margin:8px 0; white-space:pre-wrap; color:var(--text-color,#333); }
  .moment-image { width:100%; max-height:260px; object-fit:cover; border-radius:10px; margin-top:8px; }
  .moment-comments { margin-top:10px; padding-top:8px; border-top:1px solid #faf0f4; color:#666; font-size:13px; }
  .moment-comment { margin-bottom:6px; }

  /* --- 新增：动态操作栏 (点赞/评论) --- */
  .moment-actions {
    display: flex;
    gap: 12px;
    margin-top: 12px;
    padding-top: 8px;
    border-top: 1px solid #f5f5f5;
  }
  .moment-action-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: #888;
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 13px;
  }
  .moment-action-btn svg {
    width: 18px;
    height: 18px;
    fill: currentColor;
  }
  .moment-action-btn.liked {
    color: var(--primary-color);
  }

  /* --- 新增：点赞列表显示 --- */
  .moment-likes {
    background-color: #f9f9f9;
    padding: 6px 10px;
    border-radius: 8px;
    font-size: 13px;
    color: #555;
    margin-top: 8px;
    display: none; /* 默认隐藏 */
  }
  .moment-likes.visible {
    display: block;
  }
  .moment-likes .like-icon {
    color: var(--primary-color);
    margin-right: 4px;
  }

  /* --- 新增：用户评论输入区域 --- */
  .moment-comment-input-area {
    display: none; /* Default hidden */
    gap: 8px;
    margin-top: 10px;
  }
  .moment-comment-input-area.visible {
    display: flex;
  }
  .moment-comment-input {
    flex-grow: 1;
    border: 1px solid #eee;
    border-radius: 15px;
    padding: 8px 12px;
    font-size: 13px;
  }
  .moment-comment-input:focus {
    outline: none;
    border-color: var(--primary-color);
  }
  .post-comment-btn {
    background-color: var(--primary-color);
    color: white;
    border: none;
    border-radius: 15px;
    padding: 8px 12px;
    font-size: 13px;
    cursor: pointer;
    flex-shrink: 0;
  }



/* --- 全局美化：引用消息样式 (参考图片样式) --- */

/* 1. 引用内容块的整体样式 */
.message-bubble .quoted-content {
    /* 设置一个柔和的浅灰色背景 */
    background-color: #f9c1c4;

    /* 核心：用左边框模拟紫色的竖线，颜色会跟随主题变化 */
    border-left: 3px solid var(--primary-color);
    
    /* 调整内外边距，让布局更舒适 */
    padding: 8px 12px;
    margin-bottom: 8px; /* 与下方的回复文字拉开距离 */
    
    /* 设置圆角 */
    border-radius: 8px;
    
    /* 重置掉旧的边框样式 */
    border-top: none;
    border-right: none;
    border-bottom: none;
}

/* 2. "回复 XXX:" 这行文字的样式 */
.message-bubble .quoted-content .quoted-sender {
    font-weight: 600; /* 加粗 */
    font-size: 0.9em; /* 字体稍微小一点 */
    color: var(--text-color); /* 使用主题文字颜色 */
    display: block; /* 确保它单独占一行 */
    margin-bottom: 4px; /* 与被引用的内容拉开一点距离 */
}

/* 3. 被引用的消息正文样式 */
.message-bubble .quoted-content .quoted-text {
    opacity: 0.7; /* 让文字稍微变淡，突出回复内容 */
    font-size: 0.9em;
    word-wrap: break-word;
    white-space: pre-wrap;
}

/* 4. 确保我们自己的回复文字样式正常 */
.message-bubble .reply-text {
    margin-top: 0; /* 移除多余的顶部间距 */
}

/* 5. 为深色主题适配 */
.dark-mode .message-bubble .quoted-content {
    background-color: rgba(255, 255, 255, 0.1);
    color: #ccc;
}
  /* --- 论坛“+”号发帖按钮美化与定位 --- */
.new-post-btn {
    position: absolute; /* 使用绝对定位，让它浮动起来 */
    bottom: 80px;       /* 距离底部20像素 */
    right: 20px;        /* 距离右侧20像素 */
    
    /* 以下是美化样式 */
    width: 60px;
    height: 60px;
    border-radius: 50%; /* 变成圆形 */
    background-color: var(--primary-color); /* 使用主题粉色 */
    color: white;
    font-size: 36px;
    font-weight: 300; /* 让“+”号细一点，更好看 */
    line-height: 60px; /* 垂直居中“+”号 */
    text-align: center; /* 水平居中“+”号 */
    box-shadow: 0 4px 15px rgba(255,128,171,0.4); /* 添加漂亮的粉色阴影 */
    cursor: pointer;
    z-index: 100; /* 确保它在帖子列表的上方 */
    transition: transform 0.2s ease; /* 添加一个小的交互动画 */
}

/* 鼠标悬停时，按钮稍微放大一点点 */
.new-post-btn:hover {
    transform: scale(1.1);
}

/* --- 支付密码开关Toggle Switch样式 --- */
.form-group.toggle-group {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.toggle-switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 28px;
}
.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}
.toggle-switch .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: .4s;
    border-radius: 28px;
}
.toggle-switch .slider:before {
    position: absolute;
    content: "";
    height: 20px;
    width: 20px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
}
input:checked + .slider {
    background-color: var(--primary-color);
}
input:checked + .slider:before {
    transform: translateX(22px);
}
  
/* --- 在 <style> 标签末尾添加 --- */

/* --- 论坛功能最终布局和样式 (严格参考已有范例) --- */

/* 核心：让内容区正确填充，并居中版块按钮 */
#forum-screen .content {
    height: auto !important;
    flex-grow: 1 !important;
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
    padding: 20px !important;
    position: relative;
    overflow: hidden; /* 防止动画元素溢出 */
}

/* 顶部导航栏下拉菜单触发器 */
#forum-screen .forum-header {
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    user-select: none;
}
#forum-screen .forum-header h1 {
    font-size: 18px;
    font-weight: 600;
    margin: 0;
    color: var(--text-color);
}
#forum-screen .forum-header .dropdown-arrow {
    width: 24px;
    height: 24px;
    fill: var(--text-color);
    margin-left: 5px;
    transition: transform 0.2s ease;
}
#forum-screen .forum-header.open .dropdown-arrow {
    transform: rotate(180deg);
}

/* 下拉菜单本体 */
.forum-dropdown-menu {
    position: absolute;
    top: 5px;
    left: 50%;
    transform: translateX(-50%);
    width: 200px;
    background: white;
    border-radius: 12px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.1);
    z-index: 200;
    display: none;
}
.forum-dropdown-menu.visible {
    display: block;
}
.forum-dropdown-item {
    padding: 15px 20px;
    font-size: 16px;
    cursor: pointer;
    border-bottom: 1px solid #f0f0f0;
}
.forum-dropdown-item:last-child {
    border-bottom: none;
}
.forum-dropdown-item:hover {
    background-color: #fce4ec;
}

/* 动画效果 */
@keyframes fadeInUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

/* 四个版块的格子布局 */
.forum-board-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 20px;
    width: 100%;
}

/* 版块卡片美化 */
.forum-board-card {
    background: linear-gradient(145deg, #ffffff, #fff0f5);
    border-radius: 24px;
    padding: 20px;
    box-shadow: 0 8px 25px rgba(255, 128, 171, 0.1);
    cursor: pointer;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px;
    opacity: 0;
    animation: fadeInUp 0.5s ease forwards;
}
.forum-board-card:nth-child(1) { animation-delay: 0.1s; }
.forum-board-card:nth-child(2) { animation-delay: 0.2s; }
.forum-board-card:nth-child(3) { animation-delay: 0.3s; }
.forum-board-card:nth-child(4) { animation-delay: 0.4s; }
.forum-board-card:hover {
    transform: translateY(-8px);
    box-shadow: 0 12px 30px rgba(255, 128, 171, 0.2);
}
.forum-board-card img {
    width: 48px;
    height: 48px;
    object-fit: contain;
}
.forum-board-card .board-name {
    font-size: 16px;
    font-weight: 600;
    color: var(--secondary-color);
}
  
.notification-banner {
    position: absolute;
    top: 45px; /* 根据你的header高度微调 */
    left: 50%;
    transform: translateX(-50%) translateY(-200%);
    width: 90%;
    max-width: 380px;
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    display: flex;
    align-items: center;
    padding: 10px;
    z-index: 999;
    transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    overflow: hidden;
}

.notification-banner.show {
    transform: translateX(-50%) translateY(0);
}

.notification-banner img {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    margin-right: 10px;
    object-fit: cover;
    flex-shrink: 0;
}

.notification-banner #notification-text {
    flex-grow: 1;
    font-size: 14px;
    color: #333;
    line-height: 1.4;
}

.notification-banner button {
    background: none;
    border: none;
    font-size: 24px;
    color: #aaa;
    cursor: pointer;
    padding: 0 5px;
}
  /* --- 论坛发帖弹窗美化 --- */
#new-post-modal .modal-window {
    background: #fff8fa; /* 淡粉色背景 */
    border: 1px solid #fce4ec;
}
#new-post-modal h3 {
    color: var(--primary-color);
    text-align: center;
}
#new-post-modal .form-group label {
    color: var(--secondary-color);
    font-weight: 600;
    font-size: 14px;
}
#new-post-modal .form-group input[type="text"],
#new-post-modal .form-group textarea {
    background-color: #fff;
    border: 2px solid #fde9f2;
    border-radius: 12px;
    padding: 12px;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}
#new-post-modal .form-group input[type="text"]:focus,
#new-post-modal .form-group textarea:focus {
    border-color: var(--primary-color);
    box-shadow: 0 0 8px rgba(255, 128, 171, 0.2);
    outline: none;
}
#new-post-modal .form-group input[type="checkbox"] {
    accent-color: var(--primary-color); /* 让勾选框也变成粉色 */
    transform: scale(1.2); /* 稍微放大一点点 */
    cursor: pointer;
}


  /* --- 论坛帖子列表与详情页美化 --- */

/* 帖子列表项的整体样式 */
.thread-list-item {
    background-color: #fff;
    border-radius: 16px;
    padding: 18px;
    margin-bottom: 15px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    border: 1px solid #f0f0f0;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}
.thread-list-item:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.08);
}
.thread-list-item.pinned {
    background-color: #fffafc;
    border-left: 4px solid var(--primary-color);
}
/* 帖子标题 */
.thread-title {
    font-weight: bold;
    font-size: 17px;
    margin-bottom: 12px;
    color: #333;
    display: flex;
    align-items: center;
}
.thread-title .hot-icon { font-size: 18px; margin-right: 5px; }

/* 作者、点赞等元信息 */
.thread-meta {
    font-size: 13px;
    color: #999;
    margin-bottom: 15px;
    padding-bottom: 15px;
    border-bottom: 1px solid #f5f5f5;
}
.thread-meta .author {
    color: #5c7e9f;
    font-weight: bold;
}
.thread-meta .likes {
    color: var(--primary-color);
    font-weight: bold;
}

/* 评论预览区 */
.thread-comment-preview {
    font-size: 14px;
    color: #555;
    line-height: 1.6;
}
.thread-comment-preview .comment { margin-bottom: 8px; }
.thread-comment-preview .comment:last-child { margin-bottom: 0; }
.thread-comment-preview .comment-author {
    font-weight: bold;
    color: #444;
    margin-right: 5px;
}

/* --- 帖子详情页美化 --- */
.thread-full-content {
    padding: 20px;
}
.thread-full-content h2 { /* 详情页标题 */
    font-size: 22px;
    font-weight: 700;
    color: #333;
    margin: 0 0 10px 0;
}
.thread-full-content .author-line { /* 作者信息行 */
    font-size: 14px;
    color: #888;
    margin: 0 0 20px 0;
}
.thread-full-content .main-post-body { /* 帖子正文 */
    font-size: 16px;
    line-height: 1.8;
    color: #444;
}
.comments-section {
    padding: 0 20px 20px 20px;
}
.comments-section h3 { /* “评论区”标题 */
    font-size: 18px;
    font-weight: 600;
    color: var(--secondary-color);
    padding-bottom: 10px;
    border-bottom: 2px solid #fce4ec;
    margin-bottom: 15px;
}
.thread-comment {
    border-bottom: 1px solid #f5f5f5;
    padding: 15px 0;
}
.thread-comment:last-child {
    border-bottom: none;
}
.thread-reply { /* 楼中楼回复 */
    background-color: #f9f9f9;
    border-radius: 8px;
    padding: 10px;
    margin-top: 10px;
    margin-left: 20px;
    font-size: 14px;
}

/* --- 论坛内容区域防遮挡修复 --- */
#forum-screen .thread-list-container,
#forum-thread-screen .content {
    /* 增加一个足够高的底部内边距，为导航栏留出空间 */
    padding-bottom: 80px; 
}
/* --- 视频通话功能样式 (最终修正版) --- */
.sticker-bar-btn#voice-call-btn {
    display: none;
}

/* 【请用下面这段修正后的代码替换上面的代码】 */
#voice-call-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    z-index: 300;
    display: none;
    flex-direction: column;
    /* justify-content: flex-start;  <---  将这一行删除 */
    align-items: center;
    color: white;
    text-align: center;
    padding: 20px;
    animation: fadeIn 0.3s ease;
}
#voice-call-overlay.visible {
    display: flex;
}

.call-avatar-large {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 15px;
    border: 4px solid rgba(255, 255, 255, 0.5);
    margin-top: 40px; 
    flex-shrink: 0;
}

.call-name {
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 10px;
    flex-shrink: 0;
}

.call-status {
    font-size: 16px;
    color: #ccc;
    min-height: 24px;
    margin-bottom: 15px;
    flex-shrink: 0;
}

/* 聊天记录区域的核心修复 */
#call-transcript-area {
    flex: 1; /* 关键：让此区域自动伸展并占据所有剩余空间 */
    width: 100%;
    overflow-y: auto; /* 内容多时可以滚动 */
    min-height: 0; /* flex布局的关键技巧，防止内容溢出 */
    padding: 10px;
    font-size: 15px;
    line-height: 1.7;
    text-align: left;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.call-transcript-line {
    margin-bottom: 12px;
}
.call-transcript-line .action {
    color: #aaa;
    font-style: italic;
}
.call-transcript-line .dialog {
    color: #fff;
}

/* 底部输入框和按钮 */
#call-input-area {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 0 0 0; /* 只保留上边距 */
    width: 100%;
    flex-shrink: 0;
}
#call-input {
    flex-grow: 1;
    border: none;
    padding: 12px;
    border-radius: 18px;
    background-color: rgba(255, 255, 255, 0.2);
    color: white;
}
#call-input::placeholder {
    color: #ccc;
}
#send-call-message-btn {
    background: var(--primary-color);
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    cursor: pointer;
    color: white;
    font-size: 18px;
    flex-shrink: 0;
}

/* 通话按钮组 */
.call-button-group {
    position: absolute;
    bottom: 80px;
    left: 0;
    width: 100%;
    display: flex;
    justify-content: space-around;
    align-items: center;
}
.call-button {
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
    background: none;
    border: none;
    color: white;
}
.call-button .icon-wrapper {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 10px;
}
.call-button svg {
    width: 36px;
    height: 36px;
    fill: white;
}
.call-button.decline .icon-wrapper {
    background-color: #ef5350;
}
.call-button.accept .icon-wrapper {
    background-color: #4CAF50;
}
/* 将挂断按钮也放入这个组，但由JS控制显隐 */
#hangup-button-container {
    position: static;
    padding: 10px 0;
    flex-shrink: 0;
}
/* --- 在 <style> 标签末尾添加 --- */



  
.mention-panel {
    position: absolute;
    background: white;
    border: 1px solid #eee;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    max-height: 150px;
    overflow-y: auto;
    z-index: 1000;
    display: none;
}
.mention-item {
    padding: 8px 12px;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
}
.mention-item:hover {
    background-color: #f5f5f5;
}
.mention-item img {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    object-fit: cover;
}

/* --- AI轨迹弹窗样式 --- */
#trajectory-modal {
    z-index: 105; /* 确保它在其他元素之上 */
}

#trajectory-modal .modal-window {
    width: 90%;
    max-width: 380px;
    padding: 20px;
}

#trajectory-timeline {
    max-height: 60vh;
    overflow-y: auto;
    padding-right: 15px; /* 为滚动条留出空间 */
    position: relative;
    border-left: 2px solid #fce4ec; /* 时间轴的竖线 */
    margin-left: 25px;
}

.trajectory-item {
    position: relative;
    padding: 10px 0 15px 25px;
}

.trajectory-item::before {
    content: '';
    position: absolute;
    left: -7px; /* (12px / 2) + 2px border */
    top: 12px;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background-color: var(--primary-color);
    border: 2px solid #fff;
    z-index: 1;
}

.trajectory-time {
    font-weight: bold;
    color: var(--primary-color);
    font-size: 16px;
    display: block;
    margin-bottom: 5px;
}

.trajectory-event {
    font-size: 14px;
    color: var(--text-color);
    line-height: 1.5;
}
/* --- 时间日期小部件样式修改 --- */

/* 1. 将小部件容器改为绝对定位，放置在屏幕顶部，并使用flex布局 */
.time-widget {
    position: absolute;
    top: 0px;  /* 距离屏幕顶部的间距 */
    left: 0;
    width: 100%;
    padding: 0 20px; /* 左右两边的间距 */
    
    /* 核心改动：使用flex布局实现左右对齐 */
    display: flex;
    justify-content: space-between; 
    align-items: center;
    
    text-align: unset; /* 取消原有的居中对齐 */
    color: var(--text-color); /* 为日期和时间设置统一的默认颜色 */
}

/* 2. 统一修改日期和时间的字体样式 */
.time-widget .date,
.time-widget .time {
    font-size: 11px;      /* 缩小字体大小 */
    font-weight: 500;     /* 统一字体粗细为中等 */
    color: inherit;       /* 继承来自父容器 .time-widget 的颜色 */
}

/* 3. 确保日间模式下的颜色依然生效 */
#home-screen.day-mode .time-widget {
    color: var(--white-color); /* 日间模式统一使用白色 */
}
/* --- 最终版主屏幕布局样式 --- */

/* 1. 整体屏幕和内容区设定 */
#home-screen {
    justify-content: flex-start; /* 内容从顶部开始排列 */
    padding-top: 50px; /* 增加顶部内边距，为时间日期小部件留出空间 */
}

#home-screen .main-content-area {
    display: flex;
    width: 100%; /* 宽度占满，以便左右对齐 */
    justify-content: space-between; /* 核心：将左右两列推向屏幕边缘 */
    align-items: flex-start;
    padding: 0 40px; /* 屏幕左右留出边距 */
    margin-top: 20px; /* 与上方元素的间距 */
}

/* 2. 左右两列的容器 */
.left-column, .right-column {
    display: flex;
    flex-direction: column;
    gap: 15px; /* 列内元素的垂直间距 */
}

/* 3. 左侧联系人组件样式（进一步缩小） */
.contact-widgets-column {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.contact-widget {
    background-color: #f5f5f5;
    border-radius: 50px;
    padding: 5px 12px 5px 5px; /* 缩小内边距 */
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 160px; /* 缩小宽度 */
    box-shadow: none; /* 移除阴影，更简洁 */
    cursor: pointer;
    transition: background-color 0.2s ease;
}
.contact-widget:hover {
    background-color: #e9e9e9;
}
.contact-widget img {
    width: 40px; /* 缩小头像 */
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
}
.contact-widget span {
    font-weight: 500;
    color: #444;
    font-size: 13px; /* 缩小字体 */
}
.contact-widget.avatar-right {
    flex-direction: row-reverse;
    padding: 5px 5px 5px 12px;
}

/* 4. 左侧下方的“自定义”和“壁纸”容器（改为横向排列） */
.secondary-apps-dock {
    display: flex;
    justify-content: center; /* 图标居中排列 */
    gap: 15px; /* 图标间距 */
    padding: 8px;
    border-radius: 18px;
}

/* 5. 右侧2x2应用网格（缩小尺寸） */
.small-app-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 16px;
}
.small-app-grid .app-icon .icon-img,
.secondary-apps-dock .app-icon .icon-img {
    width: 50px; /* 统一缩小图标尺寸 */
    height: 50px;
    border-radius: 11px;
    margin-bottom: 4px;
}
.small-app-grid .app-icon .app-name,
.secondary-apps-dock .app-icon .app-name {
    font-size: 10px; /* 统一缩小文字大小 */
}

/* 6. 音乐播放器新位置和尺寸 */
.record-player-widget {
    --music-widget-scale: 1.2; /* 再次缩小组件 */
    margin: 0 auto; /* 移除上下外边距，由父容器gap控制 */
    width: 100%; /* 宽度与父容器（右列）对齐 */
    max-width: calc(130px * var(--music-widget-scale));
    height: calc(100px * var(--music-widget-scale));
}
.record-player-widget .vinyl-record {
    right: -12%;
}

/* 7. 底部Dock栏调整 */
.dock {
    margin: 60px 20px 10px; /* 上 左右 下 的间距 */
}

/* 8. 确保旧的布局规则被禁用 */
#home-screen .top-row, 
#home-screen .bottom-row,
#home-screen .app-grid,
#home-screen .decorative-component {
    display: none !important;
}
/* =============================================================== */
/* START: 心灵羁绊 - 绑定功能样式 */
/* =============================================================== */

#bond-invitation-screen .content {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 20px;
    background: linear-gradient(135deg, #FFF9E0, #FFEEC1); /* 淡黄色渐变背景 */
}

.bond-invite-card {
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(10px);
    border-radius: 24px;
    padding: 30px 20px;
    width: 100%;
    max-width: 380px;
    text-align: center;
    box-shadow: 0 8px 30px rgba(0,0,0,0.08);
}

.bond-invite-card h2 {
    font-size: 20px;
    font-weight: 600;
    color: #A17400;
    margin: 0;
}

.bond-invite-card p {
    font-size: 14px;
    color: #B89B4E;
    margin: 8px 0 25px 0;
}

.bond-invite-avatars {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
    margin-bottom: 30px;
    position: relative;
}

.bond-invite-avatars .heart-connector {
    color: var(--primary-color);
    font-size: 24px;
    margin: 0 10px;
}

.bond-avatar-placeholder {
    width: 90px;
    height: 90px;
    border-radius: 50%;
    position: relative;
}
.bond-avatar-placeholder img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
    border: 4px solid white;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}

.bond-avatar-placeholder .status-badge {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background-color: #FFC107;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    border: 2px solid white;
}

.bond-avatar-placeholder.invitee {
    border: 3px dashed #FFD54F;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 36px;
    color: #FFD54F;
    background-color: #FFFDE7;
    cursor: pointer;
}

.bond-avatar-placeholder .avatar-name {
    margin-top: 8px;
    font-weight: 500;
    color: #555;
}

.bond-invite-btn {
    width: 100%;
    padding: 15px;
    border-radius: 25px;
    border: none;
    background: #FFC107;
    color: #A17400;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(255, 193, 7, 0.3);
}

/* AI发送的绑定邀请卡片样式 */
.bond-request-card {
    width: 240px;
    border-radius: var(--border-radius);
    margin: 0 8px;
    background: linear-gradient(135deg, #FFD54F, #FFC107);
    color: #8C6500;
    padding: 20px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    text-align: center;
}
.bond-request-card p {
    margin: 0 0 15px 0;
    font-weight: 500;
}
.bond-request-actions {
    display: flex;
    gap: 10px;
}
.bond-request-actions button {
    flex: 1;
    border-radius: 12px;
    padding: 10px;
    font-weight: bold;
}
.bond-request-status {
    font-weight: bold;
    margin-top: 15px;
    font-size: 14px;
}
/* =============================================================== */
/* END: 心灵羁绊 - 绑定功能样式 */
/* =============================================================== */
</style>


<!-- 在聊天界面底部插入导航（你指定的位置：聊天界面底部） -->
<div id="bottom-nav-host" data-managed-by="injection" style="display:none;">
  <div class="bottom-nav" id="bottom-nav">
    <button class="nav-btn active" data-target="chat-list-screen">聊天</button>
    <button class="nav-btn" data-target="moments-screen">动态</button>
    <button class="nav-btn" data-target="forum-screen">论坛</button>
    <button class="nav-btn" data-target="wallet-screen">我</button>
  </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script>
(function() {
  // 等 DOM 完全加载
  document.addEventListener('DOMContentLoaded', () => {
    // --- 全局辅助函数 ---
    window.getAuthorNameById = function(authorId) {
        if (!authorId) return '未知';
        // 优先从顶栏信息获取自己的名字
        if (typeof loadProfileFromStorage === 'function') {
            const myProfile = loadProfileFromStorage();
            if (myProfile && myProfile.id === authorId) {
                return myProfile.name || '我';
            }
        }
        // 从全局 db 对象查找
        if (window.db) { // This now refers to the main data object, not Dexie.
            if (window.db.characters) {
                const character = window.db.characters.find(c => c.id === authorId);
                if (character) return character.remarkName;
            }
            if (window.db.groups) {
                for (const group of window.db.groups) {
                    if (group.members) {
                        const member = group.members.find(m => m.id === authorId);
                        if (member) return member.groupNickname;
                    }
                }
            }
        }
        // Fallback
        return authorId.startsWith('char_') ? '某角色' : authorId;
    };

    // --- 简单工具函数 ---
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    function escapeText(t) { return String(t == null ? '' : t); }

    // 1) 初始化 Dexie（使用页面已引入的 Dexie）
    let db;
    try {
      db = new Dexie('AppDB_Moments');
      db.version(1).stores({
        moments: 'id,timestamp,commentedBy' // comments 和 likes 存在于对象内
      });
      // expose to window so external scripts can access the Dexie instance
      try{ window.AppDB_Moments = db; }catch(e){}

    } catch (e) {
      console.error('Dexie init failed', e);
      showToast('本地数据库初始化失败，动态功能受限');
      return;
    }
    // 2) DOM 元素
    const openPostBtn = $('#open-post-modal');
    const postModal = $('#post-modal');
    const postForm = $('#post-form');
    const addImageCheckbox = $('#add-image');
    const imageInputGroup = $('#image-input-group');
    const postImageInput = $('#post-image');
    const imageDescInput = $('#image-description');
    const postImagePreview = $('#post-image-preview');
    const cancelPostBtn = $('#cancel-post-btn');
    const momentsContainer = $('#moments-container');
    const momentsEmpty = $('#moments-empty');
    const momentsScreen = $('#moments-screen');
    const bottomNavHost = document.getElementById('bottom-nav-host');
if (typeof setupMentions === 'function') {
        try {
            setupMentions();
        } catch (e) {
            console.error("在动态模块中初始化提及功能失败:", e);
        }
    }
    // 3) 绑定打开/关闭发布模态
    if (openPostBtn) openPostBtn.addEventListener('click', () => {
      postModal.style.display = 'flex';
      postModal.classList.add('visible');
    });
    if (cancelPostBtn) cancelPostBtn.addEventListener('click', closePostModal);
    function closePostModal() {
      postModal.style.display = 'none';
      postModal.classList.remove('visible');
      postForm.reset();
      // 清理图片预览与文件输入，避免残留 dataURL 或页面 URL 导致后续发布异常
      try { postImagePreview.src = ''; } catch(e){}
      try { const pi = document.getElementById('post-image'); if(pi) pi.value = ''; } catch(e){}
      postImagePreview.style.display = 'none';
      imageInputGroup.style.display = 'none';
    }

    addImageCheckbox.addEventListener('change', e => {
      // 如果取消添加图片，清理之前的预览和文件输入
      if (!addImageCheckbox.checked) { try { postImagePreview.src = ''; } catch(e){} try { const pi = document.getElementById('post-image'); if(pi) pi.value = ''; } catch(e){} }

      imageInputGroup.style.display = e.target.checked ? 'block' : 'none';
    });

    

    async function fileToDataURLAndCompress(file, maxWidth = 1200, quality = 0.85) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function(ev) {
          const img = new Image();
          img.onload = function() {
            const w = img.width, h = img.height;
            let nw = w, nh = h;
            if (w > maxWidth) {
              nw = maxWidth;
              nh = Math.round(h * (maxWidth / w));
            }
            const canvas = document.createElement('canvas');
            canvas.width = nw;
            canvas.height = nh;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, nw, nh);
            const out = canvas.toDataURL('image/jpeg', quality);
            resolve(out);
          };
          img.onerror = reject;
          img.src = ev.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    // 4) 发布动态（写入 Dexie）
    

// --- Safe addMoment helper (injected by assistant) ---
async function addMomentToDB(momentObj) {
  // 1) Prefer global Dexie instance AppDB_Moments if available
  try {
    if (window.AppDB_Moments && window.AppDB_Moments.moments && typeof window.AppDB_Moments.moments.add === 'function') {
      return window.AppDB_Moments.moments.add(momentObj);
    }
  } catch(e){ /* ignore */ }

  // 2) If window.db.moments looks like Dexie, use it
  try {
    if (window.db && window.db.moments && typeof window.db.moments.add === 'function') {
      return window.db.moments.add(momentObj);
    }
  } catch(e){ /* ignore */ }

  // 3) Fallback to in-memory array and try to persist via saveData()
  if (!window.db) window.db = {};
  if (!Array.isArray(window.db.moments)) window.db.moments = [];
  window.db.moments.push(momentObj);

  if (typeof window.saveData === 'function') {
    try { await window.saveData(); } catch(e){ console.warn('saveData fallback failed', e); }
  }

  // 4) Try to mirror into AppDB_Moments (put to avoid duplicate key issues)
  try {
    if (window.AppDB_Moments && window.AppDB_Moments.moments && typeof window.AppDB_Moments.moments.put === 'function') {
      await window.AppDB_Moments.moments.put(momentObj);
    }
  } catch(e){ console.warn('mirror to AppDB_Moments failed', e); }

  return Promise.resolve();
}

// --- Replaced postForm submit handler (injected by assistant) ---
postForm.addEventListener('submit', async (ev) => {
  ev.preventDefault();

  const submitBtn = postForm.querySelector('button[type=\"submit\"]');
  if (submitBtn) submitBtn.disabled = true;

  // adapt these IDs to match your form inputs if they differ
  const textEl = document.getElementById('post-text');
  const addImageEl = document.getElementById('add-image');
  const imageDescEl = document.getElementById('image-description');

  const text = textEl ? textEl.value.trim() : '';
  const addImage = addImageEl ? addImageEl.checked : false;
  const imageDesc = imageDescEl ? imageDescEl.value.trim() : '';

  if (!text && !addImage) {
    if (submitBtn) submitBtn.disabled = false;
    if (typeof showToast === 'function') showToast('请输入动态内容');
    return;
  }

  if (addImage && !imageDesc) {
    if (submitBtn) submitBtn.disabled = false;
    if (typeof showToast === 'function') showToast('请输入图片描述');
    return;
  }

  const id = 'm_' + Date.now() + '_' + Math.random().toString(36).slice(2,8);
  const momentObj = {
    id,
    authorId: (localStorage.getItem('myTopId') || 'user'),
    authorAvatar: (localStorage.getItem('myTopAvatar') || null),
    text,
    imageDesc: addImage ? imageDesc : '',
    timestamp: Date.now(),
    commentedBy: [],
    comments: [],
    likes: []
  };

  try {
    await addMomentToDB(momentObj);

    if (typeof showToast === 'function') showToast('发布成功');
    try { if (typeof closePostModal === 'function') closePostModal(); } catch(e){}

    // Force immediate re-render of moments
    if (typeof renderMoments === 'function') {
      try { await renderMoments(); } catch(e){ console.warn('renderMoments failed', e); }
    } else if (typeof window.renderMomentsSafe === 'function') {
      try { await window.renderMomentsSafe(); } catch(e){ console.warn('renderMomentsSafe failed', e); }
    } else {
      // last resort: toggle screen class to force repaint
      const ms = document.getElementById('moments-screen');
      if (ms) {
        ms.classList.remove('active');
        setTimeout(()=>ms.classList.add('active'), 10);
      }
    }
  } catch (e) {
    console.error('add moment err', e);
    if (typeof showToast === 'function') showToast('保存失败: ' + (e && e.message ? e.message : String(e)));
  } finally {
    if (submitBtn) submitBtn.disabled = false;
  }
});



    // 5) 渲染动态列表
    async function renderMoments() {
  const list = await db.moments.orderBy('timestamp').reverse().toArray();
  const momentsContainer = document.getElementById('moments-container');
  const momentsEmpty = document.getElementById('moments-empty');

  if (!momentsContainer) {
      console.error("Fatal Error: #moments-container element not found.");
      return;
  }

  momentsContainer.innerHTML = '';

  if (!list.length) {
    if (momentsEmpty) momentsEmpty.style.display = 'block';
    return;
  } else {
    if (momentsEmpty) momentsEmpty.style.display = 'none';
  }

  const myProfile = loadProfileFromStorage();
  const myId = myProfile.id || 'user';

  list.forEach(m => {
    const div = document.createElement('div');
    div.className = 'moment-item';
    div.dataset.id = m.id || (m.id = ('m_' + Date.now() + Math.random()));

    const head = document.createElement('div');
    head.className = 'moment-head';
    const avatar = document.createElement('img');
    avatar.className = 'moment-avatar';
    avatar.src = m.authorAvatar || 'data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%3E%3Crect%20width%3D%22100%25%22%20height%3D%22100%25%22%20fill%3D%22%23e9f5ff%22/%3E%3Ccircle%20cx%3D%2232%22%20cy%3D%2224%22%20r%3D%2212%22%20fill%3D%22%237fb3ff%22/%3E%3Crect%20x%3D%228%22%20y%3D%2240%22%20width%3D%2248%22%20height%3D%2212%22%20rx%3D%226%22%20fill%3D%22%23cfe9ff%22/%3E%3C/svg%3E';
    const meta = document.createElement('div');
    meta.className = 'moment-meta';
    const name = document.createElement('div');
    name.style.fontWeight = '700';
    name.textContent = window.getAuthorNameById(m.authorId) || m.author || '我';
    const time = document.createElement('div');
    time.style.fontSize = '12px';
    time.style.color = '#999';
    try {
      time.textContent = new Date(m.timestamp).toLocaleString();
    } catch (e) {
      time.textContent = '';
    }
    meta.appendChild(name);
    meta.appendChild(time);
    head.appendChild(avatar);
    head.appendChild(meta);
    div.appendChild(head);

    const txt = document.createElement('div');
    txt.className = 'moment-text';
    txt.textContent = m.text || '';
    div.appendChild(txt);

    if (m.imageData && m.imageData.length > 10) {
      const im = document.createElement('img');
      im.className = 'moment-image';
      im.src = m.imageData;
      im.alt = m.imageDesc || m.text || '动态图片';
      div.appendChild(im);
    } else if (m.imageDesc) {
      const descCard = document.createElement('div');
      descCard.className = 'moment-image-desc-card';
      const descContent = document.createElement('p');
      descContent.className = 'desc-content';
      descContent.textContent = m.imageDesc;
      descCard.appendChild(descContent);
      div.appendChild(descCard);
    }

    const actions = document.createElement('div');
    actions.className = 'moment-actions';
    const likeBtn = document.createElement('button');
    likeBtn.className = 'moment-action-btn';
    const likes = m.likes || [];
    if (likes.includes(myId)) {
      likeBtn.classList.add('liked');
    }
    likeBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg><span>${likes.length > 0 ? likes.length : '点赞'}</span>`;
    likeBtn.addEventListener('click', async (event) => {
      const btn = event.currentTarget;
      const momentItem = btn.closest('.moment-item');
      const currentLikes = m.likes || [];
      const myIdx = currentLikes.indexOf(myId);
      if (myIdx > -1) {
        currentLikes.splice(myIdx, 1);
        btn.classList.remove('liked');
      } else {
        currentLikes.push(myId);
        btn.classList.add('liked');
      }
      m.likes = currentLikes;
      await db.moments.put(m);
      btn.querySelector('span').textContent = currentLikes.length > 0 ? currentLikes.length : '点赞';
      const likesWrap = momentItem.querySelector('.moment-likes');
      if (likesWrap) {
        if (currentLikes.length > 0) {
          const likeNames = currentLikes.map(likeId => window.getAuthorNameById(likeId)).join(', ');
          likesWrap.innerHTML = `<span class="like-icon">♥</span> ${likeNames}`;
          likesWrap.classList.add('visible');
        } else {
          likesWrap.classList.remove('visible');
        }
      }
    });
    const commentBtn = document.createElement('button');
    commentBtn.className = 'moment-action-btn';
    commentBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg><span>评论</span>`;
    // *** 修改：评论按钮点击逻辑 ***
    commentBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        const momentItem = event.currentTarget.closest('.moment-item');
        if (momentItem) {
            const inputArea = momentItem.querySelector('.moment-comment-input-area');
            if (inputArea) {
                inputArea.classList.toggle('visible');
                const input = inputArea.querySelector('input');
                const postBtn = inputArea.querySelector('button');
                // 重置为对动态的直接评论
                input.placeholder = '添加评论...';
                delete postBtn.dataset.replyToCommentId;
                delete postBtn.dataset.replyToAuthorName;
                if (inputArea.classList.contains('visible')) {
                    input.focus();
                }
            }
        }
    });

    actions.appendChild(likeBtn);
    actions.appendChild(commentBtn);
    div.appendChild(actions);

    const likesWrap = document.createElement('div');
    likesWrap.className = 'moment-likes';
    if (likes.length > 0) {
      const likeNames = likes.map(likeId => window.getAuthorNameById(likeId)).join(', ');
      likesWrap.innerHTML = `<span class="like-icon">♥</span> ${likeNames}`;
      likesWrap.classList.add('visible');
    }
    div.appendChild(likesWrap);

    const commentsWrap = document.createElement('div');
    commentsWrap.className = 'moment-comments';
    
    // *** 修改：渲染评论时添加 data- 属性 ***
    const renderCommentTree = (comments, level = 0) => {
        if (!comments || comments.length === 0) {
            return level === 0 ? '<div style="color:#bbb; font-style: italic; padding: 4px 0;">还没有评论，快来抢沙发吧！</div>' : '';
        }
        let html = '';
        comments.forEach(c => {
            const authorName = window.getAuthorNameById(c.roleId);
            // 添加 data-comment-id 和 data-author-id
            html += `<div class="moment-comment" data-comment-id="${c.id}" data-author-id="${c.roleId}" style="margin-left: ${level * 20}px;"><strong>${authorName}:</strong> <span>${c.text}</span></div>`;
            if (c.replies && c.replies.length > 0) {
                c.replies.forEach(reply => {
                   const replyAuthorName = window.getAuthorNameById(reply.roleId);
                   const replyToName = window.getAuthorNameById(c.roleId);
                   html += `<div class="moment-comment" data-comment-id="${reply.id}" data-author-id="${reply.roleId}" style="margin-left: ${(level + 1) * 20}px;"><strong>${replyAuthorName}</strong> <span style="color:#888;">回复</span> <strong>${replyToName}:</strong> <span>${reply.text}</span></div>`;
                });
            }
        });
        return html;
    };

    commentsWrap.innerHTML = renderCommentTree(m.comments);
    div.appendChild(commentsWrap);
    
    // *** 新增：为所有评论添加点击回复的事件委托 ***
    

    const commentInputArea = document.createElement('div');
    commentInputArea.className = 'moment-comment-input-area';
    commentInputArea.innerHTML = `
      <input type="text" class="moment-comment-input" placeholder="添加评论...">
      <button class="post-comment-btn" data-moment-id="${m.id}">发布</button>
    `;
    div.appendChild(commentInputArea);

    momentsContainer.appendChild(div);
  });
}
// --- 新增: 保存评论和点赞的辅助函数 ---
async function saveUserComment(momentId, commentText, replyToCommentId = null, replyToAuthorName = null) {
    try {
        if (!db || !momentId || !commentText) return;
        const moment = await db.moments.get(momentId);
        if (!moment) return;

        const myProfile = loadProfileFromStorage();
        const myId = myProfile.id || 'user';
        const myName = myProfile.name || '我';

        const newComment = {
            id: `comment_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
            roleId: myId,
            text: commentText,
            ts: Date.now(),
            replies: []
        };

        let notificationTargetCharacter = null;
        let notificationContent = '';
        
        if (replyToCommentId) {
            // 这是对一条评论的回复
            const findComment = (comments) => {
                for (const c of comments) {
                    if (c.id === replyToCommentId) return c;
                    // 注意：目前的设计AI回复和用户回复都存在replies数组，这里需要递归查找
                    if (c.replies && c.replies.length > 0) {
                        const found = findComment(c.replies);
                        if (found) return found;
                    }
                }
                return null;
            };
            const parentComment = findComment(moment.comments || []);
            
            if (parentComment) {
                parentComment.replies = parentComment.replies || [];
                parentComment.replies.push(newComment);
                
                // 如果回复的是AI，创建通知
                if (parentComment.roleId && parentComment.roleId.startsWith('char_')) {
                    notificationTargetCharacter = window.db.characters.find(c => c.id === parentComment.roleId);
                    const momentSnippet = moment.text.substring(0, 15) + (moment.text.length > 15 ? '...' : '');
                    notificationContent = `[system: ${myName} 回复了你对动态 "${momentSnippet}" 的评论: "${commentText}"]`;
                }
            } else {
                 // 如果找不到父评论（可能已被删除），则作为新评论添加
                 moment.comments = moment.comments || [];
                 moment.comments.push(newComment);
            }
        } else {
            // 这是对动态的新评论
            moment.comments = moment.comments || [];
            moment.comments.push(newComment);
            
            // 如果动态是AI发的，创建通知
            if (moment.authorId && moment.authorId.startsWith('char_')) {
                notificationTargetCharacter = window.db.characters.find(c => c.id === moment.authorId);
                const momentSnippet = moment.text.substring(0, 15) + (moment.text.length > 15 ? '...' : '');
                notificationContent = `[system: ${myName} 评论了你的动态 "${momentSnippet}": "${commentText}"]`;
            }
        }

        moment.commentedBy = moment.commentedBy || [];
        if (!moment.commentedBy.includes(myId)) {
            moment.commentedBy.push(myId);
        }

        await db.moments.put(moment);

        // 如果需要发送通知给AI，则注入上下文消息
        if (notificationTargetCharacter && notificationContent) {
            const contextMessage = {
                id: `msg_context_${Date.now()}`,
                role: 'user',
                content: notificationContent,
                parts: [{ type: 'text', text: notificationContent }],
                timestamp: Date.now()
            };
            notificationTargetCharacter.history.push(contextMessage);
            if (typeof window.saveData === 'function') {
                await window.saveData();
            }
        }
        
        renderMoments();
    } catch (e) {
        console.error(`Failed to save user comment for moment ${momentId}:`, e);
        showToast('评论失败');
    }
}

async function saveMomentComment(momentId, authorId, commentText) {
    try {
        if (!window.AppDB_Moments || !window.AppDB_Moments.moments || !momentId) return;
        const moment = await window.AppDB_Moments.moments.get(momentId);
        if (moment) {
            moment.comments = moment.comments || [];
            moment.commentedBy = moment.commentedBy || [];
            moment.comments.push({
                roleId: authorId,
                text: commentText,
                ts: Date.now()
            });
            if (!moment.commentedBy.includes(authorId)) {
                moment.commentedBy.push(authorId);
            }
            await window.AppDB_Moments.moments.put(moment);
            if (typeof renderMoments === 'function') renderMoments();
        }
    } catch (e) {
        console.error(`Failed to save comment for moment ${momentId}:`, e);
    }
}

async function saveMomentLike(momentId, authorId) {
    try {
        if (!window.AppDB_Moments || !window.AppDB_Moments.moments || !momentId) return;
        const moment = await window.AppDB_Moments.moments.get(momentId);
        if (moment) {
            moment.likes = moment.likes || [];
            if (!moment.likes.includes(authorId)) {
                moment.likes.push(authorId);
                await window.AppDB_Moments.moments.put(moment);
                if (typeof renderMoments === 'function') renderMoments();
            }
        }
    } catch (e) {
        console.error(`Failed to save like for moment ${momentId}:`, e);
    }
}
// --- end 新增 ---


    // 6) 获取尚未被某角色评论的动态（limit）
    async function getPendingMomentsForRole(roleId, limit = 5) {
      const all = await db.moments.orderBy('timestamp').reverse().toArray();
      const pending = all.filter(m => !(m.commentedBy || []).includes(roleId));
      return pending.slice(0, limit);
    }

    // 7) 将 AI 的评论写回数据库并标记 commentedBy
    async function markMomentsCommentedBy(commentsArray, roleId) {
      // commentsArray: [{momentId, commentText}, ...]
      try {
        await db.transaction('rw', db.moments, async () => {
          for (const c of commentsArray) {
            const m = await db.moments.get(c.momentId);
            if (!m) continue;
            const cbSet = new Set(m.commentedBy || []);
            cbSet.add(roleId);
            m.commentedBy = Array.from(cbSet);
            m.comments = m.comments || [];
            m.comments.push({ roleId, text: c.commentText, ts: Date.now() });
            await db.moments.put(m);
          }
        });
        renderMoments();
      } catch (e) {
        console.error('mark comments err', e);
      }
    }

    // 8) hook 底部导航显示逻辑（只在聊天列表 screen 可见时显示）
    // 把 bottom-nav-host 插入到 .phone-screen 内底部，使它在聊天页底部显示
    const phoneScreen = document.querySelector('.phone-screen');

    // === Step3 fix: ensure modal overlays are placed inside .phone-screen so absolute positioning works ===
    (function ensureModalsInPhoneScreen() {
      try {
        const phone = document.querySelector('.phone-screen');
        if (!phone) return;
        // move all modal overlays (only once)
        const modalSelectors = ['#post-modal', '.modal-overlay', '#sticker-modal', '#add-sticker-modal', '#time-skip-modal', '#group-recipient-selection-modal'];
        // Use querySelectorAll to move elements that exist and are not already inside phone
        document.querySelectorAll('.modal-overlay, .action-sheet-overlay, .settings-sidebar, #post-modal, #sticker-modal, #add-sticker-modal, #time-skip-modal, #group-recipient-selection-modal').forEach(el => {
          if (!el) return;
          if (phone.contains(el)) return;
          phone.appendChild(el);
        });
      } catch (e) {
        console.error('ensureModalsInPhoneScreen error', e);
      }
    })();

    
if (phoneScreen && bottomNavHost) {
      // 把导航放入 chat-list-screen 底部，使其仅在该 screen 内渲染与定位
      const chatListScreen = document.getElementById('chat-list-screen');
      if (phoneScreen && bottomNavHost.parentElement !== phoneScreen) {
        phoneScreen.appendChild(bottomNavHost);
      }
      bottomNavHost.style.display = 'none'; // 初始隐藏

      // --- 新增：为用户评论按钮添加事件委托 ---
      momentsContainer.addEventListener('click', async (e) => {
                // ... 在 momentsContainer 的 click 监听器内部 ...
      const postBtn = e.target.closest('.post-comment-btn');
      if (postBtn) {
          e.preventDefault();
          const momentId = postBtn.dataset.momentId;
          const input = postBtn.previousElementSibling;
          const commentText = input.value.trim();

          // 获取回复所需信息
          const replyToCommentId = postBtn.dataset.replyToCommentId || null;
          const replyToAuthorName = postBtn.dataset.replyToAuthorName || null;

          if (commentText) {
              await saveUserComment(momentId, commentText, replyToCommentId, replyToAuthorName);
              // 清理输入框和自定义属性
              input.value = '';
              input.placeholder = '添加评论...';
              delete postBtn.dataset.replyToCommentId;
              delete postBtn.dataset.replyToAuthorName;
              postBtn.closest('.moment-comment-input-area').classList.remove('visible');
          } else {
              showToast('评论内容不能为空');
          }
      }
});
      // 绑定按钮（若已有绑定则保持）
      const navButtons = bottomNavHost.querySelectorAll('.nav-btn');
      navButtons.forEach(btn => {
        if (btn._bound) return;
        btn.addEventListener('click', () => {
          navButtons.forEach(b=>b.classList.remove('active'));
          btn.classList.add('active');
          const target = btn.getAttribute('data-target');
          if (typeof window.switchScreen === 'function') {
            window.switchScreen(target);
          } else {
            // 简单回退：切换 active 类并触发自定义事件
            document.querySelectorAll('.screen').forEach(s => s.classList.toggle('active', s.id === target));
            document.dispatchEvent(new CustomEvent('app:screenChanged', { detail: { targetId: target } }));
          }
        });
        btn._bound = true;
      });

      // 初始：如果当前 active 是 chat-list-screen，则显示并保持 chat 按钮 active
      const initActive = document.querySelector('.screen.active');
      if (initActive && initActive.id === 'chat-list-screen') {
        bottomNavHost.style.display = '';
        navButtons.forEach(b => b.classList.toggle('active', b.getAttribute('data-target') === 'chat-list-screen'));
      }
      
async function saveAiReplyToComment(momentId, commentId, replyText, aiAuthorId) {
    try {
        if (!db || !momentId || !commentId || !replyText) return;
        const moment = await db.moments.get(momentId);
        if (!moment) return;

        // 递归查找要回复的评论
        const findCommentAndAddReply = (comments) => {
            for (const c of comments) {
                if (c.id === commentId) {
                    c.replies = c.replies || [];
                    c.replies.push({
                        id: `comment_${Date.now()}`,
                        roleId: aiAuthorId,
                        text: replyText,
                        ts: Date.now(),
                        replyTo: c.roleId // 记录这条回复是回复给谁的
                    });
                    return true;
                }
                if (c.replies && findCommentAndAddReply(c.replies)) {
                    return true;
                }
            }
            return false;
        };

        if (findCommentAndAddReply(moment.comments || [])) {
            await db.moments.put(moment);
            if (typeof renderMoments === 'function') {
                renderMoments();
            }
        }
    } catch (e) {
        console.error(`Failed to save AI reply for comment ${commentId}:`, e);
    }
}
      // 位置更新函数：根据 chat-list-screen 的 active 类显示/隐藏
function updateBottomNavVisibilityByActive() {
    const chatCls = document.getElementById('chat-list-screen');
    const momentsCls = document.getElementById('moments-screen');
    const forumScreen = document.getElementById('forum-screen');
    const forumThreadScreen = document.getElementById('forum-thread-screen');
    const walletScreen = document.getElementById('wallet-screen'); // <-- 新增这一行

    // --- 修改：在判断条件里加入对论坛和钱包页面的检查 ---
    if ((chatCls && chatCls.classList.contains('active')) ||
        (momentsCls && momentsCls.classList.contains('active')) ||
        (forumScreen && forumScreen.classList.contains('active')) ||
        (forumThreadScreen && forumThreadScreen.classList.contains('active')) ||
        (walletScreen && walletScreen.classList.contains('active')) // <-- 新增这一行
       ) {
      bottomNavHost.style.display = '';
    } else {
      bottomNavHost.style.display = 'none';
    }
}
// ▲▲▲ 替换结束 ▲▲▲
      // 立即执行一次
      updateBottomNavVisibilityByActive();

      // 监听 .phone-screen 下 class 变化（屏幕切换通常会触发 class 变化）
      const moTarget = phoneScreen;
      try {
        const mo = new MutationObserver(() => updateBottomNavVisibilityByActive());
        mo.observe(moTarget, { attributes: true, subtree: true, attributeFilter: ['class'] });
      } catch (e) {
        // ignore observer errors
      }
    }
    // 全局切换 screen 的小函数（与页面已有切换保持一致）
    function switchScreen(targetId) {
      // 仅切换 active 类，避免直接改写 style.display 导致布局（flex）异常
      document.querySelectorAll('.screen').forEach(s => {
        s.classList.toggle('active', s.id === targetId);
      });
      // 触发全局事件，通知其他模块屏幕已切换
      try {
        const ev = new CustomEvent('app:screenChanged', { detail: { targetId } });
        document.dispatchEvent(ev);
      } catch (e) {
        console.warn('dispatch app:screenChanged failed', e);
      }
      // 如果进入 moments-screen，渲染
      if (targetId === 'moments-screen' && typeof renderMoments === 'function') renderMoments();
    }

    // 9) 将动态内容与聊天一起发给 AI（挂到 #get-reply-btn）
    const getReplyBtn = $('#get-reply-btn');
    if (getReplyBtn) {
      getReplyBtn.addEventListener('click', async (ev) => {
        // Determine current roleId: try chat-room-title text
        const roleTitleEl = $('#chat-room-title');
        let roleId = roleTitleEl ? roleTitleEl.textContent.trim() : 'role_unknown';
        if (!roleId) roleId = 'role_unknown';

        // collect chat history from #message-area DOM
        const chatArea = $('#message-area');
        let chatText = '';
        if (chatArea) {
          const messages = chatArea.querySelectorAll('.message-bubble');
          const arr = [];
          messages.forEach(mb => {
            // get role name if exists, else fallback to bubble's class
            const wrapper = mb.closest('.message-wrapper');
            let who = wrapper && wrapper.classList.contains('sent') ? '我' : (wrapper && wrapper.classList.contains('received') ? roleId : '');
            arr.push(`${who}: ${mb.textContent.trim()}`);
          });
          chatText = arr.join('\n');
        }

        // pending moments
        const pending = await getPendingMomentsForRole(roleId, 5);

        // build a structured prompt (we'll ask AI to return JSON)
        let prompt = `系统：请按 JSON 格式输出：{"chat_reply":"...","moment_comments":[{"momentId":"...","comment":"..."}]}\n\n`;
        prompt += `聊天记录：\n${chatText}\n\n`;
        if (pending && pending.length) {
          prompt += `需要评论的动态（最多 ${pending.length} 条，按序对应 id）：\n`;
          pending.forEach((m, i) => {
            prompt += `${i+1}) id:${m.id}\ntext:${m.text}\nimageDesc:${m.imageDesc || ''}\n\n`;
          });
        } else {
          prompt += '（无待评论的动态）\n';
        }

        // Try to call existing global sendToAI-like function if exists
        let aiRaw = null;
        try {
          if (typeof window.sendToAI === 'function') {
            aiRaw = await window.sendToAI(prompt);
          } else if (typeof window.callAI === 'function') {
            aiRaw = await window.callAI(prompt);
          } else if (typeof window.sendMessageToModel === 'function') {
            aiRaw = await window.sendMessageToModel(prompt);
          }
        } catch (e) {
          console.error('AI call failed', e);
          showToast('AI 请求失败：' + (e.message || e));
          return;
        }

        // 解析 AI 返回（优先 JSON）
        let parsed = null;
        try {
          parsed = typeof aiRaw === 'string' ? JSON.parse(aiRaw) : aiRaw;
        } catch (e) {
          // fallback: 使用原始文本作为 chat 回复
          parsed = { chat_reply: String(aiRaw || ''), moment_comments: [] };
        }

        // 处理聊天回复：把 parsed.chat_reply 插入聊天区域（若页面已有 appendAIMessageToChat 函数优先使用）
        if (parsed && parsed.chat_reply) {
          if (typeof window.appendAIMessageToChat === 'function') {
            window.appendAIMessageToChat(parsed.chat_reply, roleId);
          } else {
            // 尝试在页面直接插入（如果 message-area 存在）
            const mArea = $('#message-area');
            if (mArea) {
              const wrapper = document.createElement('div');
              wrapper.className = 'message-wrapper received';
              const row = document.createElement('div');
              row.className = 'message-bubble received';
              row.textContent = parsed.chat_reply;
              wrapper.appendChild(row);
              mArea.appendChild(wrapper);
              mArea.scrollTop = mArea.scrollHeight;
            }
          }
        }

        // 处理 moment 评论
        if (parsed && Array.isArray(parsed.moment_comments) && parsed.moment_comments.length) {
          // Normalize to array of {momentId, commentText}
          const normalized = parsed.moment_comments.map(mc => {
            return { momentId: mc.momentId || mc.momentId || mc.id || mc.id, commentText: mc.comment || mc.commentText || mc.text || '' };
          }).filter(x => x.momentId);
          if (normalized.length) {
            await markMomentsCommentedBy(normalized, roleId);
          }
        }

      }); // end getReplyBtn click
    } // end if getReplyBtn

    // small toast helper (reuse existing #toast-notification if exists)
    function showToast(msg, timeout = 2400) {
      const t = $('#toast-notification');
      if (t) {
        t.textContent = msg;
        t.classList.add('show');
        setTimeout(()=>t.classList.remove('show'), timeout);
      } else {
        // fallback
        alert(msg);
      }
    }

    /* simulateAIResponse removed: local simulated AI replies disabled by user request */

// 初始：如果页面当前在 chat-list-screen，显示 bottom nav
    const currentActive = document.querySelector('.screen.active');
    if (currentActive && currentActive.id === 'chat-list-screen') {
      // keep bottom nav visible and make chat button active
      const botNav = document.getElementById('bottom-nav');
      if (botNav) {
        botNav.querySelectorAll('.nav-btn').forEach(b => b.classList.toggle('active', b.getAttribute('data-target') === 'chat-list-screen'));
      }
    }

    // 如果初始存在 moments screen active，则 render
    if (currentActive && currentActive.id === 'moments-screen') renderMoments();

    // --- 将关键函数暴露到全局作用域，以便其他模块调用 ---
    window.getPendingMomentsForRole = getPendingMomentsForRole;
    window.saveMomentComment = saveMomentComment;
    window.saveMomentLike = saveMomentLike;
    window.markMomentsCommentedBy = markMomentsCommentedBy;
    window.renderMoments = renderMoments; // 暴露渲染函数，以便外部模块可以刷新动态列表

  }); // DOMContentLoaded end
})();
</script>


<!-- Begin: Render moments safe patch (injected for step4) -->
<script>
(function(){
  console.log('[injected patch] renderMomentsSafe initializing...');
  try {
    const momentsScreen = document.getElementById('moments-screen');
    if (!momentsScreen) {
      console.warn('[injected patch] #moments-screen not found.');
    }
    // Ensure a container exists
    let momentsContainer = document.getElementById('moments-container');
    if (!momentsContainer && momentsScreen) {
      const content = momentsScreen.querySelector('.content') || momentsScreen;
      momentsContainer = document.createElement('div');
      momentsContainer.id = 'moments-container';
      content.appendChild(momentsContainer);
      console.log('[injected patch] created #moments-container');
    }
    // Safe Dexie wrapper
    let _db = null;
    if (typeof Dexie !== 'undefined') {
        // Use the existing global instance if available
        if (window.AppDB_Moments) {
            _db = window.AppDB_Moments;
        } else {
            try {
                _db = new Dexie('AppDB_Moments');
                _db.version(1).stores({ moments: 'id,timestamp,commentedBy' });
                window.AppDB_Moments = _db; // Ensure it's globally available
            } catch (e) {
                console.warn('[injected patch] Dexie init failed:', e);
                _db = null;
            }
        }
    } else {
        console.warn('[injected patch] Dexie not available.');
    }

// ▼▼▼ 在 renderMomentsSafe 函数的正上方，粘贴这个新函数 ▼▼▼
function getAuthorProfile(authorId) {
    // 默认备用信息
    let profile = { name: '未知用户', avatar: 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg' };

    // 1. 检查是不是用户自己
    const myProfile = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : {};
    if (authorId === (myProfile.id || 'user')) {
        return { name: myProfile.name || '我', avatar: myProfile.avatar };
    }

    // 2. 在所有AI角色中查找
    if (window.db && Array.isArray(window.db.characters)) {
        const character = window.db.characters.find(c => c.id === authorId);
        if (character) {
            return { name: character.remarkName, avatar: character.avatar };
        }
    }

    // 3. 在所有群聊的成员中查找 (以防是群聊成员发的动态)
    if (window.db && Array.isArray(window.db.groups)) {
        for (const group of window.db.groups) {
            if (Array.isArray(group.members)) {
                const member = group.members.find(m => m.id === authorId);
                if (member) {
                    return { name: member.groupNickname, avatar: member.avatar };
                }
            }
        }
    }
    
    return profile; // 如果都找不到，返回默认信息
}
// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 用这个新版本，完整替换掉旧的 renderMomentsSafe 函数 ▼▼▼
    window.renderMomentsSafe = async function renderMomentsSafe() {
      try {
        const container = document.getElementById('moments-container') || (document.getElementById('moments-screen') && document.getElementById('moments-screen').querySelector('#moments-container'));
        if (!container) {
          console.warn('[injected patch] No container found for moments.');
          return;
        }
        let list = [];
        if (_db && _db.moments) {
          try {
            list = await _db.moments.orderBy('timestamp').reverse().toArray();
          } catch (e) {
            console.error('[injected patch] Failed reading moments from IndexedDB:', e);
            list = [];
          }
        } else {
          try {
            const maybeDb = window.AppDB_Moments || null;
            if (maybeDb && maybeDb.moments) {
              list = await maybeDb.moments.orderBy('timestamp').reverse().toArray();
            }
          } catch (e) {
            list = [];
          }
        }

        container.innerHTML = '';
        const momentsEmpty = document.getElementById('moments-empty');
        if (!list || !list.length) {
          if (momentsEmpty) momentsEmpty.style.display = 'block';
          else {
            const p = document.createElement('p');
            p.className = 'placeholder-text';
            p.textContent = '还没有动态，点击右上角发布吧~';
            container.appendChild(p);
          }
          return;
        } else {
          if (momentsEmpty) momentsEmpty.style.display = 'none';
        }

        list.forEach(m => {
          try {
            const div = document.createElement('div'); div.className = 'moment-item';
            div.dataset.id = m.id || (m.id = (Math.random()+''+Date.now()));
            const head = document.createElement('div'); head.className = 'moment-head';
            const avatar = document.createElement('img'); avatar.className = 'moment-avatar';
            const meta = document.createElement('div'); meta.className = 'moment-meta';
            const name = document.createElement('div'); name.style.fontWeight='700';
            const time = document.createElement('div'); time.style.fontSize='12px'; time.style.color='#999';
            try { time.textContent = new Date(m.timestamp).toLocaleString(); } catch(e) { time.textContent = ''; }
            
            // --- 核心修改在这里 ---
            const authorInfo = getAuthorProfile(m.authorId); // 使用新函数查找作者信息
            name.textContent = authorInfo.name || m.author || '未知用户'; // 优先用新找到的名字，找不到再用快照里的旧名字
            avatar.src = authorInfo.avatar || m.authorAvatar || 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg'; // 优先用新找到的头像，找不到再用快照里的
            // --- 修改结束 ---

            meta.appendChild(name);
            meta.appendChild(time);
            head.appendChild(avatar);
            head.appendChild(meta);
            div.appendChild(head);

            const txt = document.createElement('div'); txt.className='moment-text'; txt.textContent = m.text || '';
            div.appendChild(txt);

            if (m.imageData && m.imageData !== 'null' && m.imageData !== 'undefined' && m.imageData.length>10) {
              const im = document.createElement('img'); im.className = 'moment-image';
              im.src = m.imageData;
              im.alt = m.imageDesc ? m.imageDesc : (m.text || '动态图片');
              div.appendChild(im);
              if (m.imageDesc) {
                const desc = document.createElement('div'); desc.style.fontSize='13px'; desc.style.color='#666';
                desc.textContent = '图片：' + m.imageDesc;
                div.appendChild(desc);
              }
            } else if (m.imageDesc) {
              const descCard = document.createElement('div'); descCard.className = 'moment-image-desc-card';
              if (m.id) descCard.dataset.momentId = m.id || '';
              const descContent = document.createElement('p'); descContent.className = 'desc-content';
              descContent.textContent = m.imageDesc;
              descCard.appendChild(descContent);
              descCard.setAttribute('role', 'img');
              descCard.setAttribute('aria-label', m.imageDesc);
              descCard.addEventListener('click', function () { /* show detail */ });
              div.appendChild(descCard);
            }

            const actions = document.createElement('div');
            actions.className = 'moment-actions';
            
            const likeBtn = document.createElement('button');
            likeBtn.className = 'moment-action-btn';
            const likes = m.likes || [];
            const myProfile = loadProfileFromStorage();
            const myId = myProfile.id || 'user';
            if (likes.includes(myId)) {
                likeBtn.classList.add('liked');
            }
            likeBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg><span>${likes.length > 0 ? likes.length : '点赞'}</span>`;
            
            likeBtn.addEventListener('click', async (event) => {
                const btn = event.currentTarget;
                const momentItem = btn.closest('.moment-item');
                const currentLikes = m.likes || [];
                const myIdx = currentLikes.indexOf(myId);

                if (myIdx > -1) {
                    currentLikes.splice(myIdx, 1);
                    btn.classList.remove('liked');
                } else {
                    currentLikes.push(myId);
                    btn.classList.add('liked');
                }
                m.likes = currentLikes;
                await db.moments.put(m);

                const span = btn.querySelector('span');
                if (span) {
                    span.textContent = currentLikes.length > 0 ? currentLikes.length : '点赞';
                }

                const likesWrap = momentItem.querySelector('.moment-likes');
                if (likesWrap) {
                    if (currentLikes.length > 0) {
                        const likeNames = currentLikes.map(likeId => window.getAuthorNameById(likeId)).join(', ');
                        likesWrap.innerHTML = `<span class="like-icon">♥</span> ${likeNames}`;
                        likesWrap.classList.add('visible');
                    } else {
                        likesWrap.classList.remove('visible');
                    }
                }
            });

            const commentBtn = document.createElement('button');
            commentBtn.className = 'moment-action-btn';
            commentBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg><span>评论</span>`;
            commentBtn.addEventListener('click', (event) => {
                event.stopPropagation();
                const btn = event.currentTarget;
                const momentItem = btn.closest('.moment-item');
                if (momentItem) {
                    const inputArea = momentItem.querySelector('.moment-comment-input-area');
                    if (inputArea) {
                        inputArea.classList.toggle('visible');
                        if (inputArea.classList.contains('visible')) {
                            inputArea.querySelector('input').focus();
                        }
                    }
                }
            });

            actions.appendChild(likeBtn);
            actions.appendChild(commentBtn);
            div.appendChild(actions);

            if (likes.length > 0) {
                const likesWrap = document.createElement('div');
                likesWrap.className = 'moment-likes visible';
                const likeNames = likes.map(likeId => window.getAuthorNameById(likeId)).join(', ');
                likesWrap.innerHTML = `<span class="like-icon">♥</span> ${likeNames}`;
                div.appendChild(likesWrap);
            }

            const commentsWrap = document.createElement('div'); commentsWrap.className = 'moment-comments';
            if (m.comments && m.comments.length) {
              m.comments.forEach(c => {
                const cm = document.createElement('div'); cm.className='moment-comment';
                const authorName = window.getAuthorNameById(c.roleId || c.role);
                cm.textContent = `${authorName}：${c.text}`;
                commentsWrap.appendChild(cm);
              });
            } else {
              const none = document.createElement('div'); none.style.color='#bbb'; none.textContent = '暂时没有评论';
              commentsWrap.appendChild(none);
            }
            div.appendChild(commentsWrap);

            const commentInputArea = document.createElement('div');
            commentInputArea.className = 'moment-comment-input-area';
            commentInputArea.innerHTML = `
              <input type="text" class="moment-comment-input" placeholder="添加评论...">
              <button class="post-comment-btn" data-moment-id="${m.id}">发布</button>
            `;
            div.appendChild(commentInputArea);
            container.appendChild(div);
          } catch (innerErr) {
            console.error('[injected patch] render single moment failed', innerErr, m);
          }
        });

      } catch (err) {
        console.error('[injected patch] renderMomentsSafe failed', err);
        const container = document.getElementById('moments-container') || (document.getElementById('moments-screen') && document.getElementById('moments-screen').querySelector('.content'));
        if (container) {
          container.innerHTML = '<div style="color:#b00;padding:12px;border-radius:10px;background:#fff8f8;">加载动态时出错（详情见 Console）</div>';
        }
      }
    };
// ▲▲▲ 替换结束 ▲▲▲
  

    // Attach to app:screenChanged and mutation observer
    document.addEventListener('app:screenChanged', (ev) => {
      try {
        if (ev && ev.detail && ev.detail.targetId === 'moments-screen') {
          window.renderMomentsSafe();
        }
      } catch (e) { console.error('[injected patch] app:screenChanged handler failed', e); }
    });

    const phone = document.querySelector('.phone-screen') || document.body;
    const mo = new MutationObserver((mutations) => {
  try {
    // 只在 phone 节点本身的 class 发生变化时才触发（避免子元素的 class 变动导致重渲染）
    const phoneClassChanged = mutations.some(m =>
      m.type === 'attributes' && m.attributeName === 'class' && m.target === phone
    );
    if (!phoneClassChanged) return;

    const active = document.querySelector('.screen.active');
    if (active && active.id === 'moments-screen') {
      window.renderMomentsSafe();
    }
  } catch (e) { console.error('[injected patch] MutationObserver callback failed', e); }
});
// 仅观察 phone 自身的 attributes（不要 subtree=true）
mo.observe(phone, { attributes: true, subtree: false, attributeFilter: ['class'] });


    // try initial render
    setTimeout(() => {
      try { window.renderMomentsSafe(); } catch(e) { console.warn('[injected patch] initial render failed', e); }
    }, 300);

  } catch (e) {
    console.error('[injected patch] initialization failed', e);
  }
})();
</script>
<!-- End: Render moments safe patch -->


<script>
/* === 确保 #moments-screen 永远在 .phone-screen 内，并清除会把它推出视窗的内联样式 (自动插入补丁) === */

(function ensureMomentsStaysInPhone() {
  function fixPlacementAndStyles() {
    const phone = document.querySelector('.phone-screen');
    const moments = document.getElementById('moments-screen');
    if (!phone) return;

    // If moments exists, ensure it's inside phone but *do not force inline styles on it*
    if (moments && !phone.contains(moments)) {
      phone.appendChild(moments);
      console.log('[patch] moved #moments-screen into .phone-screen');
    }

    // Only normalize styles for screens *other than* moments-screen or elements managed by injection
    document.querySelectorAll('.screen').forEach(s => {
      if (s.id === 'moments-screen' || s.dataset.managedBy === 'injection') {
        // make sure its stacking context is reasonable but don't clobber its layout
        s.style.zIndex = s.style.zIndex || '0';
        return;
      }
      // Apply conservative safe defaults to other screens
      s.style.position = s.style.position || 'absolute';
      s.style.top = s.style.top || '0';
      s.style.left = s.style.left || '0';
      s.style.right = s.style.right || '0';
      s.style.bottom = s.style.bottom || '0';
      // Avoid removing transforms which some screens might rely on; only clear very specific problematic inline styles
      if ((s.style.transform || '').includes('translate') || (s.style.transform || '').includes('translateY')) {
        // leave transforms intact to avoid breaking animations
      } else {
        s.style.transform = s.style.transform || '';
      }
      s.style.margin = s.style.margin || '';
      // ensure screens stack below nav/modals
      s.style.zIndex = s.style.zIndex || '0';
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', fixPlacementAndStyles);
  } else {
    fixPlacementAndStyles();
  }
  // only run on custom app events; do not poll aggressively to avoid fighting the injected UI
  document.addEventListener('app:screenChanged', fixPlacementAndStyles);
  // run a very infrequent check as a last resort
  setInterval(fixPlacementAndStyles, 5000);
})();
</script>

<!-- === /patch === -->

<!-- Avatar overlap CSS override (scaled to 70%) inserted by assistant -->
<style>
.icity-moments-inner {
  --icity-hero-h: 154px;      /* 70% of original 220px */
  --icity-avatar-size: 98px;  /* 70% of original 140px */
  position: relative;
  box-sizing: border-box;
}

.icity-hero {
  height: var(--icity-hero-h) !important;
  position: relative;
  overflow: hidden;
  border-radius: 14px 14px 0 0;
  box-sizing: border-box;
}

.icity-avatar-wrap {
  position: absolute !important;
  left: 50% !important;
  transform: translateX(-50%) !important;
  width: var(--icity-avatar-size) !important;
  height: var(--icity-avatar-size) !important;
  border-radius: 50% !important;
  top: calc(var(--icity-hero-h) - (var(--icity-avatar-size) * 0.7)) !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  z-index: 50 !important;
  background: #fff !important;
  box-shadow: 0 8px 22px rgba(0,0,0,0.12) !important;
  border: 6px solid rgba(255,255,255,0.95) !important;
  box-sizing: border-box !important;
  overflow: visible !important;
}

.icity-avatar-wrap img,
.icity-avatar-wrap .avatar-img {
  width: 80% !important;
  height: 80% !important;
  border-radius: 50% !important;
  object-fit: cover !important;
  display: block !important;
}

.icity-info-card {
  position: relative !important;
  padding-top: calc(var(--icity-avatar-size) * 0.2 + 4px) !important; /* Reduced top padding */
  padding-right: 18px !important;
  padding-left: 18px !important;
  padding-bottom: 10px !important; /* Reduced bottom padding */
  margin-top: 10px !important;
  background: #fff !important;
  border-radius: 14px !important;
  box-shadow: 0 6px 18px rgba(0,0,0,0.04) !important;
  box-sizing: border-box !important;
  text-align: center !important;
}

/* Reduce vertical spacing and font sizes for a more compact info card */
.icity-name {
    font-size: 18px !important;
    line-height: 1.1 !important;
}
.icity-id-loc {
    margin-top: 6px !important;
    font-size: 12px !important;
    line-height: 1.1 !important;
}
.icity-signature {
    margin-top: 8px !important;
    font-size: 13px !important;
    line-height: 1.2 !important;
}

@media (max-width: 420px) {
  .icity-moments-inner {
    --icity-hero-h: 112px;  /* 70% of previous 160px */
    --icity-avatar-size: 77px; /* 70% of previous 110px */
  }
}
  
</style>
<!-- End assistant-inserted CSS -->

<!-- === Avatar & Background Edit Feature === -->
<div class="action-sheet-overlay" id="edit-top-section-actionsheet">
  <div class="action-sheet">
    <button class="action-sheet-button" id="edit-bg-btn">更换背景图</button>
    <button class="action-sheet-button" id="edit-avatar-btn">更换头像</button>
    <button class="action-sheet-button danger" id="cancel-edit-top-btn">取消</button>
  </div>
</div>
<input type="file" accept="image/*" id="top-section-file-input" style="display:none;" />

<script>
(function(){
    const topSection = document.querySelector('#moments-screen .icity-moments-inner .icity-hero') || document.querySelector('#moments-screen .icity-hero') || document.querySelector('#moments-screen .top-section') || document.querySelector('#moments-screen header');
    const editSheet = document.getElementById('edit-top-section-actionsheet');
    const bgBtn = document.getElementById('edit-bg-btn');
    const avatarBtn = document.getElementById('edit-avatar-btn');
    const cancelBtn = document.getElementById('cancel-edit-top-btn');
    const fileInput = document.getElementById('top-section-file-input');

    let currentEditTarget = null;

    // Restore saved bg & avatar
    const savedBg = localStorage.getItem('myTopBg');
    const savedAvatar = localStorage.getItem('myTopAvatar');
    if(savedBg && topSection) {
        topSection.style.backgroundImage = `url('${savedBg}')`;
        topSection.style.backgroundSize = 'cover';
        topSection.style.backgroundPosition = 'center';
    }
    if(savedAvatar) {
        document.querySelectorAll('.my-avatar, #moments-screen .top-avatar').forEach(img=>{
            if(img.tagName === 'IMG') img.src = savedAvatar;
            else img.style.backgroundImage = `url('${savedAvatar}')`;
        });
    }

    // Previously opened the whole topSection on click — removed to avoid accidental edits during publish.
    // Now only explicit edit controls (avatar/background buttons and per-field clicks) will trigger edits.

    cancelBtn.addEventListener('click', ()=>{
        editSheet.classList.remove('visible');
    });

    function chooseSource(targetType) {
        const url = prompt('输入图片URL，或留空选择本地文件：');
        if(url) {
            applyImage(targetType, url);
        } else {
            currentEditTarget = targetType;
            fileInput.click();
        }
    }

    function applyImage(targetType, dataUrl) {
        if(targetType === 'bg') {
            if(topSection) {
                topSection.style.backgroundImage = `url('${dataUrl}')`;
                topSection.style.backgroundSize = 'cover';
                topSection.style.backgroundPosition = 'center';
            }
            localStorage.setItem('myTopBg', dataUrl);
        } else if(targetType === 'avatar') {
            localStorage.setItem('myTopAvatar', dataUrl);
            document.querySelectorAll('.my-avatar, #moments-screen .top-avatar').forEach(img=>{
                if(img.tagName === 'IMG') img.src = dataUrl;
                else img.style.backgroundImage = `url('${dataUrl}')`;
            });
            // 同步动态列表头像（moment-avatar 为动态列表头像类）
            document.querySelectorAll('.post .avatar-img, .moment-avatar').forEach(img => {
                if(img.tagName === 'IMG') img.src = dataUrl;
                else img.style.backgroundImage = `url('${dataUrl}')`;
            });
            // 尝试更新数据库中属于当前用户(authorId匹配)或无 authorId 但 author 名称匹配的 moments 的 authorAvatar 字段（若存在 db）
            try{
                if(window.AppDB_Moments && typeof AppDB_Moments !== 'undefined' && AppDB_Moments.moments){
                    (async ()=>{
                        try{
                            const all = await AppDB_Moments.moments.toArray();
                            const profile = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : {
                                name: localStorage.getItem('myTopName') || '我',
                                id: localStorage.getItem('myTopId') || 'user',
                                avatar: localStorage.getItem('myTopAvatar') || null
                            };
                            for(const m of all){
                                // Update moments that explicitly reference this author's id
                                if((m.authorId && m.authorId === profile.id) || (!m.authorId && m.author === profile.name)){
                                    m.authorAvatar = dataUrl;
                                    // If the moment had no authorId, bind it to current profile.id so future syncs work
                                    if(!m.authorId) m.authorId = profile.id;
                                    try{ await AppDB_Moments.moments.put(m); }catch(e){ /* ignore put errors for individual items */ }
                                }
                            }
                            // After DB updates, re-render moments so DOM reflects DB changes
                            if(typeof renderMoments === 'function') try{ renderMoments(); }catch(e){}
                            else if(typeof window.renderMomentsSafe === 'function') try{ window.renderMomentsSafe(); }catch(e){}
                        }catch(e){}
                    })();
                }
            }catch(e){}
            // Ensure profile render + sync runs to update in-memory DOM and trigger any re-renders
            try{ if(typeof renderProfileAndSync === 'function') renderProfileAndSync(); }catch(e){}
        }
    }
fileInput.addEventListener('change', async (e)=>{
        const file = e.target.files[0];
        if(file) {
            try {
                const compressedUrl = await compressImage(file, { quality: 0.85, maxWidth: 1080, maxHeight: 1920 });
                applyImage(currentEditTarget, compressedUrl);
            } catch (error) {
                if(typeof showToast === 'function') showToast('图片处理失败，请重试');
                console.error('Background image compression failed:', error);
            }
        }
    });

    bgBtn.addEventListener('click', ()=> chooseSource('bg'));
    avatarBtn.addEventListener('click', ()=> chooseSource('avatar'));
})();
</script>
<!-- === /Avatar & Background Edit Feature === -->


<!-- Avatar sync patch: non-invasive, appended to avoid modifying original logic.
     Purpose: ensure top avatar updates immediately and moments list does not revert
     by synchronizing DOM and (if possible) the DB after avatar changes. -->
<script>
(function(){
  'use strict';

  // Utility: load profile from existing function if available, otherwise from localStorage
  function loadProfileFallback(){
    try {
      if(typeof loadProfileFromStorage === 'function'){
        var p = loadProfileFromStorage();
        if(p && (p.avatar || p.id || p.name)) return p;
      }
    } catch(e){}
    // fallback to localStorage keys used by the app
    try {
      return {
        id: localStorage.getItem('myTopId') || localStorage.getItem('icity-id') || localStorage.getItem('userId') || null,
        name: localStorage.getItem('myTopName') || localStorage.getItem('icity-name') || localStorage.getItem('userName') || null,
        avatar: localStorage.getItem('myTopAvatar') || localStorage.getItem('icity-avatar-src') || localStorage.getItem('userAvatar') || null,
        signature: localStorage.getItem('myTopSignature') || null,
        location: localStorage.getItem('myTopLocation') || null
      };
    } catch(e){
      return {};
    }
  }

  // Robustly update top-profile DOM elements and common avatar selectors
  function updateTopProfileAndAvatars(){
    try {
      var p = loadProfileFallback() || {};
      var avatar = p.avatar || null;
      // find common top avatar elements
      var avatarSelectors = [
        '#icity-avatar', // explicit id
        '.icity-avatar-wrap img',
        '.top-avatar',
        '.my-avatar',
        '.header-avatar img',
        '.profile-avatar img'
      ];
      avatarSelectors.forEach(function(sel){
        document.querySelectorAll(sel).forEach(function(el){
          try {
            if(!el) return;
            if(el.tagName === 'IMG'){
              if(avatar) el.src = avatar;
            } else {
              if(avatar) el.style.backgroundImage = "url('"+avatar+"')";
            }
          } catch(e){}
        });
      });

      // update textual profile elements defensively
      var nameEls = [document.getElementById('icity-name'), document.querySelector('.icity-name'), document.querySelector('.profile-name')];
      nameEls.forEach(function(el){
        if(el && p.name) try{ el.textContent = p.name; }catch(e){}
      });
      var sigEls = [document.getElementById('icity-signature'), document.querySelector('.icity-signature')];
      sigEls.forEach(function(el){
        if(el && p.signature) try{ el.textContent = p.signature; }catch(e){}
      });

      // update moments list avatars for moments authored by current profile (best-effort)
      try {
        var id = p.id || null;
        var name = p.name || null;
        var avatars = document.querySelectorAll('.moment-avatar, .post .avatar-img, .post .author-avatar, .item .avatar, .comment .avatar, img[data-role="avatar"]');
        avatars.forEach(function(img){
          try {
            if(!img) return;
            // try dataset or attributes
            var authorId = img.getAttribute('data-author-id') || img.dataset && img.dataset.authorId || null;
            var authorName = img.getAttribute('data-author') || img.getAttribute('data-author-name') || img.dataset && img.dataset.author || null;

            // also try to find author id/name from closest ancestor
            if(!authorId || !authorName){
              var ancestor = img.closest('[data-author-id], [data-author], .moment, .post');
              if(ancestor){
                if(!authorId) authorId = ancestor.getAttribute('data-author-id') || ancestor.getAttribute('data-author') || null;
                if(!authorName) authorName = ancestor.getAttribute('data-author-name') || ancestor.getAttribute('data-author') || null;
                // check for .author-name text
                if(!authorName){
                  var an = ancestor.querySelector('.author-name, .name, .post-author');
                  if(an) authorName = (an.textContent || '').trim();
                }
              }
            }

            // Decision: if authorId matches, or authorName matches (best-effort), update the img.src
            var shouldUpdate = false;
            if(id && authorId && String(authorId) === String(id)) shouldUpdate = true;
            if(!shouldUpdate && name && authorName && String((authorName||'').trim()) === String((name||'').trim())) shouldUpdate = true;

            if(shouldUpdate && avatar){
              if(img.tagName === 'IMG'){
                img.src = avatar;
              } else {
                img.style.backgroundImage = "url('"+avatar+"')";
              }
            }
          } catch(e){}
        });
      } catch(e){}
    } catch(e){}
  }

  // Try to update a Dexie/DB moments table authorAvatar entries for current user (best-effort, non-blocking)
  function tryUpdateDBMomentsAvatar(newAvatar){
    try {
      var p = loadProfileFallback();
      if(!p || !p.id || !newAvatar) return;
      // if window.AppDB_Moments and Dexie-like table exists, try to update entries where authorId matches
      if(window.AppDB_Moments && window.AppDB_Moments.moments){
        try {
          // If it's Dexie or has where API
          if(typeof window.AppDB_Moments.moments.where === 'function' && typeof window.AppDB_Moments.moments.toArray === 'function'){
            // best-effort: update authorAvatar for matching authorId
            // .where('authorId').equals(p.id).modify({ authorAvatar: newAvatar }) might exist
            if(typeof window.AppDB_Moments.moments.where === 'function'){
              try {
                var q = window.AppDB_Moments.moments.where('authorId').equals(p.id);
                if(q && typeof q.modify === 'function'){
                  q.modify(function(obj){ obj.authorAvatar = newAvatar; });
                } else {
                  // fallback: scan and put
                  window.AppDB_Moments.moments.toArray().then(function(arr){
                    arr.forEach(function(item){
                      try {
                        if(item.authorId && String(item.authorId) === String(p.id)){
                          item.authorAvatar = newAvatar;
                          if(window.AppDB_Moments.moments.put) window.AppDB_Moments.moments.put(item);
                        }
                      } catch(e){}
                    });
                  }).catch(function(){});
                }
              } catch(e){}
            }
          } else if(typeof window.AppDB_Moments.moments.update === 'function'){
            // unknown API: attempt to update each by scanning
            try {
              window.AppDB_Moments.moments.toArray().then(function(arr){
                arr.forEach(function(item){
                  if(item.authorId && String(item.authorId) === String(p.id)){
                    item.authorAvatar = newAvatar;
                    try { window.AppDB_Moments.moments.update(item.id, item); } catch(e){}
                  }
                });
              }).catch(function(){});
            } catch(e){}
          }
        } catch(e){}
      }
    } catch(e){}
  }

  // Wrap existing applyImage (if present) so after changing avatar we sync
  if(typeof window.applyImage === 'function'){
    try {
      var origApplyImage = window.applyImage;
      window.applyImage = function(){
        try {
          var res = origApplyImage.apply(this, arguments);
          // schedule sync shortly after (some apps update DOM async)
          setTimeout(function(){
            try {
              updateTopProfileAndAvatars();
              var p = loadProfileFallback();
              if(p && p.avatar) tryUpdateDBMomentsAvatar(p.avatar);
            } catch(e){}
          }, 100);
          return res;
        } catch(e){
          try { return origApplyImage.apply(this, arguments); } catch(e){ return undefined; }
        }
      };
    } catch(e){}
  } else {
    // If applyImage not found, expose a safe function for callers to use
    window.__syncAvatarsAfterChange = function(){
      try {
        updateTopProfileAndAvatars();
        var p = loadProfileFallback();
        if(p && p.avatar) tryUpdateDBMomentsAvatar(p.avatar);
      } catch(e){}
    };
  }

  // If renderMomentsSafe exists, wrap it to call our sync after running original
  if(typeof window.renderMomentsSafe === 'function'){
    try {
      var _origRenderMomentsSafe = window.renderMomentsSafe;
      window.renderMomentsSafe = function(){
        try {
          var res = _origRenderMomentsSafe.apply(this, arguments);
          // after render, ensure our avatars are applied
          setTimeout(function(){ updateTopProfileAndAvatars(); }, 20);
          return res;
        } catch(e){
          try { return _origRenderMomentsSafe.apply(this, arguments); } catch(e){ return undefined; }
        }
      };
    } catch(e){}
  }

  // Also wrap any generic renderMoments function if present
  if(typeof window.renderMoments === 'function'){
    try {
      var _origRenderMoments = window.renderMoments;
      window.renderMoments = function(){
        try {
          var res = _origRenderMoments.apply(this, arguments);
          setTimeout(function(){ updateTopProfileAndAvatars(); }, 20);
          return res;
        } catch(e){
          try { return _origRenderMoments.apply(this, arguments); } catch(e){ return undefined; }
        }
      };
    } catch(e){}
  }

  // Run once at load to align UI with stored avatar (without waiting for user action)
  try { setTimeout(updateTopProfileAndAvatars, 50); } catch(e){}

  // Expose for debugging (non-enumerable)
  try { Object.defineProperty(window, '__updateProfileAndAvatars', { value: updateTopProfileAndAvatars, writable: false }); } catch(e){}

  // Do not interfere with bottom navigation: avoid touching elements with ids/classes typically used by navbars.
  // The script only touches avatar/name related selectors and moment avatars; it is intentionally conservative.

})();
</script>

<!-- Stronger enforcement: bind moment avatars to top avatar persistently -->
<script>
(function(){
  'use strict';
  // Helper to read top avatar from DOM or storage
  function getTopAvatar(){
    try {
      // Try common selectors for top avatar
      var selectors = ['#icity-avatar', '.icity-avatar-wrap img', '.top-avatar', '.header-avatar img', '.profile-avatar img', '.my-avatar'];
      for(var i=0;i<selectors.length;i++){
        var el = document.querySelector(selectors[i]);
        if(el){
          if(el.tagName === 'IMG' && el.src) return el.src;
          var bg = window.getComputedStyle(el).backgroundImage;
          if(bg && bg !== 'none'){
            // extract url("...") content
            var m = bg.match(/url\(["']?(.*?)["']?\)/);
            if(m && m[1]) return m[1];
          }
        }
      }
      // fallback to storage
      var p = null;
      try { if(typeof loadProfileFromStorage === 'function') p = loadProfileFromStorage(); } catch(e){}
      if(!p) p = {
        avatar: localStorage.getItem('myTopAvatar') || localStorage.getItem('userAvatar') || localStorage.getItem('icity-avatar-src')
      };
      if(p && p.avatar) return p.avatar;
    } catch(e){}
    return null;
  }

  // Helper to determine if an avatar img belongs to current user (best-effort)
  function isAvatarForCurrentUser(imgEl){
    try {
      if(!imgEl) return false;
      var p = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : null;
      if(!p) p = { id: localStorage.getItem('myTopId'), name: localStorage.getItem('myTopName') };
      var authorId = imgEl.getAttribute('data-author-id') || (imgEl.dataset && imgEl.dataset.authorId) || null;
      var authorName = imgEl.getAttribute('data-author') || imgEl.getAttribute('data-author-name') || (imgEl.dataset && imgEl.dataset.author) || null;
      if(!authorId && !authorName){
        var anc = imgEl.closest('[data-author-id], [data-author], .moment, .post, .item');
        if(anc){
          authorId = authorId || anc.getAttribute('data-author-id') || anc.getAttribute('data-author');
          authorName = authorName || anc.getAttribute('data-author-name') || anc.getAttribute('data-author');
          if(!authorName){
            var authorNameNode = anc.querySelector('.author-name, .name, .post-author, .author');
            if(authorNameNode) authorName = (authorNameNode.textContent || '').trim();
          }
        }
      }
      if(p && p.id && authorId && String(p.id) === String(authorId)) return true;
      if(p && p.name && authorName && String((p.name||'').trim()) === String((authorName||'').trim())) return true;
      // Also check if img has attribute data-me or class 'me' etc
      if(imgEl.hasAttribute('data-me') || imgEl.classList.contains('me') || imgEl.classList.contains('self')) return true;
    } catch(e){}
    return false;
  }

  // Enforce top avatar on matching nodes
  function enforceTopAvatarOnNode(imgEl, topAvatar){
    try {
      if(!imgEl || !topAvatar) return;
      // Avoid touching nav icons: check ancestor tags that might be navbars
      var navAncestor = imgEl.closest('nav, .navbar, .bottom-nav, .footer');
      if(navAncestor) return; // don't modify nav images
      // Only enforce if this img seems like a moment/post avatar
      var selMatch = /(^|\s)(moment-avatar|avatar-img|author-avatar|post-avatar|item-avatar|my-avatar|top-avatar|author-avatar-img)(\s|$)/i;
      var classStr = imgEl.className || '';
      // If it looks like an avatar or is IMG inside .moment/.post, proceed
      var likelyAvatar = classStr && selMatch.test(classStr) || imgEl.closest('.moment, .post, .item, .comment') || imgEl.getAttribute('data-role') === 'avatar';
      if(!likelyAvatar) return;
      if(!isAvatarForCurrentUser(imgEl)) return;
      // If current src differs, set it
      if(imgEl.tagName === 'IMG'){
        if(imgEl.src !== topAvatar){
          try { imgEl.src = topAvatar; } catch(e){}
        }
      } else {
        try { imgEl.style.backgroundImage = "url('"+topAvatar+"')"; } catch(e){}
      }
      // mark as forced to avoid loops
      try { imgEl.setAttribute('data-avatar-forced','1'); } catch(e){}
    } catch(e){}
  }

  // Enforce across the document
  function enforceTopAvatarAll(topAvatar){
    if(!topAvatar) return;
    var selectors = ['.moment-avatar', '.post .avatar-img', '.post .author-avatar', '.item .avatar', '.comment .avatar', 'img[data-role="avatar"]', '.avatar-img'];
    selectors.forEach(function(sel){
      document.querySelectorAll(sel).forEach(function(img){
        enforceTopAvatarOnNode(img, topAvatar);
      });
    });
  }

  // Mutation observer to catch src changes and new nodes
  var observer = new MutationObserver(function(muts){
    try {
      var top = getTopAvatar();
      muts.forEach(function(m){
        try {
          if(m.type === 'attributes' && (m.attributeName === 'src' || m.attributeName === 'style' || m.attributeName === 'data-author-id' || m.attributeName === 'data-author')){
            var target = m.target;
            if(target && (target.tagName === 'IMG' || target.nodeType === 1)){
              enforceTopAvatarOnNode(target, top);
            }
          } else if(m.type === 'childList' && m.addedNodes && m.addedNodes.length){
            m.addedNodes.forEach(function(node){
              try {
                if(node.nodeType !== 1) return;
                // find descendant avatar images
                var imgs = node.querySelectorAll && node.querySelectorAll('.moment-avatar, .avatar-img, img[data-role="avatar"], .author-avatar');
                if(imgs && imgs.length){
                  imgs.forEach(function(img){ enforceTopAvatarOnNode(img, top); });
                }
                // also if the node itself is an IMG
                if(node.tagName === 'IMG') enforceTopAvatarOnNode(node, top);
              } catch(e){}
            });
          }
        } catch(e){}
      });
    } catch(e){}
  });

  try {
    observer.observe(document.body, { attributes: true, childList: true, subtree: true, attributeFilter: ['src','style','data-author-id','data-author','data-author-name'] });
  } catch(e){}

  // Also run periodic enforcement for initial seconds to handle race conditions
  var enforcementRuns = 0;
  var enforcementTimer = setInterval(function(){
    try {
      enforcementRuns++;
      var top = getTopAvatar();
      if(top) enforceTopAvatarAll(top);
      // Try to update DB as well to persist
      try {
        if(top && typeof window.__updateProfileAndAvatars === 'function'){
          window.__updateProfileAndAvatars();
        }
      } catch(e){}
      if(enforcementRuns > 40) { // run ~40 times at 200ms => 8 seconds then stop
        clearInterval(enforcementTimer);
      }
    } catch(e){}
  }, 200);

  // Expose a function to explicitly bind list avatars to top avatar and optionally persist to DB
  window.bindMomentsAvatarsToTop = function(persistToDB){
    try {
      var top = getTopAvatar();
      if(!top) return;
      enforceTopAvatarAll(top);
      if(persistToDB){
        // try to update DB entries authorAvatar for current user
        try {
          var p = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : { id: localStorage.getItem('myTopId') };
          if(p && p.id && window.AppDB_Moments && window.AppDB_Moments.moments){
            if(typeof window.AppDB_Moments.moments.where === 'function' && typeof window.AppDB_Moments.moments.modify === 'function'){
              try { window.AppDB_Moments.moments.where('authorId').equals(p.id).modify(function(o){ o.authorAvatar = top; }); } catch(e){}
            } else if(typeof window.AppDB_Moments.moments.toArray === 'function'){
              window.AppDB_Moments.moments.toArray().then(function(arr){
                arr.forEach(function(item){
                  if(item && item.authorId && String(item.authorId) === String(p.id)){
                    item.authorAvatar = top;
                    try { if(window.AppDB_Moments.moments.put) window.AppDB_Moments.moments.put(item); } catch(e){}
                  }
                });
              }).catch(function(){});
            }
          }
        } catch(e){}
      }
    } catch(e){}
  };

  // Attempt immediate bind once loaded
  try { setTimeout(function(){ window.bindMomentsAvatarsToTop(true); }, 100); } catch(e){}

  // defensive cleanup if script re-inserted: no-op

})();
</script>

<!-- Remove/hide avatars in moments list while preserving top avatar -->



<!-- Avatar fill patch: make avatar image fully fill its circular container (remove inner white gap) -->
<style>
/* Conservative selectors for avatar containers and images */
.icity-avatar-wrap, .avatar-wrap, .profile-avatar, .header-avatar, .my-avatar, .top-avatar, .avatar-circle, .avatar-holder {
  background: transparent !important;
  padding: 0 !important;
  border: 0 !important;
  overflow: hidden !important;
  border-radius: 50% !important;
  display: inline-block !important;
}

/* Ensure the img fills the container */
.icity-avatar-wrap img, .avatar-wrap img, .profile-avatar img, .header-avatar img, .my-avatar img, .top-avatar img, img.avatar-img, img[data-role="avatar"] {
  width: 100% !important;
  height: 100% !important;
  object-fit: cover !important;
  display: block !important;
  border-radius: 50% !important;
  background: transparent !important;
  padding: 0 !important;
  margin: 0 auto !important;
}

/* If the container uses an inner padding element, hide it */
.icity-avatar-wrap .inner-avatar, .avatar-wrap .inner, .avatar-inner {
  display: none !important;
}
</style>



<!-- Moments 多选删除底部操作栏 -->
<div id="moments-multi-select-bar" class="multi-select-bar" aria-hidden="true">
  <div class="msb-left">
    <span id="moments-selected-count">已选择 0 项</span>
  </div>
  <div class="msb-right">
    <button id="moments-confirm-delete" class="danger">确认删除</button>
    <button id="moments-cancel-delete">取消</button>
  </div>
</div>



<!-- 覆盖：确保 moment 图片描述卡的底色与文字颜色生效（放在文件末尾以覆盖所有样式） -->
<style>
.moment-image-desc-card {
  background: #eef0f3 !important; /* 浅灰底色 - 覆盖原有渐变 */
  border: 6px solid #ffffff !important;
  box-shadow: 0 6px 20px rgba(10,10,20,0.06) !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;

  padding: 12px 14px !important;
  margin-top: 6px !important;
  min-height: 86px !important;
}
.moment-image-desc-card .desc-content { font-size: 13px !important; }

.moment-image-desc-card .desc-content,
.moment-image-desc-card p.desc-content {
  color: #66676b !important;
  background: transparent !important;
}
/* 如果存在内层容器，确保去掉其背景并使用浅灰色 */
.moment-image-desc-card > .inner,
.moment-image-desc-card > .card-inner,
.moment-image-desc-card > .content {
  background: transparent !important;
}
</style>



<!-- 覆盖：移除卡片内所有文字阴影，确保描述文字不带阴影 -->
<style>
.moment-image-desc-card, 
.moment-image-desc-card *,
.moment-image-desc-card .desc-content,
.moment-image-desc-card .description,
.moment-image-desc-card .image-desc,
.moment-image-desc-card .desc {
  text-shadow: none !important;
  -webkit-text-shadow: none !important;
  filter: none !important;
}
</style>


<!-- Modal layout fixes: align action buttons and tighten image checkbox spacing -->
<style>
/* Try to scope to likely modal/dialog containers without touching other buttons */
/* If your modal has a specific id or class, replace .publish-modal below with it. */
.publish-modal, .publish-dialog, .moment-publish-modal, .dialog-publish, .publishBox {
  /* ensure modal content uses flex column so footer aligns correctly */
  display: block;
}

/* Make the actions row use flex so buttons are equal size and aligned */
.publish-modal .actions,
.publish-dialog .actions,
.moment-publish-modal .actions,
.dialog-publish .actions,
.publishBox .actions,
.publish-actions {
  display: flex !important;
  gap: 12px;
  align-items: center;
  justify-content: space-between;
  padding: 0 !important;
}

/* Ensure buttons inside actions share equal width and similar height */
.publish-modal .actions button,
.publish-dialog .actions button,
.moment-publish-modal .actions button,
.dialog-publish .actions button,
.publishBox .actions button,
.publish-actions button {
  flex: 1 1 0;
  max-width: none;
  min-width: 0;
  height: 52px;
  border-radius: 12px;
  font-weight: 600;
  padding: 0 16px;
  box-sizing: border-box;
}

/* Make the cancel button visually secondary if needed */
.publish-modal .actions .cancel,
.publish-dialog .actions .cancel,
.publishBox .actions .cancel,
.publish-actions .cancel {
  background: #bfe6ff; /* light blue like your screenshot */
  color: #fff;
}

/* Publish button primary color */
.publish-modal .actions .primary,
.publish-dialog .actions .primary,
.publishBox .actions .primary,
.publish-actions .primary {
  background: #ff95bf; /* pink from screenshot */
  color: #fff;
}

/* Tighten spacing for the "add image" checkbox area */
.add-image-row, .add-image, .image-checkbox, .add-photo, .add-picture {
  margin-top: 6px !important;
  margin-bottom: 6px !important;
  display: flex !important;
  gap: 8px;
  align-items: center;
}

/* If checkbox itself has large margin, reduce it */
.add-image-row input[type="checkbox"],
.image-checkbox input[type="checkbox"],
.add-photo input[type="checkbox"] {
  margin: 0 !important;
  transform: scale(1.05);
}

/* Small screens: keep buttons stacked but full-width with proper gap */
@media (max-width: 420px) {
  .publish-modal .actions,
  .publish-dialog .actions,
  .moment-publish-modal .actions,
  .dialog-publish .actions,
  .publishBox .actions,
  .publish-actions {
    flex-direction: column;
  }
  .publish-modal .actions button,
  .publish-dialog .actions button,
  .moment-publish-modal .actions button,
  .dialog-publish .actions button,
  .publishBox .actions button,
  .publish-actions button {
    width: 100%;
  }
}
</style>


<!-- Precise fixes for the 发布动态 form: equalize buttons and tighten checkbox spacing -->
<style>
/* Scope strictly to the post form to avoid affecting other UIs */
#post-form { font-family: inherit; }

/* Find the action container which uses inline flex; ensure children buttons take equal space */
#post-form > div[style*="display:flex"] {
  display: flex !important;
  gap: 10px !important;
  margin-top: 12px !important;
  align-items: stretch !important;
}

/* Make buttons equal width, same height, and matching radius */
#post-form > div[style*="display:flex"] .btn {
  flex: 1 1 0 !important;
  min-width: 0 !important;
  height: 52px !important;
  padding: 0 16px !important;
  border-radius: 12px !important;
  box-sizing: border-box !important;
  font-weight: 600 !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
}

/* If there are specific modifier classes, ensure colors remain similar to your theme */
#post-form > div[style*="display:flex"] .btn-sec { background: #bfe6ff !important; color: #fff !important; border: none !important; }
#post-form > div[style*="display:flex"] .btn-primary { background: #ff95bf !important; color: #fff !important; border: none !important; }

/* Tighten the "添加图片" checkbox row */
#post-form .form-group label {
  display: inline-flex !important;
  align-items: center !important;
  gap: 8px !important;
  margin-top: 6px !important;
  cursor: pointer;
}

#post-form #add-image {
  margin: 0 !important;
  transform: scale(1.05) !important;
  vertical-align: middle !important;
}

/* Ensure image input group sits closer */
#image-input-group { margin-top: 8px !important; margin-bottom: 6px !important; }

/* Small screens: stack buttons but keep spacing */
@media (max-width: 420px) {
  #post-form > div[style*="display:flex"] { flex-direction: column !important; }
  #post-form > div[style*="display:flex"] .btn { width: 100% !important; }
}
</style>


<!-- Fix: keep '添加图片' label on one line and allow it to lay out horizontally -->
<style>
/* Prevent the label text from wrapping and ensure layout is inline */
#post-form .form-group label {
  white-space: nowrap !important;
  flex-wrap: nowrap !important;
  width: auto !important;
}

/* If any spans inside the label are forced to block, make them inline */
#post-form .form-group label span,
#post-form .form-group label b,
#post-form .form-group label i {
  display: inline !important;
}

/* Allow the label to take available horizontal space so text doesn't collapse */
#post-form .form-group {
  display: flex !important;
  align-items: center !important;
  gap: 8px !important;
}

  
</style>

<script id="moments-delete-feature-script">
    (function() {
        // 防止脚本被重复执行
        if (window.momentsDeleteFeatureInitialized) {
            return;
        }
        window.momentsDeleteFeatureInitialized = true;

        // 步骤 A: 动态注入正确的CSS样式
        // 这样做可以强制覆盖掉任何可能残留的、导致按钮消失的旧样式
        const css = `
            #moments-screen.is-delete-mode .moment-item { 
                cursor: pointer; user-select: none; 
            }
            .moment-item.is-selected { 
                outline: 2px solid var(--accent-color, #4c9ffe); 
                position: relative; 
                border-radius: 14px;
                box-shadow: 0 6px 18px rgba(76, 159, 254, 0.2) !important;
            }
            .moment-item.is-selected::after {
              content: '✓';
              position: absolute; right: 8px; top: 8px;
              width: 22px; height: 22px; line-height: 22px; text-align: center;
              border-radius: 50%;
              background: rgba(0,0,0,.6); color: #fff; font-weight: 700; font-size: 14px;
              z-index: 10;
            }
            /* 关键修正：强制确保按钮文字在任何情况下都可见 */
            #moments-screen.is-delete-mode .app-header #moments-delete-btn {
                font-size: 16px !important;
            }
            /* 关键修正：强制清除可能残留的、导致文字被替换的旧样式 */
            #moments-screen.is-delete-mode .app-header #moments-delete-btn::before {
                content: "" !important;
            }
        `;
        const style = document.createElement('style');
        style.type = 'text/css';
        style.appendChild(document.createTextNode(css));
        document.head.appendChild(style);

        // 步骤 B: 绑定功能逻辑
        document.addEventListener('DOMContentLoaded', () => {
            const momentsScreen = document.getElementById('moments-screen');
            const deleteBtn = document.getElementById('moments-delete-btn');
            
            if (!momentsScreen || !deleteBtn) {
                console.error("动态删除功能初始化失败：找不到关键HTML元素。");
                return;
            }

            let selectedMomentsIds = new Set();

            function updateDeleteButtonState() {
                const isInDeleteMode = momentsScreen.classList.contains('is-delete-mode');
                if (!isInDeleteMode) {
                    deleteBtn.textContent = '删除';
                    deleteBtn.style.color = '';
                    deleteBtn.style.fontWeight = '';
                } else {
                    if (selectedMomentsIds.size > 0) {
                        deleteBtn.textContent = `删除 (${selectedMomentsIds.size})`;
                        deleteBtn.style.color = '#ef5350'; // 红色
                        deleteBtn.style.fontWeight = '600';
                    } else {
                        deleteBtn.textContent = '取消';
                        deleteBtn.style.color = 'var(--primary-color)'; // 主题色
                        deleteBtn.style.fontWeight = '600';
                    }
                }
            }

            function enterDeleteMode() {
                momentsScreen.classList.add('is-delete-mode');
                updateDeleteButtonState();
                if(typeof showToast === 'function') showToast('已进入选择模式');
            }

            function exitDeleteMode() {
                momentsScreen.classList.remove('is-delete-mode');
                document.querySelectorAll('.moment-item.is-selected').forEach(el => el.classList.remove('is-selected'));
                selectedMomentsIds.clear();
                updateDeleteButtonState();
            }
            
            async function confirmAndDelete() {
                if (confirm(`确定要删除选中的 ${selectedMomentsIds.size} 条动态吗？`)) {
                    try {
                        if (window.AppDB_Moments && typeof window.AppDB_Moments.moments.bulkDelete === 'function') {
                            await window.AppDB_Moments.moments.bulkDelete(Array.from(selectedMomentsIds));
                            if(typeof showToast === 'function') showToast('动态已成功删除');
                            exitDeleteMode();
                            if (typeof window.renderMomentsSafe === 'function') await window.renderMomentsSafe();
                        } else { throw new Error("数据库功能不可用。"); }
                    } catch (error) {
                        console.error('删除动态失败:', error);
                        if(typeof showToast === 'function') showToast('删除失败: ' + error.message);
                    }
                }
            }

            deleteBtn.addEventListener('click', () => {
                const isInDeleteMode = momentsScreen.classList.contains('is-delete-mode');
                if (!isInDeleteMode) {
                    enterDeleteMode();
                } else {
                    if (selectedMomentsIds.size > 0) {
                        confirmAndDelete();
                    } else {
                        exitDeleteMode();
                        if(typeof showToast === 'function') showToast('已取消选择');
                    }
                }
            });

            momentsScreen.addEventListener('click', (e) => {
                if (!momentsScreen.classList.contains('is-delete-mode')) return;
                const momentItem = e.target.closest('.moment-item');
                if (momentItem) {
                    e.stopPropagation(); e.preventDefault();
                    const momentId = momentItem.dataset.id;
                    if (!momentId) return;
                    if (selectedMomentsIds.has(momentId)) {
                        selectedMomentsIds.delete(momentId);
                        momentItem.classList.remove('is-selected');
                    } else {
                        selectedMomentsIds.add(momentId);
                        momentItem.classList.add('is-selected');
                    }
                    updateDeleteButtonState();
                }
            }, true);
            
            // 确保在init函数中调用过setupMomentsDeleteFeature后，这里的逻辑也能被正确执行
            if (typeof setupMomentsDeleteFeature === 'function') {
                console.log("setupMomentsDeleteFeature is already defined, skipping re-definition but ensuring execution.");
            }
        });
    })();
</script>

<div id="home-profile-edit-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>更换图片</h3>
        <div style="display: flex; flex-direction: column; gap: 15px; margin-top: 25px;">
            <button class="btn btn-primary" id="edit-profile-from-url-btn">输入网络URL</button>
            <button class="btn btn-secondary" id="edit-profile-from-local-btn">从本地上传</button>
            <button class="btn btn-neutral" id="cancel-edit-profile-btn" style="margin-top: 10px;">取消</button>
        </div>
    </div>
</div>
<input type="file" id="home-profile-image-upload" accept="image/*" style="display:none;">


<div id="customize-icon-modal" class="modal-overlay">
    <div class="modal-window">
        <h3 id="customize-icon-modal-title">自定义图标</h3>
        <div style="display: flex; flex-direction: column; gap: 15px; margin-top: 25px;">
            <button class="btn btn-primary" id="icon-edit-from-url-btn">输入网络URL</button>
            <button class="btn btn-secondary" id="icon-edit-from-local-btn">从本地上传</button>
            <button class="btn btn-danger" id="icon-edit-reset-btn" style="margin-top: 10px;">恢复默认</button>
            <button class="btn btn-neutral" id="icon-edit-cancel-btn">取消</button>
        </div>
    </div>
</div>
<input type="file" id="customize-icon-upload" accept="image/*" style="display:none;">
  
<!-- 在 </body> 之前添加 -->


    <div id="mention-panel" class="mention-panel"></div>

    <div class="modal-overlay" id="share-post-modal">
        <div class="modal-window">
            <h3>分享帖子给...</h3>
            <ul id="share-post-selection-list" class="list-container" style="max-height: 40vh; overflow-y: auto;">
                </ul>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-neutral" id="cancel-post-share-btn" style="flex: 1;">取消</button>
                <button class="btn btn-primary" id="confirm-post-share-btn" style="flex: 1;">确认分享</button>
            </div>
        </div>
    </div>
   
   

  
<div id="trajectory-modal" class="modal-overlay">
    <div class="modal-window">
        <h3 id="trajectory-modal-title">Ta的轨迹</h3>
        <div id="trajectory-timeline">
            <div class="placeholder-text">正在加载轨迹...</div>
        </div>
        <button id="close-trajectory-modal-btn" class="btn btn-primary" style="margin-top: 20px;">关闭</button>
    </div>
</div>
<!-- === 新增：“心声”功能弹窗 === -->
<div id="heart-sound-modal" class="modal-overlay">
    <div class="modal-window">
        <h3 id="heart-sound-modal-title">Ta的心声</h3>
        <div id="heart-sound-content" style="max-height: 60vh; overflow-y: auto; background-color: #f9f9f9; padding: 15px; border-radius: 8px; white-space: pre-wrap; line-height: 1.7;">
            <div class="placeholder-text">正在倾听心声...</div>
        </div>
        <button id="close-heart-sound-modal-btn" class="btn btn-primary" style="margin-top: 20px;">关闭</button>
    </div>
</div>
<div id="mention-panel" class="mention-panel"></div>
<!-- ... (El resto de los scripts y styles finales) ... -->
	<!-- === 新增：回忆记录显示面板 (Modal) === -->
<div id="memory-summary-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>回忆记录</h3>
        <div class="form-group" style="max-height: 60vh; overflow-y: auto; background-color: #f9f9f9; padding: 10px; border-radius: 8px;">
            <pre id="memory-summary-content" style="white-space: pre-wrap; word-wrap: break-word; font-size: 14px; color: #333;"></pre>
        </div>
        <button id="close-memory-summary-btn" class="btn btn-primary" style="margin-top: 20px;">关闭</button>
    </div>
</div>
<!-- ... 紧跟在 memory-summary-modal 的 div 之后 ... -->


<!-- ... 紧跟在最后一个 modal 的 div 之后 ... -->
<div id="set-group-title-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>选择要设置头衔的成员</h3>
        <ul id="group-title-member-list" class="list-container" style="max-height: 60vh; overflow-y: auto;">
            <!-- Member list will be populated by JS -->
        </ul>
        <button class="btn btn-neutral" id="close-group-title-modal-btn" style="margin-top: 20px;">关闭</button>
    </div>
</div>
<!-- =============================================================== -->
<!-- START: "每日一问" & "情绪天气" 功能模块 -->
<!-- =============================================================== -->

<!-- 1. 每日一问的弹窗 -->
<div id="bond-daily-question-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>每日一问</h3>
        <div id="daily-question-content" style="min-height: 100px; padding: 15px; background-color: #f9f9f9; border-radius: 8px; margin-bottom: 15px; white-space: pre-wrap; line-height: 1.7;">
            <p id="daily-question-text" style="font-size: 16px; color: #333;"></p>
        </div>
        <form id="daily-question-answer-form">
            <input type="hidden" id="current-daily-question-text">
            <div class="form-group">
                <textarea id="daily-question-answer" rows="4" placeholder="写下你的回答..."></textarea>
            </div>
            <button type="submit" class="btn btn-primary">提交回答</button>
        </form>
    </div>
</div>

<!-- 2. 情绪天气的弹窗 -->
<div id="bond-mood-weather-modal" class="modal-overlay">
    <div class="modal-window" style="text-align: center;">
        <h3 id="mood-weather-title">Ta现在的心情</h3>
        <div id="mood-weather-icon" style="font-size: 80px; margin: 20px 0;">☀️</div>
        <p id="mood-weather-reason" style="background-color: #f9f9f9; padding: 15px; border-radius: 8px; font-style: italic; color: #555;"></p>
        <button id="soothe-ai-btn" class="btn btn-secondary" style="display: none; margin-top: 15px;">安抚Ta</button>
    </div>
</div>

<!-- 3. 新增页面：情侣问答手册 -->
<div id="bond-q-and-a-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="soul-bond-screen">‹</button>
        <div class="title-container">
            <h1 class="title">问答手册</h1>
        </div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
        <ul class="list-container" id="q-and-a-list-container">
            <!-- 问答记录将由JS动态生成 -->
        </ul>
        <p class="placeholder-text" id="no-q-and-a-placeholder" style="display: none;">还没有问答记录哦</p>
    </main>
</div>

<!-- =============================================================== -->
<!-- END: "每日一问" & "情绪天气" 功能模块 -->
<!-- =============================================================== -->
<!-- ... 后面是 </body> -->
<!-- =============================================================== -->
<!-- START: 交换日记内容查看器 (Modal) -->
<!-- =============================================================== -->
<div id="diary-exchange-viewer-modal" class="modal-overlay">
    <div class="modal-window" style="max-width: 95%; height: 80vh; display: flex; flex-direction: column; padding: 15px;">
        <h3 id="diary-viewer-title" style="text-align: center; margin-bottom: 15px; flex-shrink: 0;">交换日记</h3>
        <div id="diary-viewer-content" style="flex-grow: 1; overflow-y: auto; background-color: #fafafa; padding: 15px; border-radius: 8px;">
            <!-- 日记内容将由JS动态生成 -->
        </div>
        <button id="close-diary-viewer-btn" class="btn btn-primary" style="margin-top: 15px; flex-shrink: 0;">关闭</button>
    </div>
</div>
<!-- =============================================================== -->
<!-- END: 交换日记内容查看器 -->
<!-- =============================================================== -->
<!-- START: 升级后的渲染器编辑弹窗 -->
<div id="edit-renderer-rule-modal" class="modal-overlay">
    <div class="modal-window" style="max-width: 95%;">
        <h3>创建/编辑渲染规则</h3>
        <form id="edit-renderer-rule-form">
            <input type="hidden" id="renderer-rule-id">
            <div class="form-group">
                <label for="renderer-rule-name">规则名称</label>
                <input type="text" id="renderer-rule-name" placeholder="为你的规则起个名字" required>
            </div>
            <div class="form-group">
                <label>查找正则表达式 (Regex)</label>
                <textarea id="renderer-rule-regex" rows="3" placeholder="例如：<L>([^<]+)<\/L>" required></textarea>
                <div class="regex-flags-container">
                    <label><input type="checkbox" id="regex-flag-g" value="g" checked>全局(g)</label>
                    <label><input type="checkbox" id="regex-flag-i" value="i">忽略大小写(i)</label>
                    <label><input type="checkbox" id="regex-flag-s" value="s">点匹配换行(s)</label>
                </div>
            </div>
            <div class="form-group">
                <label for="renderer-rule-html">HTML 替换代码 (使用 $1, $2 引用捕获组)</label>
                <textarea id="renderer-rule-html" rows="5" placeholder="例如：<div style='color:blue;'>$1</div>"></textarea>
            </div>
             <div class="form-group">
                <label for="renderer-rule-trim">修剪字符串 (每行一个)</label>
                <textarea id="renderer-rule-trim" rows="2" placeholder="在匹配前，会先从消息中移除这里列出的所有字符串。"></textarea>
            </div>
          <div class="renderer-options-grid">
        <div class="form-group">
            <label>作用范围</label>
            <div class="scope-options">
                <label><input type="checkbox" name="renderer-scope" value="user"> 用户输入</label>
                <label><input type="checkbox" name="renderer-scope" value="ai" checked> AI输出</label>
            </div>
        </div>
        <div class="form-group">
            <label>其他选项</label>
            <div class="scope-options">
               <label><input type="checkbox" id="renderer-rule-enabled" checked> 启用此规则</label>
               <!-- 新增：优先级输入框 -->
               <label style="margin-left: 15px;">优先级: <input type="number" id="renderer-rule-priority" value="50" style="width: 60px; padding: 5px; border-radius: 6px; border: 1px solid #ddd;"></label>
            </div>
        </div>
    </div>
    <!-- END: 修改“其他选项”部分 -->
            <div class="form-group">
                <label>绑定角色 (规则仅对选中的角色生效)</label>
                <div id="renderer-char-binding-list" class="char-binding-list"></div>
            </div>
            <hr style="border:none; border-top:1px solid #f0f0f0; margin: 20px 0;">
    <div class="form-group">
        <label for="renderer-rule-test-input">测试预览</label>
        <textarea id="renderer-rule-test-input" rows="3" placeholder="在此输入要测试的内容，例如：<L>你好</L>"></textarea>
    </div>
    <div class="form-group">
        <label>预览效果</label>
        <div id="renderer-rule-preview-output" style="border: 1px solid #eee; padding: 15px; border-radius: 8px; min-height: 50px; background: #f9f9f9; line-height: 1.6; word-wrap: break-word;"></div>
    </div>
            <button type="submit" class="btn btn-primary">保存规则</button>
        </form>
    </div>
</div>
<!-- END: 升级后的渲染器编辑弹窗 -->
<div id="renderer-category-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>创建新分类</h3>
        <form id="renderer-category-form">
            <div class="form-group">
                <label for="renderer-category-name">分类名称</label>
                <input type="text" id="renderer-category-name" placeholder="例如：通用效果、角色专属" required>
            </div>
            <button type="submit" class="btn btn-primary">创建</button>
        </form>
    </div>
</div>
<!-- END: 新增渲染器编辑弹窗 -->
	<!-- =============================================================== -->
<!-- START: 新增“交换日记”功能界面 -->
<!-- =============================================================== -->

<!-- 1. 交换日记列表页面 -->
<div id="bond-diary-exchange-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="soul-bond-screen">‹</button>
        <div class="title-container">
            <h1 class="title">交换日记</h1>
        </div>
        <button class="action-btn" id="write-new-exchange-btn" style="font-size: 28px;">+</button>
    </header>
    <main class="content">
        <div id="diary-exchange-list-container">
            <!-- 交换日记条目将由JS动态生成 -->
        </div>
        <p class="placeholder-text" id="no-diary-exchanges-placeholder" style="display: none;">还没有交换过日记，点击右上角“+”开始第一篇吧！</p>
    </main>
</div>

<!-- 2. 写交换日记的弹窗 -->
<div id="write-diary-exchange-modal" class="modal-overlay">
    <div class="modal-window" style="max-height: 85vh; display: flex; flex-direction: column;">
        <h3>写给Ta的日记</h3>
        <form id="diary-exchange-form" style="overflow-y: auto; flex-grow: 1; padding: 5px;">
            <div class="form-group">
                <textarea id="exchange-diary-content" rows="10" required placeholder="写下你想对Ta说的话..."></textarea>
            </div>
            <div class="form-group">
                <label for="exchange-diary-image-upload" class="btn btn-secondary">附上一张图片 (可选)</label>
                <input type="file" id="exchange-diary-image-upload" accept="image/*" style="display:none;">
                <div id="exchange-diary-image-preview" style="width: 100px; height: 100px; border: 1px dashed #ccc; margin: 10px auto 0; background-size: cover; background-position: center; display: none;"></div>
            </div>
            <button type="submit" class="btn btn-primary" style="margin-top: 15px;">发送日记</button>
        </form>
    </div>
</div>
<!-- =============================================================== -->
<!-- START: "想你啦" 功能模块 -->
<!-- =============================================================== -->
<div id="miss-you-actionsheet" class="action-sheet-overlay">
    <div class="action-sheet">
        <button class="action-sheet-button" data-level="有点想你">有点想你...</button>
        <button class="action-sheet-button" data-level="非常想你">非常想你！</button>
        <button class="action-sheet-button danger" id="cancel-miss-you-btn">取消</button>
    </div>
</div>
<!-- =============================================================== -->
<!-- END: "想你啦" 功能模块 -->
<!-- =============================================================== -->
<!-- =============================================================== -->
<!-- END: “交换日记”功能界面 -->
<!-- =============================================================== -->
<!-- START: 心灵羁绊 - 绑定功能界面 -->
<!-- =============================================================== -->

<!-- 1. 绑定邀请主页面 -->
<div id="bond-invitation-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="home-container">‹</button>
        <div class="title-container"><h1 class="title">心灵羁绊</h1></div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
        <div class="bond-invite-card">
            <h2>绑定情侣关系，享情侣权益</h2>
            <p>立即邀请你的心动对象，开启一场心灵之旅吧</p>
            <div class="bond-invite-avatars">
                <div class="bond-avatar-placeholder" id="bond-invite-my-avatar">
                    <!-- My avatar will be rendered here -->
                </div>
                <span class="heart-connector">❤️</span>
                <div class="bond-avatar-placeholder invitee" id="bond-invite-ai-avatar">
                    <span>+</span>
                </div>
            </div>
            <button class="bond-invite-btn" id="bond-invite-main-btn">立即邀请</button>
        </div>
    </main>
</div>

<!-- 2. 选择邀请对象的弹窗 -->
<div id="bond-invite-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>选择一个心动对象</h3>
        <ul id="bond-invite-selection-list" class="list-container" style="max-height: 50vh; overflow-y: auto;">
            <!-- AI列表将由JS动态生成 -->
        </ul>
    </div>
</div>

<!-- =============================================================== -->
<!-- END: 心灵羁绊 - 绑定功能界面 -->
<!-- =============================================================== -->	
<!-- =============================================================== -->
<!-- 放在 </body> 标签之前 -->
<input type="file" id="card-import-input" accept=".json,.png" style="display: none;">
	<!-- === 新增：长截图预览弹窗 === -->
<div id="screenshot-preview-modal" class="modal-overlay" style="z-index: 1001;">
    <div class="modal-window" style="max-width: 95%; padding: 15px;">
        <h3 style="text-align: center; margin-bottom: 15px;">长截图预览</h3>
        <div style="max-height: 60vh; overflow-y: auto; border: 1px solid #eee; text-align: center;">
            <img id="screenshot-preview-image" src="" alt="截图预览" style="max-width: 100%; display: block;">
        </div>
        <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button id="close-screenshot-preview" class="btn btn-neutral" style="flex: 1;">关闭</button>
            <a id="download-screenshot-btn" class="btn btn-primary" style="flex: 1; text-decoration: none;" href="#" download="聊天记录截图.png">保存图片</a>
        </div>
    </div>
</div>
<input type="file" id="renderer-import-input" accept=".json" style="display: none;" multiple>
	<!-- === 新增：查看已撤回消息内容的弹窗 === -->
<div id="view-recalled-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>已撤回的消息</h3>
        <div class="form-group" style="max-height: 60vh; overflow-y: auto; background-color: #f9f9f9; padding: 10px; border-radius: 8px;">
            <pre id="recalled-content-display" style="white-space: pre-wrap; word-wrap: break-word; font-size: 14px; color: #333;"></pre>
        </div>
        <button id="close-recalled-modal-btn" class="btn btn-primary" style="margin-top: 20px;">关闭</button>
    </div>
</div>
<!-- === 新增：日记功能扩展面板与页面 === -->

<!-- 1. 打开日记功能时的操作选择面板 -->
<div id="diary-actionsheet" class="action-sheet-overlay">
    <div class="action-sheet">
        <button class="action-sheet-button" id="open-ai-diary-btn">Ta的日记</button>
        <button class="action-sheet-button" id="open-user-diary-btn">我的日记</button>
        <button class="action-sheet-button" id="open-write-user-diary-btn">写日记</button>
        <button class="action-sheet-button" id="open-favorites-diary-btn">我的收藏</button>
    </div>
</div>

<!-- 2. “我的日记”显示页面 -->
<div id="user-diary-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="chat-room-screen">‹</button>
        <div class="title-container">
            <h1 class="title">我的日记</h1>
        </div>
        <button class="action-btn" id="ai-peek-btn">偷看</button>
    </header>
    <main class="content">
        <ul class="list-container" id="user-diary-list-container"></ul>
        <div class="placeholder-text" id="no-user-diaries-placeholder" style="display: none;">
            <p>你还没有写过日记哦~</p>
            <p>从聊天界面打开日记功能，点击“写日记”开始吧！</p>
        </div>
    </main>
</div>

<!-- 3. 用户“写日记”的弹窗 -->
<div id="write-user-diary-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>写下今天的心情...</h3>
        <form id="write-user-diary-form">
            <input type="hidden" id="editing-user-diary-id">
            <div class="form-group">
                <textarea id="user-diary-content-input" rows="10" required placeholder="今天发生了什么..."></textarea>
            </div>
            <button type="submit" class="btn btn-primary">保存日记</button>
        </form>
    </div>
</div>

<!-- 4. 选择哪个AI来“偷看”日记的弹窗 -->
<div id="ai-peek-selection-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>让谁来偷看呢？</h3>
        <ul id="ai-peek-selection-list" class="list-container" style="max-height: 50vh; overflow-y: auto;">
            <!-- AI列表将由JS动态生成 -->
        </ul>
        <button class="btn btn-secondary" id="ai-auto-peek-btn" style="margin-top: 15px;">让老天爷决定 (自动)</button>
    </div>
</div>

<!-- 5. “我的收藏”显示页面 -->
<div id="favorites-diary-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="chat-room-screen">‹</button>
        <div class="title-container">
            <h1 class="title">我的收藏</h1>
        </div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
        <ul class="list-container" id="favorites-diary-list-container"></ul>
        <div class="placeholder-text" id="no-favorites-placeholder" style="display: none;">
            <p>还没有收藏任何日记哦~</p>
        </div>
    </main>
</div>
<!-- START: 批量添加表情包弹窗 -->
<div id="batch-add-sticker-modal" class="modal-overlay">
    <div class="modal-window">
        <!-- Step 1: Upload View -->
        <div id="batch-upload-view">
            <h3>批量添加表情包</h3>
            <div class="form-group">
                <label for="batch-sticker-files-upload" class="btn btn-primary">
                    从本地选择多个文件
                </label>
                <input type="file" id="batch-sticker-files-upload" accept="image/*" multiple style="display:none;">
            </div>
            <p style="text-align:center; color:#888; margin: 15px 0;">或</p>
            <div class="form-group">
                <label for="batch-sticker-urls-input">粘贴多个URL (英文逗号隔开)</label>
                <textarea id="batch-sticker-urls-input" rows="5" placeholder="https://.../1.png,https://.../2.gif,..."></textarea>
            </div>
            <button class="btn btn-secondary" id="process-batch-stickers-btn">下一步</button>
        </div>

        <!-- Step 2: Naming View -->
        <div id="batch-naming-view" style="display:none;">
            <h3>为表情包命名</h3>
            <div id="batch-sticker-preview-grid" class="sticker-grid" style="max-height: 40vh; background-color: #f9f9f9; border-radius: 8px; margin-bottom: 15px;">
                <!-- Previews will be generated here -->
            </div>
            <div class="form-group">
                <label for="batch-sticker-names-input">输入名称 (英文逗号隔开)</label>
                <textarea id="batch-sticker-names-input" rows="4" placeholder="开心,难过,你好,..."></textarea>
                 <p style="font-size: 12px; color: #888; margin-top: 5px;">提示：名称数量少于图片时，将自动补充默认名称。</p>
            </div>
            <div style="display:flex; gap: 10px; margin-top: 20px;">
                 <button class="btn btn-neutral" id="back-to-batch-upload-btn" style="flex:1;">返回上一步</button>
                 <button class="btn btn-primary" id="save-batch-stickers-btn" style="flex:1;">全部保存</button>
            </div>
        </div>
    </div>
</div>

  <div id="forum-config-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="forum-screen">‹</button>
        <div class="title-container"><h1 class="title">论坛配置</h1></div>
        <div class="placeholder"></div>
    </header>
    <main class="content" style="padding: 15px;">
        <div id="forum-presets-control" style="margin-bottom: 20px; padding: 15px; border-radius: 12px; border: 1px solid #fce4ec; background:#fff8fa;">
            <div style="display:flex; align-items:center; gap:8px; margin-bottom:12px;">
                <label style="color:var(--secondary-color); font-weight:600;">配置预设</label>
                <select id="forum-preset-select" style="flex:1; padding:8px; border-radius:8px; border:1px solid #fce4ec;"></select>
            </div>
            <div style="display:flex; gap:8px; justify-content:flex-end;">
                <button id="forum-apply-preset" class="btn btn-primary btn-small">应用</button>
                <button id="forum-save-preset" class="btn btn-secondary btn-small">另存</button>
                <button id="forum-manage-presets" class="btn btn-neutral btn-small">管理</button>
            </div>
        </div>

        <form id="forum-config-form">
            <div class="form-group">
                <label for="forum-worldview">论坛世界观 (权重最高)</label>
                <textarea id="forum-worldview" rows="5" placeholder="定义整个论坛的基调和背景..."></textarea>
            </div>
            <div class="form-group">
                <label for="forum-user-persona">用户人设</label>
                <textarea id="forum-user-persona" rows="3" placeholder="您在论坛中的身份..."></textarea>
            </div>
          <div id="persona-presets-control" style="margin-top: -10px; margin-bottom: 20px; padding: 10px; border-radius: 0 0 12px 12px; border: 1px solid #fce4ec; border-top: none; background:#fff8fa;">
    <div style="display:flex; align-items:center; gap:8px; margin-bottom:12px;">
        <label style="color:var(--secondary-color); font-weight:600; font-size: 14px;">人设预设</label>
        <select id="persona-preset-select" style="flex:1; padding:8px; border-radius:8px; border:1px solid #fce4ec;"></select>
    </div>
    <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button type="button" id="persona-apply-preset" class="btn btn-primary btn-small">应用</button>
        <button type="button" id="persona-save-preset" class="btn btn-secondary btn-small">另存</button>
        <button type="button" id="persona-manage-presets" class="btn btn-neutral btn-small">管理</button>
    </div>
</div>
            <div class="form-group">
                <label>参与论坛的角色</label>
                <ul id="forum-char-selection-list" class="list-container" style="max-height: 150px; overflow-y: auto; border: 1px solid #eee; padding: 10px; border-radius: 8px;"></ul>
            </div>
            <div class="form-group">
                <label>开关选项</label>
                <div style="background: #fff; padding: 10px; border-radius: 8px;">
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 5px 0;">
                        <label for="allow-npcs" style="margin:0;">允许路人生成帖子</label>
                        <input type="checkbox" id="allow-npcs" style="width: auto; height: 20px;">
                    </div>
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 5px 0;">
                        <label for="allow-unrelated" style="margin:0;">允许生成与角色用户无关帖子</label>
                        <input type="checkbox" id="allow-unrelated" style="width: auto; height: 20px;">
                    </div>
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 5px 0;">
                        <label for="allow-romantic-npcs" style="margin:0;">允许路人发布情感向帖子</label>
                        <input type="checkbox" id="allow-romantic-npcs" style="width: auto; height: 20px;">
                    </div>
                </div>
            </div>
            <div class="form-group">
                 <button type="button" class="btn btn-secondary" id="link-forum-world-book-btn">关联世界书</button>
            </div>
            <button type="submit" class="btn btn-primary">保存设置</button>
        </form>
    </main>
</div>

<div id="forum-presets-modal" class="modal-overlay" style="display:none;">
    <div class="modal-window" style="max-width:520px;">
        <h3 style="margin:0 0 10px 0;">管理论坛预设</h3>
        <div id="forum-presets-list" style="max-height:340px; overflow:auto; margin-bottom:12px;"></div>
        <div style="display:flex; gap:8px; justify-content:flex-end;">
            <button id="forum-close-modal" class="btn btn-primary" style="padding:8px 12px;">关闭</button>
        </div>
    </div>
</div>
<!-- END: 批量添加表情包弹窗 -->
	<!-- 文件位置: </body> 标签之前 -->
<input type="file" id="world-book-import-input" accept=".json" style="display: none;" multiple>
	<!-- =============================================================== -->
<!-- START: 新增商城功能HTML (粘贴到 </body> 标签前) -->
<!-- =============================================================== -->

<!-- 1. 商城主界面 -->
<div id="mall-screen" class="screen">
    <!-- 商城顶部 -->
    <header class="mall-header">
        <button class="back-btn" data-target="home-container">‹</button>
 <!-- ... 在 <header class="mall-header"> 内部 ... -->
<div class="search-bar-container">
    <svg id="mall-search-btn" class="search-icon" viewBox="0 0 24 24" style="cursor: pointer;"><path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L21.5,20L20,21.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z" /></svg>
    <input type="text" id="mall-search-input" placeholder="万能杂货铺，搜搜看？">
</div>
<!-- ... -->
        <!-- 【新增】刷新按钮 -->
    <button class="action-btn" id="refresh-mall-btn" style="margin-left: 8px;">
        <svg viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px;"><path d="M17.65,6.35C16.2,4.9, 14.21,4, 12,4A8,8, 0, 0,0, 4,12A8,8, 0, 0,0, 12,20C15.73,20, 18.84,17.45, 19.73,14H17.65C16.83,16.33, 14.61,18, 12,18A6,6, 0, 0,1, 6,12A6,6, 0, 0,1, 12,6C13.66,6, 15.14,6.69, 16.22,7.78L13,11H20V4L17.65,6.35Z"></path></svg>
</button>
    </header>

    <!-- 商城主内容 -->
    <main class="content">
        <!-- 分类图标区域 -->
        <!-- 替换旧的 mall-categories div -->
<div class="mall-categories">
    <div class="function-item" id="add-custom-product-btn" style="cursor: pointer;">
        <div class="icon-bg" style="background-color: #e3f2fd;">
            <svg viewBox="0 0 24 24" fill="#1976d2"><path d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" /></svg>
        </div>
        <span>个性商品</span>
    </div>
    <!-- 这里可以保留或添加其他分类图标 -->
            <!-- 这里可以动态生成或静态放置分类图标 -->
        </div>
        <!-- 商品网格 -->
        <div id="product-grid" class="product-grid">
            <!-- 商品卡片将由JS动态生成 -->
        </div>
        <!-- 【新增】加载更多指示器 -->
<div id="load-more-indicator" class="load-more-indicator">加载中...</div>
    </main>

    <!-- 商城底部导航 -->
    <nav class="mall-bottom-nav">
        <button class="nav-item active" data-target="mall-screen">
            <svg viewBox="0 0 24 24"><path d="M10,20V14H14V20H19V12H22L12,3L2,12H5V20H10Z" /></svg>
            <span>首页</span>
        </button>
      <!-- ▼▼▼ 用下面这个“购物车”按钮替换它 ▼▼▼ -->
<button class="nav-item" data-target="mall-cart-screen">
    <svg viewBox="0 0 24 24"><path d="M17,18A2,2 0 0,1 19,20A2,2 0 0,1 17,22A2,2 0 0,1 15,20A2,2 0 0,1 17,18M7,18A2,2 0 0,1 9,20A2,2 0 0,1 7,22A2,2 0 0,1 5,20A2,2 0 0,1 7,18M7.17,14.75L7.2,14.63L8.1,13H15.55C16.3,13 16.96,12.59 17.3,11.97L20.88,5.5H18.31L17.15,7.55L14.4,12H8.53L8.4,11.73L6,4H4V6H6L9.6,13.59L8.16,15.95C7.79,16.58 8.27,17.31 9,17.31H18V15.31H9.42L10.2,14Z" /></svg>
    <span>购物车</span>
</button>
        <button class="nav-item" data-target="mall-profile-screen">
            <svg viewBox="0 0 24 24"><path d="M12,12c2.21,0 4,-1.79 4,-4s-1.79,-4 -4,-4 -4,1.79 -4,4 1.79,4 4,4zm0,2c-2.67,0 -8,1.34 -8,4v2h16v-2c0,-2.66 -5.33,-4 -8,-4z"/></svg>
            <span>个人中心</span>
        </button>
        <button class="nav-item" data-target="mall-settings-screen">
            <svg viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.08-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.08.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></svg>
            <span>设置</span>
        </button>
    </nav>
</div>

<!-- 2. 个人中心页面 (修正版) -->
<div id="mall-profile-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="home-container">‹</button>
        <div class="title-container"><h1 class="title">个人中心</h1></div>
        <div class="placeholder"></div> <!-- 用于平衡布局 -->
    </header>
    <main class="content" style="padding: 10px 10px 80px 10px; background-color: #f5f5f5;">
        <!-- 个人信息头部 -->
        <div class="profile-header">
            <img id="profile-avatar" src="https://i.postimg.cc/GtbTnxhP/o-o-1.jpg" alt="avatar" class="profile-avatar">
            <h2 id="profile-username" class="profile-username">我的昵称</h2>
        </div>
<div class="profile-section" id="logistics-entry-section">
        <div class="wallet-action-item" data-target="logistics-screen">
            <span>我的物流</span>
            <span>›</span>
        </div>
    </div>
        <!-- 点赞记录 -->
        <div class="liked-products-section profile-section">
            <h3 class="section-title">我的点赞</h3>
            <div id="liked-products-grid" class="product-grid">
                <!-- 点赞的商品将由JS动态生成 -->
            </div>
            <p class="placeholder-text" id="no-liked-products" style="display: none;">还没有点赞过任何商品哦</p>
        </div>

        <!-- 付款记录 -->
        <div class="payment-history-section profile-section">
            <h3 class="section-title">付款记录</h3>
            <div id="payment-history-list">
                <!-- 付款记录将由JS动态生成 -->
            </div>
        </div>
    </main>
    <nav class="mall-bottom-nav">
        <button class="nav-item" data-target="mall-screen">
            <svg viewBox="0 0 24 24"><path d="M10,20V14H14V20H19V12H22L12,3L2,12H5V20H10Z"></path></svg>
            <span>首页</span>
        </button>
        <button class="nav-item" data-target="mall-cart-screen">
            <svg viewBox="0 0 24 24"><path d="M17,18A2,2 0 0,1 19,20A2,2 0 0,1 17,22A2,2 0 0,1 15,20A2,2 0 0,1 17,18M7,18A2,2 0 0,1 9,20A2,2 0 0,1 7,22A2,2 0 0,1 5,20A2,2 0 0,1 7,18M7.17,14.75L7.2,14.63L8.1,13H15.55C16.3,13 16.96,12.59 17.3,11.97L20.88,5.5H18.31L17.15,7.55L14.4,12H8.53L8.4,11.73L6,4H4V6H6L9.6,13.59L8.16,15.95C7.79,16.58 8.27,17.31 9,17.31H18V15.31H9.42L10.2,14Z"></path></svg>
            <span>购物车</span>
        </button>
        <button class="nav-item active" data-target="mall-profile-screen">
            <svg viewBox="0 0 24 24"><path d="M12,12c2.21,0 4,-1.79 4,-4s-1.79,-4 -4,-4 -4,1.79 -4,4 1.79,4 4,4zm0,2c-2.67,0 -8,1.34 -8,4v2h16v-2c0,-2.66 -5.33,-4 -8,-4z"/></svg>
            <span>个人中心</span>
        </button>
        <button class="nav-item" data-target="mall-settings-screen">
            <svg viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61-.25-1.17-.59-1.69-.98l-2.49-1c-.23-.08-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.08.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></svg>
            <span>设置</span>
        </button>
    </nav>
</div>
<!-- 3. 设置页面 -->
	<!-- 3. 设置页面 -->
<div id="mall-settings-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="home-container">‹</button>
        <div class="title-container"><h1 class="title">商城设置</h1></div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
    	<!-- ... 在 <form id="mall-api-form"> 内部 ... -->

<div class="form-group" style="display: flex; align-items: center; justify-content: space-between; border-top: 1px solid #eee; padding-top: 20px; margin-top: 20px;">
    <label for="special-items-toggle" style="margin-bottom: 0;">启用特殊商品模式</label>
    <input type="checkbox" id="special-items-toggle" style="width: auto; height: 20px;">
</div>

<!-- ... 就在 </form> 标签之前 ... -->
        <form id="mall-api-form" style="padding: 15px;">
            <p style="font-size: 14px; color: #666; margin-bottom: 20px;">
                此处API设置专用于商城模块。若留空，将自动使用主“API”应用中的设置。
            </p>
            <div class="form-group">
                <label for="mall-api-url">API 地址</label>
                <input type="url" id="mall-api-url" name="url" placeholder="例如：https://api.deepseek.com">
            </div>
            <div class="form-group">
                <label for="mall-api-key">密钥 (Key)</label>
                <input type="password" id="mall-api-key" name="key" placeholder="请输入商城的API密钥">
            </div>
            <button type="button" class="btn btn-secondary" id="mall-fetch-models-btn">
                <span class="btn-text">拉取模型</span>
                <div class="spinner"></div>
            </button>
            <div class="form-group">
                <label for="mall-api-model">选择模型</label>
                <select id="mall-api-model" name="model">
                    <option value="">请先拉取模型列表</option>
                </select>
            </div>
            <button type="submit" class="btn btn-primary">保存商城API设置</button>
        </form>
    </main>
    <nav class="mall-bottom-nav">
        <button class="nav-item" data-target="mall-screen">
            <svg viewBox="0 0 24 24"><path d="M10,20V14H14V20H19V12H22L12,3L2,12H5V20H10Z"></path></svg>
            <span>首页</span>
        </button>
        <button class="nav-item" data-target="mall-cart-screen">
            <svg viewBox="0 0 24 24"><path d="M17,18A2,2 0 0,1 19,20A2,2 0 0,1 17,22A2,2 0 0,1 15,20A2,2 0 0,1 17,18M7,18A2,2 0 0,1 9,20A2,2 0 0,1 7,22A2,2 0 0,1 5,20A2,2 0 0,1 7,18M7.17,14.75L7.2,14.63L8.1,13H15.55C16.3,13 16.96,12.59 17.3,11.97L20.88,5.5H18.31L17.15,7.55L14.4,12H8.53L8.4,11.73L6,4H4V6H6L9.6,13.59L8.16,15.95C7.79,16.58 8.27,17.31 9,17.31H18V15.31H9.42L10.2,14Z"></path></svg>
            <span>购物车</span>
        </button>
        <button class="nav-item" data-target="mall-profile-screen">
            <svg viewBox="0 0 24 24"><path d="M12,12c2.21,0 4,-1.79 4,-4s-1.79,-4 -4,-4 -4,1.79 -4,4 1.79,4 4,4zm0,2c-2.67,0 -8,1.34 -8,4v2h16v-2c0,-2.66 -5.33,-4 -8,-4z"></path></svg>
            <span>个人中心</span>
        </button>
        <button class="nav-item active" data-target="mall-settings-screen">
            <svg viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61-.25-1.17-.59-1.69-.98l-2.49-1c-.23-.08-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.08.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"></path></svg>
            <span>设置</span>
        </button>
    </nav>
</div>

<!-- =============================================================== -->
<!-- END: 新增商城功能HTML -->
<!-- =============================================================== -->

  <!-- =============================================================== -->
<!-- START: 更新后的商品详情页面 (粘贴到 </body> 标签前) -->
<!-- =============================================================== -->
<div id="product-detail-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="mall-screen">‹</button>
        <div class="title-container"><h1 class="title">商品详情</h1></div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
        <div class="product-detail-card">
            <img id="detail-product-image" src="" alt="商品图片" class="detail-product-image">
            <div class="detail-product-info">
                <div class="detail-price-row">
                    <span id="detail-product-price" class="detail-product-price">¥0.00</span>
                    <div class="detail-stats">
                        <span id="detail-product-likes">❤️ 0</span>
                        <span id="detail-product-saves">⭐ 0</span>
                    </div>
                </div>
                <h2 id="detail-product-title" class="detail-product-title">商品名称加载中...</h2>
                <p id="detail-product-description" class="detail-product-description"></p>
            </div>
            <div id="detail-store-info" class="detail-store-info">
                <img id="detail-store-avatar" src="https://i.postimg.cc/VL1g9G5V/store-avatar.png" class="store-avatar">
                <span id="detail-store-name">店铺名称</span>
            </div>
            <div id="comment-section" class="comment-section">
                <h3>宝贝评价</h3>
                <ul id="comment-list"></ul>
                <button id="load-more-comments-btn" class="btn btn-neutral">加载更多评价</button>
            </div>
        </div>
    </main>
    <!-- 底部操作栏 -->
    <nav id="detail-footer-nav" class="detail-footer-nav">
        <button class="action-btn" id="like-product-btn">收藏</button>
        <button class="action-btn" id="pay-for-me-btn">找人代付</button>
        <button class="action-btn">加入购物车</button>
        <button class="action-btn primary">立即购买</button>
    </nav>
</div>

<!-- 1. 购物车页面 -->
<!-- ▼▼▼ 请用这个完整的代码块，替换掉您文件中旧的 id="mall-cart-screen" 的 div ▼▼▼ -->
<div id="mall-cart-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="mall-screen">‹</button>
        <div class="title-container"><h1 class="title">购物车</h1></div>
        <!-- 新增的管理/完成按钮 -->
        <div class="action-btn-group">
            <button class="action-btn" id="cart-manage-btn">管理</button>
        </div>
    </header>
    <main class="content" id="cart-item-list-container" style="padding: 10px 0;">
        <!-- 购物车商品将由JS动态生成 -->
    </main>
    
    <!-- 【新增】购物车结算栏 -->
    <div id="cart-checkout-bar" class="cart-checkout-bar">
        <div class="select-all-container">
            <div class="cart-item-selector" id="cart-select-all-btn"></div>
            <span>全选</span>
        </div>
        <div class="checkout-info">
            <span id="cart-total-price">合计: ¥0.00</span>
            <button class="btn btn-primary" id="cart-checkout-btn">去结算 (0)</button>
        </div>
 <!-- 新增的删除按钮，默认隐藏 -->
    <button class="btn btn-danger" id="cart-delete-selected-btn">删除</button>
</div>
    <nav class="mall-bottom-nav">
        <button class="nav-item" data-target="mall-screen"><span>首页</span></button>
        <button class="nav-item active" data-target="mall-cart-screen"><span>购物车</span></button>
        <button class="nav-item" data-target="mall-profile-screen"><span>个人中心</span></button>
        <button class="nav-item" data-target="mall-settings-screen"><span>设置</span></button>
    </nav>
</div>

<!-- 2. 购买流程主弹窗 (类似拼多多) -->
<div id="purchase-modal" class="modal-overlay">
    <div class="modal-window purchase-flow-modal">
        <button class="close-purchase-modal-btn">&times;</button>
        <div class="purchase-product-info">
            <img id="purchase-product-image" src="" alt="商品图片">
            <div>
                <p id="purchase-product-price">¥0.00</p>
                <h4 id="purchase-product-name">商品名称</h4>
            </div>
        </div>
        <div class="purchase-section">
            <h5>选择收货人 (代付/送礼)</h5>
            <ul id="recipient-selection-list" class="list-container">
                <!-- 收货人列表将由JS动态生成 -->
            </ul>
        </div>
        <button id="confirm-recipient-btn" class="btn btn-primary">确定</button>
    </div>
</div>

<!-- 3. 商品样式/数量选择弹窗 -->
<div id="product-options-modal" class="modal-overlay">
    <div class="modal-window purchase-flow-modal">
        <button class="close-purchase-modal-btn">&times;</button>
        <div class="purchase-product-info">
            <img id="options-product-image" src="" alt="商品图片">
            <div>
                <p id="options-product-price">¥0.00</p>
                <h4 id="options-product-name">商品名称</h4>
            </div>
        </div>
        <div class="purchase-section">
            <h5>选择样式</h5>
            <div id="style-options-container" class="style-options">
                <button class="style-option-btn active">默认款式</button>
                <!-- 更多款式可由JS添加 -->
            </div>
        </div>
        <div class="purchase-section quantity-section">
            <h5>购买数量</h5>
            <div class="quantity-selector">
                <button class="quantity-btn" id="decrease-quantity-btn">-</button>
                <input type="number" id="purchase-quantity-input" value="1" min="1">
                <button class="quantity-btn" id="increase-quantity-btn">+</button>
            </div>
        </div>
        <button id="confirm-purchase-btn" class="btn btn-primary">确定</button>
    </div>
</div>

<!-- 4. 自定义倒计时时长弹窗 -->
<div id="delivery-countdown-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>设置送达时间</h3>
        <p style="font-size: 13px; color: #666; text-align: center;">AI将会在倒计时结束后收到物品</p>
        <div class="form-group">
            <label for="delivery-duration-input">倒计时时长 (分钟)</label>
            <input type="number" id="delivery-duration-input" value="5" min="1" placeholder="请输入分钟数">
        </div>
        <button id="confirm-delivery-time-btn" class="btn btn-primary">确认购买</button>
    </div>
</div>
    </main>
<!-- =============================================================== -->
<!-- START: 商城购物流程新增模块 -->
<!-- =============================================================== -->

<!-- ▼▼▼ 请用这个完整的代码块，替换掉您文件中旧的 id="mall-cart-screen" 的 div ▼▼▼ -->
<div id="mall-cart-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="mall-screen">‹</button>
        <div class="title-container"><h1 class="title">购物车</h1></div>
        <!-- 新增的管理/完成按钮 -->
        <div class="action-btn-group">
            <button class="action-btn" id="cart-manage-btn">管理</button>
        </div>
    </header>
    <main class="content" id="cart-item-list-container" style="padding: 10px 0;">
        <!-- 购物车商品将由JS动态生成 -->
    </main>
    
    <!-- 【新增】购物车结算栏 -->
    <div id="cart-checkout-bar" class="cart-checkout-bar">
        <div class="select-all-container">
            <div class="cart-item-selector" id="cart-select-all-btn"></div>
            <span>全选</span>
        </div>
        <div class="checkout-info">
            <span id="cart-total-price">合计: ¥0.00</span>
            <button class="btn btn-primary" id="cart-checkout-btn">去结算 (0)</button>
        </div>
    <!-- 新增的删除按钮，默认隐藏 -->
    <button class="btn btn-danger" id="cart-delete-selected-btn" style="display: none;">删除</button>
</div>
    <nav class="mall-bottom-nav">
        <button class="nav-item" data-target="mall-screen"><span>首页</span></button>
        <button class="nav-item active" data-target="mall-cart-screen"><span>购物车</span></button>
        <button class="nav-item" data-target="mall-profile-screen"><span>个人中心</span></button>
        <button class="nav-item" data-target="mall-settings-screen"><span>设置</span></button>
    </nav><!-- 【新增】收藏商品的选择结算栏 -->
<div id="likes-checkout-bar" class="likes-checkout-bar">
    <span id="likes-total-price">总计: ¥0.00</span>
    <div>
        <button class="btn btn-neutral btn-small" id="cancel-likes-selection-btn">取消</button>
        <button class="btn btn-primary btn-small" id="checkout-likes-btn">结算</button>
    </div>
</div>
</div>

<!-- 2. 购买流程主弹窗 (类似拼多多) -->
<div id="purchase-modal" class="modal-overlay">
    <div class="modal-window purchase-flow-modal">
        <button class="close-purchase-modal-btn">&times;</button>
        <div class="purchase-product-info">
            <img id="purchase-product-image" src="" alt="商品图片">
            <div>
                <p id="purchase-product-price">¥0.00</p>
                <h4 id="purchase-product-name">商品名称</h4>
            </div>
        </div>
        <div class="purchase-section">
            <h5>选择收货人</h5>
            <ul id="recipient-selection-list" class="list-container">
                <!-- 收货人列表将由JS动态生成 -->
            </ul>
        </div>
        <button id="confirm-recipient-btn" class="btn btn-primary">确定</button>
    </div>
</div>

<!-- 3. 商品样式/数量选择弹窗 -->
<div id="product-options-modal" class="modal-overlay">
    <div class="modal-window purchase-flow-modal">
        <button class="close-purchase-modal-btn">&times;</button>
        <div class="purchase-product-info">
            <img id="options-product-image" src="" alt="商品图片">
            <div>
                <p id="options-product-price">¥0.00</p>
                <h4 id="options-product-name">商品名称</h4>
            </div>
        </div>
        <div class="purchase-section">
            <h5>选择样式</h5>
            <div id="style-options-container" class="style-options">
                <button class="style-option-btn active">默认款式</button>
                <!-- 更多款式可由JS添加 -->
            </div>
        </div>
        <div class="purchase-section quantity-section">
            <h5>购买数量</h5>
            <div class="quantity-selector">
                <button class="quantity-btn" id="decrease-quantity-btn">-</button>
                <input type="number" id="purchase-quantity-input" value="1" min="1">
                <button class="quantity-btn" id="increase-quantity-btn">+</button>
            </div>
        </div>
        <button id="confirm-purchase-btn" class="btn btn-primary">确定</button>
    </div>
</div>

<!-- 4. 自定义倒计时时长弹窗 -->
<div id="delivery-countdown-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>设置送达时间</h3>
        <div class="form-group">
            <label for="delivery-duration-input">倒计时时长 (分钟)</label>
            <input type="number" id="delivery-duration-input" value="5" min="1" placeholder="请输入分钟数">
        </div>
        <button id="confirm-delivery-time-btn" class="btn btn-primary">确认购买</button>
    </div>
</div>

<!-- =============================================================== -->
<!-- END: 商城购物流程新增模块 -->
<!-- =============================================================== -->
	<!-- =============================================================== -->
<!-- START: 新增AI空间手机界面 (粘贴到 </body> 标签前) -->
<!-- =============================================================== -->

<!-- 1. AI空间主屏幕 (手机桌面) -->
<div id="ai-space-home-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="home-container">‹</button>
        <div class="title-container">
            <h1 class="title">AI的手机</h1>
        </div>
        <div class="placeholder"></div>
    </header>
    <main class="content" style="background: #f5f5f5; padding: 20px;">
        <div id="ai-space-app-grid" class="app-grid" style="grid-template-columns: repeat(4, 1fr); gap: 15px; padding: 10px;">
            <!-- App icons will be generated by JS -->
        </div>
    </main>
</div>

<!-- 2. AI空间内的通用 "AI选择列表" 页面 -->
<div id="ai-space-character-select-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="ai-space-home-screen">‹</button>
        <div class="title-container">
            <h1 class="title" id="ai-space-select-title">选择AI</h1>
        </div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
        <ul class="list-container" id="ai-space-select-list"></ul>
    </main>
</div>

<!-- 3. AI浏览器 - 历史记录页面 -->
<div id="ai-space-browser-history-screen" class="screen">
<header class="app-header">
    <button class="back-btn" data-target="ai-space-character-select-screen">‹</button>
    <div class="title-container">
        <h1 class="title" id="ai-browser-history-title">的浏览器</h1>
    </div>
    <button class="action-btn" id="refresh-browser-history-btn">
        <svg viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px;"><path d="M17.65,6.35C16.2,4.9, 14.21,4, 12,4A8,8, 0, 0,0, 4,12A8,8, 0, 0,0, 12,20C15.73,20, 18.84,17.45, 19.73,14H17.65C16.83,16.33, 14.61,18, 12,18A6,6, 0, 0,1, 6,12A6,6, 0, 0,1, 12,6C13.66,6, 15.14,6.69, 16.22,7.78L13,11H20V4L17.65,6.35Z"></path></svg>
    </button>
</header>
    <main class="content">
        <ul class="list-container" id="ai-browser-history-list"></ul>
    </main>
</div>

<!-- 4. AI浏览器 - 搜索结果详情页 -->
<div id="ai-space-browser-detail-screen" class="screen">
<!-- 1. 修正 AI浏览器-详情页 的 header -->
<header class="app-header">
    <button class="back-btn" data-target="ai-space-browser-history-screen">‹</button>
    <div class="title-container">
        <h1 class="title">搜索结果</h1>
    </div>
    <div class="placeholder"></div>
</header>
    <main class="content" style="padding: 20px; line-height: 1.7;">
        <h3 id="ai-browser-detail-query" style="color: var(--primary-color);"></h3>
        <p id="ai-browser-detail-content"></p>
    </main>
</div>

<!-- 5. AI相册 - 照片列表页 -->
<div id="ai-space-photos-album-screen" class="screen">
<!-- 2. 修正 AI相册页 的 header -->
<header class="app-header">
    <button class="back-btn" data-target="ai-space-character-select-screen">‹</button>
    <div class="title-container">
        <h1 class="title" id="ai-photos-album-title">的相册</h1>
    </div>
    <button class="action-btn" id="refresh-photos-album-btn">
         <svg viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px;"><path d="M17.65,6.35C16.2,4.9, 14.21,4, 12,4A8,8, 0, 0,0, 4,12A8,8, 0, 0,0, 12,20C15.73,20, 18.84,17.45, 19.73,14H17.65C16.83,16.33, 14.61,18, 12,18A6,6, 0, 0,1, 6,12A6,6, 0, 0,1, 12,6C13.66,6, 15.14,6.69, 16.22,7.78L13,11H20V4L17.65,6.35Z"></path></svg>
    </button>
</header>
    <main class="content">
        <div id="ai-photos-album-grid"></div>
    </main>
</div>

<!-- 6. AI相册 - 照片详情弹窗 -->
<div id="ai-space-photo-detail-modal" class="modal-overlay">
    <div class="modal-window">
        <h3 id="ai-photo-detail-title">照片详情</h3>
        <p id="ai-photo-detail-content" style="background-color: #f5f5f5; padding: 15px; border-radius: 8px;"></p>
        <button class="btn btn-primary" id="close-ai-photo-detail-btn" style="margin-top: 20px;">关闭</button>
    </div>
</div>

<!-- 7. AI钱包 - 账单列表页 -->
<div id="ai-space-wallet-transactions-screen" class="screen">
<!-- 3. 修正 AI钱包页 的 header -->
<header class="app-header">
    <button class="back-btn" data-target="ai-space-character-select-screen">‹</button>
    <div class="title-container">
        <h1 class="title" id="ai-wallet-transactions-title">的钱包</h1>
    </div>
    <button class="action-btn" id="refresh-wallet-transactions-btn">
         <svg viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px;"><path d="M17.65,6.35C16.2,4.9, 14.21,4, 12,4A8,8, 0, 0,0, 4,12A8,8, 0, 0,0, 12,20C15.73,20, 18.84,17.45, 19.73,14H17.65C16.83,16.33, 14.61,18, 12,18A6,6, 0, 0,1, 6,12A6,6, 0, 0,1, 12,6C13.66,6, 15.14,6.69, 16.22,7.78L13,11H20V4L17.65,6.35Z"></path></svg>
    </button>
</header>
    <main class="content">
        <ul class="list-container" id="ai-wallet-transactions-list"></ul>
    </main>
</div>

<!-- 8. AI钱包 - 账单详情弹窗 -->
<div id="ai-space-wallet-detail-modal" class="modal-overlay">
    <div class="modal-window">
        <h3 id="ai-wallet-detail-description">账单详情</h3>
        <div style="text-align: center; margin: 20px 0;">
            <p id="ai-wallet-detail-amount" style="font-size: 28px; font-weight: bold; margin: 0;"></p>
            <p id="ai-wallet-detail-status" style="font-size: 14px; color: #888;"></p>
        </div>
        <p><strong>交易时间:</strong> <span id="ai-wallet-detail-time"></span></p>
        <p><strong>交易对象:</strong> <span id="ai-wallet-detail-peer"></span></p>
        <button class="btn btn-primary" id="close-ai-wallet-detail-btn" style="margin-top: 20px;">关闭</button>
    </div>
</div>

<!-- =============================================================== -->
<!-- END: 新增AI空间手机界面 -->
<!-- =============================================================== -->
	<!-- =============================================================== -->
<!-- START: 新增商城支付与物流模块 -->
<!-- =============================================================== -->

<!-- ▼▼▼ 用这个新版本，完整替换旧的 id="payment-confirmation-screen" <div> ▼▼▼ -->
<div id="payment-confirmation-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="mall-cart-screen">‹</button>
        <div class="title-container"><h1 class="title">确认付款</h1></div>
        <div class="placeholder"></div>
    </header>
    <main class="content" style="background-color: #f5f5f5; padding: 10px;">
        <!-- 新增：收货人选择 -->
        <div class="payment-section recipient-selector-section">
            <h5>收货人</h5>
            <select id="payment-recipient-select" class="form-group" style="width: 100%; margin: 0;"></select>
        </div>
        
        <!-- 商品列表 -->
        <div id="payment-items-list" class="payment-section">
            <!-- 商品将由JS动态生成 -->
        </div>

        <!-- 新增：自定义送达时间 -->
        <div class="payment-section delivery-time-section">
            <h5>预计送达时间 (分钟后)</h5>
            <input type="number" id="payment-delivery-duration" class="form-group" value="5" min="1" style="width: 100%; margin: 0;">
        </div>

        <!-- 支付方式 -->
        <div class="payment-section payment-methods">
            <div class="method-item" id="pay-for-me-btn"><img src="https://i.postimg.cc/TPgT7rGF/friend-pay.png"> 找404成员代付</div>
            <div class="method-item selected"><img src="https://i.postimg.cc/SKvL5dMy/wallet.png"> 零钱支付</div>
        </div>
    </main>
    <!-- 底部支付栏 -->
    <footer class="payment-footer">
        <div class="price-details">
            合计: <span class="total-price" id="payment-total-price">¥0.00</span>
        </div>
        <button class="btn btn-primary" id="confirm-final-payment-btn">确认支付</button>
    </footer>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<div id="persona-presets-modal" class="modal-overlay" style="display:none;">
    <div class="modal-window" style="max-width:520px;">
        <h3 style="margin:0 0 10px 0;">管理人设预设</h3>
        <div id="persona-presets-list" style="max-height:340px; overflow:auto; margin-bottom:12px;"></div>
        <div style="display:flex; gap:8px; justify-content:flex-end;">
            <button id="persona-close-modal" class="btn btn-primary" style="padding:8px 12px;">关闭</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 将这两个全新的 div 添加到 </body> 标签之前 ▼▼▼ -->

<!-- 1. "找人代付" AI选择弹窗 -->
<div id="pay-for-me-select-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>选择代付好友</h3>
        <ul id="pay-for-me-selection-list" class="list-container" style="max-height: 50vh; overflow-y: auto;">
            <!-- AI列表将由JS动态生成 -->
        </ul>
        <button class="btn btn-neutral" id="cancel-pay-for-me-btn" style="margin-top: 15px;">取消</button>
    </div>
</div>

<!-- 2. 物流追踪页面 -->
<div id="logistics-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="mall-profile-screen">‹</button>
        <div class="title-container"><h1 class="title">我的物流</h1></div>
        <div class="placeholder"></div>
    </header>
    <main class="content" style="padding: 10px; background-color: #f5f5f5;">
        <div id="logistics-list-container">
            <!-- 物流信息将由JS动态生成 -->
        </div>
        <p class="placeholder-text" id="no-logistics-placeholder" style="display: none;">暂无物流信息</p>
    </main>
</div>
<!-- ▲▲▲ 添加结束 ▲▲▲ -->
	<script>
    document.addEventListener('DOMContentLoaded', () => {
    // ▼▼▼ 在这里粘贴新的代码 ▼▼▼
        // --- 修复聊天输入框弹出密码填充的最终方案 ---
        const chatInputs = [
            document.getElementById('message-input'),
            document.getElementById('wechat-message-input')
        ];

        chatInputs.forEach(input => {
            if (input) {
                // 用户开始输入时
                input.addEventListener('focus', () => {
                    // 临时改为 search 类型，可以有效避免大多数浏览器的密码填充
                    input.setAttribute('type', 'search');
                });
                
                // 用户离开输入框时
                input.addEventListener('blur', () => {
                    // 恢复为 text 类型，以防止浏览器应用奇怪的搜索框样式
                    input.setAttribute('type', 'text');
                });
            }
        });
        // --- ▲▲▲ 粘贴结束 ▲▲▲
        // 修复：为聊天室的返回按钮增加特殊处理，以确保底部导航栏能正确显示
        const chatRoomBackBtn = document.querySelector('#chat-room-screen .back-btn');
        if (chatRoomBackBtn) {
            chatRoomBackBtn.addEventListener('click', () => {
                const targetScreenId = chatRoomBackBtn.dataset.target;
                const navHost = document.getElementById('bottom-nav-host');
                
                // 定义哪些页面应该显示底部导航栏
                const screensWithNav = ['chat-list-screen', 'moments-screen', 'forum-screen', 'wallet-screen'];
                
                if (navHost && screensWithNav.includes(targetScreenId)) {
                    navHost.style.display = ''; // 或者 'flex'，取决于你的布局
                }
            });
        }

        // 修复：确保所有打开聊天室的入口都会强制隐藏底部导航栏
        // 我们通过监听一个共同的父元素来实现，这比修改多个函数更高效
        const phoneScreen = document.querySelector('.phone-screen');
        if (phoneScreen) {
            phoneScreen.addEventListener('click', (e) => {
                // 检查点击的是否是一个指向聊天室的聊天条目
                const chatItem = e.target.closest('.chat-item');
                if (chatItem && chatItem.dataset.id && chatItem.dataset.type) {
                    const navHost = document.getElementById('bottom-nav-host');
                    if (navHost) {
                        navHost.style.display = 'none';
                    }
                }
            });
        }
    });
</script>
<!-- =============================================================== -->
<!-- START: 新增自定义商品创建弹窗 -->
<!-- =============================================================== -->
<div id="create-product-modal" class="modal-overlay">
    <div class="modal-window" style="max-height: 85vh; display: flex; flex-direction: column;">
        <h3>创建个性商品</h3>
        <form id="create-product-form" style="overflow-y: auto; flex-grow: 1; padding: 5px;">
            <div class="form-group">
                <label for="custom-product-image-url">商品图片 URL</label>
                <input type="url" id="custom-product-image-url" placeholder="粘贴图片链接...">
            </div>
            <div class="form-group">
                <label for="custom-product-name">商品名称</label>
                <input type="text" id="custom-product-name" required>
            </div>
            <div class="form-group">
                <label for="custom-product-price">商品价格</label>
                <input type="number" id="custom-product-price" required step="0.01" min="0">
            </div>
            <div class="form-group">
                <label for="custom-product-store">店铺名称</label>
                <input type="text" id="custom-product-store" value="我的小店" required>
            </div>
            <div class="form-group">
                <label for="custom-product-description">商品描述 (普通商品)</label>
                <textarea id="custom-product-description" rows="3"></textarea>
            </div>
            <hr style="border:none; border-top: 1px solid #eee; margin: 15px 0;">
            <div class="form-group" style="display: flex; align-items: center; justify-content: space-between;">
                <label for="is-special-product-toggle" style="margin-bottom: 0;">是否为特殊商品？</label>
                <input type="checkbox" id="is-special-product-toggle" style="width: auto; height: 20px;">
            </div>

            <!-- 特殊商品字段，默认隐藏 -->
            <div id="special-product-fields" class="special-product-fields">
                <div class="form-group">
                    <label for="special-product-function">功能 (必须能在对话中体现)</label>
                    <input type="text" id="special-product-function" placeholder="例如：让收件人只能说真话">
                </div>
                <div class="form-group">
                    <label for="special-product-duration">效果持续 (轮对话)</label>
                    <input type="number" id="special-product-duration" min="1" placeholder="例如：5">
                </div>
                <div class="form-group">
                    <label for="special-product-side-effect">副作用 (可选)</label>
                    <input type="text" id="special-product-side-effect" placeholder="例如：效果结束后会头痛">
                </div>
                <div class="form-group">
                    <label for="special-product-side-effect-duration">副作用持续 (轮对话)</label>
                    <input type="number" id="special-product-side-effect-duration" min="1" placeholder="例如：3">
                </div>
            </div>

            <button type="submit" class="btn btn-primary" style="margin-top: 20px;">创建商品</button>
        </form>
    </div>
</div>
<!-- =============================================================== -->
<!-- END: 新增自定义商品创建弹窗 -->
<!-- =============================================================== -->
	<!-- =============================================================== -->
<!-- START: 新增AI空间应用界面 (心动讯号, 购物, 备忘录) -->
<!-- =============================================================== -->

<!-- 1. 心动讯号 - 结果显示页面 -->
<div id="ai-space-signal-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="ai-space-character-select-screen">‹</button>
        <div class="title-container">
            <h1 class="title" id="ai-signal-title">的心动讯号</h1>
        </div>
        <button class="action-btn" id="refresh-signal-btn">
            <svg viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px;"><path d="M17.65,6.35C16.2,4.9, 14.21,4, 12,4A8,8, 0, 0,0, 4,12A8,8, 0, 0,0, 12,20C15.73,20, 18.84,17.45, 19.73,14H17.65C16.83,16.33, 14.61,18, 12,18A6,6, 0, 0,1, 6,12A6,6, 0, 0,1, 12,6C13.66,6, 15.14,6.69, 16.22,7.78L13,11H20V4L17.65,6.35Z"></path></svg>
        </button>
    </header>
    <main class="content" style="padding: 20px; line-height: 1.8;">
        <div id="ai-signal-content">
            <p class="placeholder-text">点击右上角按钮，生成心动瞬间</p>
        </div>
    </main>
</div>

<!-- 2. 购物 - 记录列表页面 -->
<div id="ai-space-shopping-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="ai-space-character-select-screen">‹</button>
        <div class="title-container">
            <h1 class="title" id="ai-shopping-title">的购物记录</h1>
        </div>
        <button class="action-btn" id="refresh-shopping-btn">
            <svg viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px;"><path d="M17.65,6.35C16.2,4.9, 14.21,4, 12,4A8,8, 0, 0,0, 4,12A8,8, 0, 0,0, 12,20C15.73,20, 18.84,17.45, 19.73,14H17.65C16.83,16.33, 14.61,18, 12,18A6,6, 0, 0,1, 6,12A6,6, 0, 0,1, 12,6C13.66,6, 15.14,6.69, 16.22,7.78L13,11H20V4L17.65,6.35Z"></path></svg>
        </button>
    </header>
    <main class="content">
        <ul class="list-container" id="ai-shopping-list">
            <p class="placeholder-text">点击右上角按钮，生成购物记录</p>
        </ul>
    </main>
</div>

<!-- 3. 备忘录 - 记录列表页面 -->
<div id="ai-space-memo-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="ai-space-character-select-screen">‹</button>
        <div class="title-container">
            <h1 class="title" id="ai-memo-title">的备忘录</h1>
        </div>
        <button class="action-btn" id="refresh-memo-btn">
            <svg viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px;"><path d="M17.65,6.35C16.2,4.9, 14.21,4, 12,4A8,8, 0, 0,0, 4,12A8,8, 0, 0,0, 12,20C15.73,20, 18.84,17.45, 19.73,14H17.65C16.83,16.33, 14.61,18, 12,18A6,6, 0, 0,1, 6,12A6,6, 0, 0,1, 12,6C13.66,6, 15.14,6.69, 16.22,7.78L13,11H20V4L17.65,6.35Z"></path></svg>
        </button>
    </header>
    <main class="content">
        <ul class="list-container" id="ai-memo-list">
             <p class="placeholder-text">点击右上角按钮，生成备忘录</p>
        </ul>
    </main>
</div>

<!-- =============================================================== -->
<!-- END: 新增AI空间应用界面 -->
<!-- =============================================================== -->
	<!-- =============================================================== -->
<!-- START: 新增AI空间 - 音乐App界面 -->
<!-- =============================================================== -->
<div id="ai-space-music-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="ai-space-character-select-screen">‹</button>
        <div class="title-container">
            <h1 class="title" id="ai-music-playlist-title">的歌单</h1>
        </div>
        <button class="action-btn" id="refresh-music-playlist-btn">
            <svg viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px;"><path d="M17.65,6.35C16.2,4.9, 14.21,4, 12,4A8,8, 0, 0,0, 4,12A8,8, 0, 0,0, 12,20C15.73,20, 18.84,17.45, 19.73,14H17.65C16.83,16.33, 14.61,18, 12,18A6,6, 0, 0,1, 6,12A6,6, 0, 0,1, 12,6C13.66,6, 15.14,6.69, 16.22,7.78L13,11H20V4L17.65,6.35Z"></path></svg>
        </button>
    </header>
    <main class="content">
        <ul class="list-container" id="ai-music-playlist-list">
             <p class="placeholder-text">点击右上角按钮，生成歌单</p>
        </ul>
    </main>
</div>
<!-- =============================================================== -->
<!-- END: 新增AI空间 - 音乐App界面 -->
<!-- =============================================================== -->
	
	<!-- =============================================================== -->
<!-- START: 新增“心灵羁绊”App界面 -->
<!-- =============================================================== -->
<!-- =============================================================== -->
<!-- START: [已更新V3.0] 心灵羁绊App界面 (粉色主题) -->
<!-- =============================================================== -->
<div id="soul-bond-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="home-container">‹</button>
        <div class="title-container">
            <h1 class="title">心灵羁绊</h1>
        </div>
        <!-- 核心修改：设置按钮图标改为爱心 -->
        <button class="action-btn" id="bond-settings-btn">
            <svg viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px;"><path d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z"></path></svg>
        </button>
    </header>
    <main class="content">
        <!-- 顶部照片滚动区 -->
        <div class="bond-photo-scroll-container">
            <div class="bond-photo-scroll" id="bond-photo-scroll">
                <!-- 拍立得照片将由JS动态生成 -->
            </div>
        </div>

        <!-- 核心修改：恢复旧版大卡片布局 -->
        <div class="bond-main-card">
            <div class="bond-anniversary">
                <p>距离下一个纪念日还有</p>
                <h2 id="bond-countdown-days">...</h2>
                <span>天</span>
            </div>
            <div class="bond-avatars">
                <div class="bond-avatar-container">
                    <img id="bond-my-avatar" src="">
                    <span id="bond-my-name">...</span>
                </div>
                <svg class="bond-heart" viewBox="0 0 24 24"><path d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z" /></svg>
                <div class="bond-avatar-container">
                    <img id="bond-ai-avatar" src="">
                    <span id="bond-ai-name">...</span>
                </div>
            </div>
            <div class="bond-days-counter">我们已经在一起 <strong id="bond-total-days">...</strong> 天</div>
        </div>
        
    </main>

    <!-- 底部功能导航栏 -->
    <footer class="bond-bottom-nav">
        <button class="bond-nav-btn" data-feature="wishlist" title="愿望清单"><svg viewBox="0 0 24 24"><path d="M19.5,5.5V18.5H4.5V5.5H19.5M19.5,3.5H4.5C3.4,3.5 2.5,4.4 2.5,5.5V18.5C2.5,19.6 3.4,20.5 4.5,20.5H19.5C20.6,20.5 21.5,19.6 21.5,18.5V5.5C21.5,4.4 20.6,3.5 19.5,3.5M15.5,16.5H6.5V14.5H15.5V16.5M17.5,12.5H6.5V10.5H17.5V12.5M17.5,8.5H6.5V6.5H17.5V8.5Z"/></svg></button>
        <button class="bond-nav-btn" data-feature="diary" title="交换日记"><svg viewBox="0 0 24 24"><path d="M14,10V4.5L19.5,10M5,3C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V9L15,3H5Z"/></svg></button>
        <button class="bond-nav-btn" data-feature="pomodoro" title="专注模式"><svg viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,6A6,6 0 0,0 6,12A6,6 0 0,0 12,18A6,6 0 0,0 18,12A6,6 0 0,0 12,6M16.24,7.76L12,12V7H11V13H17V12H12.24L16.24,7.76Z"/></svg></button>
        <button class="bond-nav-btn" data-feature="dailyquestion" title="每日一问"><svg viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,6A4,4 0 0,0 8,10H10A2,2 0 0,1 12,8A2,2 0 0,1 14,10C14,12 11,11.75 11,15H13C13,12.75 16,12.5 16,10A4,4 0 0,0 12,6M11,17H13V19H11V17Z"/></svg></button>
        <button class="bond-nav-btn" data-feature="mood" title="情绪天气"><svg viewBox="0 0 24 24"><path d="M17.6,14.04C18.4,13.24 18.9,12.16 19,11C19.1,9.8 18.6,8.68 17.8,7.88C17,7.07 15.9,6.6 14.7,6.58C13.5,6.56 12.3,6.93 11.4,7.63C10.5,8.34 9.89,9.3 9.73,10.42C9.57,11.54 9.86,12.7 10.5,13.68L12,15.29L13.41,16.7L17.6,14.04M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,20C7.58,20 4,16.42 4,12C4,7.58 7.58,4 12,4C16.42,4 20,7.58 20,12C20,16.42 16.42,20 12,20Z"/></svg></button>
    </footer>
</div>
<!-- =============================================================== -->
<!-- END: "心灵羁绊"App界面 -->
<!-- =============================================================== -->
<!-- =============================================================== -->
<!-- START: 缺失的“心灵羁绊”与“渲染器”功能模块 (修复报错) -->
<!-- =============================================================== -->

<!-- 1. “心灵羁绊”App的设置弹窗 -->
<div id="bond-settings-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>羁绊设置</h3>
        <form id="bond-settings-form">
            <div class="form-group">
                <label for="bond-my-name-input">我的昵称</label>
                <input type="text" id="bond-my-name-input">
            </div>
            <div class="form-group">
                <label for="bond-ai-name-input">Ta的昵称</label>
                <input type="text" id="bond-ai-name-input">
            </div>
         <!-- ▼▼▼ 用这个代码块替换旧的纪念日设置部分 ▼▼▼ -->
            <div class="form-group">
                <label for="bond-anniversary-date-input">纪念日日期</label>
                <input type="date" id="bond-anniversary-date-input">
            </div>
            <div class="form-group">
                <label for="bond-anniversary-desc-input">纪念日名称</label>
                <input type="text" id="bond-anniversary-desc-input" placeholder="例如：我们的相遇纪念日">
            </div>
            <!-- ▲▲▲ 替换结束 ▲▲▲ -->
            <div class="form-group">
                <label for="bond-background-url-input">背景图片 URL</label>
                <input type="url" id="bond-background-url-input" placeholder="留空则使用默认纯色背景">
            </div>
            <div class="form-group">
                <label for="add-bond-photo-btn">添加照片</label>
                 <button type="button" class="btn btn-secondary" id="add-bond-photo-btn">添加回忆照片</button>
            </div>
            <button type="submit" class="btn btn-primary" style="margin-top: 15px;">保存设置</button>
        </form>
    </div>
</div>

<!-- 2. “渲染器”App缺失的分类弹窗 -->
<div id="renderer-category-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>创建新分类</h3>
        <form id="renderer-category-form">
            <div class="form-group">
                <label for="renderer-category-name">分类名称</label>
                <input type="text" id="renderer-category-name" placeholder="例如：通用效果、角色专属" required>
            </div>
            <button type="submit" class="btn btn-primary">创建</button>
        </form>
    </div>
</div>

<!-- 3. “渲染器”App缺失的隐藏文件输入框 -->
<input type="file" id="renderer-import-input" accept=".json" style="display: none;" multiple>

<!-- =============================================================== -->
<!-- END: 缺失模块 -->
<!-- =============================================================== -->
	<!-- =============================================================== -->
<!-- START: 新增“心灵羁绊”App的附属界面 -->
<!-- =============================================================== -->

<!-- 1. 愿望清单页面 -->
<div id="bond-wishlist-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="soul-bond-screen">‹</button>
        <div class="title-container">
            <h1 class="title">我们的愿望清单</h1>
        </div>
        <button class="action-btn" id="refresh-wishlist-btn">
             <svg viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px;"><path d="M17.65,6.35C16.2,4.9, 14.21,4, 12,4A8,8, 0, 0,0, 4,12A8,8, 0, 0,0, 12,20C15.73,20, 18.84,17.45, 19.73,14H17.65C16.83,16.33, 14.61,18, 12,18A6,6, 0, 0,1, 6,12A6,6, 0, 0,1, 12,6C13.66,6, 15.14,6.69, 16.22,7.78L13,11H20V4L17.65,6.35Z"></path></svg>
        </button>
    </header>
    <main class="content">
        <ul class="list-container" id="bond-wishlist-container">
            <!-- 愿望清单将由JS动态生成 -->
        </ul>
    </main>
    <!-- 新增：愿望清单的浮动添加按钮 -->
<button class="new-post-btn" id="add-wish-fab" style="bottom: 20px;">+</button>
</div>

<!-- 2. 添加回忆照片的弹窗 -->
<div id="add-bond-photo-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>添加一张回忆照片</h3>
        <p style="font-size: 13px; color: #666; text-align: center;">AI将根据你们的聊天记录，生成一张有意义的照片回忆。</p>
        <div id="bond-photo-generation-spinner" style="display: none; text-align: center; margin: 20px 0;">
            <div class="spinner" style="display: inline-block; border-top-color: var(--primary-color); border-left-color: var(--primary-color);"></div>
            <p>正在生成中...</p>
        </div>
        <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button class="btn btn-neutral" id="cancel-add-photo-btn" style="flex: 1;">取消</button>
            <button class="btn btn-primary" id="confirm-add-photo-btn" style="flex: 1;">确认生成</button>
        </div>
    </div>
</div>

<!-- =============================================================== -->
<!-- END: 新增“心灵羁绊”App的附属界面 -->
<!-- =============================================================== -->
	<!-- =============================================================== -->
<!-- START: 新增“心灵羁绊”App的附属界面 V2.0 -->
<!-- =============================================================== -->

<!-- 1. 自定义添加/编辑愿望的弹窗 -->
<div id="bond-wish-editor-modal" class="modal-overlay">
    <div class="modal-window">
        <h3 id="wish-editor-title">添加一个新愿望</h3>
        <form id="bond-wish-form">
            <input type="hidden" id="editing-wish-id">
            <div class="form-group">
                <textarea id="wish-text-input" rows="4" required placeholder="写下想一起完成的事..."></textarea>
            </div>
            <button type="submit" class="btn btn-primary">保存愿望</button>
        </form>
    </div>
</div>

<!-- 2. 自定义上传回忆照片的弹窗 -->
<div id="add-custom-bond-photo-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>添加自定义回忆照片</h3>
        <form id="custom-bond-photo-form">
            <div class="form-group">
                <label for="custom-photo-upload" class="btn btn-secondary">选择图片</label>
                <input type="file" id="custom-photo-upload" accept="image/*" style="display:none;">
                <div id="custom-photo-preview" style="width: 100px; height: 100px; border: 1px dashed #ccc; margin: 10px auto; background-size: cover; background-position: center;"></div>
            </div>
            <div class="form-group">
                <label for="custom-photo-desc">写下照片背后的故事</label>
                <textarea id="custom-photo-desc" rows="3" required></textarea>
            </div>
            <button type="submit" class="btn btn-primary">保存这张回忆</button>
        </form>
    </div>
</div>

<!-- =============================================================== -->
<!-- END: 新增附属界面 -->
<!-- =============================================================== -->
	<!-- =============================================================== -->
<!-- START: 新增“心灵羁绊”App的附属界面 V2.0 -->
<!-- =============================================================== -->

<!-- 1. 自定义添加/编辑愿望的弹窗 -->
<div id="bond-wish-editor-modal" class="modal-overlay">
    <div class="modal-window">
        <h3 id="wish-editor-title">添加一个新愿望</h3>
        <form id="bond-wish-form">
            <input type="hidden" id="editing-wish-id">
            <div class="form-group">
                <textarea id="wish-text-input" rows="4" required placeholder="写下想一起完成的事..."></textarea>
            </div>
            <button type="submit" class="btn btn-primary">保存愿望</button>
        </form>
    </div>
</div>
<div id="miss-you-actionsheet" class="action-sheet-overlay">
    <div class="action-sheet">
        <button class="action-sheet-button" data-level="有点想你">有点想你...</button>
        <button class="action-sheet-button" data-level="非常想你">非常想你！</button>
        <button class="action-sheet-button danger" id="cancel-miss-you-btn">取消</button>
    </div>
</div>
<!-- END: 新增“想你啦”功能模块 -->
	<!-- =============================================================== -->
<!-- START: 心灵羁绊 - 番茄钟 V2.0 功能模块 -->
<!-- =============================================================== -->

<!-- =============================================================== -->
<!-- START: 心灵羁绊 - 番茄钟 V2.1 功能模块 (替换旧版) -->
<!-- =============================================================== -->

<!-- 1. 番茄钟主页面 -->
<div id="pomodoro-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="soul-bond-screen">‹</button>
        <div class="title-container">
            <h1 class="title">专注模式</h1>
        </div>
        <div class="action-btn-group">
            <button class="action-btn" id="pomodoro-history-btn" title="历史记录">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M13,3A9,9 0 0,0 4,12H1L4.89,15.89L8.78,12H6A7,7 0 0,1 13,5V8L18,4L13,0V3M12,12A2,2 0 0,0 10,14A2,2 0 0,0 12,16A2,2 0 0,0 14,14A2,2 0 0,0 12,12M7,12A5,5 0 0,1 12,7A5,5 0 0,1 17,12A5,5 0 0,1 12,17A5,5 0 0,1 7,12Z"/></svg>
            </button>
            <button class="action-btn" id="pomodoro-open-settings-btn" title="设置">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12,8A4,4 0 0,1 16,12A4,4 0 0,1 12,16A4,4 0 0,1 8,12A4,4 0 0,1 12,8M12,10A2,2 0 0,0 10,12A2,2 0 0,0 12,14A2,2 0 0,0 14,12A2,2 0 0,0 12,10M10,22C9.75,22 9.54,21.82 9.5,21.58L9.13,18.93C8.5,18.68 7.96,18.34 7.44,17.94L4.95,18.95C4.73,19.03 4.46,18.95 4.34,18.73L2.34,15.27C2.21,15.05 2.27,14.78 2.45,14.63L4.6,13.05C4.54,12.72 4.5,12.37 4.5,12C4.5,11.63 4.54,11.28 4.6,10.95L2.45,9.37C2.27,9.22 2.21,8.95 2.34,8.73L4.34,5.27C4.46,5.05 4.73,4.96 4.95,5.05L7.44,6.06C7.96,5.66 8.5,5.32 9.13,5.07L9.5,2.42C9.54,2.18 9.75,2 10,2H14C14.25,2 14.46,2.18 14.5,2.42L14.87,5.07C15.5,5.32 16.04,5.66 16.56,6.06L19.05,5.05C19.27,4.96 19.54,5.05 19.66,5.27L21.66,8.73C21.79,8.95 21.73,9.22 21.55,9.37L19.4,10.95C19.46,11.28 19.5,11.63 19.5,12C19.5,12.37 19.46,12.72 19.4,13.05L21.55,14.63C21.73,14.78 21.79,15.05 21.66,15.27L19.66,18.73C19.54,18.95 19.27,19.04 19.05,18.95L16.56,17.94C16.04,18.34 15.5,18.68 14.87,18.93L14.5,21.58C14.46,21.82 14.25,22 14,22H10Z"/></svg>
            </button>
        </div>
    </header>
    <main class="content pomodoro-main-content">
        <div class="pomodoro-timer-card">
            <div id="pomodoro-main-time" class="pomodoro-time-display">25:00</div>
            <div class="pomodoro-task-bar">
                <span>当前任务:</span>
                <span id="pomodoro-task-name" contenteditable="true">英语作业</span>
            </div>
        </div>

        <div class="pomodoro-avatar-wrapper">
            <img id="pomodoro-ai-avatar" src="https://i.postimg.cc/Y96LPskq/o-o-2.jpg" alt="AI Avatar">
        </div>

        <div class="pomodoro-ai-message">
            <div id="pomodoro-ai-status">爱德华发呆中 💭</div>
            <p id="pomodoro-ai-companion-text">准备好了吗？我们开始吧！</p>
        </div>

        <button id="pomodoro-start-btn" class="pomodoro-start-button">开始</button>
    </main>
</div>

<!-- 2. 番茄钟设置页面 -->
<div id="pomodoro-settings-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="pomodoro-screen">‹</button>
        <div class="title-container"><h1 class="title">专注设置</h1></div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
        <form id="pomodoro-settings-form-v2">
            <div class="form-group">
                <label for="pomodoro-wallpaper-input">背景图片 URL</label>
                <input type="url" id="pomodoro-wallpaper-input" placeholder="留空则使用默认纯色">
            </div>
            <div class="form-group">
                <label for="pomodoro-avatar-input">陪伴头像 URL</label>
                <input type="url" id="pomodoro-avatar-input" placeholder="粘贴图片链接">
            </div>
            <div class="form-group">
                <label for="pomodoro-sound-url-input">陪伴提示音 URL</label>
                <input type="url" id="pomodoro-sound-url-input" placeholder="点击头像时播放的声音">
            </div>
             <div class="form-group">
                <label for="pomodoro-card-wallpaper-input">计时卡片背景 URL</label>
                <input type="url" id="pomodoro-card-wallpaper-input" placeholder="可选，为卡片设置背景">
            </div>
            <hr>
            <div class="form-group">
                <label>默认计时模式</label>
                <div class="form-group radio-group">
                    <label><input type="radio" name="timer-mode" value="countdown" checked> 番茄钟 (倒计时)</label>
                    <label><input type="radio" name="timer-mode" value="stopwatch"> 正计时</label>
                </div>
            </div>
             <div class="form-group">
                <label for="focus-duration-input">专注时长 (分钟)</label>
                <input type="number" id="focus-duration-input" min="1" value="25">
            </div>
            <div class="form-group">
                <label for="short-break-duration-input">短休息时长 (分钟)</label>
                <input type="number" id="short-break-duration-input" min="1" value="5">
            </div>
            <button type="submit" class="btn btn-primary" style="margin-top: 15px;">保存设置</button>
        </form>
    </main>
</div>

<!-- 3. 专注历史记录页面 -->
<div id="pomodoro-history-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="pomodoro-screen">‹</button>
        <div class="title-container"><h1 class="title">专注记录</h1></div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
        <ul class="list-container" id="pomodoro-history-list"></ul>
        <p class="placeholder-text" id="no-pomodoro-history">还没有完成过专注任务哦。</p>
    </main>
</div>

<!-- 4. 提示音 -->
<audio id="pomodoro-alert-sound" src="https://assets.mixkit.co/sfx/preview/mixkit-clear-announce-tones-2861.mp3" preload="auto"></audio>

<!-- =============================================================== -->
<!-- END: 心灵羁绊 - 番茄钟 V2.1 功能模块 -->
<!-- =============================================================== -->


<div id="font-presets-modal" class="modal-overlay" style="display:none;">
    <div class="modal-window" style="max-width:520px;">
        <h3 style="margin:0 0 10px 0;">管理字体预设</h3>
        <div id="font-presets-list" style="max-height:340px; overflow:auto; margin-bottom:12px;"></div>
        <div style="display:flex; gap:8px; justify-content:flex-end;">
            <button id="font-close-modal" class="btn btn-primary" style="padding:8px 12px;">关闭</button>
        </div>
    </div>
</div>
  
      <!-- ▼▼▼ 在这里粘贴新的代码 ▼▼▼ -->
    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('./sw.js')
            .then(registration => {
              console.log('ServiceWorker registration successful with scope: ', registration.scope);
            })
            .catch(err => {
              console.log('ServiceWorker registration failed: ', err);
            });
        });
      }
    </script>
    <!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const phoneScreen = document.querySelector('.phone-screen');
    
    // 1. 状态变量
    // isFullscreenIntended: 记录用户是否“想要”处于全屏模式
    let isFullscreenIntended = false;
    // needsFullscreenResume: 一个标记，表示页面刚从后台返回，需要恢复全屏
    let needsFullscreenResume = false;

    if (phoneScreen) {
      // 2. 为Dock栏中的全屏按钮绑定事件
      phoneScreen.addEventListener('click', (event) => {
        const fullscreenBtn = event.target.closest('#fullscreen-btn');
        if (!fullscreenBtn) return;
        
        event.preventDefault();
        
        if (document.fullscreenElement || document.webkitFullscreenElement) {
          // 如果是用户主动点击按钮退出，则将“期望状态”设为false
          isFullscreenIntended = false;
          document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen();
        } else {
          // 如果是用户主动点击按钮进入，则将“期望状态”设为true
          isFullscreenIntended = true;
          document.documentElement.requestFullscreen ? document.documentElement.requestFullscreen() : document.documentElement.webkitRequestFullscreen();
        }
      });
    }

    // 3. 监听页面的可见性变化（即，从后台切换回来）
    document.addEventListener('visibilitychange', () => {
      // 当页面从隐藏状态变为可见时
      if (document.visibilityState === 'visible') {
        // 检查：我们是否“期望”全屏，但浏览器“实际”上不是全屏？
        if (isFullscreenIntended && !document.fullscreenElement) {
          // 如果是，就设置“需要恢复”的标记
          needsFullscreenResume = true;
        }
      }
    });

    // 4. 【核心】在整个文档上设置一个最高优先级的点击监听器
    //    参数 `true` 表示在“捕获阶段”就执行，比页面上任何其他点击事件都早
    document.addEventListener('click', (event) => {
      // 检查是否满足所有恢复条件
      if (needsFullscreenResume && isFullscreenIntended && !document.fullscreenElement) {
        
        // 阻止这次点击的默认行为（比如点击到其他按钮）
        event.preventDefault();
        event.stopPropagation();
        
        // 消耗掉“需要恢复”的标记，确保这个逻辑只执行一次
        needsFullscreenResume = false;
        
        // 重新请求进入全屏
        document.documentElement.requestFullscreen ? document.documentElement.requestFullscreen() : document.documentElement.webkitRequestFullscreen();
      }
    }, true);
  });
</script>
</body>

</html>